###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               21/Jul/2020  00:38:08
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EW8922.tmp ("D:\AA\Z-Stack
#        3.0.2\Components\stack\zcl\zcl_general.c" -D
#        ZCL_REPORT_DESTINATION_DEVICE -D BDB_REPORTING -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D NV_INIT -D xNV_RESTORE -D xZTOOL_P1 -D xMT_TASK -D
#        xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_HVAC_CLUSTER -D ZCL_GROUPS -D ZCL_REPORTING_DEVICE -D
#        ZCL_TEMPERATURE_MEASUREMENT -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\CoordinatorEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\" -I
#        "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\CoordinatorEB\List\zcl_general.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleThermostat\CC2530DB\CoordinatorEB\Obj\zcl_general.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2015-09-10 09:36:48 -0700 (Thu, 10 Sep 2015) $
      4            Revision:       $Revision: 44493 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License"). You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product. Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "zcl.h"
     46          #include "zcl_general.h"
     47          //#include "ZDApp.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          #include "bdb.h"
     53          
     54          /*********************************************************************
     55           * MACROS
     56           */
     57          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     58          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     59          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     60          
     61          #ifdef ZCL_SCENES
     62          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     63          #endif // ZCL_SCENES
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          
     69          /*********************************************************************
     70           * TYPEDEFS
     71           */
     72          typedef struct zclGenCBRec
     73          {
     74            struct zclGenCBRec        *next;
     75            uint8                     endpoint; // Used to link it into the endpoint descriptor
     76            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     77          } zclGenCBRec_t;
     78          
     79          typedef struct zclGenSceneItem
     80          {
     81            struct zclGenSceneItem    *next;
     82            uint8                     endpoint; // Used to link it into the endpoint descriptor
     83            zclGeneral_Scene_t        scene;    // Scene info
     84          } zclGenSceneItem_t;
     85          
     86          typedef struct zclGenAlarmItem
     87          {
     88            struct zclGenAlarmItem    *next;
     89            uint8                     endpoint; // Used to link it into the endpoint descriptor
     90            zclGeneral_Alarm_t        alarm;    // Alarm info
     91          } zclGenAlarmItem_t;
     92          
     93          // Scene NV types
     94          typedef struct
     95          {
     96            uint16                    numRecs;
     97          } nvGenScenesHdr_t;
     98          
     99          typedef struct zclGenSceneNVItem
    100          {
    101            uint8                     endpoint;
    102            zclGeneral_Scene_t        scene;
    103          } zclGenSceneNVItem_t;
    104          
    105          /*********************************************************************
    106           * GLOBAL VARIABLES
    107           */
    108          
    109          /*********************************************************************
    110           * GLOBAL FUNCTIONS
    111           */
    112          
    113          /*********************************************************************
    114           * LOCAL VARIABLES
    115           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    116          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    117          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    118          
    119          #if defined( ZCL_SCENES )
    120            #if !defined ( ZCL_STANDALONE )
    121              static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    122            #endif
    123          #endif // ZCL_SCENES
    124          
    125          #ifdef ZCL_ALARMS
    126          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    127          #endif // ZCL_ALARMS
    128          
    129          /*********************************************************************
    130           * LOCAL FUNCTIONS
    131           */
    132          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    133          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    134          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    135          
    136          // Device Configuration and Installation clusters
    137          #ifdef ZCL_BASIC
    138          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    139          #endif // ZCL_BASIC
    140          
    141          #ifdef ZCL_IDENTIFY
    142          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    143          #endif // ZCL_IDENTIFY
    144          
    145          // Groups and Scenes clusters
    146          #ifdef ZCL_GROUPS
    147          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    148          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    149          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    150          #endif // ZCL_GROUPS
    151          
    152          #ifdef ZCL_SCENES
    153          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    154          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    155          #endif // ZCL_SCENES
    156          
    157          // On/Off and Level Control Configuration clusters
    158          #ifdef ZCL_ON_OFF
    159          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    160          //static ZStatus_t zclGeneral_ProcessInOnOffTest( zclIncoming_t *pInMsg );
    161          #endif // ZCL_ONOFF
    162          
    163          #ifdef ZCL_LEVEL_CTRL
    164          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    165          #endif // ZCL_LEVEL_CTRL
    166          
    167          // Alarms cluster
    168          #ifdef ZCL_ALARMS
    169          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    170          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    171          #endif // ZCL_ALARMS
    172          
    173          // Location cluster
    174          #ifdef ZCL_LOCATION
    175          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    176          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    177          #endif // ZCL_LOCATION
    178          
    179          #ifdef ZCL_SCENES
    180            #if !defined ( ZCL_STANDALONE )
    181              static uint8 zclGeneral_ScenesInitNV( void );
    182              static void zclGeneral_ScenesSetDefaultNV( void );
    183              static void zclGeneral_ScenesWriteNV( void );
    184              static uint16 zclGeneral_ScenesRestoreFromNV( void );
    185            #endif
    186          #endif // ZCL_SCENES
    187          
    188          /*********************************************************************
    189           * @fn      zclGeneral_RegisterCmdCallbacks
    190           *
    191           * @brief   Register an applications command callbacks
    192           *
    193           * @param   endpoint - application's endpoint
    194           * @param   callbacks - pointer to the callback record.
    195           *
    196           * @return  ZMemError if not able to allocate
    197           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    198          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    199          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
    200            zclGenCBRec_t *pNewItem;
    201            zclGenCBRec_t *pLoop;
    202          
    203            // Register as a ZCL Plugin
    204            if ( zclGenPluginRegisted == FALSE )
   \   00000B   90....       MOV       DPTR,#zclGenPluginRegisted
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   7021         JNZ       ??zclGeneral_RegisterCmdCallbacks_0
    205            {
    206              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    207                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    208                                  zclGeneral_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV       ?V2,#`??zclGeneral_HdlIncoming::?relay` & 0xff
   \   000014   75....       MOV       ?V3,#(`??zclGeneral_HdlIncoming::?relay` >> 8) & 0xff
   \   000017   78..         MOV       R0,#?V2
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   7C14         MOV       R4,#0x14
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7A00         MOV       R2,#0x0
   \   000022   7B00         MOV       R3,#0x0
   \   000024   12....       LCALL     `??zcl_registerPlugin::?relay`; Banked call to: zcl_registerPlugin
   \   000027   7402         MOV       A,#0x2
   \   000029   12....       LCALL     ?DEALLOC_XSTACK8
    209          
    210          #ifdef ZCL_SCENES
    211              // Initialize the Scenes Table
    212              zclGeneral_ScenesInit();
    213          #endif // ZCL_SCENES
    214          
    215              zclGenPluginRegisted = TRUE;
   \   00002C   90....       MOV       DPTR,#zclGenPluginRegisted
   \   00002F   7401         MOV       A,#0x1
   \   000031   F0           MOVX      @DPTR,A
    216            }
    217          
    218            // Fill in the new profile list
    219            pNewItem = zcl_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A05         MOV       R2,#0x5
   \   000034   7B00         MOV       R3,#0x0
   \   000036   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000039   8A..         MOV       ?V2,R2
   \   00003B   8B..         MOV       ?V3,R3
   \   00003D   A8..         MOV       R0,?V2
   \   00003F   A9..         MOV       R1,?V3
    220            if ( pNewItem == NULL )
   \   000041   EA           MOV       A,R2
   \   000042   49           ORL       A,R1
   \   000043   7004         JNZ       ??zclGeneral_RegisterCmdCallbacks_1
    221              return (ZMemError);
   \   000045   7910         MOV       R1,#0x10
   \   000047   8047         SJMP      ??zclGeneral_RegisterCmdCallbacks_2
    222          
    223            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_1:
   \   000049   8A82         MOV       DPL,R2
   \   00004B   8B83         MOV       DPH,R3
   \   00004D   E4           CLR       A
   \   00004E   F0           MOVX      @DPTR,A
   \   00004F   A3           INC       DPTR
   \   000050   F0           MOVX      @DPTR,A
    224            pNewItem->endpoint = endpoint;
   \   000051   8A82         MOV       DPL,R2
   \   000053   8B83         MOV       DPH,R3
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   E5..         MOV       A,?V0
   \   000059   F0           MOVX      @DPTR,A
    225            pNewItem->CBs = callbacks;
   \   00005A   8A82         MOV       DPL,R2
   \   00005C   8B83         MOV       DPH,R3
   \   00005E   A3           INC       DPTR
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   EE           MOV       A,R6
   \   000062   F0           MOVX      @DPTR,A
   \   000063   A3           INC       DPTR
   \   000064   EF           MOV       A,R7
   \   000065   F0           MOVX      @DPTR,A
    226          
    227            // Find spot in list
    228            if (  zclGenCBs == NULL )
   \   000066   90....       MOV       DPTR,#zclGenCBs
   \   000069   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00006C   EA           MOV       A,R2
   \   00006D   4B           ORL       A,R3
   \   00006E   90....       MOV       DPTR,#zclGenCBs
   \   000071   6018         JZ        ??zclGeneral_RegisterCmdCallbacks_3
    229            {
    230              zclGenCBs = pNewItem;
    231            }
    232            else
    233            {
    234              // Look for end of list
    235              pLoop = zclGenCBs;
   \   000073   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000076   8003         SJMP      ??zclGeneral_RegisterCmdCallbacks_4
    236              while ( pLoop->next != NULL )
    237                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   000078   EA           MOV       A,R2
   \   000079   FC           MOV       R4,A
   \   00007A   EB           MOV       A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   00007B   FD           MOV       R5,A
   \   00007C   8C82         MOV       DPL,R4
   \   00007E   8D83         MOV       DPH,R5
   \   000080   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000083   EA           MOV       A,R2
   \   000084   4B           ORL       A,R3
   \   000085   70F1         JNZ       ??zclGeneral_RegisterCmdCallbacks_5
    238          
    239              // Put new item at end of list
    240              pLoop->next = pNewItem;
   \   000087   8C82         MOV       DPL,R4
   \   000089   8D83         MOV       DPH,R5
    241            }
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   00008B   12....       LCALL     ?Subroutine24 & 0xFFFF
    242          
    243            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_108:
   \   00008E   7900         MOV       R1,#0x0
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   000090   02....       LJMP      ??Subroutine44_0 & 0xFFFF
    244          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine44_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E8           MOV       A,R0
   \   000001                REQUIRE ??Subroutine51_0
   \   000001                ; // Fall through to label ??Subroutine51_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine51_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   E9           MOV       A,R1
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET
    245          
    246          #ifdef ZCL_IDENTIFY
    247          /*********************************************************************
    248           * @fn      zclGeneral_SendIdentify
    249           *
    250           * @brief   Call to send out an Identify Command
    251           *
    252           * @param   srcEP - Sending application's endpoint
    253           * @param   dstAddr - where you want the message to go
    254           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    255           * @param   seqNum - identification number for the transaction
    256           *
    257           * @return  ZStatus_t
    258           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    259          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    260                                             uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    261          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    262            uint8 buf[2];
    263          
    264            buf[0] = LO_UINT16( identifyTime );
   \   00000C   EC           MOV       A,R4
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    265            buf[1] = HI_UINT16( identifyTime );
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ?Subroutine23 & 0xFFFF
    266          
    267            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    268                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    269                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_43:
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   75..02       MOV       ?V0,#0x2
   \   000022   75..00       MOV       ?V1,#0x0
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   7411         MOV       A,#0x11
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000035   E4           CLR       A
   \   000036   F5..         MOV       ?V0,A
   \   000038   78..         MOV       R0,#?V0
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7413         MOV       A,#0x13
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000048   75..00       MOV       ?V0,#0x0
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000050   75..01       MOV       ?V0,#0x1
   \   000053                REQUIRE ?Subroutine1
   \   000053                ; // Fall through to label ?Subroutine1
    270          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   78..         MOV       R0,#?V0
   \   000002   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000005   75..00       MOV       ?V0,#0x0
   \   000008   78..         MOV       R0,#?V0
   \   00000A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00000D   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000010   12....       LCALL     ?DEALLOC_XSTACK8
   \   000013   7402         MOV       A,#0x2
   \   000015   12....       LCALL     ?DEALLOC_XSTACK8
   \   000018                REQUIRE ??Subroutine37_0
   \   000018                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   ED           MOV       A,R5
   \   000001   F0           MOVX      @DPTR,A
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002   A8..         MOV       R0,?XSP + 0
   \   000004   A9..         MOV       R1,?XSP + 1
   \   000006   88..         MOV       ?V0,R0
   \   000008   89..         MOV       ?V1,R1
   \   00000A   78..         MOV       R0,#?V0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   78..         MOV       R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   7C03         MOV       R4,#0x3
   \   000002                REQUIRE ??Subroutine45_0
   \   000002                ; // Fall through to label ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine45_0:
   \   000000   7D00         MOV       R5,#0x0
   \   000002   EE           MOV       A,R6
   \   000003   F9           MOV       R1,A
   \   000004                REQUIRE ??Subroutine46_0
   \   000004                ; // Fall through to label ??Subroutine46_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine46_0:
   \   000000   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000003   740B         MOV       A,#0xb
   \   000005   22           RET
    271          
    272          /*********************************************************************
    273           * @fn      zclGeneral_SendIdentifyEZModeInvoke
    274           *
    275           * @brief   Call to send out an Identify EZ-Mode Invoke Command
    276           *
    277           * @param   srcEP - Sending application's endpoint
    278           * @param   dstAddr - where you want the message to go
    279           * @param   action - describes the EZ-Mode action to be performed
    280           * @param   seqNum - identification number for the transaction
    281           *
    282           * @return  ZStatus_t
    283           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    284          ZStatus_t zclGeneral_SendIdentifyEZModeInvoke( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyEZModeInvoke:
    285                                                         uint8 action, uint8 disableDefaultRsp, uint8 seqNum )
    286          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
    287            uint8 buf[1];
    288          
    289            buf[0] = action;
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   12....       LCALL     ??Subroutine38_0 & 0xFFFF
    290          
    291            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    292                                    COMMAND_IDENTIFY_EZMODE_INVOKE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    293                                    disableDefaultRsp, 0, seqNum, 1, buf );
   \                     ??CrossCallReturnLabel_64:
   \   000016   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000019   75..01       MOV       ?V2,#0x1
   \   00001C   75..00       MOV       ?V3,#0x0
   \   00001F   78..         MOV       R0,#?V2
   \   000021   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000024   7411         MOV       A,#0x11
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00002C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00002F   E4           CLR       A
   \   000030   F5..         MOV       ?V2,A
   \   000032   78..         MOV       R0,#?V2
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000037   ED           MOV       A,R5
   \   000038   F5..         MOV       ?V1,A
   \   00003A   78..         MOV       R0,#?V1
   \   00003C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00003F   75..00       MOV       ?V1,#0x0
   \   000042   78..         MOV       R0,#?V1
   \   000044   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000047   75..01       MOV       ?V1,#0x1
   \   00004A   78..         MOV       R0,#?V1
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004F   75..02       MOV       ?V1,#0x2
   \   000052   78..         MOV       R0,#?V1
   \   000054   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000057   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00005A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005D   7401         MOV       A,#0x1
   \   00005F   02....       LJMP      ??Subroutine43_0 & 0xFFFF
    294          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001   A8..         MOV       R0,?XSP + 0
   \   000003   A9..         MOV       R1,?XSP + 1
   \   000005   88..         MOV       ?V2,R0
   \   000007   89..         MOV       ?V3,R1
   \   000009   78..         MOV       R0,#?V2
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V1,A
   \   000003   78..         MOV       R0,#?V1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine44_0
   \   000003                ; // Fall through to label ??Subroutine44_0
    295          
    296          /*********************************************************************
    297           * @fn      zclGeneral_SendIdentifyUpdateCommState
    298           *
    299           * @brief   Call to send out an Identify Update Commission State Command
    300           *
    301           * @param   srcEP - Sending application's endpoint
    302           * @param   dstAddr - where you want the message to go
    303           * @param   action - describes the EZ-Mode action to be performed
    304           * @param   commissionStateMask - updates the device's commission state
    305           * @param   seqNum - identification number for the transaction
    306           *
    307           * @return  ZStatus_t
    308           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    309          ZStatus_t zclGeneral_SendIdentifyUpdateCommState( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyUpdateCommState:
    310                                                            uint8 action, uint8 commissionStateMask,
    311                                                            uint8 disableDefaultRsp, uint8 seqNum )
    312          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
    313            uint8 buf[2];
    314          
    315            buf[0] = action;
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    316            buf[1] = commissionStateMask;
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   ED           MOV       A,R5
   \   00001A   12....       LCALL     ??Subroutine38_0 & 0xFFFF
    317          
    318            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    319                                    COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    320                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_65:
   \   00001D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000020   75..02       MOV       ?V2,#0x2
   \   000023   75..00       MOV       ?V3,#0x0
   \   000026   78..         MOV       R0,#?V2
   \   000028   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002B   7413         MOV       A,#0x13
   \   00002D   12....       LCALL     ?XSTACK_DISP0_8
   \   000030   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000036   E4           CLR       A
   \   000037   F5..         MOV       ?V2,A
   \   000039   78..         MOV       R0,#?V2
   \   00003B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003E   7415         MOV       A,#0x15
   \   000040   12....       LCALL     ?XSTACK_DISP0_8
   \   000043   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000046   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000049   75..00       MOV       ?V1,#0x0
   \   00004C   78..         MOV       R0,#?V1
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000051   75..01       MOV       ?V1,#0x1
   \   000054   78..         MOV       R0,#?V1
   \   000056   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000059   75..03       MOV       ?V1,#0x3
   \   00005C   78..         MOV       R0,#?V1
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000061   7C03         MOV       R4,#0x3
   \   000063   7D00         MOV       R5,#0x0
   \   000065   EE           MOV       A,R6
   \   000066   F9           MOV       R1,A
   \   000067   02....       LJMP      ?Subroutine0 & 0xFFFF
    321          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000003   12....       LCALL     ?DEALLOC_XSTACK8
   \   000006   7402         MOV       A,#0x2
   \   000008                REQUIRE ??Subroutine43_0
   \   000008                ; // Fall through to label ??Subroutine43_0
    322          
    323          #ifdef ZCL_LIGHT_LINK_ENHANCE
    324          /*********************************************************************
    325           * @fn      zclGeneral_SendIdentifyTriggerEffect
    326           *
    327           * @brief   Call to send out a Trigger Effect Command
    328           *
    329           * @param   srcEP - Sending application's endpoint
    330           * @param   dstAddr - where you want the message to go
    331           * @param   effectId - identify effect to use
    332           * @param   effectVariant - which variant of effect to be triggered
    333           * @param   disableDefaultRsp - whether to disable the Default Response command
    334           * @param   seqNum - identification number for the transaction
    335           *
    336           * @return  ZStatus_t
    337           */
    338          ZStatus_t zclGeneral_SendIdentifyTriggerEffect( uint8 srcEP, afAddrType_t *dstAddr,
    339                                                          uint8 effectId, uint8 effectVariant,
    340                                                          uint8 disableDefaultRsp, uint8 seqNum )
    341          {
    342            uint8 buf[2];
    343          
    344            buf[0] = effectId;
    345            buf[1] = effectVariant;
    346          
    347            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    348                                    COMMAND_IDENTIFY_TRIGGER_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    349                                    disableDefaultRsp, 0, seqNum, 2, buf );
    350          }
    351          #endif // ZCL_LIGHT_LINK_ENHANCE
    352          
    353          /*********************************************************************
    354           * @fn      zclGeneral_SendIdentifyQueryResponse
    355           *
    356           * @brief   Call to send out an Identify Query Response Command
    357           *
    358           * @param   srcEP - Sending application's endpoint
    359           * @param   dstAddr - where you want the message to go
    360           * @param   timeout - how long the device will continue to identify itself (in seconds)
    361           * @param   seqNum - identification number for the transaction
    362           *
    363           * @return  ZStatus_t
    364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    365          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    366                                                          uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    367          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    368            uint8 buf[2];
    369          
    370            buf[0] = LO_UINT16( timeout );
   \   00000C   EC           MOV       A,R4
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    371            buf[1] = HI_UINT16( timeout );
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ?Subroutine23 & 0xFFFF
    372          
    373            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    374                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    375                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_44:
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   75..02       MOV       ?V0,#0x2
   \   000022   75..00       MOV       ?V1,#0x0
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   7411         MOV       A,#0x11
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000035   E4           CLR       A
   \   000036   F5..         MOV       ?V0,A
   \   000038   78..         MOV       R0,#?V0
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7413         MOV       A,#0x13
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000048   75..01       MOV       ?V0,#0x1
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000050   02....       LJMP      ?Subroutine1 & 0xFFFF
    376          }
    377          #endif // ZCL_IDENTIFY
    378          
    379          #ifdef ZCL_GROUPS
    380          /*********************************************************************
    381           * @fn      zclGeneral_SendGroupRequest
    382           *
    383           * @brief   Send a Group Request to a device.  You can also use the
    384           *          appropriate macro.
    385           *
    386           * @param   srcEP - Sending Apps endpoint
    387           * @param   dstAddr - where to send the request
    388           * @param   cmd - one of the following:
    389           *              COMMAND_GROUP_VIEW
    390           *              COMMAND_GROUP_REMOVE
    391           * @param   groupID -
    392           *
    393           * @return  ZStatus_t
    394           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    395          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupRequest:
    396                                                 uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    397          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
   \   00000C   740E         MOV       A,#0xe
   \   00000E   12....       LCALL     ?XSTACK_DISP0_8
   \   000011   12....       LCALL     ?Subroutine13 & 0xFFFF
    398            uint8 buf[2];
    399          
    400            buf[0] = LO_UINT16( groupID );
   \                     ??CrossCallReturnLabel_20:
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   F0           MOVX      @DPTR,A
    401            buf[1] = HI_UINT16( groupID );
   \   00001B   7401         MOV       A,#0x1
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   12....       LCALL     ?Subroutine20 & 0xFFFF
    402          
    403            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    404                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    405                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
   \                     ??CrossCallReturnLabel_62:
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000026   75..02       MOV       ?V2,#0x2
   \   000029   75..00       MOV       ?V3,#0x0
   \   00002C   78..         MOV       R0,#?V2
   \   00002E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000031   7414         MOV       A,#0x14
   \   000033   12....       LCALL     ?XSTACK_DISP0_8
   \   000036   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000039   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00003C   E4           CLR       A
   \   00003D   F5..         MOV       ?V2,A
   \   00003F   78..         MOV       R0,#?V2
   \   000041   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000044   ED           MOV       A,R5
   \   000045   F5..         MOV       ?V1,A
   \   000047   78..         MOV       R0,#?V1
   \   000049   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004C   75..00       MOV       ?V1,#0x0
   \   00004F   78..         MOV       R0,#?V1
   \   000051   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000054   75..01       MOV       ?V1,#0x1
   \   000057   78..         MOV       R0,#?V1
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005C   EC           MOV       A,R4
   \   00005D   F5..         MOV       ?V1,A
   \   00005F   78..         MOV       R0,#?V1
   \   000061   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000064   7C04         MOV       R4,#0x4
   \   000066   7D00         MOV       R5,#0x0
   \   000068   A9..         MOV       R1,?V0
   \   00006A   02....       LJMP      ?Subroutine0 & 0xFFFF
    406          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E9           MOV       A,R1
   \   000001                REQUIRE ??Subroutine38_0
   \   000001                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL     ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000003   F9           MOV       R1,A
   \   000004   E8           MOV       A,R0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine50_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET
    407          
    408          /*********************************************************************
    409           * @fn      zclGeneral_SendAddGroupRequest
    410           *
    411           * @brief   Send the Add Group Request to a device
    412           *
    413           * @param   srcEP - Sending Apps endpoint
    414           * @param   dstAddr - where to send the request
    415           * @param   cmd - one of the following:
    416           *                COMMAND_GROUP_ADD
    417           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    418           * @param   groupID - pointer to the group structure
    419           * @param   groupName - pointer to Group Name.  This is a Zigbee
    420           *          string data type, so the first byte is the length of the
    421           *          name (in bytes), then the name.
    422           *
    423           * @return  ZStatus_t
    424           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    425          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendAddGroupRequest:
    426                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    427                                                    uint8 disableDefaultRsp, uint8 seqNum )
    428          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V7,R1
   \   00000C   8A..         MOV       ?V10,R2
   \   00000E   8B..         MOV       ?V11,R3
   \   000010   8C..         MOV       ?V9,R4
   \   000012   8D..         MOV       ?V8,R5
   \   000014   7417         MOV       A,#0x17
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ?Subroutine14 & 0xFFFF
    429            uint8 *buf;
    430            uint8 *pBuf;
    431            uint8 len;
    432            ZStatus_t status;
    433          
    434            len = 2;    // Group ID
    435            len += groupName[0] + 1;  // String + 1 for length
   \                     ??CrossCallReturnLabel_24:
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   2403         ADD       A,#0x3
   \   00001F   85..82       MOV       DPL,?XSP + 0
   \   000022   85..83       MOV       DPH,?XSP + 1
   \   000025   F0           MOVX      @DPTR,A
    436          
    437            buf = zcl_mem_alloc( len );
   \   000026   12....       LCALL     ?Subroutine21 & 0xFFFF
    438            if ( buf )
   \                     ??CrossCallReturnLabel_70:
   \   000029   7003         JNZ       $+5
   \   00002B   02....       LJMP      ??zclGeneral_SendAddGroupRequest_0 & 0xFFFF
   \   00002E   7415         MOV       A,#0x15
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   12....       LCALL     ?Subroutine13 & 0xFFFF
    439            {
    440              pBuf = buf;
    441              *pBuf++ = LO_UINT16( groupID );
   \                     ??CrossCallReturnLabel_21:
   \   000036   8A82         MOV       DPL,R2
   \   000038   8B83         MOV       DPH,R3
   \   00003A   F0           MOVX      @DPTR,A
    442              *pBuf++ = HI_UINT16( groupID );
   \   00003B   E9           MOV       A,R1
   \   00003C   A3           INC       DPTR
   \   00003D   12....       LCALL     ?Subroutine33 & 0xFFFF
    443              *pBuf++ = groupName[0]; // string length
   \                     ??CrossCallReturnLabel_59:
   \   000040   12....       LCALL     ?Subroutine18 & 0xFFFF
    444              zcl_memcpy( pBuf, &(groupName[1]), groupName[0] );
   \                     ??CrossCallReturnLabel_39:
   \   000043                ; Setup parameters for call to function osal_memcpy
   \   000043   85..82       MOV       DPL,?V2
   \   000046   85..83       MOV       DPH,?V3
   \   000049   A3           INC       DPTR
   \   00004A   A982         MOV       R1,DPL
   \   00004C   AA83         MOV       R2,DPH
   \   00004E   89..         MOV       ?V4,R1
   \   000050   8A..         MOV       ?V5,R2
   \   000052   75..00       MOV       ?V6,#0x0
   \   000055   78..         MOV       R0,#?V4
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00005A   85..82       MOV       DPL,?V2
   \   00005D   85..83       MOV       DPH,?V3
   \   000060   E0           MOVX      A,@DPTR
   \   000061   FC           MOV       R4,A
   \   000062   7D00         MOV       R5,#0x0
   \   000064   E5..         MOV       A,?V0
   \   000066   2403         ADD       A,#0x3
   \   000068   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   00006B   12....       LCALL     ?DEALLOC_XSTACK8
    445          
    446              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    447                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    448                                        disableDefaultRsp, 0, seqNum, len, buf );
   \   00006E                ; Setup parameters for call to function zcl_SendCommand
   \   00006E   78..         MOV       R0,#?V0
   \   000070   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000073   8E..         MOV       ?V2,R6
   \   000075   75..00       MOV       ?V3,#0x0
   \   000078   78..         MOV       R0,#?V2
   \   00007A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007D   741D         MOV       A,#0x1d
   \   00007F   12....       LCALL     ?XSTACK_DISP0_8
   \   000082   E0           MOVX      A,@DPTR
   \   000083   F5..         MOV       ?V2,A
   \   000085   78..         MOV       R0,#?V2
   \   000087   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008A   E4           CLR       A
   \   00008B   F5..         MOV       ?V2,A
   \   00008D   78..         MOV       R0,#?V2
   \   00008F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000092   E5..         MOV       A,?V8
   \   000094   F5..         MOV       ?V2,A
   \   000096   78..         MOV       R0,#?V2
   \   000098   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00009B   75..00       MOV       ?V2,#0x0
   \   00009E   78..         MOV       R0,#?V2
   \   0000A0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A3   75..01       MOV       ?V2,#0x1
   \   0000A6   78..         MOV       R0,#?V2
   \   0000A8   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000AB   E5..         MOV       A,?V9
   \   0000AD   F5..         MOV       ?V2,A
   \   0000AF   78..         MOV       R0,#?V2
   \   0000B1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B4   7C04         MOV       R4,#0x4
   \   0000B6   7D00         MOV       R5,#0x0
   \   0000B8   AA..         MOV       R2,?V10
   \   0000BA   AB..         MOV       R3,?V11
   \   0000BC   A9..         MOV       R1,?V7
   \   0000BE   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   0000C1   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C4   E9           MOV       A,R1
   \   0000C5   FE           MOV       R6,A
    449              zcl_mem_free( buf );
   \   0000C6                ; Setup parameters for call to function osal_mem_free
   \   0000C6   AA..         MOV       R2,?V0
   \   0000C8   AB..         MOV       R3,?V1
   \   0000CA   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000CD   8002         SJMP      ??zclGeneral_SendAddGroupRequest_1
    450            }
    451            else
    452              status = ZMemError;
   \                     ??zclGeneral_SendAddGroupRequest_0:
   \   0000CF   7E10         MOV       R6,#0x10
    453          
    454            return ( status );
   \                     ??zclGeneral_SendAddGroupRequest_1:
   \   0000D1   EE           MOV       A,R6
   \   0000D2   F9           MOV       R1,A
   \   0000D3   7401         MOV       A,#0x1
   \   0000D5                REQUIRE ?Subroutine2
   \   0000D5                ; // Fall through to label ?Subroutine2
    455          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine39_0
   \   000003                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   7F0C         MOV       R7,#0xc
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   FA           MOV       R2,A
   \   000001   E4           CLR       A
   \   000002   35..         ADDC      A,?V1
   \   000004                REQUIRE ??Subroutine40_0
   \   000004                ; // Fall through to label ??Subroutine40_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   FB           MOV       R3,A
   \   000001                REQUIRE ??Subroutine41_0
   \   000001                ; // Fall through to label ??Subroutine41_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine41_0:
   \   000000   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000003   7403         MOV       A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   FE           MOV       R6,A
   \   000001                ; Setup parameters for call to function osal_mem_alloc
   \   000001                ; Setup parameters for call to function osal_mem_alloc
   \   000001   FA           MOV       R2,A
   \   000002   7B00         MOV       R3,#0x0
   \   000004                REQUIRE ??Subroutine42_0
   \   000004                ; // Fall through to label ??Subroutine42_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000003   8A..         MOV       ?V0,R2
   \   000005   8B..         MOV       ?V1,R3
   \   000007   EA           MOV       A,R2
   \   000008   4B           ORL       A,R3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function osal_memcpy
   \   000001   85..82       MOV       DPL,?V2
   \   000004   85..83       MOV       DPH,?V3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V3,A
   \   000007   85..82       MOV       DPL,?V2
   \   00000A   F583         MOV       DPH,A
   \   00000C   22           RET
    456          
    457          /*********************************************************************
    458           * @fn      zclGeneral_SendGroupGetMembershipRequest
    459           *
    460           * @brief   Send a Get Group Membership (Resposne) Command to a device
    461           *
    462           * @param   srcEP - Sending Apps endpoint
    463           * @param   dstAddr - where to send the request
    464           * @param   cmd - one of the following:
    465           *                COMMAND_GROUP_GET_MEMBERSHIP
    466           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    467           * @param   groupID - pointer to the group structure
    468           * @param   groupName - pointer to Group Name.  This is a Zigbee
    469           *          string data type, so the first byte is the length of the
    470           *          name (in bytes), then the name.
    471           *
    472           * @return  ZStatus_t
    473           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    474          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupGetMembershipRequest:
    475                                                              uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    476                                                              uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    477          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V6,R2
   \   000009   8B..         MOV       ?V7,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
    478            uint8 *buf;
    479            uint8 *pBuf;
    480            uint8 len = 0;
   \   00000F   7800         MOV       R0,#0x0
    481            uint8 i;
    482            ZStatus_t status;
    483          
    484            if ( rspCmd )
   \   000011   6002         JZ        ??zclGeneral_SendGroupGetMembershipRequest_0
    485              len++;  // Capacity
   \   000013   7801         MOV       R0,#0x1
   \                     ??zclGeneral_SendGroupGetMembershipRequest_0:
   \   000015   7416         MOV       A,#0x16
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F5..         MOV       ?V3,A
    486          
    487            len++;  // Group Count
    488            len += sizeof ( uint16 ) * grpCnt;  // Group List
   \   00001D   C3           CLR       C
   \   00001E   33           RLC       A
   \   00001F   04           INC       A
   \   000020   28           ADD       A,R0
    489          
    490            buf = zcl_mem_alloc( len );
   \   000021   F5..         MOV       ?V4,A
   \   000023   75..00       MOV       ?V5,#0x0
   \   000026                ; Setup parameters for call to function osal_mem_alloc
   \   000026   FA           MOV       R2,A
   \   000027   AB..         MOV       R3,?V5
   \   000029   12....       LCALL     ??Subroutine42_0 & 0xFFFF
    491            if ( buf )
   \                     ??CrossCallReturnLabel_72:
   \   00002C   7003         JNZ       $+5
   \   00002E   02....       LJMP      ??zclGeneral_SendGroupGetMembershipRequest_1 & 0xFFFF
    492            {
    493              pBuf = buf;
   \   000031   A8..         MOV       R0,?V0
   \   000033   A9..         MOV       R1,?V1
    494              if ( rspCmd )
   \   000035   EF           MOV       A,R7
   \   000036   6010         JZ        ??zclGeneral_SendGroupGetMembershipRequest_2
    495                *pBuf++ = capacity;
   \   000038   7415         MOV       A,#0x15
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   8A82         MOV       DPL,R2
   \   000040   8B83         MOV       DPH,R3
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   A882         MOV       R0,DPL
   \   000046   A983         MOV       R1,DPH
    496          
    497              *pBuf++ = grpCnt;
   \                     ??zclGeneral_SendGroupGetMembershipRequest_2:
   \   000048   8882         MOV       DPL,R0
   \   00004A   8983         MOV       DPH,R1
   \   00004C   E5..         MOV       A,?V3
   \   00004E   F0           MOVX      @DPTR,A
   \   00004F   A3           INC       DPTR
   \   000050   A882         MOV       R0,DPL
   \   000052   A983         MOV       R1,DPH
    498              for ( i = 0; i < grpCnt; i++ )
   \   000054   7C00         MOV       R4,#0x0
   \   000056   7417         MOV       A,#0x17
   \   000058   12....       LCALL     ?XSTACK_DISP0_8
   \   00005B   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   00005E   8034         SJMP      ??zclGeneral_SendGroupGetMembershipRequest_3
    499              {
    500                *pBuf++ = LO_UINT16( grpList[i] );
   \                     ??zclGeneral_SendGroupGetMembershipRequest_4:
   \   000060   EC           MOV       A,R4
   \   000061   25E0         ADD       A,0xE0 /* A   */
   \   000063   F5..         MOV       ?V8,A
   \   000065   E4           CLR       A
   \   000066   33           RLC       A
   \   000067   F5..         MOV       ?V9,A
   \   000069   EA           MOV       A,R2
   \   00006A   25..         ADD       A,?V8
   \   00006C   F5..         MOV       ?V8,A
   \   00006E   EB           MOV       A,R3
   \   00006F   35..         ADDC      A,?V9
   \   000071   F5..         MOV       ?V9,A
   \   000073   85..82       MOV       DPL,?V8
   \   000076   F583         MOV       DPH,A
   \   000078   E0           MOVX      A,@DPTR
   \   000079   8882         MOV       DPL,R0
   \   00007B   8983         MOV       DPH,R1
   \   00007D   F0           MOVX      @DPTR,A
    501                *pBuf++ = HI_UINT16( grpList[i] );
   \   00007E   85..82       MOV       DPL,?V8
   \   000081   85..83       MOV       DPH,?V9
   \   000084   A3           INC       DPTR
   \   000085   E0           MOVX      A,@DPTR
   \   000086   8882         MOV       DPL,R0
   \   000088   8983         MOV       DPH,R1
   \   00008A   A3           INC       DPTR
   \   00008B   F0           MOVX      @DPTR,A
   \   00008C   E8           MOV       A,R0
   \   00008D   2402         ADD       A,#0x2
   \   00008F   F8           MOV       R0,A
   \   000090   5001         JNC       ??zclGeneral_SendGroupGetMembershipRequest_5
   \   000092   09           INC       R1
    502              }
   \                     ??zclGeneral_SendGroupGetMembershipRequest_5:
   \   000093   0C           INC       R4
   \                     ??zclGeneral_SendGroupGetMembershipRequest_3:
   \   000094   EC           MOV       A,R4
   \   000095   C3           CLR       C
   \   000096   95..         SUBB      A,?V3
   \   000098   40C6         JC        ??zclGeneral_SendGroupGetMembershipRequest_4
    503          
    504              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    505                                        cmd, TRUE, direction,
    506                                        disableDefaultRsp, 0, seqNum, len, buf );
   \   00009A                ; Setup parameters for call to function zcl_SendCommand
   \   00009A   78..         MOV       R0,#?V0
   \   00009C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009F   78..         MOV       R0,#?V4
   \   0000A1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A4   741E         MOV       A,#0x1e
   \   0000A6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A9   E0           MOVX      A,@DPTR
   \   0000AA   F5..         MOV       ?V3,A
   \   0000AC   78..         MOV       R0,#?V3
   \   0000AE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B1   E4           CLR       A
   \   0000B2   F5..         MOV       ?V4,A
   \   0000B4   78..         MOV       R0,#?V4
   \   0000B6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B9   7420         MOV       A,#0x20
   \   0000BB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BE   E0           MOVX      A,@DPTR
   \   0000BF   F5..         MOV       ?V3,A
   \   0000C1   78..         MOV       R0,#?V3
   \   0000C3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C6   741C         MOV       A,#0x1c
   \   0000C8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CB   E0           MOVX      A,@DPTR
   \   0000CC   F5..         MOV       ?V3,A
   \   0000CE   78..         MOV       R0,#?V3
   \   0000D0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D3   75..01       MOV       ?V3,#0x1
   \   0000D6   78..         MOV       R0,#?V3
   \   0000D8   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000DB   EE           MOV       A,R6
   \   0000DC   F5..         MOV       ?V3,A
   \   0000DE   78..         MOV       R0,#?V3
   \   0000E0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E3   7C04         MOV       R4,#0x4
   \   0000E5   7D00         MOV       R5,#0x0
   \   0000E7   AA..         MOV       R2,?V6
   \   0000E9   AB..         MOV       R3,?V7
   \   0000EB   A9..         MOV       R1,?V2
   \   0000ED   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   0000F0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000F3   E9           MOV       A,R1
   \   0000F4   F5..         MOV       ?V3,A
    507              zcl_mem_free( buf );
   \   0000F6                ; Setup parameters for call to function osal_mem_free
   \   0000F6   AA..         MOV       R2,?V0
   \   0000F8   AB..         MOV       R3,?V1
   \   0000FA   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000FD   8003         SJMP      ??zclGeneral_SendGroupGetMembershipRequest_6
    508            }
    509            else
    510              status = ZMemError;
   \                     ??zclGeneral_SendGroupGetMembershipRequest_1:
   \   0000FF   75..10       MOV       ?V3,#0x10
    511          
    512            return ( status );
   \                     ??zclGeneral_SendGroupGetMembershipRequest_6:
   \   000102   A9..         MOV       R1,?V3
   \   000104   02....       LJMP      ??Subroutine39_0 & 0xFFFF
    513          }
    514          
    515          /*********************************************************************
    516           * @fn      zclGeneral_SendGroupResponse
    517           *
    518           * @brief   Send Group Response (not Group View Response)
    519           *
    520           * @param   srcEP - Sending application's endpoint
    521           * @param   dstAddr - where you want the message to go
    522           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    523           * @param   status - group command status
    524           * @param   groupID - what group
    525           *
    526           * @return  ZStatus_t
    527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    528          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupResponse:
    529                                                  uint8 cmd, uint8 status, uint16 groupID,
    530                                                  uint8 disableDefaultRsp, uint8 seqNum )
    531          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    532            uint8 buf[3];
    533          
    534            buf[0] = status;
   \   00000C   85..82       MOV       DPL,?XSP + 0
   \   00000F   85..83       MOV       DPH,?XSP + 1
   \   000012   ED           MOV       A,R5
   \   000013   F0           MOVX      @DPTR,A
   \   000014   740F         MOV       A,#0xf
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00001C   F9           MOV       R1,A
    535            buf[1] = LO_UINT16( groupID );
   \   00001D   7401         MOV       A,#0x1
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   E8           MOV       A,R0
   \   000023   F0           MOVX      @DPTR,A
    536            buf[2] = HI_UINT16( groupID );
   \   000024   7402         MOV       A,#0x2
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   12....       LCALL     ?Subroutine20 & 0xFFFF
    537          
    538            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    539                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    540                                    disableDefaultRsp, 0, seqNum, 3, buf );
   \                     ??CrossCallReturnLabel_63:
   \   00002C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002F   75..03       MOV       ?V2,#0x3
   \   000032   75..00       MOV       ?V3,#0x0
   \   000035   78..         MOV       R0,#?V2
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003A   7416         MOV       A,#0x16
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000042   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000045   E4           CLR       A
   \   000046   F5..         MOV       ?V2,A
   \   000048   78..         MOV       R0,#?V2
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004D   7418         MOV       A,#0x18
   \   00004F   12....       LCALL     ?XSTACK_DISP0_8
   \   000052   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000055   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000058   75..01       MOV       ?V1,#0x1
   \   00005B   78..         MOV       R0,#?V1
   \   00005D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000060   78..         MOV       R0,#?V1
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000065   EC           MOV       A,R4
   \   000066   F5..         MOV       ?V1,A
   \   000068   78..         MOV       R0,#?V1
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006D   7C04         MOV       R4,#0x4
   \   00006F   12....       LCALL     ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000072   12....       LCALL     ?DEALLOC_XSTACK8
   \   000075   7403         MOV       A,#0x3
   \   000077   80..         SJMP      ??Subroutine43_0
    541          }
    542          
    543          /*********************************************************************
    544           * @fn      zclGeneral_SendGroupViewResponse
    545           *
    546           * @brief   Call to send Group Response Command
    547           *
    548           * @param   srcEP - Sending application's endpoint
    549           * @param   dstAddr - where you want the message to go
    550           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    551           * @param   status - group command status
    552           * @param   grp - group info
    553           *
    554           * @return  ZStatus_t
    555           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    556          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupViewResponse:
    557                                                      uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    558          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V8,R1
   \   000007   8A..         MOV       ?V12,R2
   \   000009   8B..         MOV       ?V13,R3
   \   00000B   8C..         MOV       ?V7,R4
   \   00000D   8D..         MOV       ?V9,R5
    559            uint8 *buf;
    560            uint8 len;
    561            ZStatus_t stat;
    562          
    563            len = 1 + 2 + 1; // Status + Group ID + name length
   \   00000F   7804         MOV       R0,#0x4
   \   000011   7416         MOV       A,#0x16
   \   000013   12....       LCALL     ?XSTACK_DISP0_8
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F5..         MOV       ?V4,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F5..         MOV       ?V5,A
    564          
    565            if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   E5..         MOV       A,?V4
   \   00001F   2402         ADD       A,#0x2
   \   000021   F5..         MOV       ?V2,A
   \   000023   E4           CLR       A
   \   000024   35..         ADDC      A,?V5
   \   000026   F5..         MOV       ?V3,A
   \   000028   EC           MOV       A,R4
   \   000029   7009         JNZ       ??zclGeneral_SendGroupViewResponse_0
    566            {
    567              len += grp->name[0];  // String length
   \   00002B   85..82       MOV       DPL,?V2
   \   00002E   85..83       MOV       DPH,?V3
   \   000031   E0           MOVX      A,@DPTR
   \   000032   28           ADD       A,R0
   \   000033   F8           MOV       R0,A
    568            }
    569          
    570            buf = zcl_mem_alloc( len );
   \                     ??zclGeneral_SendGroupViewResponse_0:
   \   000034   E8           MOV       A,R0
   \   000035   12....       LCALL     ?Subroutine21 & 0xFFFF
    571            if ( buf )
   \                     ??CrossCallReturnLabel_71:
   \   000038   7003         JNZ       $+5
   \   00003A   02....       LJMP      ??zclGeneral_SendGroupViewResponse_1 & 0xFFFF
    572            {
    573              buf[0] = status;
   \   00003D   8A82         MOV       DPL,R2
   \   00003F   8B83         MOV       DPH,R3
   \   000041   E5..         MOV       A,?V7
   \   000043   F0           MOVX      @DPTR,A
    574              buf[1] = LO_UINT16( grp->ID );
   \   000044   85..82       MOV       DPL,?V4
   \   000047   85..83       MOV       DPH,?V5
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   8A82         MOV       DPL,R2
   \   00004D   8B83         MOV       DPH,R3
   \   00004F   A3           INC       DPTR
   \   000050   12....       LCALL     ?Subroutine26 & 0xFFFF
    575              buf[2] = HI_UINT16( grp->ID );
   \                     ??CrossCallReturnLabel_47:
   \   000053   12....       LCALL     ?Subroutine18 & 0xFFFF
    576          
    577              if ( status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_40:
   \   000056   EA           MOV       A,R2
   \   000057   2403         ADD       A,#0x3
   \   000059   F8           MOV       R0,A
   \   00005A   E4           CLR       A
   \   00005B   35..         ADDC      A,?V1
   \   00005D   F9           MOV       R1,A
   \   00005E   E5..         MOV       A,?V7
   \   000060   7036         JNZ       ??zclGeneral_SendGroupViewResponse_2
    578              {
    579                buf[3] = grp->name[0]; // string length
   \   000062   85..82       MOV       DPL,?V2
   \   000065   85..83       MOV       DPH,?V3
   \   000068   E0           MOVX      A,@DPTR
   \   000069   8882         MOV       DPL,R0
   \   00006B   8983         MOV       DPH,R1
   \   00006D   12....       LCALL     ?Subroutine26 & 0xFFFF
    580                zcl_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    581              }
   \                     ??CrossCallReturnLabel_48:
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   A982         MOV       R1,DPL
   \   000074   AA83         MOV       R2,DPH
   \   000076   89..         MOV       ?V4,R1
   \   000078   8A..         MOV       ?V5,R2
   \   00007A   75..00       MOV       ?V6,#0x0
   \   00007D   78..         MOV       R0,#?V4
   \   00007F   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000082   85..82       MOV       DPL,?V2
   \   000085   85..83       MOV       DPH,?V3
   \   000088   E0           MOVX      A,@DPTR
   \   000089   FC           MOV       R4,A
   \   00008A   7D00         MOV       R5,#0x0
   \   00008C   E5..         MOV       A,?V0
   \   00008E   2404         ADD       A,#0x4
   \   000090   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000093   12....       LCALL     ?DEALLOC_XSTACK8
   \   000096   8006         SJMP      ??zclGeneral_SendGroupViewResponse_3
    582              else //ZCL_STATUS_NOT_FOUND
    583              {
    584                buf[3] = 0;
   \                     ??zclGeneral_SendGroupViewResponse_2:
   \   000098   8882         MOV       DPL,R0
   \   00009A   8983         MOV       DPH,R1
   \   00009C   E4           CLR       A
   \   00009D   F0           MOVX      @DPTR,A
    585              }
    586          
    587              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    588                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    589                                      disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zclGeneral_SendGroupViewResponse_3:
   \   00009E                ; Setup parameters for call to function zcl_SendCommand
   \   00009E   78..         MOV       R0,#?V0
   \   0000A0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A3   8E..         MOV       ?V2,R6
   \   0000A5   75..00       MOV       ?V3,#0x0
   \   0000A8   78..         MOV       R0,#?V2
   \   0000AA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AD   741C         MOV       A,#0x1c
   \   0000AF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   F5..         MOV       ?V2,A
   \   0000B5   78..         MOV       R0,#?V2
   \   0000B7   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000BA   E4           CLR       A
   \   0000BB   F5..         MOV       ?V2,A
   \   0000BD   78..         MOV       R0,#?V2
   \   0000BF   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C2   E5..         MOV       A,?V9
   \   0000C4   F5..         MOV       ?V2,A
   \   0000C6   78..         MOV       R0,#?V2
   \   0000C8   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000CB   75..01       MOV       ?V2,#0x1
   \   0000CE   78..         MOV       R0,#?V2
   \   0000D0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D3   78..         MOV       R0,#?V2
   \   0000D5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D8   78..         MOV       R0,#?V2
   \   0000DA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000DD   7C04         MOV       R4,#0x4
   \   0000DF   7D00         MOV       R5,#0x0
   \   0000E1   AA..         MOV       R2,?V12
   \   0000E3   AB..         MOV       R3,?V13
   \   0000E5   A9..         MOV       R1,?V8
   \   0000E7   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   0000EA   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000ED   E9           MOV       A,R1
   \   0000EE   FE           MOV       R6,A
    590              zcl_mem_free( buf );
   \   0000EF                ; Setup parameters for call to function osal_mem_free
   \   0000EF   AA..         MOV       R2,?V0
   \   0000F1   AB..         MOV       R3,?V1
   \   0000F3   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000F6   8002         SJMP      ??zclGeneral_SendGroupViewResponse_4
    591            }
    592            else
    593            {
    594              stat = ZMemError;
   \                     ??zclGeneral_SendGroupViewResponse_1:
   \   0000F8   7E10         MOV       R6,#0x10
    595            }
    596          
    597            return ( stat );
   \                     ??zclGeneral_SendGroupViewResponse_4:
   \   0000FA   EE           MOV       A,R6
   \   0000FB   F9           MOV       R1,A
   \   0000FC                REQUIRE ?Subroutine3
   \   0000FC                ; // Fall through to label ?Subroutine3
    598          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F0E         MOV       R7,#0xe
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function osal_memcpy
   \   000001   85..82       MOV       DPL,?V4
   \   000004   85..83       MOV       DPH,?V5
   \   000007   A3           INC       DPTR
   \   000008   22           RET
    599          #endif // ZCL_GROUPS
    600          
    601          #ifdef ZCL_SCENES
    602          /*********************************************************************
    603           * @fn      zclGeneral_SendAddSceneRequest
    604           *
    605           * @brief   Send the (Enhanced) Add Scene Request to a device. You can
    606           *           also use the appropriate macro.
    607           *
    608           * @param   srcEP - Sending Apps endpoint
    609           * @param   dstAddr - where to send the request
    610           * @param   scene - pointer to the scene structure
    611           * @param  cmd - COMMAND_SCENE_ADD or COMMAND_SCENE_ENHANCED_ADD
    612           * @param   disableDefaultRsp - whether to disable the Default Response command
    613           * @param   seqNum - sequence number
    614           *
    615           * @return  ZStatus_t
    616           */
    617          ZStatus_t zclGeneral_SendAddSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    618                                                    uint8 cmd, zclGeneral_Scene_t *scene,
    619                                                    uint8 disableDefaultRsp, uint8 seqNum )
    620          {
    621            uint8 *buf;
    622            uint8 *pBuf;
    623            uint8 len;
    624            ZStatus_t status;
    625          
    626            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    627            len += scene->name[0] + 1; // String + 1 for length
    628          
    629            // Add something for the extension field length
    630            len += scene->extLen;
    631          
    632            buf = zcl_mem_alloc( len );
    633            if ( buf )
    634            {
    635              pBuf = buf;
    636              *pBuf++ = LO_UINT16( scene->groupID );
    637              *pBuf++ = HI_UINT16( scene->groupID );
    638              *pBuf++ = scene->ID;
    639              *pBuf++ = LO_UINT16( scene->transTime );
    640              *pBuf++ = HI_UINT16( scene->transTime );
    641              *pBuf++ = scene->name[0]; // string length
    642              zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    643              pBuf += scene->name[0]; // move pass name
    644          
    645              // Add the extension fields
    646              if ( scene->extLen > 0 )
    647                zcl_memcpy( pBuf, scene->extField, scene->extLen );
    648          
    649              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    650                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    651                                        disableDefaultRsp, 0, seqNum, len, buf );
    652              zcl_mem_free( buf );
    653            }
    654            else
    655              status = ZMemError;
    656          
    657            return ( status );
    658          }
    659          
    660          /*********************************************************************
    661           * @fn      zclGeneral_SendSceneRequest
    662           *
    663           * @brief   Send a Scene Request to a device.  You can also use the
    664           *          appropriate macro.
    665           *
    666           * @param   srcEP - Sending Apps endpoint
    667           * @param   dstAddr - where to send the request
    668           * @param   cmd - one of the following:
    669           *              COMMAND_SCENE_VIEW
    670           *              COMMAND_SCENE_REMOVE
    671           *              COMMAND_SCENE_REMOVE_ALL
    672           *              COMMAND_SCENE_STORE
    673           *              COMMAND_SCENE_RECALL
    674           *              COMMAND_SCENE_GET_MEMBERSHIP
    675           *              COMMAND_SCENE_ENHANCED_VIEW
    676           * @param   groupID - group ID
    677           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    678           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    679           * @param   disableDefaultRsp - whether to disable the Default Response command
    680           * @param   seqNum - sequence number
    681           * @return  ZStatus_t
    682           */
    683          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    684                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    685                                                 uint8 disableDefaultRsp, uint8 seqNum )
    686          {
    687            uint8 buf[3];
    688            uint8 len = 2;
    689          
    690            buf[0] = LO_UINT16( groupID );
    691            buf[1] = HI_UINT16( groupID );
    692          
    693            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    694            {
    695              buf[2] = sceneID;
    696              len++;
    697            }
    698          
    699            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    700                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    701                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    702          }
    703          
    704          /*********************************************************************
    705           * @fn      zclGeneral_SendSceneResponse
    706           *
    707           * @brief   Send Group Response (not Group View Response)
    708           *
    709           * @param   srcEP - Sending application's endpoint
    710           * @param   dstAddr - where you want the message to go
    711           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    712           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    713           * @param   status - scene command status
    714           * @param   groupID - what group
    715           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    716           *
    717           * @return  ZStatus_t
    718           */
    719          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    720                                                  uint8 cmd, uint8 status, uint16 groupID,
    721                                                  uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    722          {
    723            uint8 buf[4];
    724            uint8 len = 1 + 2; // Status + Group ID
    725          
    726            buf[0] = status;
    727            buf[1] = LO_UINT16( groupID );
    728            buf[2] = HI_UINT16( groupID );
    729          
    730            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    731            {
    732              buf[3] = sceneID;
    733              len++;
    734            }
    735          
    736            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    737                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    738                                    disableDefaultRsp, 0, seqNum, len, buf );
    739          }
    740          
    741          /*********************************************************************
    742           * @fn      zclGeneral_SendSceneViewResponse
    743           *
    744           * @brief   Call to send Scene (Enahced) View Response Command. You can
    745           *           also use the appropriate macro.
    746           *
    747           * @param   srcEP - Sending application's endpoint
    748           * @param   dstAddr - where you want the message to go
    749           * @param   cmd - either COMMAND_SCENE_VIEW_RSP or COMMAND_SCENE_ENHANCED_VIEW_RSP
    750           * @param   status - scene command status
    751           * @param   scene - scene info
    752           *
    753           * @return  ZStatus_t
    754           */
    755          ZStatus_t zclGeneral_SendSceneViewRsp( uint8 srcEP, afAddrType_t *dstAddr,
    756                                                 uint8 cmd, uint8 status, zclGeneral_Scene_t *scene,
    757                                                 uint8 disableDefaultRsp, uint8 seqNum )
    758          {
    759            uint8 *buf;
    760            uint8 *pBuf;
    761            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    762            ZStatus_t stat;
    763          
    764            if ( status == ZCL_STATUS_SUCCESS )
    765            {
    766              len += 2; // Transition Time
    767              len += scene->name[0] + 1; // string + 1 for length
    768          
    769              // Add something for the extension field length
    770              len += scene->extLen;
    771            }
    772          
    773            buf = zcl_mem_alloc( len );
    774            if ( buf )
    775            {
    776              pBuf = buf;
    777              *pBuf++ = status;
    778              *pBuf++ = LO_UINT16( scene->groupID );
    779              *pBuf++ = HI_UINT16( scene->groupID );
    780              *pBuf++ = scene->ID;
    781              if ( status == ZCL_STATUS_SUCCESS )
    782              {
    783                uint16 transTime = scene->transTime;
    784                if ( cmd == COMMAND_SCENE_ENHANCED_VIEW_RSP )
    785                {
    786                  // Transition time is in 1/10s
    787                  transTime *= 10;
    788                  transTime += scene->transTime100ms;
    789                }
    790          
    791                *pBuf++ = LO_UINT16( transTime );
    792                *pBuf++ = HI_UINT16( transTime );
    793                *pBuf++ = scene->name[0]; // string length
    794                if ( scene->name[0] != 0 )
    795                {
    796                  zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    797                  pBuf += scene->name[0]; // move pass name
    798                }
    799          
    800                // Add the extension fields
    801                if ( scene->extLen > 0 )
    802                  zcl_memcpy( pBuf, scene->extField, scene->extLen );
    803              }
    804          
    805              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    806                                      cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    807                                      disableDefaultRsp, 0, seqNum, len, buf );
    808              zcl_mem_free( buf );
    809            }
    810            else
    811              stat = ZMemError;
    812          
    813            return ( stat );
    814          }
    815          
    816          /*********************************************************************
    817           * @fn      zclGeneral_SendSceneGetMembershipResponse
    818           *
    819           * @brief   Call to send Scene Get Membership Response Command
    820           *
    821           * @param   srcEP - Sending application's endpoint
    822           * @param   dstAddr - where you want the message to go
    823           * @param   status - scene command status
    824           * @param   capacity - remaining capacity of the scene table
    825           * @param   sceneCnt - number of scenes in the scene list
    826           * @param   sceneList - list of scene IDs
    827           * @param   groupID - group ID that scene belongs to
    828           * @param   seqNum - sequence number
    829           *
    830           * @return  ZStatus_t
    831           */
    832          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    833                                                               uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    834                                                               uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    835          {
    836            uint8 *buf;
    837            uint8 *pBuf;
    838            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    839            uint8 i;
    840            ZStatus_t stat;
    841          
    842            if ( status == ZCL_STATUS_SUCCESS )
    843            {
    844              len++; // Scene Count
    845              len += sceneCnt; // Scene List (Scene ID is a single octet)
    846            }
    847          
    848            buf = zcl_mem_alloc( len );
    849            if ( buf )
    850            {
    851              pBuf = buf;
    852              *pBuf++ = status;
    853              *pBuf++ = capacity;
    854              *pBuf++ = LO_UINT16( groupID );
    855              *pBuf++ = HI_UINT16( groupID );
    856              if ( status == ZCL_STATUS_SUCCESS )
    857              {
    858                *pBuf++ = sceneCnt;
    859                for ( i = 0; i < sceneCnt; i++ )
    860                  *pBuf++ = sceneList[i];
    861              }
    862          
    863              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    864                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    865                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    866              zcl_mem_free( buf );
    867            }
    868            else
    869              stat = ZMemError;
    870          
    871            return ( stat );
    872          }
    873          
    874          #ifdef ZCL_LIGHT_LINK_ENHANCE
    875          /*********************************************************************
    876           * @fn      zclGeneral_SendSceneCopy
    877           *
    878           * @brief   Send Scene Copy Request to a device
    879           *
    880           * @param   srcEP - sending application's endpoint
    881           * @param   dstAddr - where to send the request
    882           * @param   mode - how scene copy is to proceed
    883           * @param   groupIDFrom - group from which scene to be copied
    884           * @param   sceneIDFrom - scene from which scene to be copied
    885           * @param   groupIDTo - group to which scene to be copied
    886           * @param   sceneIDTo - scene to which scene to be copied
    887           * @param   disableDefaultRsp - disable Default Response command
    888           * @param   seqNum - the identification number for the transaction
    889           *
    890           * @return  ZStatus_t
    891           */
    892          ZStatus_t zclGeneral_SendSceneCopy( uint8 srcEP, afAddrType_t *dstAddr,
    893                                              uint8 mode, uint16 groupIDFrom, uint8 sceneIDFrom,
    894                                              uint16 groupIDTo, uint8 sceneIDTo,
    895                                              uint8 disableDefaultRsp, uint8 seqNum )
    896          {
    897            uint8 buf[7];
    898          
    899            buf[0] = mode;
    900            buf[1] = LO_UINT16( groupIDFrom );
    901            buf[2] = HI_UINT16( groupIDFrom );
    902            buf[3] = sceneIDFrom;
    903            buf[4] = LO_UINT16( groupIDTo );
    904            buf[5] = HI_UINT16( groupIDTo );
    905            buf[6] = sceneIDTo;
    906          
    907            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    908                                      COMMAND_SCENE_COPY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    909                                      disableDefaultRsp, 0, seqNum, 7, buf ) );
    910          }
    911          
    912          /*********************************************************************
    913           * @fn      zclGeneral_SendSceneCopyResponse
    914           *
    915           * @brief   Send Scene Copy Response to a device
    916           *
    917           * @param   srcEP - sending application's endpoint
    918           * @param   dstAddr - where to send the request
    919           * @param   status - status of copy scene attemp
    920           * @param   groupIDFrom - group from which scene was copied
    921           * @param   sceneIDFrom - scene from which scene was copied
    922           * @param   disableDefaultRsp - disable Default Response command
    923           * @param   seqNum - the identification number for the transaction
    924           *
    925           * @return  ZStatus_t
    926           */
    927          ZStatus_t zclGeneral_SendSceneCopyResponse( uint8 srcEP, afAddrType_t *dstAddr,
    928                                                      uint8 status, uint16 groupIDFrom, uint8 sceneIDFrom,
    929                                                      uint8 disableDefaultRsp, uint8 seqNum )
    930          {
    931            uint8 buf[4];
    932          
    933            buf[0] = status;
    934            buf[1] = LO_UINT16( groupIDFrom );
    935            buf[2] = HI_UINT16( groupIDFrom );
    936            buf[3] = sceneIDFrom;
    937          
    938            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    939                                      COMMAND_SCENE_COPY_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    940                                      disableDefaultRsp, 0, seqNum, 4, buf ) );
    941          }
    942          #endif // ZCL_LIGHT_LINK_ENHANCE
    943          #endif // ZCL_SCENES
    944          
    945          #ifdef ZCL_ON_OFF
    946          #ifdef ZCL_LIGHT_LINK_ENHANCE
    947          /*********************************************************************
    948           * @fn      zclGeneral_SendOnOff_CmdOffWithEffect
    949           *
    950           * @brief   Call to send out an Off with Effect Command.
    951           *
    952           * @param   srcEP - Sending application's endpoint
    953           * @param   dstAddr - where you want the message to go
    954           * @param   effectId - fading effect to use when switching light off
    955           * @param   effectVariant - which variant of effect to be triggered
    956           * @param   disableDefaultRsp - whether to disable the Default Response command
    957           * @param   seqNum - sequence number
    958           *
    959           * @return  ZStatus_t
    960           */
    961          ZStatus_t zclGeneral_SendOnOff_CmdOffWithEffect( uint8 srcEP, afAddrType_t *dstAddr,
    962                                                           uint8 effectId, uint8 effectVariant,
    963                                                           uint8 disableDefaultRsp, uint8 seqNum )
    964          {
    965            uint8 buf[2];
    966          
    967            buf[0] = effectId;
    968            buf[1] = effectVariant;
    969          
    970            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
    971                                    COMMAND_OFF_WITH_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    972                                    disableDefaultRsp, 0, seqNum, 2, buf );
    973          }
    974          
    975          /*********************************************************************
    976           * @fn      zclGeneral_SendOnOff_CmdOnWithTimedOff
    977           *
    978           * @brief   Call to send out an On with Timed Off Command.
    979           *
    980           * @param   srcEP - Sending application's endpoint
    981           * @param   dstAddr - where you want the message to go
    982           * @param   onOffCtrl - how the lamp is to be operated
    983           * @param   onTime - the length of time (in 1/10ths second) that the lamp is to remain on, before automatically turning off
    984           * @param   offWaitTime - the length of time (in 1/10ths second) that the lamp shall remain off, and guarded to prevent an on command turning the light back on.
    985           * @param   disableDefaultRsp - whether to disable the Default Response command
    986           * @param   seqNum - sequence number
    987           *
    988           * @return  ZStatus_t
    989           */
    990          ZStatus_t zclGeneral_SendOnOff_CmdOnWithTimedOff ( uint8 srcEP, afAddrType_t *dstAddr,
    991                                                             zclOnOffCtrl_t onOffCtrl, uint16 onTime, uint16 offWaitTime,
    992                                                             uint8 disableDefaultRsp, uint8 seqNum )
    993          {
    994            uint8 buf[5];
    995          
    996            buf[0] = onOffCtrl.byte;
    997            buf[1] = LO_UINT16( onTime );
    998            buf[2] = HI_UINT16( onTime );
    999            buf[3] = LO_UINT16( offWaitTime );
   1000            buf[4] = HI_UINT16( offWaitTime );
   1001          
   1002            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
   1003                                    COMMAND_ON_WITH_TIMED_OFF, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1004                                    disableDefaultRsp, 0, seqNum, 5, buf );
   1005          }
   1006          #endif // ZCL_LIGHT_LINK_ENHANCE
   1007          #endif // ZCL_ON_OFF
   1008          
   1009          #ifdef ZCL_LEVEL_CTRL
   1010          /*********************************************************************
   1011           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
   1012           *
   1013           * @brief   Call to send out a Level Control Request. You can also use
   1014           *          the appropriate macro.
   1015           *
   1016           * @param   srcEP - Sending application's endpoint
   1017           * @param   dstAddr - where you want the message to go
   1018           * @param   cmd - one of the following:
   1019           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
   1020           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
   1021           * @param   level - what level to move to
   1022           * @param   transitionTime - how long to take to get to the level (in seconds)
   1023           *
   1024           * @return  ZStatus_t
   1025           */
   1026          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1027                                                                   uint8 cmd, uint8 level, uint16 transTime,
   1028                                                                   uint8 disableDefaultRsp, uint8 seqNum )
   1029          {
   1030            uint8 buf[3];
   1031          
   1032            buf[0] = level;
   1033            buf[1] = LO_UINT16( transTime );
   1034            buf[2] = HI_UINT16( transTime );
   1035          
   1036            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1037                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1038                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1039          }
   1040          
   1041          /*********************************************************************
   1042           * @fn      zclGeneral_SendLevelControlMoveRequest
   1043           *
   1044           * @brief   Call to send out a Level Control Request. You can also use
   1045           *          the appropriate macro.
   1046           *
   1047           * @param   srcEP - Sending application's endpoint
   1048           * @param   dstAddr - where you want the message to go
   1049           * @param   cmd - one of the following:
   1050           *              COMMAND_LEVEL_MOVE or
   1051           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
   1052           * @param   moveMode - LEVEL_MOVE_UP or
   1053           *                     LEVEL_MOVE_DOWN
   1054           * @param   rate - number of steps to take per second
   1055           *
   1056           * @return  ZStatus_t
   1057           */
   1058          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1059                                                            uint8 cmd, uint8 moveMode, uint8 rate,
   1060                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1061          {
   1062            uint8 buf[2];
   1063          
   1064            buf[0] = moveMode;
   1065            buf[1] = rate;
   1066          
   1067            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1068                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1069                                    disableDefaultRsp, 0, seqNum, 2, buf );
   1070          }
   1071          
   1072          /*********************************************************************
   1073           * @fn      zclGeneral_SendLevelControlStepRequest
   1074           *
   1075           * @brief   Call to send out a Level Control Request. You can also use
   1076           *          the appropriate macro.
   1077           *
   1078           * @param   srcEP - Sending application's endpoint
   1079           * @param   dstAddr - where you want the message to go
   1080           * @param   cmd - one of the following:
   1081           *              COMMAND_LEVEL_STEP
   1082           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
   1083           * @param   stepMode - LEVEL_STEP_UP or
   1084           *                     LEVEL_STEP_DOWN
   1085           * @param   amount - number of levels to step
   1086           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
   1087           *
   1088           * @return  ZStatus_t
   1089           */
   1090          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1091                                                            uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
   1092                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1093          {
   1094            uint8 buf[4];
   1095          
   1096            buf[0] = stepMode;
   1097            buf[1] = stepSize;
   1098            buf[2] = LO_UINT16( transTime );
   1099            buf[3] = HI_UINT16( transTime );
   1100          
   1101            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1102                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1103                                    disableDefaultRsp, 0, seqNum, 4, buf );
   1104          }
   1105          
   1106          /*********************************************************************
   1107           * @fn      zclGeneral_SendLevelControlStepRequest
   1108           *
   1109           * @brief   Call to send out a Level Control Request. You can also use
   1110           *          the appropriate macro.
   1111           *
   1112           * @param   srcEP - Sending application's endpoint
   1113           * @param   dstAddr - where you want the message to go
   1114           * @param   cmd - one of the following:
   1115           *              COMMAND_LEVEL_STOP
   1116           *              COMMAND_LEVEL_STOP_WITH_ON_OFF
   1117           *
   1118           * @return  ZStatus_t
   1119           */
   1120          ZStatus_t zclGeneral_SendLevelControlStopRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1121                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1122          {
   1123            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1124                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1125                                    disableDefaultRsp, 0, seqNum, 0, NULL );
   1126          }
   1127          #endif // ZCL_LEVEL_CTRL
   1128          
   1129          #ifdef ZCL_ALARMS
   1130          /*********************************************************************
   1131           * @fn      zclGeneral_SendAlarm
   1132           *
   1133           * @brief   Call to send out an Alarm Request Command
   1134           *
   1135           * @param   srcEP - Sending application's endpoint
   1136           * @param   dstAddr - where you want the message to go
   1137           * @param   cmd - COMMAND_ALARMS_ALARM
   1138           * @param   alarmCode - code for the cause of the alarm
   1139           * @param   clusterID - cluster whose attribute generate the alarm
   1140           *
   1141           * @return  ZStatus_t
   1142           */
   1143          ZStatus_t zclGeneral_SendAlarm( uint8 srcEP, afAddrType_t *dstAddr,
   1144                                          uint8 alarmCode, uint16 clusterID,
   1145                                          uint8 disableDefaultRsp, uint8 seqNum )
   1146          {
   1147            uint8 buf[3];
   1148          
   1149            buf[0] = alarmCode;
   1150            buf[1] = LO_UINT16( clusterID );
   1151            buf[2] = HI_UINT16( clusterID );
   1152          
   1153            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1154                                    COMMAND_ALARMS_ALARM, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1155                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1156          }
   1157          
   1158          /*********************************************************************
   1159           * @fn      zclGeneral_SendAlarmReset
   1160           *
   1161           * @brief   Call to send out an Alarm Reset Command
   1162           *
   1163           * @param   srcEP - Sending application's endpoint
   1164           * @param   dstAddr - where you want the message to go
   1165           * @param   alarmCode - code for the cause of the alarm
   1166           * @param   clusterID - cluster whose attribute generate the alarm
   1167           *
   1168           * @return  ZStatus_t
   1169          */
   1170          ZStatus_t zclGeneral_SendAlarmReset( uint8 srcEP, afAddrType_t *dstAddr,
   1171                                               uint8 alarmCode, uint16 clusterID,
   1172                                               uint8 disableDefaultRsp, uint8 seqNum )
   1173          {
   1174            uint8 buf[3];
   1175          
   1176            buf[0] = alarmCode;
   1177            buf[1] = LO_UINT16( clusterID );
   1178            buf[2] = HI_UINT16( clusterID );
   1179          
   1180            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1181                                    COMMAND_ALARMS_RESET, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1182                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1183          }
   1184          
   1185          /*********************************************************************
   1186           * @fn      zclGeneral_SendAlarmGetResponse
   1187           *
   1188           * @brief   Call to send out an Alarm Get Response Command
   1189           *
   1190           * @param   srcEP - Sending application's endpoint
   1191           * @param   dstAddr - where you want the message to go
   1192           * @param   status - SUCCESS or NOT_FOUND
   1193           * @param   alarmCode - code for the cause of the alarm
   1194           * @param   clusterID - cluster whose attribute generate the alarm
   1195           * @param   timeStamp - time at which the alarm occured
   1196           *
   1197           * @return  ZStatus_t
   1198           */
   1199          ZStatus_t zclGeneral_SendAlarmGetResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1200                                                     uint8 status, uint8 alarmCode, uint16 clusterID,
   1201                                                     uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
   1202          {
   1203            uint8 buf[8];
   1204            uint8 len = 1; // Status
   1205          
   1206            buf[0] = status;
   1207            if ( status == ZCL_STATUS_SUCCESS )
   1208            {
   1209              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
   1210              buf[1] = alarmCode;
   1211              buf[2] = LO_UINT16( clusterID );
   1212              buf[3] = HI_UINT16( clusterID );
   1213              zcl_buffer_uint32( &buf[4], timeStamp );
   1214            }
   1215          
   1216            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1217                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1218                                    disableDefaultRsp, 0, seqNum, len, buf );
   1219          }
   1220          
   1221          #ifdef SE_UK_EXT
   1222          /*********************************************************************
   1223           * @fn      zclGeneral_SendAlarmGetEventLog
   1224           *
   1225           * @brief   Call to send out an Alarm Get Event Log Command
   1226           *
   1227           * @param   srcEP - Sending application's endpoint
   1228           * @param   dstAddr - where you want the message to go
   1229           * @param   pEventLog - pointer to Get Event Log Command
   1230           * @param   disableDefaultRsp - disable default response
   1231           * @param   seqNum - ZCL sequence number
   1232           *
   1233           * @return  ZStatus_t
   1234           */
   1235          ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1236                                                     zclGetEventLog_t *pEventLog,
   1237                                                     uint8 disableDefaultRsp, uint8 seqNum )
   1238          {
   1239            uint8 buf[10];
   1240          
   1241            buf[0] = pEventLog->logID;
   1242            zcl_buffer_uint32( &buf[1], pEventLog->startTime );
   1243            zcl_buffer_uint32( &buf[5], pEventLog->endTime );
   1244            buf[9] = pEventLog->numEvents;
   1245          
   1246            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1247                                    COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1248                                    disableDefaultRsp, 0, seqNum, 10, buf );
   1249          }
   1250          
   1251          /*********************************************************************
   1252           * @fn      zclGeneral_SendAlarmPublishEventLog
   1253           *
   1254           * @brief   Call to send out an Alarm Publish Event Log Command
   1255           *
   1256           * @param   srcEP - Sending application's endpoint
   1257           * @param   dstAddr - where you want the message to go
   1258           * @param   pEventLog - pointer to Publish Event Log Command
   1259           * @param   disableDefaultRsp - disable default response
   1260           * @param   seqNum - ZCL sequence number
   1261           *
   1262           * @return  ZStatus_t
   1263           */
   1264          ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1265                                                         zclPublishEventLog_t *pEventLog,
   1266                                                         uint8 disableDefaultRsp, uint8 seqNum )
   1267          {
   1268            uint8 *buf;
   1269            uint8 *pBuf;
   1270            uint8 bufLen;
   1271          
   1272            // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
   1273            bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
   1274          
   1275            buf = zcl_mem_alloc( bufLen );
   1276            if ( buf == NULL )
   1277            {
   1278              return (ZMemError);
   1279            }
   1280          
   1281            pBuf = buf;
   1282            *pBuf++ = pEventLog->logID;
   1283            *pBuf++ = pEventLog->cmdIndex;
   1284            *pBuf++ = pEventLog->totalCmds;
   1285          
   1286            for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
   1287            {
   1288              zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
   1289          
   1290              *pBuf++ = pLogs->eventId;
   1291              pBuf = zcl_buffer_uint32( pBuf, pLogs->eventTime );
   1292            }
   1293          
   1294            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1295                                    COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1296                                    disableDefaultRsp, 0, seqNum, bufLen, buf );
   1297          }
   1298          #endif // SE_UK_EXT
   1299          #endif // ZCL_ALARMS
   1300          
   1301          #ifdef ZCL_LOCATION
   1302          /*********************************************************************
   1303           * @fn      zclGeneral_SendLocationSetAbsolute
   1304           *
   1305           * @brief   Call to send out a Set Absolute Location Command
   1306           *
   1307           * @param   srcEP - Sending application's endpoint
   1308           * @param   dstAddr - where you want the message to go
   1309           * @param   absLoc - absolute location info
   1310           *
   1311           * @return  ZStatus_t
   1312           */
   1313          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
   1314                                                        zclLocationAbsolute_t *absLoc,
   1315                                                        uint8 disableDefaultRsp, uint8 seqNum )
   1316          {
   1317             uint8 buf[10]; // 5 fields (2 octects each)
   1318          
   1319             buf[0] = LO_UINT16( absLoc->coordinate1 );
   1320             buf[1] = HI_UINT16( absLoc->coordinate1 );
   1321             buf[2] = LO_UINT16( absLoc->coordinate2 );
   1322             buf[3] = HI_UINT16( absLoc->coordinate2 );
   1323             buf[4] = LO_UINT16( absLoc->coordinate3 );
   1324             buf[5] = HI_UINT16( absLoc->coordinate3 );
   1325             buf[6] = LO_UINT16( absLoc->power );
   1326             buf[7] = HI_UINT16( absLoc->power );
   1327             buf[8] = LO_UINT16( absLoc->pathLossExponent );
   1328             buf[9] = HI_UINT16( absLoc->pathLossExponent );
   1329          
   1330             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1331                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
   1332                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
   1333          }
   1334          
   1335          /*********************************************************************
   1336           * @fn      zclGeneral_SendLocationSetDevCfg
   1337           *
   1338           * @brief   Call to send out a Set Device Configuration Command
   1339           *
   1340           * @param   srcEP - Sending application's endpoint
   1341           * @param   dstAddr - where you want the message to go
   1342           * @param   devCfg - device configuration info
   1343           *
   1344           * @return  ZStatus_t
   1345           */
   1346          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1347                                                      zclLocationDevCfg_t *devCfg,
   1348                                                      uint8 disableDefaultRsp, uint8 seqNum )
   1349          {
   1350             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
   1351          
   1352             buf[0] = LO_UINT16( devCfg->power );
   1353             buf[1] = HI_UINT16( devCfg->power );
   1354             buf[2] = LO_UINT16( devCfg->pathLossExponent );
   1355             buf[3] = HI_UINT16( devCfg->pathLossExponent );
   1356             buf[4] = LO_UINT16( devCfg->calcPeriod );
   1357             buf[5] = HI_UINT16( devCfg->calcPeriod );
   1358             buf[6] = devCfg->numMeasurements;
   1359             buf[7] = LO_UINT16( devCfg->reportPeriod );
   1360             buf[8] = HI_UINT16( devCfg->reportPeriod );
   1361          
   1362             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1363                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
   1364                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
   1365          }
   1366          
   1367          /*********************************************************************
   1368           * @fn      zclGeneral_SendLocationGetDevCfg
   1369           *
   1370           * @brief   Call to send out a Get Device Configuration Command
   1371           *
   1372           * @param   srcEP - Sending application's endpoint
   1373           * @param   dstAddr - where you want the message to go
   1374           * @param   targetAddr - device for which location parameters are being requested
   1375           *
   1376           * @return  ZStatus_t
   1377           */
   1378          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1379                                                      uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1380          {
   1381            uint8 buf[8];
   1382          
   1383            zcl_memcpy( buf, targetAddr, 8 );
   1384          
   1385            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1386                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1387                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1388          }
   1389          
   1390          /*********************************************************************
   1391           * @fn      zclGeneral_SendLocationGetData
   1392           *
   1393           * @brief   Call to send out a Get Location Data Command
   1394           *
   1395           * @param   srcEP - Sending application's endpoint
   1396           * @param   dstAddr - where you want the message to go
   1397           * @param   locaData - location information and channel parameters that are requested.
   1398           *
   1399           * @return  ZStatus_t
   1400           */
   1401          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1402                                                    zclLocationGetData_t *locData,
   1403                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1404          {
   1405            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1406            uint8 *pBuf = buf;
   1407            uint8 len = 2; // bitmap + number responses
   1408          
   1409            *pBuf  = locData->absoluteOnly;
   1410            *pBuf |= locData->recalculate << 1;
   1411            *pBuf |= locData->brdcastIndicator << 2;
   1412            *pBuf |= locData->brdcastResponse << 3;
   1413            *pBuf |= locData->compactResponse << 4;
   1414            pBuf++;  // move past the bitmap field
   1415          
   1416            *pBuf++ = locData->numResponses;
   1417          
   1418            if ( locData->brdcastIndicator == 0 )
   1419            {
   1420              zcl_memcpy( pBuf, locData->targetAddr, 8 );
   1421              len += 8; // ieee addr
   1422            }
   1423          
   1424            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1425                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1426                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1427          }
   1428          
   1429          /*********************************************************************
   1430           * @fn      zclGeneral_SendLocationDevCfgResponse
   1431           *
   1432           * @brief   Call to send out a Device Configuration Response Command
   1433           *
   1434           * @param   srcEP - Sending application's endpoint
   1435           * @param   dstAddr - where you want the message to go
   1436           * @param   devCfg - device's location parameters that are requested
   1437           *
   1438           * @return  ZStatus_t
   1439           */
   1440          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1441                                                           zclLocationDevCfgRsp_t *devCfg,
   1442                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1443          {
   1444            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1445            uint8 len = 1; // Status
   1446          
   1447            buf[0] = devCfg->status;
   1448            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1449            {
   1450              buf[1] = LO_UINT16( devCfg->data.power );
   1451              buf[2] = HI_UINT16( devCfg->data.power );
   1452              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1453              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1454              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1455              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1456              buf[7] = devCfg->data.numMeasurements;
   1457              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1458              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1459              len += 9;
   1460            }
   1461          
   1462            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1463                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1464                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1465          }
   1466          
   1467          /*********************************************************************
   1468           * @fn      zclGeneral_SendLocationData
   1469           *
   1470           * @brief   Call to send out location data
   1471           *
   1472           * @param   srcEP - Sending application's endpoint
   1473           * @param   dstAddr - where you want the message to go
   1474           * @param   status - indicates whether response to request was successful or not
   1475           * @param   locData - location information and channel parameters being sent
   1476           *
   1477           * @return  ZStatus_t
   1478           */
   1479          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1480                                                 uint8 status, zclLocationData_t *locData,
   1481                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1482          {
   1483            uint8 buf[16];
   1484            uint8 *pBuf = buf;
   1485            uint8 len = 0;
   1486          
   1487            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1488            {
   1489              // Only response command includes a status field
   1490              *pBuf++ = status;
   1491              len++;
   1492            }
   1493          
   1494            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1495            {
   1496              // Notification or Response with successful status
   1497              *pBuf++ = locData->type;
   1498              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1499              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1500              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1501              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1502              len += 5;
   1503          
   1504              if ( locationType2D(locData->type) == 0 )
   1505              {
   1506                // 2D location doesn't have coordinate 3
   1507                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1508                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1509                len += 2;
   1510              }
   1511          
   1512              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1513              {
   1514                // Compact notification doesn't include these fields
   1515                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1516                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1517                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1518                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1519                len += 4;
   1520              }
   1521          
   1522              if ( locationTypeAbsolute(locData->type) == 0 )
   1523              {
   1524                // Absolute location doesn't include these fields
   1525                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1526                {
   1527                  // Compact notification doesn't include this field
   1528                  *pBuf++ = locData->calcLoc.locationMethod;
   1529                  len++;
   1530                }
   1531          
   1532                *pBuf++ = locData->calcLoc.qualityMeasure;
   1533                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1534                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1535                len += 3;
   1536              }
   1537            }
   1538          
   1539            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1540                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1541                                    disableDefaultRsp, 0, seqNum, len, buf );
   1542          }
   1543          #endif // ZCL_LOCATION
   1544          
   1545          /*********************************************************************
   1546           * @fn      zclGeneral_FindCallbacks
   1547           *
   1548           * @brief   Find the callbacks for an endpoint
   1549           *
   1550           * @param   endpoint - endpoint to find the application callbacks for
   1551           *
   1552           * @return  pointer to the callbacks
   1553           */
   1554          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1555          {
   1556            zclGenCBRec_t *pCBs;
   1557          
   1558            pCBs = zclGenCBs;
   1559            while ( pCBs )
   1560            {
   1561              if ( pCBs->endpoint == endpoint )
   1562                return ( pCBs->CBs );
   1563              pCBs = pCBs->next;
   1564            }
   1565            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1566          }
   1567          
   1568          /*********************************************************************
   1569           * @fn      zclGeneral_HdlIncoming
   1570           *
   1571           * @brief   Callback from ZCL to process incoming Commands specific
   1572           *          to this cluster library or Profile commands for attributes
   1573           *          that aren't in the attribute list
   1574           *
   1575           *
   1576           * @param   pInMsg - pointer to the incoming message
   1577           *
   1578           * @return  ZStatus_t
   1579           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1580          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1581          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1582            ZStatus_t stat = ZSuccess;
   1583          
   1584          #if defined ( INTER_PAN )
   1585            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1586              return ( stat ); // Cluster not supported thru Inter-PAN
   1587          #endif
   1588            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   5407         ANL       A,#0x7
   \   00000D   6401         XRL       A,#0x1
   \   00000F   7007         JNZ       ??zclGeneral_HdlIncoming_0
   1589            {
   1590              // Is this a manufacturer specific command?
   1591              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   1592              {
   1593                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   000011                ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
   \   000011   12....       LCALL     `??zclGeneral_HdlInSpecificCommands::?relay`; Banked call to: zclGeneral_HdlInSpecificCommands
   \   000014   E9           MOV       A,R1
   \   000015   F9           MOV       R1,A
   \   000016   8002         SJMP      ??zclGeneral_HdlIncoming_1
   1594              }
   1595              else
   1596              {
   1597                // We don't support any manufacturer specific command.
   1598                stat = ZFailure;
   1599              }
   1600            }
   1601            else
   1602            {
   1603              // Handle all the normal (Read, Write...) commands -- should never get here
   1604              stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_0:
   \   000018   7901         MOV       R1,#0x1
   1605            }
   1606            return ( stat );
   \                     ??zclGeneral_HdlIncoming_1:
   \   00001A   D083         POP       DPH
   \   00001C   D082         POP       DPL
   \   00001E   02....       LJMP      ?BRET
   1607          }
   1608          
   1609          /*********************************************************************
   1610           * @fn      zclGeneral_HdlInSpecificCommands
   1611           *
   1612           * @brief   Callback from ZCL to process incoming Commands specific
   1613           *          to this cluster library
   1614          
   1615           * @param   pInMsg - pointer to the incoming message
   1616           *
   1617           * @return  ZStatus_t
   1618           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1619          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1620          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1621            ZStatus_t stat;
   1622            zclGeneral_AppCallbacks_t *pCBs;
   1623          
   1624            // make sure endpoint exists
   1625            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   EC           MOV       A,R4
   \   000010   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000013   F8           MOV       R0,A
   \   000014   90....       MOV       DPTR,#zclGenCBs
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   000017   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   00001A   4D           ORL       A,R5
   \   00001B   6057         JZ        ??zclGeneral_HdlInSpecificCommands_1
   \   00001D   8C82         MOV       DPL,R4
   \   00001F   8D83         MOV       DPH,R5
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   68           XRL       A,R0
   \   000025   8C82         MOV       DPL,R4
   \   000027   8D83         MOV       DPH,R5
   \   000029   70EC         JNZ       ??zclGeneral_HdlInSpecificCommands_0
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   12....       LCALL     ?Subroutine17 & 0xFFFF
   1626            if ( pCBs == NULL )
   \                     ??CrossCallReturnLabel_37:
   \   000031   4D           ORL       A,R5
   \   000032   6040         JZ        ??zclGeneral_HdlInSpecificCommands_1
   1627              return ( ZFailure );
   1628          
   1629            switch ( pInMsg->msg->clusterId )
   \   000034   8E82         MOV       DPL,R6
   \   000036   8F83         MOV       DPH,R7
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F5..         MOV       ?V0,A
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   F5..         MOV       ?V1,A
   \   000043   78..         MOV       R0,#?V0
   \   000045   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
   \   000048   0000         DW        0
   \   00004A   06           DB        6
   \   00004B   ....         DW        ??zclGeneral_HdlInSpecificCommands_1
   \   00004D   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   00004F   ....         DW        ??zclGeneral_HdlInSpecificCommands_1
   \   000051   ....         DW        ??zclGeneral_HdlInSpecificCommands_1
   \   000053   ....         DW        ??zclGeneral_HdlInSpecificCommands_3
   \   000055   ....         DW        ??zclGeneral_HdlInSpecificCommands_4
   \   000057   ....         DW        ??zclGeneral_HdlInSpecificCommands_1
   \   000059   ....         DW        ??zclGeneral_HdlInSpecificCommands_5
   1630            {
   1631          #ifdef ZCL_BASIC
   1632              case ZCL_CLUSTER_ID_GEN_BASIC:
   1633                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   00005B   8A82         MOV       DPL,R2
   \   00005D   8B83         MOV       DPH,R3
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   5408         ANL       A,#0x8
   \   000064   7026         JNZ       ??zclGeneral_HdlInSpecificCommands_6
   \   000066   8A82         MOV       DPL,R2
   \   000068   8B83         MOV       DPH,R3
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A3           INC       DPTR
   \   000071   E0           MOVX      A,@DPTR
   \   000072   6004         JZ        ??zclGeneral_HdlInSpecificCommands_7
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   000074   7901         MOV       R1,#0x1
   \   000076   8032         SJMP      ??zclGeneral_HdlInSpecificCommands_5
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   000078   8C82         MOV       DPL,R4
   \   00007A   8D83         MOV       DPH,R5
   \   00007C   12....       LCALL     ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   00007F   8882         MOV       DPL,R0
   \   000081   F583         MOV       DPH,A
   \   000083   E582         MOV       A,DPL
   \   000085   4583         ORL       A,DPH
   \   000087   6003         JZ        ??zclGeneral_HdlInSpecificCommands_6
   \   000089                ; Setup parameters for indirect call
   \   000089   12....       LCALL     ?CALL_IND
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   00008C   7900         MOV       R1,#0x0
   \   00008E   801A         SJMP      ??zclGeneral_HdlInSpecificCommands_5
   1634                break;
   1635          #endif // ZCL_BASIC
   1636          
   1637          #ifdef ZCL_IDENTIFY
   1638              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1639                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   000090                ; Setup parameters for call to function zclGeneral_ProcessInIdentity
   \   000090   12....       LCALL     `??zclGeneral_ProcessInIdentity::?relay`; Banked call to: zclGeneral_ProcessInIdentity
   \   000093   8013         SJMP      ??zclGeneral_HdlInSpecificCommands_8
   1640                break;
   1641          #endif // ZCL_IDENTIFY
   1642          
   1643          #ifdef ZCL_GROUPS
   1644              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1645                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   000095   8A82         MOV       DPL,R2
   \   000097   8B83         MOV       DPH,R3
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   5408         ANL       A,#0x8
   \   00009E   7005         JNZ       ??zclGeneral_HdlInSpecificCommands_9
   1646                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   \   0000A0                ; Setup parameters for call to function zclGeneral_ProcessInGroupsServer
   \   0000A0   12....       LCALL     `??zclGeneral_ProcessInGroupsServer::?relay`; Banked call to: zclGeneral_ProcessInGroupsServer
   \   0000A3   8003         SJMP      ??zclGeneral_HdlInSpecificCommands_8
   1647                else
   1648                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_9:
   \   0000A5                ; Setup parameters for call to function zclGeneral_ProcessInGroupsClient
   \   0000A5   12....       LCALL     `??zclGeneral_ProcessInGroupsClient::?relay`; Banked call to: zclGeneral_ProcessInGroupsClient
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   0000A8   E9           MOV       A,R1
   \   0000A9   F9           MOV       R1,A
   1649                break;
   1650          #endif // ZCL_GROUPS
   1651          
   1652          #ifdef ZCL_SCENES
   1653              case ZCL_CLUSTER_ID_GEN_SCENES:
   1654                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1655                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1656                else
   1657                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1658                break;
   1659          #endif // ZCL_SCENES
   1660          
   1661          #ifdef ZCL_ON_OFF
   1662              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1663                //stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   1664                //stat = zclGeneral_ProcessInOnOffTest( pInMsg );
   1665                break;
   1666          #endif // ZCL_ON_OFF
   1667          
   1668          #ifdef ZCL_LEVEL_CTRL
   1669              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1670                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1671                break;
   1672          #endif // ZCL_LEVEL_CTRL
   1673          
   1674          #ifdef ZCL_ALARMS
   1675              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1676                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1677                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1678                else
   1679                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1680                break;
   1681          #endif // ZCL_ALARMS
   1682          
   1683          #ifdef ZCL_LOCATION
   1684              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1685                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1686                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1687                else
   1688                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1689                break;
   1690          #endif // ZCL_LOCATION
   1691          
   1692              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1693              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1694              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1695              case ZCL_CLUSTER_ID_GEN_TIME:
   1696              default:
   1697                stat = ZFailure;
   1698                break;
   1699            }
   1700          
   1701            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   0000AA   02....       LJMP      ??Subroutine37_0 & 0xFFFF
   1702          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000003   FD           MOV       R5,A
   \   000004   EC           MOV       A,R4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   2414         ADD       A,#0x14
   \   000002   F582         MOV       DPL,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   F583         MOV       DPH,A
   \   000008   E0           MOVX      A,@DPTR
   \   000009   22           RET
   1703          
   1704          #ifdef ZCL_BASIC
   1705          /*********************************************************************
   1706           * @fn      zclGeneral_ProcessInBasic
   1707           *
   1708           * @brief   Process in the received Basic Command.
   1709           *
   1710           * @param   pInMsg - pointer to the incoming message
   1711           *
   1712           * @return  ZStatus_t
   1713           */
   1714          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1715                                                      zclGeneral_AppCallbacks_t *pCBs )
   1716          {
   1717            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1718            {
   1719              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1720                return ( ZFailure );   // Error ignore the command
   1721          
   1722              if ( pCBs->pfnBasicReset )
   1723                pCBs->pfnBasicReset();
   1724            }
   1725            // no Client command
   1726          
   1727            return ( ZSuccess );
   1728          }
   1729          #endif // ZCL_BASIC
   1730          
   1731          #ifdef ZCL_IDENTIFY
   1732          /*********************************************************************
   1733           * @fn      zclGeneral_ProcessInIdentity
   1734           *
   1735           * @brief   Process in the received Identity Command.
   1736           *
   1737           * @param   pInMsg - pointer to the incoming message
   1738           *
   1739           * @return  ZStatus_t
   1740           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1741          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInIdentity:
   1742                                                         zclGeneral_AppCallbacks_t *pCBs )
   1743          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV       A,#-0x6
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   1744            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F8           MOV       R0,A
   \   00001B   8A82         MOV       DPL,R2
   \   00001D   8B83         MOV       DPH,R3
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   5408         ANL       A,#0x8
   \   000024   6003         JZ        $+5
   \   000026   02....       LJMP      ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
   1745            {
   1746              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   \   000029   E8           MOV       A,R0
   \   00002A   7024         JNZ       ??zclGeneral_ProcessInIdentity_1
   1747              {
   1748                uint16 identifyTime;
   1749                
   1750                identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1751                
   1752                bdb_ZclIdentifyCmdInd( identifyTime, pInMsg->msg->endPoint);
   \   00002C   8A82         MOV       DPL,R2
   \   00002E   8B83         MOV       DPH,R3
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   12....       LCALL     ?Subroutine13 & 0xFFFF
   1753              }
   \                     ??CrossCallReturnLabel_22:
   \   00003B   FA           MOV       R2,A
   \   00003C   E9           MOV       A,R1
   \   00003D   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000040   8A82         MOV       DPL,R2
   \   000042   8B83         MOV       DPH,R3
   \   000044   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000047   FB           MOV       R3,A
   \   000048   EC           MOV       A,R4
   \   000049   FA           MOV       R2,A
   \   00004A   12....       LCALL     `??bdb_ZclIdentifyCmdInd::?relay`; Banked call to: bdb_ZclIdentifyCmdInd
   \   00004D   02....       LJMP      ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
   1754              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_QUERY )
   \                     ??zclGeneral_ProcessInIdentity_1:
   \   000050   7401         MOV       A,#0x1
   \   000052   68           XRL       A,R0
   \   000053   6003         JZ        $+5
   \   000055   02....       LJMP      ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
   1755              {
   1756                uint16 identifyTime = 0;
   \   000058   85..82       MOV       DPL,?XSP + 0
   \   00005B   85..83       MOV       DPH,?XSP + 1
   \   00005E   E4           CLR       A
   \   00005F   F0           MOVX      @DPTR,A
   \   000060   A3           INC       DPTR
   \   000061   F0           MOVX      @DPTR,A
   1757          
   1758                // Retrieve Identify Time
   1759                zcl_ReadAttrData( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   1760                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   \   000062   8A82         MOV       DPL,R2
   \   000064   8B83         MOV       DPH,R3
   \   000066   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000069   FE           MOV       R6,A
   \   00006A   E9           MOV       A,R1
   \   00006B   FF           MOV       R7,A
   \   00006C                ; Setup parameters for call to function zcl_ReadAttrData
   \   00006C   E4           CLR       A
   \   00006D   F5..         MOV       ?V2,A
   \   00006F   F5..         MOV       ?V3,A
   \   000071   78..         MOV       R0,#?V2
   \   000073   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000076   7402         MOV       A,#0x2
   \   000078   12....       LCALL     ?XSTACK_DISP100_8
   \   00007B   88..         MOV       ?V2,R0
   \   00007D   89..         MOV       ?V3,R1
   \   00007F   78..         MOV       R0,#?V2
   \   000081   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000084   7C00         MOV       R4,#0x0
   \   000086   7D00         MOV       R5,#0x0
   \   000088   8E82         MOV       DPL,R6
   \   00008A   8F83         MOV       DPH,R7
   \   00008C   A3           INC       DPTR
   \   00008D   A3           INC       DPTR
   \   00008E   A3           INC       DPTR
   \   00008F   A3           INC       DPTR
   \   000090   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000093   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000096   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   000099   7404         MOV       A,#0x4
   \   00009B   12....       LCALL     ?DEALLOC_XSTACK8
   1761          
   1762                // Is device identifying itself?
   1763                if ( identifyTime > 0 )
   \   00009E   85..82       MOV       DPL,?XSP + 0
   \   0000A1   85..83       MOV       DPH,?XSP + 1
   \   0000A4   12....       LCALL     ??Subroutine49_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   0000A7   6078         JZ        ??zclGeneral_ProcessInIdentity_2
   1764                {
   1765                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1766                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   \   0000A9   85..82       MOV       DPL,?V0
   \   0000AC   85..83       MOV       DPH,?V1
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   FE           MOV       R6,A
   \   0000B1   A3           INC       DPTR
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   FF           MOV       R7,A
   \   0000B4                ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
   \   0000B4   85..82       MOV       DPL,?V0
   \   0000B7   85..83       MOV       DPH,?V1
   \   0000BA   A3           INC       DPTR
   \   0000BB   A3           INC       DPTR
   \   0000BC   A3           INC       DPTR
   \   0000BD   A3           INC       DPTR
   \   0000BE   A3           INC       DPTR
   \   0000BF   A3           INC       DPTR
   \   0000C0   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0000C3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C6   75..01       MOV       ?V0,#0x1
   \   0000C9   78..         MOV       R0,#?V0
   \   0000CB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000CE   7402         MOV       A,#0x2
   \   0000D0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D3   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000D6   12....       LCALL     `??zclGeneral_SendIdentifyQueryResponse::?relay`; Banked call to: zclGeneral_SendIdentifyQueryResponse
   \   0000D9   7402         MOV       A,#0x2
   \   0000DB   12....       LCALL     ?DEALLOC_XSTACK8
   1767                  return ( ZCL_STATUS_CMD_HAS_RSP );
   \   0000DE   79FF         MOV       R1,#-0x1
   \   0000E0   8041         SJMP      ??zclGeneral_ProcessInIdentity_4
   1768                }
   1769              }
   1770          
   1771          #ifdef ZCL_LIGHT_LINK_ENHANCE
   1772              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_TRIGGER_EFFECT )
   1773              {
   1774                if ( pCBs->pfnIdentifyTriggerEffect )
   1775                {
   1776                  zclIdentifyTriggerEffect_t cmd;
   1777          
   1778                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1779                  cmd.effectId = pInMsg->pData[0];
   1780                  cmd.effectVariant = pInMsg->pData[1];
   1781          
   1782                  pCBs->pfnIdentifyTriggerEffect( &cmd );
   1783                }
   1784              }
   1785          #endif //ZCL_LIGHT_LINK_ENHANCE
   1786              else
   1787              {
   1788                return ( ZFailure );   // Error ignore the command
   1789              }
   1790            }
   1791            else // Client Command
   1792            {
   1793              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   \                     ??zclGeneral_ProcessInIdentity_0:
   \   0000E2   E8           MOV       A,R0
   \   0000E3   6004         JZ        ??zclGeneral_ProcessInIdentity_5
   1794                return ( ZFailure );   // Error ignore the command
   \                     ??zclGeneral_ProcessInIdentity_3:
   \   0000E5   7901         MOV       R1,#0x1
   \   0000E7   803A         SJMP      ??zclGeneral_ProcessInIdentity_4
   1795          
   1796              zclIdentifyQueryRsp_t rsp;
   1797              
   1798              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \                     ??zclGeneral_ProcessInIdentity_5:
   \   0000E9   8A82         MOV       DPL,R2
   \   0000EB   8B83         MOV       DPH,R3
   \   0000ED   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0000F0   7402         MOV       A,#0x2
   \   0000F2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F5   12....       LCALL     ?Subroutine24 & 0xFFFF
   1799              rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \                     ??CrossCallReturnLabel_109:
   \   0000F8   8A82         MOV       DPL,R2
   \   0000FA   8B83         MOV       DPH,R3
   \   0000FC   A3           INC       DPTR
   \   0000FD   A3           INC       DPTR
   \   0000FE   A3           INC       DPTR
   \   0000FF   A3           INC       DPTR
   \   000100   A3           INC       DPTR
   \   000101   A3           INC       DPTR
   \   000102   A3           INC       DPTR
   \   000103   A3           INC       DPTR
   \   000104   E0           MOVX      A,@DPTR
   \   000105   FA           MOV       R2,A
   \   000106   A3           INC       DPTR
   \   000107   E0           MOVX      A,@DPTR
   \   000108   8A82         MOV       DPL,R2
   \   00010A   F583         MOV       DPH,A
   \   00010C   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00010F   F9           MOV       R1,A
   \   000110   7404         MOV       A,#0x4
   \   000112   12....       LCALL     ?XSTACK_DISP0_8
   \   000115   EC           MOV       A,R4
   \   000116   12....       LCALL     ??Subroutine51_0 & 0xFFFF
   1800              
   1801              bdb_ZclIdentifyQueryCmdInd( &rsp );
   \                     ??CrossCallReturnLabel_105:
   \   000119                ; Setup parameters for call to function bdb_ZclIdentifyQueryCmdInd
   \   000119   7402         MOV       A,#0x2
   \   00011B   12....       LCALL     ?XSTACK_DISP101_8
   \   00011E   12....       LCALL     `??bdb_ZclIdentifyQueryCmdInd::?relay`; Banked call to: bdb_ZclIdentifyQueryCmdInd
   1802            }
   1803            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInIdentity_2:
   \   000121   7900         MOV       R1,#0x0
   \                     ??zclGeneral_ProcessInIdentity_4:
   \   000123   7406         MOV       A,#0x6
   \   000125   02....       LJMP      ??Subroutine43_0 & 0xFFFF
   1804          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   FB           MOV       R3,A
   \   000001                ; Setup parameters for call to function bdb_ZclIdentifyCmdInd
   \   000001                REQUIRE ??Subroutine47_0
   \   000001                ; // Fall through to label ??Subroutine47_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine47_0:
   \   000000   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine48_0:
   \   000000   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine49_0:
   \   000000   12....       LCALL     ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000003   F9           MOV       R1,A
   \   000004   E8           MOV       A,R0
   \   000005   49           ORL       A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006                REQUIRE ??Subroutine50_0
   \   000006                ; // Fall through to label ??Subroutine50_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000003   FD           MOV       R5,A
   \   000004   EE           MOV       A,R6
   \   000005   2406         ADD       A,#0x6
   \   000007   FA           MOV       R2,A
   \   000008   E4           CLR       A
   \   000009   3F           ADDC      A,R7
   \   00000A   FB           MOV       R3,A
   \   00000B   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   EE           MOV       A,R6
   \   000001   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000004   F9           MOV       R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000003   C8           XCH       A,R0
   \   000004   2414         ADD       A,#0x14
   \   000006   F582         MOV       DPL,A
   \   000008   E4           CLR       A
   \   000009   38           ADDC      A,R0
   \   00000A   F583         MOV       DPH,A
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F9           MOV       R1,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2406         ADD       A,#0x6
   \   000003   F8           MOV       R0,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   3400         ADDC      A,#0x0
   \   000008   F9           MOV       R1,A
   \   000009   22           RET
   1805          #endif // ZCL_IDENTIFY
   1806          
   1807          #ifdef ZCL_GROUPS
   1808          
   1809          /*********************************************************************
   1810           * @fn      zclGeneral_AddGroup
   1811           *
   1812           * @brief   Add a Group.
   1813           *
   1814           * @param   endPoint - application endpoint
   1815           * @param   group - group to be added
   1816           * @param   pData - pointer to the group info
   1817           *
   1818           * @return  ZStatus_t
   1819           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1820          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   \                     zclGeneral_AddGroup:
   1821          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V1,R1
   \   00000C   EA           MOV       A,R2
   \   00000D   FE           MOV       R6,A
   \   00000E   EB           MOV       A,R3
   \   00000F   FF           MOV       R7,A
   \   000010   8C..         MOV       ?V2,R4
   \   000012   8D..         MOV       ?V3,R5
   1822            uint8 nameLen;
   1823            uint8 nameSupport = FALSE;
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   E4           CLR       A
   \   00001B   F0           MOVX      @DPTR,A
   1824          
   1825            pData += 2;   // Move past group ID
   1826            nameLen = *pData++;
   \   00001C   8C82         MOV       DPL,R4
   \   00001E   8D83         MOV       DPH,R5
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   F5..         MOV       ?V0,A
   1827          
   1828            // Retrieve Name Support attribute
   1829            zcl_ReadAttrData( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS,
   1830                              ATTRID_GROUP_NAME_SUPPORT, &nameSupport, NULL );
   \   000025                ; Setup parameters for call to function zcl_ReadAttrData
   \   000025   E4           CLR       A
   \   000026   F5..         MOV       ?V4,A
   \   000028   F5..         MOV       ?V5,A
   \   00002A   78..         MOV       R0,#?V4
   \   00002C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002F   7402         MOV       A,#0x2
   \   000031   12....       LCALL     ?XSTACK_DISP100_8
   \   000034   88..         MOV       ?V4,R0
   \   000036   89..         MOV       ?V5,R1
   \   000038   78..         MOV       R0,#?V4
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7C00         MOV       R4,#0x0
   \   00003F   7D00         MOV       R5,#0x0
   \   000041   7A04         MOV       R2,#0x4
   \   000043   7B00         MOV       R3,#0x0
   \   000045   A9..         MOV       R1,?V1
   \   000047   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   00004A   7404         MOV       A,#0x4
   \   00004C   12....       LCALL     ?DEALLOC_XSTACK8
   1831          
   1832            if ( nameSupport )
   \   00004F   85..82       MOV       DPL,?XSP + 0
   \   000052   85..83       MOV       DPH,?XSP + 1
   \   000055   E0           MOVX      A,@DPTR
   \   000056   6038         JZ        ??zclGeneral_AddGroup_0
   1833            {
   1834              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   \   000058   E5..         MOV       A,?V0
   \   00005A   C3           CLR       C
   \   00005B   9410         SUBB      A,#0x10
   \   00005D   4003         JC        ??zclGeneral_AddGroup_1
   1835                 nameLen = (APS_GROUP_NAME_LEN-1);
   \   00005F   75..0F       MOV       ?V0,#0xf
   1836              group->name[0] = nameLen;
   \                     ??zclGeneral_AddGroup_1:
   \   000062   8E82         MOV       DPL,R6
   \   000064   8F83         MOV       DPH,R7
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   E5..         MOV       A,?V0
   \   00006A   12....       LCALL     ?Subroutine33 & 0xFFFF
   1837              zcl_memcpy( &(group->name[1]), pData, nameLen );
   1838            }
   \                     ??CrossCallReturnLabel_60:
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A982         MOV       R1,DPL
   \   000072   AA83         MOV       R2,DPH
   \   000074   89..         MOV       ?V4,R1
   \   000076   8A..         MOV       ?V5,R2
   \   000078   75..00       MOV       ?V6,#0x0
   \   00007B   78..         MOV       R0,#?V4
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000080   AC..         MOV       R4,?V0
   \   000082   7D00         MOV       R5,#0x0
   \   000084   EE           MOV       A,R6
   \   000085   2403         ADD       A,#0x3
   \   000087   FA           MOV       R2,A
   \   000088   E4           CLR       A
   \   000089   3F           ADDC      A,R7
   \   00008A   12....       LCALL     ??Subroutine40_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00008D   12....       LCALL     ?DEALLOC_XSTACK8
   1839          
   1840            return ( aps_AddGroup( endPoint, group ) );
   \                     ??zclGeneral_AddGroup_0:
   \   000090                ; Setup parameters for call to function aps_AddGroup
   \   000090   EE           MOV       A,R6
   \   000091   FA           MOV       R2,A
   \   000092   EF           MOV       A,R7
   \   000093   FB           MOV       R3,A
   \   000094   A9..         MOV       R1,?V1
   \   000096   12....       LCALL     `??aps_AddGroup::?relay`; Banked call to: aps_AddGroup
   \   000099   7401         MOV       A,#0x1
   \   00009B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00009E   7F07         MOV       R7,#0x7
   \   0000A0   02....       LJMP      ?BANKED_LEAVE_XDATA
   1841          }
   1842          
   1843          /*********************************************************************
   1844           * @fn      zclGeneral_ProcessInGroupsServer
   1845           *
   1846           * @brief   Process in the received Groups Command.
   1847           *
   1848           * @param   pInMsg - pointer to the incoming message
   1849           *
   1850           * @return  ZStatus_t
   1851           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1852          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   \                     zclGeneral_ProcessInGroupsServer:
   1853          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 54
   \   000005   74CA         MOV       A,#-0x36
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   1854            aps_Group_t group;
   1855            aps_Group_t *pGroup;
   1856            uint8 *pData;
   1857            uint8 status;
   1858            uint8 grpCnt;
   1859            uint8 grpRspCnt = 0;
   \   00000E   7F00         MOV       R7,#0x0
   1860            uint16 *grpList;
   1861            uint16 identifyTime = 0;
   \   000010   7402         MOV       A,#0x2
   \   000012   12....       LCALL     ?XSTACK_DISP0_8
   \   000015   E4           CLR       A
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   F0           MOVX      @DPTR,A
   1862            uint8 i;
   1863            ZStatus_t stat = ZSuccess;
   \   000019   7E00         MOV       R6,#0x0
   1864          
   1865            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   \   00001B                ; Setup parameters for call to function osal_memset
   \   00001B   7C12         MOV       R4,#0x12
   \   00001D   FD           MOV       R5,A
   \   00001E   F9           MOV       R1,A
   \   00001F   7404         MOV       A,#0x4
   \   000021   12....       LCALL     ?XSTACK_DISP101_8
   \   000024   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1866          
   1867            pData = pInMsg->pData;
   \   000027   85..82       MOV       DPL,?V0
   \   00002A   85..83       MOV       DPH,?V1
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   12....       LCALL     ?Subroutine14 & 0xFFFF
   1868            group.ID = BUILD_UINT16( pData[0], pData[1] );
   \                     ??CrossCallReturnLabel_25:
   \   000038   A3           INC       DPTR
   \   000039   A882         MOV       R0,DPL
   \   00003B   A983         MOV       R1,DPH
   \   00003D   85..82       MOV       DPL,?V2
   \   000040   F583         MOV       DPH,A
   \   000042   E0           MOVX      A,@DPTR
   \   000043   FC           MOV       R4,A
   \   000044   8882         MOV       DPL,R0
   \   000046   8983         MOV       DPH,R1
   \   000048   E0           MOVX      A,@DPTR
   \   000049   FB           MOV       R3,A
   \   00004A   7404         MOV       A,#0x4
   \   00004C   12....       LCALL     ?XSTACK_DISP0_8
   \   00004F   EC           MOV       A,R4
   \   000050   F0           MOVX      @DPTR,A
   \   000051   A3           INC       DPTR
   \   000052   EB           MOV       A,R3
   \   000053   F0           MOVX      @DPTR,A
   1869            switch ( pInMsg->hdr.commandID )
   \   000054   E5..         MOV       A,?V0
   \   000056   2406         ADD       A,#0x6
   \   000058   F5..         MOV       ?V8,A
   \   00005A   E4           CLR       A
   \   00005B   35..         ADDC      A,?V1
   \   00005D   F5..         MOV       ?V9,A
   \   00005F   E5..         MOV       A,?V0
   \   000061   2407         ADD       A,#0x7
   \   000063   F5..         MOV       ?V6,A
   \   000065   E4           CLR       A
   \   000066   35..         ADDC      A,?V1
   \   000068   F5..         MOV       ?V7,A
   \   00006A   85..82       MOV       DPL,?V6
   \   00006D   F583         MOV       DPH,A
   \   00006F   E0           MOVX      A,@DPTR
   \   000070   601E         JZ        ??zclGeneral_ProcessInGroupsServer_0
   \   000072   14           DEC       A
   \   000073   6053         JZ        ??zclGeneral_ProcessInGroupsServer_1
   \   000075   14           DEC       A
   \   000076   7003         JNZ       $+5
   \   000078   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_2 & 0xFFFF
   \   00007B   14           DEC       A
   \   00007C   7003         JNZ       $+5
   \   00007E   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_3 & 0xFFFF
   \   000081   14           DEC       A
   \   000082   7003         JNZ       $+5
   \   000084   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_4 & 0xFFFF
   \   000087   14           DEC       A
   \   000088   7003         JNZ       $+5
   \   00008A   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_5 & 0xFFFF
   \   00008D   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_6 & 0xFFFF
   1870            {
   1871              case COMMAND_GROUP_ADD:
   1872                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   \                     ??zclGeneral_ProcessInGroupsServer_0:
   \   000090                ; Setup parameters for call to function zclGeneral_AddGroup
   \   000090   AC..         MOV       R4,?V2
   \   000092   AD..         MOV       R5,?V3
   \   000094   7404         MOV       A,#0x4
   \   000096   12....       LCALL     ?XSTACK_DISP101_8
   \   000099   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00009C   E9           MOV       A,R1
   \   00009D   FC           MOV       R4,A
   1873                if ( status != ZSuccess )
   \   00009E   600B         JZ        ??zclGeneral_ProcessInGroupsServer_7
   1874                {
   1875                  if ( status == ZApsDuplicateEntry )
   \   0000A0   74B8         MOV       A,#-0x48
   \   0000A2   6C           XRL       A,R4
   \   0000A3   7004         JNZ       ??zclGeneral_ProcessInGroupsServer_8
   1876                  {
   1877                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   \   0000A5   7C8A         MOV       R4,#-0x76
   \   0000A7   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_7
   1878                  }
   1879                  else
   1880                  {
   1881                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   \                     ??zclGeneral_ProcessInGroupsServer_8:
   \   0000A9   7C89         MOV       R4,#-0x77
   1882                  }
   1883                }
   1884          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1885                if ( UNICAST_MSG( pInMsg->msg ) )
   1886          #endif
   1887                {
   1888                  zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1889                                                   status, group.ID, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_7:
   \   0000AB   12....       LCALL     ?Subroutine4 & 0xFFFF
   1890                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1891                }
   \                     ??CrossCallReturnLabel_0:
   \   0000AE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B1   75..01       MOV       ?V0,#0x1
   \   0000B4   78..         MOV       R0,#?V0
   \   0000B6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B9   7406         MOV       A,#0x6
   \   0000BB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BE   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0000C1   EC           MOV       A,R4
   \   0000C2   FD           MOV       R5,A
   \   0000C3   7C00         MOV       R4,#0x0
   \   0000C5   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_9 & 0xFFFF
   1892                break;
   1893          
   1894              case COMMAND_GROUP_VIEW:
   1895          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1896                if ( UNICAST_MSG( pInMsg->msg ) )
   1897          #endif
   1898                {
   1899                  pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   \                     ??zclGeneral_ProcessInGroupsServer_1:
   \   0000C8                ; Setup parameters for call to function aps_FindGroup
   \   0000C8   7404         MOV       A,#0x4
   \   0000CA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CD   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000D0   12....       LCALL     `??aps_FindGroup::?relay`; Banked call to: aps_FindGroup
   \   0000D3   8A..         MOV       ?V2,R2
   \   0000D5   8B..         MOV       ?V3,R3
   1900                  if ( pGroup )
   \   0000D7   EA           MOV       A,R2
   \   0000D8   4B           ORL       A,R3
   \   0000D9   6004         JZ        ??zclGeneral_ProcessInGroupsServer_10
   1901                  {
   1902                    status = ZCL_STATUS_SUCCESS;
   \   0000DB   7C00         MOV       R4,#0x0
   \   0000DD   800B         SJMP      ??zclGeneral_ProcessInGroupsServer_11
   1903                  }
   1904                  else
   1905                  {
   1906                    // Group not found
   1907                    status = ZCL_STATUS_NOT_FOUND;
   \                     ??zclGeneral_ProcessInGroupsServer_10:
   \   0000DF   7C8B         MOV       R4,#-0x75
   1908                    pGroup = &group;
   \   0000E1   7404         MOV       A,#0x4
   \   0000E3   12....       LCALL     ?XSTACK_DISP100_8
   \   0000E6   88..         MOV       ?V2,R0
   \   0000E8   89..         MOV       ?V3,R1
   1909                  }
   1910                  zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1911                                                    status, pGroup, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_11:
   \   0000EA   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000ED   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000F0   78..         MOV       R0,#?V2
   \   0000F2   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000F5   7D01         MOV       R5,#0x1
   \   0000F7   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   0000FA   12....       LCALL     `??zclGeneral_SendGroupViewResponse::?relay`; Banked call to: zclGeneral_SendGroupViewResponse
   \   0000FD   7403         MOV       A,#0x3
   \   0000FF   12....       LCALL     ?DEALLOC_XSTACK8
   1912                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \   000102   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_12 & 0xFFFF
   1913                }
   1914                break;
   1915          
   1916              case COMMAND_GROUP_GET_MEMBERSHIP:
   1917          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1918                if ( UNICAST_MSG( pInMsg->msg ) )
   1919          #endif
   1920                {
   1921                  grpCnt = *pData++;
   \                     ??zclGeneral_ProcessInGroupsServer_2:
   \   000105   85..82       MOV       DPL,?V2
   \   000108   85..83       MOV       DPH,?V3
   \   00010B   E0           MOVX      A,@DPTR
   \   00010C   FE           MOV       R6,A
   \   00010D   88..         MOV       ?V2,R0
   \   00010F   89..         MOV       ?V3,R1
   1922          
   1923                  // Allocate space for the group list
   1924                  grpList = zcl_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   \   000111                ; Setup parameters for call to function osal_mem_alloc
   \   000111   7A20         MOV       R2,#0x20
   \   000113   7B00         MOV       R3,#0x0
   \   000115   12....       LCALL     ?Subroutine25 & 0xFFFF
   1925                  if ( grpList != NULL )
   \                     ??CrossCallReturnLabel_45:
   \   000118   7003         JNZ       $+5
   \   00011A   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_13 & 0xFFFF
   1926                  {
   1927                    if ( grpCnt == 0 )
   \   00011D   EE           MOV       A,R6
   \   00011E   7006         JNZ       ??zclGeneral_ProcessInGroupsServer_14
   1928                    {
   1929                      // Find out all the groups of which the endpoint is a member.
   1930                      grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   \   000120                ; Setup parameters for call to function aps_FindAllGroupsForEndpoint
   \   000120   12....       LCALL     ?Subroutine9 & 0xFFFF
   1931                    }
   \                     ??CrossCallReturnLabel_12:
   \   000123   FF           MOV       R7,A
   \   000124   8053         SJMP      ??zclGeneral_ProcessInGroupsServer_15
   1932                    else
   1933                    {
   1934                      // Find out the groups (in the list) of which the endpoint is a member.
   1935                      for ( i = 0; i < grpCnt; i++ )
   \                     ??zclGeneral_ProcessInGroupsServer_14:
   \   000126   8E..         MOV       ?V10,R6
   1936                      {
   1937                        group.ID = BUILD_UINT16( pData[0], pData[1] );
   \                     ??zclGeneral_ProcessInGroupsServer_16:
   \   000128   85..82       MOV       DPL,?V2
   \   00012B   85..83       MOV       DPH,?V3
   \   00012E   E0           MOVX      A,@DPTR
   \   00012F   FA           MOV       R2,A
   \   000130   A3           INC       DPTR
   \   000131   E0           MOVX      A,@DPTR
   \   000132   F9           MOV       R1,A
   \   000133   7404         MOV       A,#0x4
   \   000135   12....       LCALL     ?XSTACK_DISP0_8
   \   000138   EA           MOV       A,R2
   \   000139   12....       LCALL     ??Subroutine51_0 & 0xFFFF
   1938                        pData += 2;
   \                     ??CrossCallReturnLabel_106:
   \   00013C   E5..         MOV       A,?V2
   \   00013E   2402         ADD       A,#0x2
   \   000140   F5..         MOV       ?V2,A
   \   000142   5002         JNC       ??zclGeneral_ProcessInGroupsServer_17
   \   000144   05..         INC       ?V3
   1939          
   1940                        if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   \                     ??zclGeneral_ProcessInGroupsServer_17:
   \   000146                ; Setup parameters for call to function aps_FindGroup
   \   000146   7404         MOV       A,#0x4
   \   000148   12....       LCALL     ?XSTACK_DISP0_8
   \   00014B   E0           MOVX      A,@DPTR
   \   00014C   FA           MOV       R2,A
   \   00014D   A3           INC       DPTR
   \   00014E   E0           MOVX      A,@DPTR
   \   00014F   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000152   12....       LCALL     `??aps_FindGroup::?relay`; Banked call to: aps_FindGroup
   \   000155   EA           MOV       A,R2
   \   000156   4B           ORL       A,R3
   \   000157   6017         JZ        ??zclGeneral_ProcessInGroupsServer_18
   1941                          grpList[grpRspCnt++] = group.ID;
   \   000159   7404         MOV       A,#0x4
   \   00015B   12....       LCALL     ?XSTACK_DISP0_8
   \   00015E   12....       LCALL     ?Subroutine15 & 0xFFFF
   1942                      }
   \                     ??CrossCallReturnLabel_30:
   \   000161   EF           MOV       A,R7
   \   000162   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000165   E5..         MOV       A,?V5
   \   000167   39           ADDC      A,R1
   \   000168   F583         MOV       DPH,A
   \   00016A   EA           MOV       A,R2
   \   00016B   F0           MOVX      @DPTR,A
   \   00016C   A3           INC       DPTR
   \   00016D   EB           MOV       A,R3
   \   00016E   F0           MOVX      @DPTR,A
   \   00016F   0F           INC       R7
   \                     ??zclGeneral_ProcessInGroupsServer_18:
   \   000170   15..         DEC       ?V10
   \   000172   E5..         MOV       A,?V10
   \   000174   70B2         JNZ       ??zclGeneral_ProcessInGroupsServer_16
   \   000176   EF           MOV       A,R7
   \   000177   606A         JZ        ??zclGeneral_ProcessInGroupsServer_19
   1943                    }
   1944          
   1945                    if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1946                    {
   1947                      zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1948                                                                 aps_GroupsRemaingCapacity(), grpRspCnt,
   1949                                                                 grpList, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_15:
   \   000179                ; Setup parameters for call to function aps_CountAllGroups
   \   000179   12....       LCALL     `??aps_CountAllGroups::?relay`; Banked call to: aps_CountAllGroups
   \   00017C   E9           MOV       A,R1
   \   00017D   F9           MOV       R1,A
   \   00017E   85..82       MOV       DPL,?V0
   \   000181   85..83       MOV       DPH,?V1
   \   000184   E0           MOVX      A,@DPTR
   \   000185   F5..         MOV       ?V0,A
   \   000187   A3           INC       DPTR
   \   000188   E0           MOVX      A,@DPTR
   \   000189   F5..         MOV       ?V1,A
   \   00018B                ; Setup parameters for call to function zclGeneral_SendGroupGetMembershipRequest
   \   00018B   85..82       MOV       DPL,?V8
   \   00018E   85..83       MOV       DPH,?V9
   \   000191   E0           MOVX      A,@DPTR
   \   000192   F5..         MOV       ?V2,A
   \   000194   78..         MOV       R0,#?V2
   \   000196   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000199   75..01       MOV       ?V2,#0x1
   \   00019C   78..         MOV       R0,#?V2
   \   00019E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001A1   78..         MOV       R0,#?V4
   \   0001A3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001A6   EF           MOV       A,R7
   \   0001A7   F5..         MOV       ?V2,A
   \   0001A9   78..         MOV       R0,#?V2
   \   0001AB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001AE   7410         MOV       A,#0x10
   \   0001B0   C3           CLR       C
   \   0001B1   99           SUBB      A,R1
   \   0001B2   F5..         MOV       ?V2,A
   \   0001B4   78..         MOV       R0,#?V2
   \   0001B6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001B9   75..01       MOV       ?V2,#0x1
   \   0001BC   78..         MOV       R0,#?V2
   \   0001BE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C1   7D01         MOV       R5,#0x1
   \   0001C3   7C02         MOV       R4,#0x2
   \   0001C5   E5..         MOV       A,?V0
   \   0001C7   2406         ADD       A,#0x6
   \   0001C9   FA           MOV       R2,A
   \   0001CA   E4           CLR       A
   \   0001CB   35..         ADDC      A,?V1
   \   0001CD   FB           MOV       R3,A
   \   0001CE   E5..         MOV       A,?V0
   \   0001D0   2414         ADD       A,#0x14
   \   0001D2   F582         MOV       DPL,A
   \   0001D4   E4           CLR       A
   \   0001D5   35..         ADDC      A,?V1
   \   0001D7   F583         MOV       DPH,A
   \   0001D9   E0           MOVX      A,@DPTR
   \   0001DA   F9           MOV       R1,A
   \   0001DB   12....       LCALL     `??zclGeneral_SendGroupGetMembershipRequest::?re`; Banked call to: zclGeneral_SendGroupGetMembershipRequest
   \   0001DE   7407         MOV       A,#0x7
   \   0001E0   12....       LCALL     ?DEALLOC_XSTACK8
   1950                    }
   1951          
   1952                    zcl_mem_free( grpList );
   \                     ??zclGeneral_ProcessInGroupsServer_19:
   \   0001E3                ; Setup parameters for call to function osal_mem_free
   \   0001E3   AA..         MOV       R2,?V4
   \   0001E5   AB..         MOV       R3,?V5
   \   0001E7   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001EA   8054         SJMP      ??zclGeneral_ProcessInGroupsServer_20
   1953                  }
   1954                  else
   1955                  {
   1956                    // Couldn't allocate space for the group list -- send a Default Response command back.
   1957                    zclDefaultRspCmd_t defaultRspCmd;
   1958          
   1959                    defaultRspCmd.commandID = pInMsg->hdr.commandID;
   \                     ??zclGeneral_ProcessInGroupsServer_13:
   \   0001EC   85..82       MOV       DPL,?V6
   \   0001EF   85..83       MOV       DPH,?V7
   \   0001F2   E0           MOVX      A,@DPTR
   \   0001F3   85..82       MOV       DPL,?XSP + 0
   \   0001F6   85..83       MOV       DPH,?XSP + 1
   \   0001F9   F0           MOVX      @DPTR,A
   1960                    defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   \   0001FA   7401         MOV       A,#0x1
   \   0001FC   12....       LCALL     ?XSTACK_DISP0_8
   \   0001FF   7489         MOV       A,#-0x77
   \   000201   F0           MOVX      @DPTR,A
   1961                    zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1962                                           pInMsg->msg->clusterId, &defaultRspCmd,
   1963                                           ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   \   000202   12....       LCALL     ?Subroutine4 & 0xFFFF
   1964                  }
   \                     ??CrossCallReturnLabel_2:
   \   000205   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000208   E4           CLR       A
   \   000209   F5..         MOV       ?V0,A
   \   00020B   F5..         MOV       ?V1,A
   \   00020D   78..         MOV       R0,#?V0
   \   00020F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000212   75..01       MOV       ?V0,#0x1
   \   000215   78..         MOV       R0,#?V0
   \   000217   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00021A   78..         MOV       R0,#?V0
   \   00021C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00021F   7405         MOV       A,#0x5
   \   000221   12....       LCALL     ?XSTACK_DISP100_8
   \   000224   88..         MOV       ?V0,R0
   \   000226   89..         MOV       ?V1,R1
   \   000228   78..         MOV       R0,#?V0
   \   00022A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00022D   8E82         MOV       DPL,R6
   \   00022F   8F83         MOV       DPH,R7
   \   000231   A3           INC       DPTR
   \   000232   A3           INC       DPTR
   \   000233   A3           INC       DPTR
   \   000234   A3           INC       DPTR
   \   000235   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000238   12....       LCALL     `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   00023B   7407         MOV       A,#0x7
   \   00023D   12....       LCALL     ?DEALLOC_XSTACK8
   1965          
   1966                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \                     ??zclGeneral_ProcessInGroupsServer_20:
   \   000240   8039         SJMP      ??zclGeneral_ProcessInGroupsServer_12
   1967                }
   1968                break;
   1969          
   1970              case COMMAND_GROUP_REMOVE:
   1971          #if defined ( ZCL_SCENES )
   1972                zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, group.ID );
   1973          #endif
   1974                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   \                     ??zclGeneral_ProcessInGroupsServer_3:
   \   000242                ; Setup parameters for call to function aps_RemoveGroup
   \   000242   7404         MOV       A,#0x4
   \   000244   12....       LCALL     ?XSTACK_DISP0_8
   \   000247   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00024A   12....       LCALL     `??aps_RemoveGroup::?relay`; Banked call to: aps_RemoveGroup
   \   00024D   E9           MOV       A,R1
   \   00024E   6004         JZ        ??zclGeneral_ProcessInGroupsServer_21
   1975                {
   1976                  status = ZCL_STATUS_SUCCESS;
   \   000250   7C00         MOV       R4,#0x0
   \   000252   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_22
   1977                }
   1978                else
   1979                {
   1980                  status = ZCL_STATUS_NOT_FOUND;
   \                     ??zclGeneral_ProcessInGroupsServer_21:
   \   000254   7C8B         MOV       R4,#-0x75
   1981                }
   1982          
   1983          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1984                if ( UNICAST_MSG( pInMsg->msg ) )
   1985          #endif
   1986                {
   1987                  zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1988                                                      status, group.ID, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_22:
   \   000256   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000259   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00025C   75..01       MOV       ?V0,#0x1
   \   00025F   78..         MOV       R0,#?V0
   \   000261   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000264   7406         MOV       A,#0x6
   \   000266   12....       LCALL     ?XSTACK_DISP0_8
   \   000269   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00026C   EC           MOV       A,R4
   \   00026D   FD           MOV       R5,A
   \   00026E   7C03         MOV       R4,#0x3
   \                     ??zclGeneral_ProcessInGroupsServer_9:
   \   000270   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000273   12....       LCALL     `??zclGeneral_SendGroupResponse::?relay`; Banked call to: zclGeneral_SendGroupResponse
   \   000276   7404         MOV       A,#0x4
   \   000278   12....       LCALL     ?DEALLOC_XSTACK8
   1989                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \                     ??zclGeneral_ProcessInGroupsServer_12:
   \   00027B   7EFF         MOV       R6,#-0x1
   1990                }
   1991                break;
   \   00027D   8057         SJMP      ??zclGeneral_ProcessInGroupsServer_23
   1992          
   1993              case COMMAND_GROUP_REMOVE_ALL:
   1994                {
   1995                  uint8 numGroups;
   1996                  uint16 groupList[APS_MAX_GROUPS];
   1997          
   1998                  if ( numGroups = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, groupList ) )
   \                     ??zclGeneral_ProcessInGroupsServer_4:
   \   00027F                ; Setup parameters for call to function aps_FindAllGroupsForEndpoint
   \   00027F   7416         MOV       A,#0x16
   \   000281   12....       LCALL     ?XSTACK_DISP101_8
   \   000284   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000287   604D         JZ        ??zclGeneral_ProcessInGroupsServer_23
   1999                  {
   2000                    for ( i = 0; i < numGroups; i++ )
   2001                    {
   2002          #if defined ( ZCL_SCENES )
   2003                      zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, groupList[i] );
   2004          #endif
   2005                    }
   2006          
   2007                    aps_RemoveAllGroup( pInMsg->msg->endPoint );
   \   000289                ; Setup parameters for call to function aps_RemoveAllGroup
   \   000289   12....       LCALL     ??Subroutine47_0 & 0xFFFF
   2008                  }
   2009                }
   \                     ??CrossCallReturnLabel_80:
   \   00028C   12....       LCALL     `??aps_RemoveAllGroup::?relay`; Banked call to: aps_RemoveAllGroup
   \   00028F   8045         SJMP      ??zclGeneral_ProcessInGroupsServer_23
   2010                break;
   2011          
   2012              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   2013                // Retrieve Identify Time
   2014                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2015                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   \                     ??zclGeneral_ProcessInGroupsServer_5:
   \   000291                ; Setup parameters for call to function zcl_ReadAttrData
   \   000291   E4           CLR       A
   \   000292   F5..         MOV       ?V4,A
   \   000294   F5..         MOV       ?V5,A
   \   000296   78..         MOV       R0,#?V4
   \   000298   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00029B   7404         MOV       A,#0x4
   \   00029D   12....       LCALL     ?XSTACK_DISP100_8
   \   0002A0   88..         MOV       ?V4,R0
   \   0002A2   89..         MOV       ?V5,R1
   \   0002A4   78..         MOV       R0,#?V4
   \   0002A6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0002A9   7C00         MOV       R4,#0x0
   \   0002AB   7D00         MOV       R5,#0x0
   \   0002AD   7A03         MOV       R2,#0x3
   \   0002AF   7B00         MOV       R3,#0x0
   \   0002B1   12....       LCALL     ??Subroutine47_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   0002B4   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   0002B7   7404         MOV       A,#0x4
   \   0002B9   12....       LCALL     ?DEALLOC_XSTACK8
   2016          
   2017                // Is device identifying itself?
   2018                if ( identifyTime > 0 )
   \   0002BC   7402         MOV       A,#0x2
   \   0002BE   12....       LCALL     ?XSTACK_DISP0_8
   \   0002C1   12....       LCALL     ??Subroutine49_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   0002C4   6010         JZ        ??zclGeneral_ProcessInGroupsServer_23
   2019                {
   2020                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   \   0002C6                ; Setup parameters for call to function zclGeneral_AddGroup
   \   0002C6   AC..         MOV       R4,?V2
   \   0002C8   AD..         MOV       R5,?V3
   \   0002CA   7404         MOV       A,#0x4
   \   0002CC   12....       LCALL     ?XSTACK_DISP101_8
   \   0002CF   12....       LCALL     ?Subroutine8 & 0xFFFF
   2021                }
   \                     ??CrossCallReturnLabel_11:
   \   0002D2   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_23
   2022                break;
   2023          
   2024              default:
   2025                stat = ZFailure;
   \                     ??zclGeneral_ProcessInGroupsServer_6:
   \   0002D4   7E01         MOV       R6,#0x1
   2026                break;
   2027            }
   2028          
   2029            return ( stat );
   \                     ??zclGeneral_ProcessInGroupsServer_23:
   \   0002D6   EE           MOV       A,R6
   \   0002D7   F9           MOV       R1,A
   \   0002D8   7436         MOV       A,#0x36
   \   0002DA   02....       LJMP      ?Subroutine2 & 0xFFFF
   2030          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   EE           MOV       A,R6
   \   000001   2406         ADD       A,#0x6
   \   000003   FA           MOV       R2,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   FB           MOV       R3,A
   \   000007                REQUIRE ??Subroutine48_0
   \   000007                ; // Fall through to label ??Subroutine48_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000003   12....       LCALL     `??aps_FindAllGroupsForEndpoint::?relay`; Banked call to: aps_FindAllGroupsForEndpoint
   \   000006   E9           MOV       A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000003   12....       LCALL     `??zclGeneral_AddGroup::?relay`; Banked call to: zclGeneral_AddGroup
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FE           MOV       R6,A
   \   000008   A3           INC       DPTR
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   FF           MOV       R7,A
   \   00000B                ; Setup parameters for call to function zclGeneral_SendGroupResponse
   \   00000B                ; Setup parameters for call to function zclGeneral_SendGroupViewResponse
   \   00000B                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   00000B                ; Setup parameters for call to function zclGeneral_SendGroupResponse
   \   00000B   85..82       MOV       DPL,?V8
   \   00000E   85..83       MOV       DPH,?V9
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F5..         MOV       ?V0,A
   \   000014   78..         MOV       R0,#?V0
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   25E0         ADD       A,0xE0 /* A   */
   \   000002   F8           MOV       R0,A
   \   000003   E4           CLR       A
   \   000004   33           RLC       A
   \   000005   F9           MOV       R1,A
   \   000006   E5..         MOV       A,?V4
   \   000008   28           ADD       A,R0
   \   000009   F582         MOV       DPL,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000003   8A..         MOV       ?V4,R2
   \   000005   8B..         MOV       ?V5,R3
   \   000007   EA           MOV       A,R2
   \   000008   4B           ORL       A,R3
   \   000009   22           RET
   2031          
   2032          /*********************************************************************
   2033           * @fn      zclGeneral_ProcessInGroupsClient
   2034           *
   2035           * @brief   Process in the received Groups Command.
   2036           *
   2037           * @param   pInMsg - pointer to the incoming message
   2038           *
   2039           * @return  ZStatus_t
   2040           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006                REQUIRE ??Subroutine49_0
   \   000006                ; // Fall through to label ??Subroutine49_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2041          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInGroupsClient:
   2042                                                             zclGeneral_AppCallbacks_t *pCBs )
   2043          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 28
   \   000005   74E4         MOV       A,#-0x1c
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
   2044            aps_Group_t group;
   2045            uint8 *pData = pInMsg->pData;
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   FE           MOV       R6,A
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   FF           MOV       R7,A
   2046            uint8 grpCnt;
   2047            uint8 nameLen;
   2048            zclGroupRsp_t rsp;
   2049            uint8 i;
   2050            ZStatus_t stat = ZSuccess;
   \   000023   75..00       MOV       ?V11,#0x0
   2051          
   2052            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   \   000026                ; Setup parameters for call to function osal_memset
   \   000026   7C12         MOV       R4,#0x12
   \   000028   7D00         MOV       R5,#0x0
   \   00002A   7900         MOV       R1,#0x0
   \   00002C   740A         MOV       A,#0xa
   \   00002E   12....       LCALL     ?XSTACK_DISP101_8
   \   000031   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2053            zcl_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   \   000034                ; Setup parameters for call to function osal_memset
   \   000034   7C0A         MOV       R4,#0xa
   \   000036   7D00         MOV       R5,#0x0
   \   000038   7900         MOV       R1,#0x0
   \   00003A   AA..         MOV       R2,?XSP + 0
   \   00003C   AB..         MOV       R3,?XSP + 1
   \   00003E   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2054          
   2055            switch ( pInMsg->hdr.commandID )
   \   000041   EE           MOV       A,R6
   \   000042   2402         ADD       A,#0x2
   \   000044   FA           MOV       R2,A
   \   000045   E4           CLR       A
   \   000046   3F           ADDC      A,R7
   \   000047   FB           MOV       R3,A
   \   000048   E5..         MOV       A,?V0
   \   00004A   240C         ADD       A,#0xc
   \   00004C   F5..         MOV       ?V0,A
   \   00004E   5002         JNC       ??zclGeneral_ProcessInGroupsClient_0
   \   000050   05..         INC       ?V1
   \                     ??zclGeneral_ProcessInGroupsClient_0:
   \   000052   8E82         MOV       DPL,R6
   \   000054   8F83         MOV       DPH,R7
   \   000056   A3           INC       DPTR
   \   000057   A882         MOV       R0,DPL
   \   000059   A983         MOV       R1,DPH
   \   00005B   E5..         MOV       A,?V6
   \   00005D   2407         ADD       A,#0x7
   \   00005F   F5..         MOV       ?V2,A
   \   000061   E4           CLR       A
   \   000062   35..         ADDC      A,?V7
   \   000064   F5..         MOV       ?V3,A
   \   000066   85..82       MOV       DPL,?V2
   \   000069   F583         MOV       DPH,A
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   600F         JZ        ??zclGeneral_ProcessInGroupsClient_1
   \   00006E   14           DEC       A
   \   00006F   600C         JZ        ??zclGeneral_ProcessInGroupsClient_1
   \   000071   14           DEC       A
   \   000072   7003         JNZ       $+5
   \   000074   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_2 & 0xFFFF
   \   000077   14           DEC       A
   \   000078   6003         JZ        $+5
   \   00007A   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_3 & 0xFFFF
   2056            {
   2057              case COMMAND_GROUP_ADD_RSP:
   2058              case COMMAND_GROUP_VIEW_RSP:
   2059              case COMMAND_GROUP_REMOVE_RSP:
   2060                rsp.status = *pData++;
   \                     ??zclGeneral_ProcessInGroupsClient_1:
   \   00007D   8E82         MOV       DPL,R6
   \   00007F   8F83         MOV       DPH,R7
   \   000081   E0           MOVX      A,@DPTR
   \   000082   FC           MOV       R4,A
   \   000083   7403         MOV       A,#0x3
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   EC           MOV       A,R4
   \   000089   F0           MOVX      @DPTR,A
   \   00008A   E9           MOV       A,R1
   \   00008B   FF           MOV       R7,A
   2061                group.ID = BUILD_UINT16( pData[0], pData[1] );
   \   00008C   8882         MOV       DPL,R0
   \   00008E   F583         MOV       DPH,A
   \   000090   E0           MOVX      A,@DPTR
   \   000091   F5..         MOV       ?V4,A
   \   000093   8A82         MOV       DPL,R2
   \   000095   8B83         MOV       DPH,R3
   \   000097   E0           MOVX      A,@DPTR
   \   000098   F9           MOV       R1,A
   \   000099   740A         MOV       A,#0xa
   \   00009B   12....       LCALL     ?XSTACK_DISP0_8
   \   00009E   E5..         MOV       A,?V4
   \   0000A0   12....       LCALL     ??Subroutine51_0 & 0xFFFF
   2062          
   2063                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   \                     ??CrossCallReturnLabel_107:
   \   0000A3   EC           MOV       A,R4
   \   0000A4   7059         JNZ       ??CrossCallReturnLabel_110
   \   0000A6   85..82       MOV       DPL,?V2
   \   0000A9   85..83       MOV       DPH,?V3
   \   0000AC   E0           MOVX      A,@DPTR
   \   0000AD   6401         XRL       A,#0x1
   \   0000AF   704E         JNZ       ??CrossCallReturnLabel_110
   2064                {
   2065                  pData += 2;   // Move past ID
   2066                  nameLen = *pData++;
   \   0000B1   8882         MOV       DPL,R0
   \   0000B3   8F83         MOV       DPH,R7
   \   0000B5   A3           INC       DPTR
   \   0000B6   A3           INC       DPTR
   \   0000B7   E0           MOVX      A,@DPTR
   \   0000B8   F9           MOV       R1,A
   \   0000B9   E8           MOV       A,R0
   \   0000BA   2403         ADD       A,#0x3
   \   0000BC   FE           MOV       R6,A
   \   0000BD   5001         JNC       ??zclGeneral_ProcessInGroupsClient_4
   \   0000BF   0F           INC       R7
   2067                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   \                     ??zclGeneral_ProcessInGroupsClient_4:
   \   0000C0   E9           MOV       A,R1
   \   0000C1   C3           CLR       C
   \   0000C2   9410         SUBB      A,#0x10
   \   0000C4   4002         JC        ??zclGeneral_ProcessInGroupsClient_5
   2068                    nameLen = (APS_GROUP_NAME_LEN-1);
   \   0000C6   790F         MOV       R1,#0xf
   2069                  group.name[0] = nameLen;
   \                     ??zclGeneral_ProcessInGroupsClient_5:
   \   0000C8   740C         MOV       A,#0xc
   \   0000CA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CD   E9           MOV       A,R1
   \   0000CE   F0           MOVX      @DPTR,A
   2070                  zcl_memcpy( &(group.name[1]), pData, nameLen );
   \   0000CF                ; Setup parameters for call to function osal_memcpy
   \   0000CF   8E..         MOV       ?V8,R6
   \   0000D1   8F..         MOV       ?V9,R7
   \   0000D3   75..00       MOV       ?V10,#0x0
   \   0000D6   78..         MOV       R0,#?V8
   \   0000D8   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000DB   E9           MOV       A,R1
   \   0000DC   FC           MOV       R4,A
   \   0000DD   7D00         MOV       R5,#0x0
   \   0000DF   7410         MOV       A,#0x10
   \   0000E1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E4   AA82         MOV       R2,DPL
   \   0000E6   AB83         MOV       R3,DPH
   \   0000E8   12....       LCALL     ??Subroutine41_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0000EB   12....       LCALL     ?DEALLOC_XSTACK8
   2071                  rsp.grpName = group.name;
   \   0000EE   740C         MOV       A,#0xc
   \   0000F0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F3   A882         MOV       R0,DPL
   \   0000F5   A983         MOV       R1,DPH
   \   0000F7   7408         MOV       A,#0x8
   \   0000F9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000FC   12....       LCALL     ?Subroutine24 & 0xFFFF
   2072                }
   2073          
   2074                if ( pCBs->pfnGroupRsp )
   \                     ??CrossCallReturnLabel_110:
   \   0000FF   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000102   7003         JNZ       $+5
   \   000104   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_6 & 0xFFFF
   2075                {
   2076                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   000107   12....       LCALL     ?Subroutine5 & 0xFFFF
   2077                  rsp.cmdID = pInMsg->hdr.commandID;
   \                     ??CrossCallReturnLabel_4:
   \   00010A   C0E0         PUSH      A
   \   00010C   7402         MOV       A,#0x2
   \   00010E   12....       LCALL     ?XSTACK_DISP0_8
   \   000111   D0E0         POP       A
   \   000113   F0           MOVX      @DPTR,A
   2078                  rsp.grpCnt = 1;
   \   000114   7404         MOV       A,#0x4
   \   000116   12....       LCALL     ?XSTACK_DISP0_8
   \   000119   7401         MOV       A,#0x1
   \   00011B   F0           MOVX      @DPTR,A
   2079                  rsp.grpList = &group.ID;
   \   00011C   740A         MOV       A,#0xa
   \   00011E   12....       LCALL     ?XSTACK_DISP100_8
   \   000121   7405         MOV       A,#0x5
   \   000123   12....       LCALL     ?XSTACK_DISP0_8
   \   000126   12....       LCALL     ?Subroutine24 & 0xFFFF
   2080                  rsp.capacity = 0;
   \                     ??CrossCallReturnLabel_111:
   \   000129   7407         MOV       A,#0x7
   \   00012B   12....       LCALL     ?XSTACK_DISP0_8
   \   00012E   E4           CLR       A
   \   00012F   12....       LCALL     ?Subroutine19 & 0xFFFF
   2081          
   2082                  pCBs->pfnGroupRsp( &rsp );
   2083                }
   \                     ??CrossCallReturnLabel_41:
   \   000132   12....       LCALL     ?CALL_IND
   \   000135   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_6 & 0xFFFF
   2084                break;
   2085          
   2086              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   2087                {
   2088                  uint16 *grpList = NULL;
   \                     ??zclGeneral_ProcessInGroupsClient_2:
   \   000138   75..00       MOV       ?V4,#0x0
   \   00013B   75..00       MOV       ?V5,#0x0
   2089                  rsp.capacity = *pData++;
   \   00013E   8E82         MOV       DPL,R6
   \   000140   8F83         MOV       DPH,R7
   \   000142   E0           MOVX      A,@DPTR
   \   000143   C0E0         PUSH      A
   \   000145   7407         MOV       A,#0x7
   \   000147   12....       LCALL     ?XSTACK_DISP0_8
   \   00014A   D0E0         POP       A
   \   00014C   F0           MOVX      @DPTR,A
   2090                  grpCnt = *pData++;
   \   00014D   8882         MOV       DPL,R0
   \   00014F   8983         MOV       DPH,R1
   \   000151   E0           MOVX      A,@DPTR
   \   000152   F5..         MOV       ?V8,A
   \   000154   0E           INC       R6
   \   000155   0E           INC       R6
   \   000156   EB           MOV       A,R3
   \   000157   FF           MOV       R7,A
   2091          
   2092                  if ( grpCnt > 0 )
   \   000158   E5..         MOV       A,?V8
   \   00015A   6042         JZ        ??zclGeneral_ProcessInGroupsClient_7
   2093                  {
   2094                    // Allocate space for the group list
   2095                    grpList = zcl_mem_alloc( sizeof( uint16 ) * grpCnt );
   \   00015C                ; Setup parameters for call to function osal_mem_alloc
   \   00015C   25E0         ADD       A,0xE0 /* A   */
   \   00015E   FA           MOV       R2,A
   \   00015F   E4           CLR       A
   \   000160   33           RLC       A
   \   000161   FB           MOV       R3,A
   \   000162   12....       LCALL     ?Subroutine25 & 0xFFFF
   2096                    if ( grpList != NULL )
   \                     ??CrossCallReturnLabel_46:
   \   000165   6037         JZ        ??zclGeneral_ProcessInGroupsClient_7
   2097                    {
   2098                      rsp.grpCnt = grpCnt;
   \   000167   7404         MOV       A,#0x4
   \   000169   12....       LCALL     ?XSTACK_DISP0_8
   \   00016C   E5..         MOV       A,?V8
   \   00016E   F0           MOVX      @DPTR,A
   2099                      for ( i = 0; i < grpCnt; i++ )
   \   00016F   7A00         MOV       R2,#0x0
   \   000171   8025         SJMP      ??zclGeneral_ProcessInGroupsClient_8
   2100                      {
   2101                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   \                     ??zclGeneral_ProcessInGroupsClient_9:
   \   000173   8E82         MOV       DPL,R6
   \   000175   8F83         MOV       DPH,R7
   \   000177   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   00017A   F8           MOV       R0,A
   \   00017B   E4           CLR       A
   \   00017C   C8           XCH       A,R0
   \   00017D   F9           MOV       R1,A
   \   00017E   EC           MOV       A,R4
   \   00017F   28           ADD       A,R0
   \   000180   E4           CLR       A
   \   000181   39           ADDC      A,R1
   \   000182   FD           MOV       R5,A
   \   000183   EA           MOV       A,R2
   \   000184   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000187   EB           MOV       A,R3
   \   000188   39           ADDC      A,R1
   \   000189   F583         MOV       DPH,A
   \   00018B   EC           MOV       A,R4
   \   00018C   F0           MOVX      @DPTR,A
   \   00018D   A3           INC       DPTR
   \   00018E   ED           MOV       A,R5
   \   00018F   F0           MOVX      @DPTR,A
   2102                        pData += 2;
   \   000190   EE           MOV       A,R6
   \   000191   2402         ADD       A,#0x2
   \   000193   FE           MOV       R6,A
   \   000194   5001         JNC       ??zclGeneral_ProcessInGroupsClient_10
   \   000196   0F           INC       R7
   2103                      }
   \                     ??zclGeneral_ProcessInGroupsClient_10:
   \   000197   0A           INC       R2
   \                     ??zclGeneral_ProcessInGroupsClient_8:
   \   000198   EA           MOV       A,R2
   \   000199   C3           CLR       C
   \   00019A   95..         SUBB      A,?V8
   \   00019C   40D5         JC        ??zclGeneral_ProcessInGroupsClient_9
   2104                    }
   2105                  }
   2106          
   2107                  if ( pCBs->pfnGroupRsp )
   \                     ??zclGeneral_ProcessInGroupsClient_7:
   \   00019E   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   0001A1   601E         JZ        ??zclGeneral_ProcessInGroupsClient_11
   2108                  {
   2109                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   0001A3   12....       LCALL     ?Subroutine5 & 0xFFFF
   2110                    rsp.cmdID = pInMsg->hdr.commandID;
   \                     ??CrossCallReturnLabel_5:
   \   0001A6   C0E0         PUSH      A
   \   0001A8   7402         MOV       A,#0x2
   \   0001AA   12....       LCALL     ?XSTACK_DISP0_8
   \   0001AD   D0E0         POP       A
   \   0001AF   F0           MOVX      @DPTR,A
   2111                    rsp.grpList = grpList;
   \   0001B0   7405         MOV       A,#0x5
   \   0001B2   12....       LCALL     ?XSTACK_DISP0_8
   \   0001B5   E5..         MOV       A,?V4
   \   0001B7   F0           MOVX      @DPTR,A
   \   0001B8   A3           INC       DPTR
   \   0001B9   E5..         MOV       A,?V5
   \   0001BB   12....       LCALL     ?Subroutine19 & 0xFFFF
   2112          
   2113                    pCBs->pfnGroupRsp( &rsp );
   2114                  }
   \                     ??CrossCallReturnLabel_42:
   \   0001BE   12....       LCALL     ?CALL_IND
   2115          
   2116                  if ( grpList != NULL )
   \                     ??zclGeneral_ProcessInGroupsClient_11:
   \   0001C1   E5..         MOV       A,?V4
   \   0001C3   45..         ORL       A,?V5
   \   0001C5   600C         JZ        ??zclGeneral_ProcessInGroupsClient_6
   2117                  {
   2118                    zcl_mem_free( grpList );
   \   0001C7                ; Setup parameters for call to function osal_mem_free
   \   0001C7   AA..         MOV       R2,?V4
   \   0001C9   AB..         MOV       R3,?V5
   \   0001CB   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001CE   8003         SJMP      ??zclGeneral_ProcessInGroupsClient_6
   2119                  }
   2120                }
   2121                break;
   2122          
   2123              default:
   2124                stat = ZFailure;
   \                     ??zclGeneral_ProcessInGroupsClient_3:
   \   0001D0   75..01       MOV       ?V11,#0x1
   2125                break;
   2126            }
   2127          
   2128            return ( stat );
   \                     ??zclGeneral_ProcessInGroupsClient_6:
   \   0001D3   A9..         MOV       R1,?V11
   \   0001D5   741C         MOV       A,#0x1c
   \   0001D7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001DA   02....       LJMP      ?Subroutine3 & 0xFFFF
   2129          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for indirect call
   \   000001                ; Setup parameters for indirect call
   \   000001   AA..         MOV       R2,?XSP + 0
   \   000003   AB..         MOV       R3,?XSP + 1
   \   000005   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000008   F583         MOV       DPH,A
   \   00000A   8882         MOV       DPL,R0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   85..82       MOV       DPL,?V6
   \   000003   85..83       MOV       DPH,?V7
   \   000006   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   E8           MOV       A,R0
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   E9           MOV       A,R1
   \   000013   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000016   E0           MOVX      A,@DPTR
   \   000017   22           RET
   2130          #endif // ZCL_GROUPS
   2131          
   2132          #if defined( ZCL_SCENES )
   2133          #if !defined ( ZCL_STANDALONE )
   2134          /*********************************************************************
   2135           * @fn      zclGeneral_AddScene
   2136           *
   2137           * @brief   Add a scene for an endpoint
   2138           *
   2139           * @param   endpoint -
   2140           * @param   scene - new scene item
   2141           *
   2142           * @return  ZStatus_t
   2143           */
   2144          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   2145          {
   2146            zclGenSceneItem_t *pNewItem;
   2147            zclGenSceneItem_t *pLoop;
   2148          
   2149            // Fill in the new profile list
   2150            pNewItem = zcl_mem_alloc( sizeof( zclGenSceneItem_t ) );
   2151            if ( pNewItem == NULL )
   2152              return ( ZMemError );
   2153          
   2154            // Fill in the plugin record.
   2155            pNewItem->next = (zclGenSceneItem_t *)NULL;
   2156            pNewItem->endpoint = endpoint;
   2157            zcl_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   2158          
   2159            // Find spot in list
   2160            if (  zclGenSceneTable == NULL )
   2161            {
   2162              zclGenSceneTable = pNewItem;
   2163            }
   2164            else
   2165            {
   2166              // Look for end of list
   2167              pLoop = zclGenSceneTable;
   2168              while ( pLoop->next != NULL )
   2169                pLoop = pLoop->next;
   2170          
   2171              // Put new item at end of list
   2172              pLoop->next = pNewItem;
   2173            }
   2174          
   2175            // Update NV
   2176            zclGeneral_ScenesWriteNV();
   2177          
   2178            return ( ZSuccess );
   2179          }
   2180          #endif // ZCL_STANDALONE
   2181          
   2182          #if !defined ( ZCL_STANDALONE )
   2183          /*********************************************************************
   2184           * @fn      zclGeneral_FindScene
   2185           *
   2186           * @brief   Find a scene with endpoint and sceneID
   2187           *
   2188           * @param   endpoint -
   2189           * @param   groupID - what group the scene belongs to
   2190           * @param   sceneID - ID to look for scene
   2191           *
   2192           * @return  a pointer to the scene information, NULL if not found
   2193           */
   2194          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2195          {
   2196            zclGenSceneItem_t *pLoop;
   2197          
   2198            // Look for end of list
   2199            pLoop = zclGenSceneTable;
   2200            while ( pLoop )
   2201            {
   2202              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   2203                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2204              {
   2205                return ( &(pLoop->scene) );
   2206              }
   2207              pLoop = pLoop->next;
   2208            }
   2209          
   2210            return ( (zclGeneral_Scene_t *)NULL );
   2211          }
   2212          #endif // ZCL_STANDALONE
   2213          
   2214          #if !defined ( ZCL_STANDALONE )
   2215          /*********************************************************************
   2216           * @fn      zclGeneral_FindAllScenesForGroup
   2217           *
   2218           * @brief   Find all the scenes with groupID
   2219           *
   2220           * @param   endpoint - endpoint to look for
   2221           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   2222           *
   2223           * @return  number of scenes copied to sceneList
   2224           */
   2225          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   2226          {
   2227            zclGenSceneItem_t *pLoop;
   2228            uint8 cnt = 0;
   2229          
   2230            // Look for end of list
   2231            pLoop = zclGenSceneTable;
   2232            while ( pLoop )
   2233            {
   2234              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2235                sceneList[cnt++] = pLoop->scene.ID;
   2236              pLoop = pLoop->next;
   2237            }
   2238            return ( cnt );
   2239          }
   2240          #endif // ZCL_STANDALONE
   2241          
   2242          #if !defined ( ZCL_STANDALONE )
   2243          /*********************************************************************
   2244           * @fn      zclGeneral_RemoveScene
   2245           *
   2246           * @brief   Remove a scene with endpoint and sceneID
   2247           *
   2248           * @param   endpoint -
   2249           * @param   groupID - what group the scene belongs to
   2250           * @param   sceneID - ID to look for scene
   2251           *
   2252           * @return  TRUE if removed, FALSE if not found
   2253           */
   2254          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2255          {
   2256            zclGenSceneItem_t *pLoop;
   2257            zclGenSceneItem_t *pPrev;
   2258          
   2259            // Look for end of list
   2260            pLoop = zclGenSceneTable;
   2261            pPrev = NULL;
   2262            while ( pLoop )
   2263            {
   2264              if ( pLoop->endpoint == endpoint
   2265                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2266              {
   2267                if ( pPrev == NULL )
   2268                  zclGenSceneTable = pLoop->next;
   2269                else
   2270                  pPrev->next = pLoop->next;
   2271          
   2272                // Free the memory
   2273                zcl_mem_free( pLoop );
   2274          
   2275                // Update NV
   2276                zclGeneral_ScenesWriteNV();
   2277          
   2278                return ( TRUE );
   2279              }
   2280              pPrev = pLoop;
   2281              pLoop = pLoop->next;
   2282            }
   2283          
   2284            return ( FALSE );
   2285          }
   2286          #endif // ZCL_STANDALONE
   2287          
   2288          #if !defined ( ZCL_STANDALONE )
   2289          /*********************************************************************
   2290           * @fn      zclGeneral_RemoveAllScenes
   2291           *
   2292           * @brief   Remove all scenes with endpoint and group Id
   2293           *
   2294           * @param   endpoint -
   2295           * @param   groupID - ID to look for group
   2296           *
   2297           * @return  none
   2298           */
   2299          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   2300          {
   2301            zclGenSceneItem_t *pLoop;
   2302            zclGenSceneItem_t *pPrev;
   2303            zclGenSceneItem_t *pNext;
   2304          
   2305            // Look for end of list
   2306            pLoop = zclGenSceneTable;
   2307            pPrev = NULL;
   2308            while ( pLoop )
   2309            {
   2310              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2311              {
   2312                if ( pPrev == NULL )
   2313                  zclGenSceneTable = pLoop->next;
   2314                else
   2315                  pPrev->next = pLoop->next;
   2316                pNext = pLoop->next;
   2317          
   2318                // Free the memory
   2319                zcl_mem_free( pLoop );
   2320                pLoop = pNext;
   2321              }
   2322              else
   2323              {
   2324                pPrev = pLoop;
   2325                pLoop = pLoop->next;
   2326              }
   2327            }
   2328          
   2329            // Update NV
   2330            zclGeneral_ScenesWriteNV();
   2331          }
   2332          #endif // ZCL_STANDALONE
   2333          
   2334          #if !defined ( ZCL_STANDALONE )
   2335          /*********************************************************************
   2336           * @fn      zclGeneral_CountScenes
   2337           *
   2338           * @brief   Count the number of scenes for an endpoint
   2339           *
   2340           * @param   endpoint -
   2341           *
   2342           * @return  number of scenes assigned to an endpoint
   2343           */
   2344          uint8 zclGeneral_CountScenes( uint8 endpoint )
   2345          {
   2346            zclGenSceneItem_t *pLoop;
   2347            uint8 cnt = 0;
   2348          
   2349            // Look for end of list
   2350            pLoop = zclGenSceneTable;
   2351            while ( pLoop )
   2352            {
   2353              if ( pLoop->endpoint == endpoint  )
   2354                cnt++;
   2355              pLoop = pLoop->next;
   2356            }
   2357            return ( cnt );
   2358          }
   2359          #endif
   2360          
   2361          #if !defined ( ZCL_STANDALONE )
   2362          /*********************************************************************
   2363           * @fn      zclGeneral_CountAllScenes
   2364           *
   2365           * @brief   Count the total number of scenes
   2366           *
   2367           * @param   none
   2368           *
   2369           * @return  number of scenes
   2370           */
   2371          uint8 zclGeneral_CountAllScenes( void )
   2372          {
   2373            zclGenSceneItem_t *pLoop;
   2374            uint8 cnt = 0;
   2375          
   2376            // Look for end of list
   2377            pLoop = zclGenSceneTable;
   2378            while ( pLoop )
   2379            {
   2380              cnt++;
   2381              pLoop = pLoop->next;
   2382            }
   2383            return ( cnt );
   2384          }
   2385          #endif // ZCL_STANDALONE
   2386          
   2387          /*********************************************************************
   2388           * @fn      zclGeneral_ReadSceneCountCB
   2389           *
   2390           * @brief   Read the number of scenes currently in the device's
   2391           *          scene table (i.e., the Scene Count attribute).
   2392           *
   2393           *          Note: This function gets called only when the pointer
   2394           *                'dataPtr' to the Scene Count attribute value is
   2395           *                NULL in the attribute database registered with
   2396           *                the ZCL.
   2397           *
   2398           * @param   clusterId - cluster that attribute belongs to
   2399           * @param   attrId - attribute to be read or written
   2400           * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ, or ZCL_OPER_WRITE
   2401           * @param   pValue - pointer to attribute value
   2402           * @param   pLen - pointer to length of attribute value read
   2403           *
   2404           * @return  status
   2405           */
   2406          ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
   2407                                                 uint8 oper, uint8 *pValue, uint16 *pLen )
   2408          {
   2409            ZStatus_t status = ZCL_STATUS_SUCCESS;
   2410          
   2411            // This callback function should only be called for the Scene Count attribute
   2412            switch ( oper )
   2413            {
   2414              case ZCL_OPER_LEN:
   2415                *pLen = 1; // uint8
   2416                break;
   2417          
   2418              case ZCL_OPER_READ:
   2419                *pValue = zclGeneral_CountAllScenes();
   2420          
   2421                if ( pLen != NULL )
   2422                {
   2423                  *pLen = 1;
   2424                }
   2425                break;
   2426          
   2427              case ZCL_OPER_WRITE:
   2428                // Fall through
   2429          
   2430              default:
   2431                status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
   2432                break;
   2433            }
   2434          
   2435            return ( status );
   2436          }
   2437          
   2438          /*********************************************************************
   2439           * @fn      zclGeneral_ProcessInScenesServer
   2440           *
   2441           * @brief   Process in the received Scenes Command.
   2442           *
   2443           * @param   pInMsg - pointer to the incoming message
   2444           *
   2445           * @return  ZStatus_t
   2446           */
   2447          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   2448                                                             zclGeneral_AppCallbacks_t *pCBs )
   2449          {
   2450            zclGeneral_Scene_t scene;
   2451            zclGeneral_Scene_t *pScene;
   2452            uint8 *pData = pInMsg->pData;
   2453            uint8 nameLen;
   2454            uint8 status;
   2455            uint8 sceneCnt = 0;
   2456            uint8 *sceneList = NULL;
   2457            uint8 sendRsp = TRUE;
   2458            uint8 nameSupport = FALSE;
   2459            ZStatus_t stat = ZSuccess;
   2460          
   2461            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2462          
   2463            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2464            pData += 2;   // Move past group ID
   2465            scene.ID = *pData++;
   2466          
   2467            switch ( pInMsg->hdr.commandID )
   2468            {
   2469              case COMMAND_SCENE_ADD:
   2470          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2471              case COMMAND_SCENE_ENHANCED_ADD:
   2472          #endif // ZCL_LIGHT_LINK_ENHANCE
   2473                // Parse the rest of the incoming message
   2474                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2475                pData += 2;
   2476          
   2477                if ( pInMsg->hdr.commandID == COMMAND_SCENE_ENHANCED_ADD )
   2478                {
   2479                  // Received transition time is in 1/10 second
   2480                  scene.transTime100ms = scene.transTime % 10;
   2481                  scene.transTime /= 10;
   2482                }
   2483          
   2484                nameLen= *pData++; // Name length
   2485          
   2486                // Retrieve Name Support attribute
   2487                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES,
   2488                                  ATTRID_SCENES_NAME_SUPPORT, &nameSupport, NULL );
   2489          
   2490                if ( nameSupport )
   2491                {
   2492                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2493                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2494                  scene.name[0] = nameLen;
   2495                  zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2496                }
   2497          
   2498                pData += nameLen; // move past name, use original length
   2499          
   2500                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2501                if ( scene.extLen > 0 )
   2502                {
   2503                  // Copy the extention field(s)
   2504                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2505                  {
   2506                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2507                  }
   2508                  zcl_memcpy( scene.extField, pData, scene.extLen );
   2509                }
   2510          
   2511                if ( scene.groupID == 0x0000 ||
   2512                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2513                {
   2514                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2515                  // does and the corresponding Group exits
   2516                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2517                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2518                  {
   2519                    status = ZCL_STATUS_SUCCESS;
   2520                    if ( pScene != NULL )
   2521                    {
   2522                      // The Scene already exists so update it
   2523                      pScene->transTime = scene.transTime;
   2524                      zcl_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2525          
   2526                      // Use the new extention field(s)
   2527                      zcl_memcpy( pScene->extField, scene.extField, scene.extLen );
   2528                      pScene->extLen = scene.extLen;
   2529          
   2530                      // Save Scenes
   2531                      zclGeneral_ScenesSave();
   2532                    }
   2533                    else
   2534                    {
   2535                      // The Scene doesn't exist so add it
   2536                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2537                    }
   2538                  }
   2539                  else
   2540                  {
   2541                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2542                  }
   2543                }
   2544                else
   2545                {
   2546                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2547                }
   2548          
   2549                if ( UNICAST_MSG( pInMsg->msg ) )
   2550                {
   2551                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_ADD )
   2552                  {
   2553                    zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2554                                                    status, scene.groupID, scene.ID,
   2555                                                    true, pInMsg->hdr.transSeqNum );
   2556                  }
   2557          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2558                  else // COMMAND_SCENE_ENHANCED_ADD
   2559                  {
   2560                    zclGeneral_SendSceneEnhancedAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2561                                                            status, scene.groupID, scene.ID,
   2562                                                            true, pInMsg->hdr.transSeqNum );
   2563                  }
   2564          #endif // ZCL_LIGHT_LINK_ENHANCE
   2565                }
   2566                stat = ZCL_STATUS_CMD_HAS_RSP;
   2567          
   2568                break;
   2569          
   2570              case COMMAND_SCENE_VIEW:
   2571          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2572              case COMMAND_SCENE_ENHANCED_VIEW:
   2573          #endif // ZCL_LIGHT_LINK_ENHANCE
   2574                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2575                if ( pScene != NULL )
   2576                {
   2577                  status = ZCL_STATUS_SUCCESS;
   2578                }
   2579                else
   2580                {
   2581                  // Scene not found
   2582                  if ( scene.groupID != 0x0000 &&
   2583                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2584                  {
   2585                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2586                  }
   2587                  else
   2588                  {
   2589                    status = ZCL_STATUS_NOT_FOUND;
   2590                  }
   2591                  pScene = &scene;
   2592                }
   2593          
   2594                if ( UNICAST_MSG( pInMsg->msg ) )
   2595                {
   2596                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_VIEW )
   2597                  {
   2598                    zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2599                                                     status, pScene, true, pInMsg->hdr.transSeqNum );
   2600                  }
   2601          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2602                  else
   2603                  {
   2604                    zclGeneral_SendSceneEnhancedViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2605                                                             status, pScene, true, pInMsg->hdr.transSeqNum );
   2606                  }
   2607          #endif // ZCL_LIGHT_LINK_ENHANCE
   2608                }
   2609                stat = ZCL_STATUS_CMD_HAS_RSP;
   2610                break;
   2611          
   2612              case COMMAND_SCENE_REMOVE:
   2613                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2614                {
   2615                  status = ZCL_STATUS_SUCCESS;
   2616                }
   2617                else
   2618                {
   2619                  // Scene not found
   2620                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2621                  {
   2622                    // The Group is not in the Group Table
   2623                    status = ZCL_STATUS_INVALID_FIELD;
   2624                  }
   2625                  else
   2626                  {
   2627                    status = ZCL_STATUS_NOT_FOUND;
   2628                  }
   2629                }
   2630          
   2631                if ( UNICAST_MSG( pInMsg->msg ) )
   2632                {
   2633                  // Addressed to this device (not to a group) - send a response back
   2634                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2635                                                      status, scene.groupID,
   2636                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2637                }
   2638                stat = ZCL_STATUS_CMD_HAS_RSP;
   2639                break;
   2640          
   2641              case COMMAND_SCENE_REMOVE_ALL:
   2642                if ( scene.groupID == 0x0000 ||
   2643                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2644                {
   2645                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2646                  status = ZCL_STATUS_SUCCESS;
   2647                }
   2648                else
   2649                {
   2650                  status = ZCL_STATUS_INVALID_FIELD;
   2651                }
   2652          
   2653                if ( UNICAST_MSG( pInMsg->msg ) )
   2654                {
   2655                  // Addressed to this device (not to a group) - send a response back
   2656                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2657                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2658                }
   2659                stat = ZCL_STATUS_CMD_HAS_RSP;
   2660                break;
   2661          
   2662              case COMMAND_SCENE_STORE:
   2663                if ( scene.groupID == 0x0000 ||
   2664                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2665                {
   2666                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2667                  // does and the corresponding Group exits
   2668                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2669                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2670                  {
   2671                    uint8 sceneChanged = FALSE;
   2672          
   2673                    status = ZCL_STATUS_SUCCESS;
   2674                    if ( pScene == NULL )
   2675                    {
   2676                      // Haven't been added yet
   2677                      pScene = &scene;
   2678                    }
   2679          
   2680                    if ( pCBs->pfnSceneStoreReq )
   2681                    {
   2682                      zclSceneReq_t req;
   2683          
   2684                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2685                      req.scene = pScene;
   2686          
   2687                      // Get the latest Scene info
   2688                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2689                      {
   2690                        sceneChanged = TRUE;
   2691                      }
   2692                    }
   2693          
   2694                    if ( pScene == &scene )
   2695                    {
   2696                      // The Scene doesn't exist so add it
   2697                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2698                    }
   2699                    else if ( sceneChanged )
   2700                    {
   2701                      // The Scene already exists so update only NV
   2702                      zclGeneral_ScenesSave();
   2703                    }
   2704                  }
   2705                  else
   2706                  {
   2707                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2708                  }
   2709                }
   2710                else
   2711                {
   2712                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2713                }
   2714          
   2715                if ( UNICAST_MSG( pInMsg->msg ) )
   2716                {
   2717                  // Addressed to this device (not to a group) - send a response back
   2718                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2719                                                     status, scene.groupID, scene.ID,
   2720                                                     true, pInMsg->hdr.transSeqNum );
   2721                }
   2722                stat = ZCL_STATUS_CMD_HAS_RSP;
   2723                break;
   2724          
   2725              case COMMAND_SCENE_RECALL:
   2726                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2727                if ( pScene && pCBs->pfnSceneRecallReq )
   2728                {
   2729                  zclSceneReq_t req;
   2730          
   2731                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2732                  req.scene = pScene;
   2733          
   2734                  pCBs->pfnSceneRecallReq( &req );
   2735                }
   2736                // No response
   2737                break;
   2738          
   2739              case COMMAND_SCENE_GET_MEMBERSHIP:
   2740                // Find all the Scenes corresponding to the Group ID
   2741                if ( scene.groupID == 0x0000 ||
   2742                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2743                {
   2744                  // Allocate space for the scene list
   2745                  sceneList = zcl_mem_alloc( ZCL_GEN_MAX_SCENES );
   2746                  if ( sceneList != NULL )
   2747                  {
   2748                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2749                                                                 scene.groupID, sceneList );
   2750                    status = ZCL_STATUS_SUCCESS;
   2751                    if ( ! UNICAST_MSG( pInMsg->msg ) )
   2752                    {
   2753                      // Addressed to the Group - ONLY send a response if an entry within the
   2754                      // Scene Table corresponds to the Group ID
   2755                      if ( sceneCnt == 0 )
   2756                      {
   2757                        sendRsp = FALSE;
   2758                      }
   2759                    }
   2760                  }
   2761                  else
   2762                  {
   2763                    // Couldn't allocate space for the scene list!
   2764                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2765                  }
   2766                }
   2767                else
   2768                {
   2769                  // The Group is not in the Group Table - send a response back
   2770                  status = ZCL_STATUS_INVALID_FIELD;
   2771                }
   2772          
   2773          #ifdef ZCL_LIGHT_LINK_ENHANCE //ZLL allows response to unicast only
   2774                if ( sendRsp && UNICAST_MSG( pInMsg->msg ) )
   2775          #else
   2776                if ( sendRsp )
   2777          #endif //ZCL_LIGHT_LINK_ENHANCE
   2778                {
   2779                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2780                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2781                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2782                }
   2783          
   2784                if ( sceneList != NULL )
   2785                  zcl_mem_free( sceneList );
   2786          
   2787                stat = ZCL_STATUS_CMD_HAS_RSP;
   2788                break;
   2789          
   2790          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2791              case COMMAND_SCENE_COPY:
   2792                {
   2793                  uint8 mode;
   2794                  uint16 groupIDFrom, groupIDTo;
   2795                  uint8 sceneIDFrom, sceneIDTo;
   2796          
   2797                  pData = pInMsg->pData; // different payload format
   2798          
   2799                  mode = *pData++;
   2800                  groupIDFrom = BUILD_UINT16( pData[0], pData[1] ); // from group ID
   2801                  pData += 2;
   2802                  sceneIDFrom = *pData++; // from scene ID
   2803                  groupIDTo = BUILD_UINT16( pData[0], pData[1] ); // to group ID
   2804                  pData += 2;
   2805                  if ( (mode & SCENE_COPY_MODE_ALL_BIT) == 0 )
   2806                  {
   2807                    sceneIDTo = *pData++; // to scene ID
   2808                  }
   2809          
   2810                  // Make sure the groups exist
   2811                  if ( ( aps_FindGroup( pInMsg->msg->endPoint, groupIDFrom ) != NULL ) &&
   2812                       ( aps_FindGroup( pInMsg->msg->endPoint, groupIDTo ) != NULL ) )
   2813                  {
   2814                    // Allocate space for the scene list
   2815                    sceneList = zcl_mem_alloc( (mode & SCENE_COPY_MODE_ALL_BIT) ? ZCL_GEN_MAX_SCENES : 1 );
   2816                    if ( sceneList == NULL )
   2817                    {
   2818                      status = ZCL_STATUS_INSUFFICIENT_SPACE; // Couldn't allocate space for the scene list!
   2819                    }
   2820                    else
   2821                    {
   2822                      status = ZCL_STATUS_SUCCESS;
   2823                      if ( mode & SCENE_COPY_MODE_ALL_BIT ) // Copy all scenes
   2824                      {
   2825                        sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2826                                                                     groupIDFrom, sceneList );
   2827                      }
   2828                      else // Copy single scene
   2829                      {
   2830                        // Make sure the scene exists
   2831                        pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneIDFrom );
   2832                        if ( pScene != NULL )
   2833                        {
   2834                          sceneList[0] = sceneIDFrom;
   2835                          sceneCnt = 1;
   2836                        }
   2837                        else
   2838                        {
   2839                          status = ZCL_STATUS_INVALID_FIELD; // Scene not found
   2840                        }
   2841                      }
   2842                    }
   2843          
   2844                    if ( status == ZCL_STATUS_SUCCESS )
   2845                    {
   2846                      uint8 numScenesToAdd = 0;
   2847                      uint8 i;
   2848                      for ( i = 0; i < sceneCnt; i++ )
   2849                      {
   2850                        if ( zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, sceneList[i] ) == NULL )
   2851                        {
   2852                          numScenesToAdd++;
   2853                        }
   2854                      }
   2855                      if ( zclGeneral_ScenesRemaingCapacity() >= numScenesToAdd )
   2856                      {
   2857                        // Copy the scenes
   2858                        for ( i = 0; i < sceneCnt; i++ )
   2859                        {
   2860                          // Ignore scene ID from and scene ID to fields
   2861                          pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneList[i] );
   2862                          if ( pScene != NULL )
   2863                          {
   2864                            zclGeneral_Scene_t *pToScene;
   2865                            scene = *pScene;
   2866                            scene.groupID = groupIDTo;
   2867                            scene.ID = ( (mode & SCENE_COPY_MODE_ALL_BIT) ? sceneList[i] : sceneIDTo );
   2868          
   2869                            pToScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2870                            if( pToScene != NULL )
   2871                            {
   2872                              zclGeneral_RemoveScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2873                            }
   2874                            // Add the scene
   2875                            zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2876                          }
   2877                        }
   2878                      }
   2879                      else
   2880                      {
   2881                        status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2882                      }
   2883                    }
   2884                  }
   2885                  else
   2886                  {
   2887                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2888                  }
   2889          
   2890                  if ( UNICAST_MSG( pInMsg->msg ) )
   2891                  {
   2892                    if ( pScene == NULL )
   2893                    {
   2894                      pScene = &scene;
   2895                    }
   2896                    // Addressed to this device (not to a group) - send a response back
   2897                    zclGeneral_SendSceneCopyResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2898                                                      status, pScene->groupID, pScene->ID,
   2899                                                      true, pInMsg->hdr.transSeqNum );
   2900                  }
   2901          
   2902                  if ( sceneList != NULL )
   2903                  {
   2904                    zcl_mem_free( sceneList );
   2905                  }
   2906                }
   2907          
   2908                stat = ZCL_STATUS_CMD_HAS_RSP;
   2909                break;
   2910          #endif // ZCL_LIGHT_LINK_ENHANCE
   2911          
   2912              default:
   2913                stat = ZFailure;
   2914              break;
   2915            }
   2916          
   2917            return ( stat );
   2918          }
   2919          
   2920          /*********************************************************************
   2921           * @fn      zclGeneral_ProcessInScenesClient
   2922           *
   2923           * @brief   Process in the received Scenes Command.
   2924           *
   2925           * @param   pInMsg - pointer to the incoming message
   2926           *
   2927           * @return  ZStatus_t
   2928           */
   2929          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2930                                                             zclGeneral_AppCallbacks_t *pCBs )
   2931          {
   2932            zclGeneral_Scene_t scene;
   2933            uint8 *pData = pInMsg->pData;
   2934            uint8 nameLen;
   2935            zclSceneRsp_t rsp;
   2936            uint8 i;
   2937            ZStatus_t stat = ZSuccess;
   2938          
   2939            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2940            zcl_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2941          
   2942            // Get the status field first
   2943            rsp.status = *pData++;
   2944          
   2945            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2946            {
   2947              rsp.capacity = *pData++;
   2948            }
   2949          
   2950            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2951            pData += 2;   // Move past group ID
   2952          
   2953            switch ( pInMsg->hdr.commandID )
   2954            {
   2955              case COMMAND_SCENE_VIEW_RSP:
   2956                // Parse the rest of the incoming message
   2957                scene.ID = *pData++; // Not applicable to Remove All Response command
   2958                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2959                pData += 2;
   2960                nameLen = *pData++; // Name length
   2961                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2962                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2963          
   2964                scene.name[0] = nameLen;
   2965                zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2966          
   2967                pData += nameLen; // move past name, use original length
   2968          
   2969                //*** Do something with the extension field(s)
   2970          
   2971                // Fall through to callback - break is left off intentionally
   2972          
   2973              case COMMAND_SCENE_ADD_RSP:
   2974              case COMMAND_SCENE_REMOVE_RSP:
   2975              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2976              case COMMAND_SCENE_STORE_RSP:
   2977                if ( pCBs->pfnSceneRsp )
   2978                {
   2979                  if ( pInMsg->hdr.commandID != COMMAND_SCENE_REMOVE_ALL_RSP )
   2980                  {
   2981                    scene.ID = *pData++;
   2982                  }
   2983                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2984                  rsp.cmdID = pInMsg->hdr.commandID;
   2985                  rsp.scene = &scene;
   2986          
   2987                  pCBs->pfnSceneRsp( &rsp );
   2988                }
   2989                break;
   2990          
   2991              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2992                {
   2993                  uint8 *sceneList = NULL;
   2994          
   2995                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   2996                  {
   2997                    uint8 sceneCnt = *pData++;
   2998          
   2999                    if ( sceneCnt > 0 )
   3000                    {
   3001                      // Allocate space for the scene list
   3002                      sceneList = zcl_mem_alloc( sceneCnt );
   3003                      if ( sceneList != NULL )
   3004                      {
   3005                        rsp.sceneCnt = sceneCnt;
   3006                        for ( i = 0; i < sceneCnt; i++ )
   3007                          sceneList[i] = *pData++;
   3008                      }
   3009                    }
   3010                  }
   3011          
   3012                  if ( pCBs->pfnSceneRsp )
   3013                  {
   3014                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3015                    rsp.cmdID = pInMsg->hdr.commandID;
   3016                    rsp.sceneList = sceneList;
   3017                    rsp.scene = &scene;
   3018          
   3019                    pCBs->pfnSceneRsp( &rsp);
   3020                  }
   3021          
   3022                  if ( sceneList != NULL )
   3023                  {
   3024                    zcl_mem_free( sceneList );
   3025                  }
   3026                }
   3027                break;
   3028          
   3029              default:
   3030                stat = ZFailure;
   3031                break;
   3032            }
   3033          
   3034            return ( stat );
   3035          }
   3036          #endif // ZCL_SCENES
   3037          
   3038          #ifdef ZCL_ON_OFF
   3039          /*********************************************************************
   3040           * @fn      zclGeneral_ProcessInCmdOnOff
   3041           *
   3042           * @brief   Process in the received On/Off Command.
   3043           *
   3044           * @param   pInMsg - pointer to the incoming message
   3045           *
   3046           * @return  ZStatus_t
   3047           */
   3048          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
                                  ^
Warning[Pe177]: function "zclGeneral_ProcessInOnOff" was declared but never
          referenced
   3049                                                      zclGeneral_AppCallbacks_t *pCBs )
   3050          {
   3051            ZStatus_t stat = ZSuccess;
   3052          
   3053            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3054            {
   3055              switch ( pInMsg->hdr.commandID )
   3056              {
   3057                case COMMAND_OFF:
   3058                case COMMAND_ON:
   3059                case COMMAND_TOGGLE:
   3060                  if ( pCBs->pfnOnOff )
   3061                  {
   3062                    pCBs->pfnOnOff( pInMsg->hdr.commandID );
   3063                  }
   3064                  break;
   3065          
   3066          #ifdef ZCL_LIGHT_LINK_ENHANCE
   3067                case COMMAND_OFF_WITH_EFFECT:
   3068                  if ( pCBs->pfnOnOff_OffWithEffect )
   3069                  {
   3070                    zclOffWithEffect_t cmd;
   3071          
   3072                    cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3073                    cmd.effectId = pInMsg->pData[0];
   3074                    cmd.effectVariant = pInMsg->pData[1];
   3075          
   3076                    pCBs->pfnOnOff_OffWithEffect( &cmd );
   3077                  }
   3078                  break;
   3079          
   3080                case COMMAND_ON_WITH_RECALL_GLOBAL_SCENE:
   3081                  if ( pCBs->pfnOnOff_OnWithRecallGlobalScene )
   3082                  {
   3083                    pCBs->pfnOnOff_OnWithRecallGlobalScene();
   3084                  }
   3085                  break;
   3086          
   3087                case COMMAND_ON_WITH_TIMED_OFF:
   3088                  if ( pCBs->pfnOnOff_OnWithTimedOff )
   3089                  {
   3090                    zclOnWithTimedOff_t cmd;
   3091          
   3092                    cmd.onOffCtrl.byte = pInMsg->pData[0];
   3093                    cmd.onTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3094                    cmd.offWaitTime = BUILD_UINT16( pInMsg->pData[3], pInMsg->pData[4] );
   3095                    pCBs->pfnOnOff_OnWithTimedOff( &cmd );
   3096                  }
   3097                  break;
   3098          #endif // ZCL_LIGHT_LINK_ENHANCE
   3099          
   3100                default:
   3101                  stat = ZFailure;
   3102                  break;
   3103              }
   3104            }
   3105            // no Client command
   3106          
   3107            return ( stat );
   3108          }
   3109          
   3110          //static ZStatus_t zclGeneral_ProcessInOnOffTest( zclIncoming_t *pInMsg )
   3111          //{
   3112          //  ZStatus_t stat = ZSuccess;
   3113          //  int8 cmdID;
   3114          //
   3115          //  cmdID = pInMsg->hdr.commandID;
   3116          //  
   3117          //  switch ( cmdID )				
   3118          //  {
   3119          //
   3120          //    default:
   3121          //      stat = ZFailure;
   3122          //      break;
   3123          //  }
   3124          //  // no Client command
   3125          //
   3126          //  return ( stat );
   3127          //}
   3128          #endif // ZCL_ON_OFF
   3129          
   3130          #ifdef ZCL_LEVEL_CTRL
   3131          /*********************************************************************
   3132           * @fn      zclGeneral_ProcessInLevelControl
   3133           *
   3134           * @brief   Process in the received Level Control Command.
   3135           *
   3136           * @param   pInMsg - pointer to the incoming message
   3137           *
   3138           * @return  ZStatus_t
   3139           */
   3140          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   3141                                                             zclGeneral_AppCallbacks_t *pCBs )
   3142          {
   3143            uint8 withOnOff = FALSE;
   3144            ZStatus_t stat = ZSuccess;
   3145          
   3146            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3147            {
   3148              switch ( pInMsg->hdr.commandID )
   3149              {
   3150                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   3151                  withOnOff = TRUE;
   3152                  // fall through
   3153                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   3154                  if ( pCBs->pfnLevelControlMoveToLevel )
   3155                  {
   3156                    zclLCMoveToLevel_t cmd;
   3157          
   3158                    cmd.level = pInMsg->pData[0];
   3159          
   3160                    if ( ( cmd.level >= ATTR_LEVEL_MIN_LEVEL ) &&
   3161                         ( cmd.level <= ATTR_LEVEL_MAX_LEVEL ) )
   3162                    {
   3163                      cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3164                      cmd.withOnOff = withOnOff;
   3165          
   3166                      pCBs->pfnLevelControlMoveToLevel( &cmd );
   3167                    }
   3168                    else
   3169                    {
   3170                      // level range requested is invalid
   3171                      stat = ZCL_STATUS_INVALID_VALUE;
   3172                    }
   3173                  }
   3174                  break;
   3175          
   3176                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   3177                  withOnOff = TRUE;
   3178                  // fall through
   3179                case COMMAND_LEVEL_MOVE:
   3180                  if ( pCBs->pfnLevelControlMove )
   3181                  {
   3182                    zclLCMove_t cmd;
   3183          
   3184                    cmd.moveMode = pInMsg->pData[0];
   3185                    cmd.rate = pInMsg->pData[1];
   3186                    cmd.withOnOff = withOnOff;
   3187          
   3188                    pCBs->pfnLevelControlMove( &cmd );
   3189                  }
   3190                  break;
   3191          
   3192                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   3193                  withOnOff = TRUE;
   3194                  // fall through
   3195                case COMMAND_LEVEL_STEP:
   3196                  if ( pCBs->pfnLevelControlStep )
   3197                  {
   3198                    zclLCStep_t cmd;
   3199          
   3200                    cmd.stepMode = pInMsg->pData[0];
   3201                    cmd.amount =  pInMsg->pData[1];
   3202                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   3203                    cmd.withOnOff = withOnOff;
   3204          
   3205                    pCBs->pfnLevelControlStep( &cmd );
   3206                  }
   3207                  break;
   3208          
   3209                case COMMAND_LEVEL_STOP:
   3210                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   3211                  // Both Stop commands are identical
   3212                  if ( pCBs->pfnLevelControlStop )
   3213                  {
   3214                    pCBs->pfnLevelControlStop();
   3215                  }
   3216                  break;
   3217          
   3218                default:
   3219                  stat = ZFailure;
   3220                  break;
   3221              }
   3222            }
   3223            // no Client command
   3224          
   3225            return ( stat );
   3226          }
   3227          #endif // ZCL_LEVEL_CTRL
   3228          
   3229          #ifdef ZCL_ALARMS
   3230          /*********************************************************************
   3231           * @fn      zclGeneral_AddAlarm
   3232           *
   3233           * @brief   Add an alarm for a cluster
   3234           *
   3235           * @param   endpoint -
   3236           * @param   alarm - new alarm item
   3237           *
   3238           * @return  ZStatus_t
   3239           */
   3240          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   3241          {
   3242            zclGenAlarmItem_t *pNewItem;
   3243            zclGenAlarmItem_t *pLoop;
   3244          
   3245            // Fill in the new profile list
   3246            pNewItem = zcl_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   3247            if ( pNewItem == NULL )
   3248              return ( ZMemError );
   3249          
   3250            // Fill in the plugin record.
   3251            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   3252            pNewItem->endpoint =  endpoint;
   3253            zcl_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   3254          
   3255            // Find spot in list
   3256            if (  zclGenAlarmTable == NULL )
   3257            {
   3258              zclGenAlarmTable = pNewItem;
   3259            }
   3260            else
   3261            {
   3262              // Look for end of list
   3263              pLoop = zclGenAlarmTable;
   3264              while ( pLoop->next != NULL )
   3265                pLoop = pLoop->next;
   3266          
   3267              // Put new item at end of list
   3268              pLoop->next = pNewItem;
   3269            }
   3270          
   3271            return ( ZSuccess );
   3272          }
   3273          
   3274          /*********************************************************************
   3275           * @fn      zclGeneral_FindAlarm
   3276           *
   3277           * @brief   Find an alarm with alarmCode and clusterID
   3278           *
   3279           * @param   endpoint -
   3280           * @param   groupID - what group the scene belongs to
   3281           * @param   sceneID - ID to look for scene
   3282           *
   3283           * @return  a pointer to the alarm information, NULL if not found
   3284           */
   3285          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3286          {
   3287            zclGenAlarmItem_t *pLoop;
   3288          
   3289            // Look for the alarm
   3290            pLoop = zclGenAlarmTable;
   3291            while ( pLoop )
   3292            {
   3293              if ( pLoop->endpoint == endpoint &&
   3294                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3295              {
   3296                return ( &(pLoop->alarm) );
   3297              }
   3298              pLoop = pLoop->next;
   3299            }
   3300          
   3301            return ( (zclGeneral_Alarm_t *)NULL );
   3302          }
   3303          
   3304          /*********************************************************************
   3305           * @fn      zclGeneral_FindEarliestAlarm
   3306           *
   3307           * @brief   Find an alarm with the earliest timestamp
   3308           *
   3309           * @param   endpoint -
   3310           *
   3311           * @return  a pointer to the alarm information, NULL if not found
   3312           */
   3313          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   3314          {
   3315            zclGenAlarmItem_t *pLoop;
   3316            zclGenAlarmItem_t earliestAlarm;
   3317            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   3318          
   3319            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   3320          
   3321            // Look for alarm with earliest time
   3322            pLoop = zclGenAlarmTable;
   3323            while ( pLoop )
   3324            {
   3325              if ( pLoop->endpoint == endpoint &&
   3326                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   3327              {
   3328                pEarliestAlarm = pLoop;
   3329              }
   3330              pLoop = pLoop->next;
   3331            }
   3332          
   3333            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   3334              return ( &(pEarliestAlarm->alarm) );
   3335          
   3336            // No alarm
   3337            return ( (zclGeneral_Alarm_t *)NULL );
   3338          }
   3339          
   3340          /*********************************************************************
   3341           * @fn      zclGeneral_ResetAlarm
   3342           *
   3343           * @brief   Remove an alarm with alarmCode and clusterID
   3344           *
   3345           * @param   endpoint -
   3346           * @param   alarmCode -
   3347           * @param   clusterID -
   3348           *
   3349           * @return  TRUE if removed, FALSE if not found
   3350           */
   3351          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3352          {
   3353            zclGenAlarmItem_t *pLoop;
   3354            zclGenAlarmItem_t *pPrev;
   3355          
   3356            // Look for end of list
   3357            pLoop = zclGenAlarmTable;
   3358            pPrev = NULL;
   3359            while ( pLoop )
   3360            {
   3361              if ( pLoop->endpoint == endpoint &&
   3362                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3363              {
   3364                if ( pPrev == NULL )
   3365                  zclGenAlarmTable = pLoop->next;
   3366                else
   3367                  pPrev->next = pLoop->next;
   3368          
   3369                // Free the memory
   3370                zcl_mem_free( pLoop );
   3371          
   3372                // Notify the Application so that if the alarm condition still active then
   3373                // a new notification will be generated, and a new alarm record will be
   3374                // added to the alarm log
   3375                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   3376                return;
   3377              }
   3378              pPrev = pLoop;
   3379              pLoop = pLoop->next;
   3380            }
   3381          }
   3382          
   3383          /*********************************************************************
   3384           * @fn      zclGeneral_ResetAllAlarms
   3385           *
   3386           * @brief   Remove all alarms with endpoint
   3387           *
   3388           * @param   endpoint -
   3389           * @param   notifyApp -
   3390           *
   3391           * @return  none
   3392           */
   3393          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   3394          {
   3395            zclGenAlarmItem_t *pLoop;
   3396            zclGenAlarmItem_t *pPrev;
   3397            zclGenAlarmItem_t *pNext;
   3398          
   3399            // Look for end of list
   3400            pLoop = zclGenAlarmTable;
   3401            pPrev = NULL;
   3402            while ( pLoop )
   3403            {
   3404              if (  pLoop->endpoint == endpoint )
   3405              {
   3406                if ( pPrev == NULL )
   3407                  zclGenAlarmTable = pLoop->next;
   3408                else
   3409                  pPrev->next = pLoop->next;
   3410          
   3411                pNext = pLoop->next;
   3412          
   3413                // Free the memory
   3414                zcl_mem_free( pLoop );
   3415          
   3416                pLoop = pNext;
   3417              }
   3418              else
   3419              {
   3420                pPrev = pLoop;
   3421                pLoop = pLoop->next;
   3422              }
   3423            }
   3424          
   3425            if ( notifyApp )
   3426            {
   3427              // Notify the Application so that if any alarm conditions still active then
   3428              // a new notification will be generated, and a new alarm record will be
   3429              // added to the alarm log
   3430              // zclGeneral_NotifyResetAll(); // callback function?
   3431            }
   3432          }
   3433          
   3434          /*********************************************************************
   3435           * @fn      zclGeneral_ProcessInAlarmsServer
   3436           *
   3437           * @brief   Process in the received Alarms Command.
   3438           *
   3439           * @param   pInMsg - pointer to the incoming message
   3440           *
   3441           * @return  ZStatus_t
   3442           */
   3443          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   3444                                                             zclGeneral_AppCallbacks_t *pCBs )
   3445          {
   3446            zclAlarm_t alarm;
   3447            zclGeneral_Alarm_t *pAlarm;
   3448            uint8 *pData = pInMsg->pData;
   3449            ZStatus_t stat = ZSuccess;
   3450          
   3451            switch ( pInMsg->hdr.commandID )
   3452            {
   3453              case COMMAND_ALARMS_RESET:
   3454                if ( pCBs->pfnAlarm )
   3455                {
   3456                  alarm.cmdID = pInMsg->hdr.commandID;
   3457                  alarm.alarmCode = pData[0];
   3458                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3459          
   3460                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3461                }
   3462                else
   3463                {
   3464                  stat = ZCL_STATUS_FAILURE;
   3465                }
   3466                break;
   3467          
   3468              case COMMAND_ALARMS_RESET_ALL:
   3469                if ( pCBs->pfnAlarm )
   3470                {
   3471                  alarm.cmdID = pInMsg->hdr.commandID;
   3472          
   3473                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3474                }
   3475                else
   3476                {
   3477                  stat = ZCL_STATUS_FAILURE;
   3478                }
   3479                break;
   3480          
   3481              case COMMAND_ALARMS_GET:
   3482                if ( pCBs->pfnAlarm )
   3483                {
   3484                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3485                  alarm.cmdID = pInMsg->hdr.commandID;
   3486          
   3487                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3488          
   3489                  pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   3490                  if ( pAlarm )
   3491                  {
   3492                    // Send a response back
   3493                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3494                                                     ZCL_STATUS_SUCCESS, pAlarm->code,
   3495                                                     pAlarm->clusterID, pAlarm->timeStamp,
   3496                                                     true, pInMsg->hdr.transSeqNum );
   3497                    // Remove the entry from the Alarm table
   3498                    zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   3499                  }
   3500                  else
   3501                  {
   3502                    // Send a response back
   3503                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3504                                                     ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   3505                                                     true, pInMsg->hdr.transSeqNum );
   3506                  }
   3507                  stat = ZCL_STATUS_CMD_HAS_RSP;
   3508                }
   3509                else
   3510                {
   3511                  stat = ZCL_STATUS_FAILURE;
   3512                }
   3513                break;
   3514          
   3515              case COMMAND_ALARMS_RESET_LOG:
   3516                if ( pCBs->pfnAlarm )
   3517                {
   3518                  alarm.cmdID = pInMsg->hdr.commandID;
   3519          
   3520                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3521          
   3522                  zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   3523                }
   3524                else
   3525                {
   3526                  stat = ZCL_STATUS_FAILURE;
   3527                }
   3528                break;
   3529          
   3530          #ifdef SE_UK_EXT
   3531              case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
   3532                if ( pCBs->pfnPublishEventLog )
   3533                {
   3534                  zclPublishEventLog_t eventLog;
   3535          
   3536                  eventLog.logID = *pData++;
   3537                  eventLog.cmdIndex = *pData++;
   3538                  eventLog.totalCmds = *pData++;
   3539          
   3540                  // First try to find out number of Sub Log Payloads
   3541                  eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
   3542                  if ( eventLog.numSubLogs > 0 )
   3543                  {
   3544                    // Try to alloc space for Log Payload
   3545                    eventLog.pLogs = (zclEventLogPayload_t *)zcl_mem_alloc( sizeof( zclEventLogPayload_t ) *
   3546                                                                             eventLog.numSubLogs );
   3547                    if ( eventLog.pLogs != NULL )
   3548                    {
   3549                      // Copy Log Payload
   3550                      for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
   3551                      {
   3552                        eventLog.pLogs[i].eventId = *pData++;
   3553                        eventLog.pLogs[i].eventTime = zcl_build_uint32( pData, 4 );
   3554                        pData += 4;
   3555                      }
   3556                    }
   3557                    else
   3558                    {
   3559                      stat = ZCL_STATUS_SOFTWARE_FAILURE;
   3560                    }
   3561                  }
   3562                  else
   3563                  {
   3564                    eventLog.pLogs = NULL;
   3565                  }
   3566          
   3567                  if ( stat == ZSuccess )
   3568                  {
   3569                    pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
   3570                  }
   3571          
   3572                  if ( eventLog.pLogs != NULL )
   3573                  {
   3574                    zcl_mem_free( eventLog.pLogs );
   3575                  }
   3576                }
   3577                break;
   3578          #endif // SE_UK_EXT
   3579          
   3580              default:
   3581                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3582                break;
   3583            }
   3584          
   3585            return ( stat );
   3586          }
   3587          
   3588          /*********************************************************************
   3589           * @fn      zclGeneral_ProcessInAlarmsClient
   3590           *
   3591           * @brief   Process in the received Alarms Command.
   3592           *
   3593           * @param   pInMsg - pointer to the incoming message
   3594           *
   3595           * @return  ZStatus_t
   3596           */
   3597          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   3598                                                             zclGeneral_AppCallbacks_t *pCBs )
   3599          {
   3600            uint8 *pData = pInMsg->pData;
   3601            zclAlarm_t alarm;
   3602            ZStatus_t stat = ZSuccess;
   3603          
   3604            zcl_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   3605          
   3606            switch ( pInMsg->hdr.commandID )
   3607            {
   3608              case COMMAND_ALARMS_ALARM:
   3609                if ( pCBs->pfnAlarm )
   3610                {
   3611                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3612                  alarm.cmdID = pInMsg->hdr.commandID;
   3613                  alarm.alarmCode = pData[0];
   3614                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3615          
   3616                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3617                }
   3618                else
   3619                {
   3620                  stat = ZCL_STATUS_FAILURE;
   3621                }
   3622                break;
   3623          
   3624              case COMMAND_ALARMS_GET_RSP:
   3625                if ( pCBs->pfnAlarm )
   3626                {
   3627                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3628                  alarm.cmdID = pInMsg->hdr.commandID;
   3629                  alarm.alarmCode = *pData++;
   3630                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   3631          
   3632                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3633                }
   3634                else
   3635                {
   3636                  stat = ZCL_STATUS_FAILURE;
   3637                }
   3638                break;
   3639          
   3640          #ifdef SE_UK_EXT
   3641              case COMMAND_ALARMS_GET_EVENT_LOG:
   3642                if ( pCBs->pfnGetEventLog )
   3643                {
   3644                  zclGetEventLog_t eventLog;
   3645          
   3646                  eventLog.logID = *pData++;
   3647                  eventLog.startTime = zcl_build_uint32( pData, 4 );
   3648                  pData += 4;
   3649                  eventLog.endTime = zcl_build_uint32( pData, 4 );
   3650                  pData += 4;
   3651                  eventLog.numEvents = *pData;
   3652          
   3653                  pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3654                                        &eventLog, pInMsg->hdr.transSeqNum );
   3655                }
   3656                break;
   3657          #endif // SE_UK_EXT
   3658          
   3659              default:
   3660                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3661                break;
   3662            }
   3663          
   3664            return ( stat );
   3665          }
   3666          #endif // ZCL_ALARMS
   3667          
   3668          #ifdef ZCL_LOCATION
   3669          /*********************************************************************
   3670           * @fn      zclGeneral_ProcessInLocationServer
   3671           *
   3672           * @brief   Process in the received Location Command.
   3673           *
   3674           * @param   pInMsg - pointer to the incoming message
   3675           *
   3676           * @return  ZStatus_t
   3677           */
   3678          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   3679                                                               zclGeneral_AppCallbacks_t *pCBs )
   3680          {
   3681            uint8 *pData = pInMsg->pData;
   3682            zclLocation_t cmd;
   3683            ZStatus_t stat = ZSuccess;
   3684          
   3685            zcl_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   3686          
   3687            switch ( pInMsg->hdr.commandID )
   3688            {
   3689              case COMMAND_LOCATION_SET_ABSOLUTE:
   3690                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3691                pData += 2;
   3692                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3693                pData += 2;
   3694                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3695                pData += 2;
   3696                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3697                pData += 2;
   3698                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3699          
   3700                if ( pCBs->pfnLocation )
   3701                {
   3702                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3703                  cmd.cmdID = pInMsg->hdr.commandID;
   3704          
   3705                  // Update the absolute location info
   3706                  pCBs->pfnLocation( &cmd );
   3707                }
   3708                break;
   3709          
   3710              case COMMAND_LOCATION_SET_DEV_CFG:
   3711                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   3712                pData += 2;
   3713                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3714                pData += 2;
   3715                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3716                pData += 2;
   3717                cmd.un.devCfg.numMeasurements = *pData++;
   3718                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3719          
   3720                if ( pCBs->pfnLocation )
   3721                {
   3722                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3723                  cmd.cmdID = pInMsg->hdr.commandID;
   3724          
   3725                  // Update the device configuration info
   3726                  pCBs->pfnLocation( &cmd );
   3727                }
   3728                break;
   3729          
   3730              case COMMAND_LOCATION_GET_DEV_CFG:
   3731                cmd.un.ieeeAddr = pData;
   3732          
   3733                if ( pCBs->pfnLocation )
   3734                {
   3735                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3736                  cmd.cmdID = pInMsg->hdr.commandID;
   3737                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3738          
   3739                  // Retreive the Device Configuration
   3740                  pCBs->pfnLocation( &cmd );
   3741                }
   3742                stat = ZCL_STATUS_CMD_HAS_RSP;
   3743                break;
   3744          
   3745              case COMMAND_LOCATION_GET_DATA:
   3746                cmd.un.loc.bitmap.locByte = *pData++;
   3747                cmd.un.loc.numResponses = *pData++;
   3748          
   3749                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   3750                  zcl_memcpy( cmd.un.loc.targetAddr, pData, 8 );
   3751          
   3752                if ( pCBs->pfnLocation )
   3753                {
   3754                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3755                  cmd.cmdID = pInMsg->hdr.commandID;
   3756                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3757          
   3758                  // Retreive the Location Data
   3759                  pCBs->pfnLocation( &cmd );
   3760                }
   3761                stat = ZCL_STATUS_CMD_HAS_RSP;
   3762                break;
   3763          
   3764              default:
   3765                stat = ZFailure;
   3766                break;
   3767            }
   3768          
   3769            return ( stat );
   3770          }
   3771          
   3772          /*********************************************************************
   3773           * @fn      zclGeneral_ProcessInLocationDataRsp
   3774           *
   3775           * @brief   Process in the received Location Command.
   3776           *
   3777           * @param   pInMsg - pointer to the incoming message
   3778           *
   3779           * @return  ZStatus_t
   3780           */
   3781          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   3782                                                           zclGeneral_AppCallbacks_t *pCBs )
   3783          {
   3784            uint8 *pData = pInMsg->pData;
   3785            zclLocationRsp_t rsp;
   3786          
   3787            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3788          
   3789            if ( pCBs->pfnLocationRsp )
   3790            {
   3791              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   3792                rsp.un.loc.status = *pData++;
   3793          
   3794              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   3795                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   3796              {
   3797                rsp.un.loc.data.type = *pData++;
   3798                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3799                pData += 2;
   3800                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3801                pData += 2;
   3802          
   3803                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   3804                {
   3805                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3806                  pData += 2;
   3807                }
   3808          
   3809                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3810                {
   3811                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3812                  pData += 2;
   3813                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3814                  pData += 2;
   3815                }
   3816          
   3817                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   3818                {
   3819                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3820                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   3821          
   3822                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   3823                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   3824                }
   3825              }
   3826          
   3827              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3828              rsp.cmdID = pInMsg->hdr.commandID;
   3829          
   3830              // Notify the Application
   3831              pCBs->pfnLocationRsp( &rsp );
   3832            }
   3833          }
   3834          
   3835          /*********************************************************************
   3836           * @fn      zclGeneral_ProcessInLocationClient
   3837           *
   3838           * @brief   Process in the received Location Command.
   3839           *
   3840           * @param   pInMsg - pointer to the incoming message
   3841           *
   3842           * @return  ZStatus_t
   3843           */
   3844          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   3845                                                               zclGeneral_AppCallbacks_t *pCBs )
   3846          {
   3847            uint8 *pData = pInMsg->pData;
   3848            zclLocationRsp_t rsp;
   3849            ZStatus_t stat = ZSuccess;
   3850          
   3851            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3852          
   3853            switch ( pInMsg->hdr.commandID )
   3854            {
   3855              case COMMAND_LOCATION_DEV_CFG_RSP:
   3856                if ( pCBs->pfnLocationRsp )
   3857                {
   3858                  rsp.un.devCfg.status = *pData++;
   3859                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   3860                  {
   3861                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   3862                    pData += 2;
   3863                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3864                    pData += 2;
   3865                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3866                    pData += 2;
   3867                    rsp.un.devCfg.data.numMeasurements = *pData++;
   3868                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3869          
   3870                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3871                    rsp.cmdID = pInMsg->hdr.commandID;
   3872          
   3873                    // Notify the Application
   3874                    pCBs->pfnLocationRsp( &rsp );
   3875                  }
   3876                }
   3877                break;
   3878          
   3879              case COMMAND_LOCATION_DATA_RSP:
   3880              case COMMAND_LOCATION_DATA_NOTIF:
   3881              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3882                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3883                break;
   3884          
   3885              case COMMAND_LOCATION_RSSI_PING:
   3886                if ( pCBs->pfnLocationRsp )
   3887                {
   3888                  rsp.un.locationType = *pData;
   3889          
   3890                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3891                  rsp.cmdID = pInMsg->hdr.commandID;
   3892          
   3893                  // Notify the Application
   3894                  pCBs->pfnLocationRsp( &rsp );
   3895                }
   3896                break;
   3897          
   3898              default:
   3899                stat = ZFailure;
   3900                break;
   3901            }
   3902          
   3903            return ( stat );
   3904          }
   3905          #endif // ZCL_LOCATION
   3906          
   3907          #ifdef ZCL_SCENES
   3908          #if !defined ( ZCL_STANDALONE )
   3909          /*********************************************************************
   3910           * @fn      zclGeneral_ScenesInitNV
   3911           *
   3912           * @brief   Initialize the NV Scene Table Items
   3913           *
   3914           * @param   none
   3915           *
   3916           * @return  number of scenes
   3917           */
   3918          static uint8 zclGeneral_ScenesInitNV( void )
   3919          {
   3920            uint8  status;
   3921            uint16 size;
   3922          
   3923            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3924                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3925          
   3926            status = zcl_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3927          
   3928            if ( status != ZSUCCESS )
   3929            {
   3930              zclGeneral_ScenesSetDefaultNV();
   3931            }
   3932          
   3933            return status;
   3934          }
   3935          #endif // ZCL_STANDALONE
   3936          
   3937          #if !defined ( ZCL_STANDALONE )
   3938          /*********************************************************************
   3939           * @fn          zclGeneral_ScenesSetDefaultNV
   3940           *
   3941           * @brief       Write the defaults to NV
   3942           *
   3943           * @param       none
   3944           *
   3945           * @return      none
   3946           */
   3947          static void zclGeneral_ScenesSetDefaultNV( void )
   3948          {
   3949            nvGenScenesHdr_t hdr;
   3950          
   3951            // Initialize the header
   3952            hdr.numRecs = 0;
   3953          
   3954            // Save off the header
   3955            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3956          }
   3957          #endif // ZCL_STANDALONE
   3958          
   3959          #if !defined ( ZCL_STANDALONE )
   3960          /*********************************************************************
   3961           * @fn          zclGeneral_ScenesWriteNV
   3962           *
   3963           * @brief       Save the Scene Table in NV
   3964           *
   3965           * @param       none
   3966           *
   3967           * @return      none
   3968           */
   3969          static void zclGeneral_ScenesWriteNV( void )
   3970          {
   3971            nvGenScenesHdr_t hdr;
   3972            zclGenSceneItem_t *pLoop;
   3973            zclGenSceneNVItem_t item;
   3974          
   3975            hdr.numRecs = 0;
   3976          
   3977            // Look for end of list
   3978            pLoop = zclGenSceneTable;
   3979            while ( pLoop )
   3980            {
   3981              // Build the record
   3982              item.endpoint = pLoop->endpoint;
   3983              zcl_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3984          
   3985              // Save the record to NV
   3986              zcl_nv_write( ZCD_NV_SCENE_TABLE,
   3987                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3988                              sizeof ( zclGenSceneNVItem_t ), &item );
   3989          
   3990              hdr.numRecs++;
   3991          
   3992              pLoop = pLoop->next;
   3993            }
   3994          
   3995            // Save off the header
   3996            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3997          }
   3998          #endif // ZCL_STANDALONE
   3999          
   4000          #if !defined ( ZCL_STANDALONE )
   4001          /*********************************************************************
   4002           * @fn          zclGeneral_ScenesRestoreFromNV
   4003           *
   4004           * @brief       Restore the Scene table from NV
   4005           *
   4006           * @param       none
   4007           *
   4008           * @return      Number of entries restored
   4009           */
   4010          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   4011          {
   4012            uint16 x;
   4013            nvGenScenesHdr_t hdr;
   4014          
   4015            zclGenSceneNVItem_t item;
   4016            uint16 numAdded = 0;
   4017          
   4018            if ( zcl_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   4019            {
   4020              // Read in the device list
   4021              for ( x = 0; x < hdr.numRecs; x++ )
   4022              {
   4023                if ( zcl_nv_read( ZCD_NV_SCENE_TABLE,
   4024                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   4025                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   4026                {
   4027                  // Add the scene
   4028                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   4029                  {
   4030                    numAdded++;
   4031                  }
   4032                }
   4033              }
   4034            }
   4035          
   4036            return ( numAdded );
   4037          }
   4038          #endif // ZCL_STANDALONE
   4039          
   4040          #if !defined ( ZCL_STANDALONE )
   4041          /*********************************************************************
   4042           * @fn          zclGeneral_ScenesInit
   4043           *
   4044           * @brief       Initialize the scenes table
   4045           *
   4046           * @param       none
   4047           *
   4048           * @return      none
   4049           */
   4050          void zclGeneral_ScenesInit( void )
   4051          {
   4052            // Initialize NV items
   4053            zclGeneral_ScenesInitNV();
   4054          
   4055            // Restore the Scene table
   4056            zclGeneral_ScenesRestoreFromNV();
   4057          }
   4058          #endif // ZCL_STANDALONE
   4059          
   4060          #if !defined ( ZCL_STANDALONE )
   4061          /*********************************************************************
   4062           * @fn          zclGeneral_ScenesSave
   4063           *
   4064           * @brief       Save the scenes table
   4065           *
   4066           * @param       none
   4067           *
   4068           * @return      none
   4069           */
   4070          void zclGeneral_ScenesSave( void )
   4071          {
   4072            // Update NV
   4073            zclGeneral_ScenesWriteNV();
   4074          }
   4075          #endif // ZCL_STANDALONE
   4076          
   4077          #endif // ZCL_SCENES
   4078          
   4079          /***************************************************************************
   4080          ****************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     94   zclGeneral_AddGroup
        0     16   -> aps_AddGroup
        0     19   -> osal_memcpy
        0     20   -> zcl_ReadAttrData
      0     10   zclGeneral_HdlInSpecificCommands
        0     10   -> zclGeneral_ProcessInGroupsClient
        0     10   -> zclGeneral_ProcessInGroupsServer
        0     10   -> zclGeneral_ProcessInIdentity
      2      0   zclGeneral_HdlIncoming
        2      0   -> zclGeneral_HdlInSpecificCommands
      1     63   zclGeneral_ProcessInGroupsClient
        0     50   -> osal_mem_alloc
        0     50   -> osal_mem_free
        0     53   -> osal_memcpy
        0     50   -> osal_memset
      1     91   zclGeneral_ProcessInGroupsServer
        0     74   -> aps_CountAllGroups
        0     74   -> aps_FindAllGroupsForEndpoint
        0     74   -> aps_FindGroup
        0     74   -> aps_RemoveAllGroup
        0     74   -> aps_RemoveGroup
        0     74   -> osal_mem_alloc
        0     74   -> osal_mem_free
        0     74   -> osal_memset
        0     74   -> zclGeneral_AddGroup
        0     81   -> zclGeneral_SendGroupGetMembershipRequest
        0     78   -> zclGeneral_SendGroupResponse
        0     77   -> zclGeneral_SendGroupViewResponse
        0     78   -> zcl_ReadAttrData
        0     81   -> zcl_SendDefaultRspCmd
      0     32   zclGeneral_ProcessInIdentity
        0     18   -> bdb_ZclIdentifyCmdInd
        0     18   -> bdb_ZclIdentifyQueryCmdInd
        0     20   -> zclGeneral_SendIdentifyQueryResponse
        0     22   -> zcl_ReadAttrData
      1     14   zclGeneral_RegisterCmdCallbacks
        0     12   -> osal_mem_alloc
        0     14   -> zcl_registerPlugin
      1     37   zclGeneral_SendAddGroupRequest
        0     21   -> osal_mem_alloc
        0     21   -> osal_mem_free
        0     24   -> osal_memcpy
        0     32   -> zcl_SendCommand
      1    112   zclGeneral_SendGroupGetMembershipRequest
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     28   zclGeneral_SendGroupRequest
        0     25   -> zcl_SendCommand
      1    104   zclGeneral_SendGroupResponse
        0     26   -> zcl_SendCommand
      1    110   zclGeneral_SendGroupViewResponse
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     25   -> osal_memcpy
        0     33   -> zcl_SendCommand
      1     25   zclGeneral_SendIdentify
        0     23   -> zcl_SendCommand
      1     25   zclGeneral_SendIdentifyEZModeInvoke
        0     24   -> zcl_SendCommand
      1     43   zclGeneral_SendIdentifyQueryResponse
        0     23   -> zcl_SendCommand
      1     27   zclGeneral_SendIdentifyUpdateCommState
        0     25   -> zcl_SendCommand


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ??Subroutine37_0
      12  ??Subroutine38_0
       5  ??Subroutine39_0
       1  ??Subroutine40_0
       6  ??Subroutine41_0
      10  ??Subroutine42_0
       3  ??Subroutine43_0
       5  ??Subroutine44_0
       4  ??Subroutine45_0
       6  ??Subroutine46_0
       4  ??Subroutine47_0
       4  ??Subroutine48_0
       7  ??Subroutine49_0
       5  ??Subroutine50_0
       5  ??Subroutine51_0
       8  ?Subroutine0
      24  ?Subroutine1
       1  ?Subroutine10
       6  ?Subroutine11
       6  ?Subroutine12
       6  ?Subroutine13
      13  ?Subroutine14
       6  ?Subroutine15
       6  ?Subroutine16
       6  ?Subroutine17
       9  ?Subroutine18
      13  ?Subroutine19
       3  ?Subroutine2
       1  ?Subroutine20
       4  ?Subroutine21
       2  ?Subroutine22
      13  ?Subroutine23
       1  ?Subroutine24
      10  ?Subroutine25
       9  ?Subroutine26
       7  ?Subroutine27
      12  ?Subroutine28
       4  ?Subroutine29
       5  ?Subroutine3
      15  ?Subroutine30
      10  ?Subroutine31
       5  ?Subroutine32
       8  ?Subroutine33
       6  ?Subroutine34
       6  ?Subroutine35
      10  ?Subroutine36
      23  ?Subroutine4
      24  ?Subroutine5
       6  ?Subroutine6
      15  ?Subroutine7
       7  ?Subroutine8
       8  ?Subroutine9
       2  zclGenCBs
       1  zclGenPluginRegisted
     163  zclGeneral_AddGroup
     173  zclGeneral_HdlInSpecificCommands
      33  zclGeneral_HdlIncoming
     477  zclGeneral_ProcessInGroupsClient
     733  zclGeneral_ProcessInGroupsServer
     296  zclGeneral_ProcessInIdentity
     147  zclGeneral_RegisterCmdCallbacks
     213  zclGeneral_SendAddGroupRequest
     263  zclGeneral_SendGroupGetMembershipRequest
     109  zclGeneral_SendGroupRequest
     121  zclGeneral_SendGroupResponse
     252  zclGeneral_SendGroupViewResponse
      83  zclGeneral_SendIdentify
      98  zclGeneral_SendIdentifyEZModeInvoke
      83  zclGeneral_SendIdentifyQueryResponse
     106  zclGeneral_SendIdentifyUpdateCommState
      96  -- Other

 
 3 750 bytes in segment BANKED_CODE
    96 bytes in segment BANK_RELAYS
     3 bytes in segment XDATA_Z
 
    96 bytes of CODE     memory
 3 750 bytes of HUGECODE memory
     3 bytes of XDATA    memory

Errors: none
Warnings: 1
