###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               05/Aug/2020  22:51:09
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack 3.0.2\Components\osal\common\OSAL_Memory.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EW4540.tmp ("D:\AA\Z-Stack
#        3.0.2\Components\osal\common\OSAL_Memory.c" -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D POWER_SAVING -D
#        NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC
#        -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_GROUPS -D BDB_TL_INITIATOR -D INTER_PAN -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=0
#        -DQUEUED_POLL_RATE=0 -DRESPONSE_POLL_RATE=0 -DREJOIN_POLL_RATE=0
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\" -I
#        "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -On --require_prototypes --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_cross_call)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List\OSAL_Memory.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj\OSAL_Memory.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Components\osal\common\OSAL_Memory.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Memory.c
      3            Revised:        $Date: 2014-11-24 18:26:24 -0800 (Mon, 24 Nov 2014) $
      4            Revision:       $Revision: 41234 $
      5          
      6            Description:    OSAL Heap Memory management functions. There is an Application Note that
      7                            should be read before studying and/or modifying this module:
      8                            SWRA204 "Heap Memory Management"
      9          
     10            Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /* ------------------------------------------------------------------------------------------------
     42           *                                          Includes
     43           * ------------------------------------------------------------------------------------------------
     44           */
     45          
     46          #include <stdlib.h>
     47          
     48          #include "comdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Memory.h"
     51          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     52          #include "hal_mcu.h"
     53          #include "hal_assert.h"
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                           Constants
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          
     60          #define OSALMEM_IN_USE             0x8000
     61          #if (MAXMEMHEAP & OSALMEM_IN_USE)
     62          #error MAXMEMHEAP is too big to manage!
     63          #endif
     64          
     65          #define OSALMEM_HDRSZ              sizeof(osalMemHdr_t)
     66          
     67          // Round a value up to the ceiling of OSALMEM_HDRSZ for critical dependencies on even multiples.
     68          #define OSALMEM_ROUND(X)       ((((X) + OSALMEM_HDRSZ - 1) / OSALMEM_HDRSZ) * OSALMEM_HDRSZ)
     69          
     70          /* Minimum wasted bytes to justify splitting a block before allocation.
     71           * Adjust accordingly to attempt to balance the tradeoff of wasted space and runtime throughput
     72           * spent splitting blocks into sizes that may not be practically usable when sandwiched between
     73           * two blocks in use (and thereby not able to be coalesced.)
     74           * Ensure that this size is an even multiple of OSALMEM_HDRSZ.
     75           */
     76          #if !defined OSALMEM_MIN_BLKSZ
     77          #define OSALMEM_MIN_BLKSZ         (OSALMEM_ROUND((OSALMEM_HDRSZ * 2)))
     78          #endif
     79          
     80          #if !defined OSALMEM_LL_BLKSZ
     81          #if defined NONWK
     82          #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(6) + (1 * OSALMEM_HDRSZ))
     83          #else
     84          /*
     85           * Profiling the sample apps with default settings shows the following long-lived allocations
     86           * which should live at the bottom of the small-block bucket so that they are never iterated over
     87           * by osal_mem_alloc/free(), nor ever considered for coalescing, etc. This saves significant
     88           * run-time throughput (on 8051 SOC if not also MSP). This is dynamic "dead space" and is not
     89           * available to the small-block bucket heap.
     90           *
     91           * Adjust this size accordingly to accomodate application-specific changes including changing the
     92           * size of long-lived objects profiled by sample apps and long-lived objects added by application.
     93           */
     94          #if defined ZCL_KEY_ESTABLISH_OLD // CBKE no longer uses long lived memory allocations.
     95          #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(526) + (32 * OSALMEM_HDRSZ))
     96          #elif defined TC_LINKKEY_JOIN
     97          #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(454) + (21 * OSALMEM_HDRSZ))
     98          #elif ((defined SECURE) && (SECURE != 0))
     99          #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(418) + (19 * OSALMEM_HDRSZ))
    100          #else
    101          #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(417) + (19 * OSALMEM_HDRSZ))
    102          #endif
    103          #endif
    104          #endif
    105          
    106          /* Adjust accordingly to attempt to accomodate the block sizes of the vast majority of
    107           * very high frequency allocations/frees by profiling the system runtime.
    108           * This default of 16 accomodates the OSAL timers block, osalTimerRec_t, and many others.
    109           * Ensure that this size is an even multiple of OSALMEM_MIN_BLKSZ for run-time efficiency.
    110           */
    111          #if !defined OSALMEM_SMALL_BLKSZ
    112          #define OSALMEM_SMALL_BLKSZ       (OSALMEM_ROUND(16))
    113          #endif
    114          #if !defined OSALMEM_SMALL_BLKCNT
    115          #define OSALMEM_SMALL_BLKCNT       8
    116          #endif
    117          
    118          /*
    119           * These numbers setup the size of the small-block bucket which is reserved at the front of the
    120           * heap for allocations of OSALMEM_SMALL_BLKSZ or smaller.
    121           */
    122          
    123          // Size of the heap bucket reserved for small block-sized allocations.
    124          // Adjust accordingly to attempt to accomodate the vast majority of very high frequency operations.
    125          #define OSALMEM_SMALLBLK_BUCKET  ((OSALMEM_SMALL_BLKSZ * OSALMEM_SMALL_BLKCNT) + OSALMEM_LL_BLKSZ)
    126          // Index of the first available osalMemHdr_t after the small-block heap which will be set in-use in
    127          // order to prevent the small-block bucket from being coalesced with the wilderness.
    128          #define OSALMEM_SMALLBLK_HDRCNT   (OSALMEM_SMALLBLK_BUCKET / OSALMEM_HDRSZ)
    129          // Index of the first available osalMemHdr_t after the small-block heap which will be set in-use in
    130          #define OSALMEM_BIGBLK_IDX        (OSALMEM_SMALLBLK_HDRCNT + 1)
    131          // The size of the wilderness after losing the small-block heap, the wasted header to block the
    132          // small-block heap from being coalesced, and the wasted header to mark the end of the heap.
    133          #define OSALMEM_BIGBLK_SZ         (MAXMEMHEAP - OSALMEM_SMALLBLK_BUCKET - OSALMEM_HDRSZ*2)
    134          // Index of the last available osalMemHdr_t at the end of the heap which will be set to zero for
    135          // fast comparisons with zero to determine the end of the heap.
    136          #define OSALMEM_LASTBLK_IDX      ((MAXMEMHEAP / OSALMEM_HDRSZ) - 1)
    137          
    138          // For information about memory profiling, refer to SWRA204 "Heap Memory Management", section 1.5.
    139          #if !defined OSALMEM_PROFILER
    140          #define OSALMEM_PROFILER           FALSE  // Enable/disable the memory usage profiling buckets.
    141          #endif
    142          #if !defined OSALMEM_PROFILER_LL
    143          #define OSALMEM_PROFILER_LL        FALSE  // Special profiling of the Long-Lived bucket.
    144          #endif
    145          
    146          #if OSALMEM_PROFILER
    147          #define OSALMEM_INIT              'X'
    148          #define OSALMEM_ALOC              'A'
    149          #define OSALMEM_REIN              'F'
    150          #endif
    151          
    152          /* ------------------------------------------------------------------------------------------------
    153           *                                           Typedefs
    154           * ------------------------------------------------------------------------------------------------
    155           */
    156          
    157          typedef struct {
    158            // The 15 LSB's of 'val' indicate the total item size, including the header, in 8-bit bytes.
    159            unsigned len : 15;
    160            // The 1 MSB of 'val' is used as a boolean to indicate in-use or freed.
    161            unsigned inUse : 1;
    162          } osalMemHdrHdr_t;
    163          
    164          typedef union {
    165            /* Dummy variable so compiler forces structure to alignment of largest element while not wasting
    166             * space on targets when the halDataAlign_t is smaller than a UINT16.
    167             */
    168            halDataAlign_t alignDummy;
    169            uint16 val;
    170            osalMemHdrHdr_t hdr;
    171          } osalMemHdr_t;
    172          
    173          /* ------------------------------------------------------------------------------------------------
    174           *                                           Local Variables
    175           * ------------------------------------------------------------------------------------------------
    176           */
    177          
    178          #if !defined ( ZBIT ) && defined ewarm
    179          static __no_init osalMemHdr_t theHeap[MAXMEMHEAP / OSALMEM_HDRSZ];
    180          static __no_init osalMemHdr_t *ff1;  // First free block in the small-block bucket.
    181          #else

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    182          static osalMemHdr_t theHeap[MAXMEMHEAP / OSALMEM_HDRSZ];
   \                     theHeap:
   \   000000                DS 2048
   \   000800                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          static osalMemHdr_t *ff1;  // First free block in the small-block bucket.
   \                     ff1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    184          #endif
    185          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    186          static uint8 osalMemStat;            // Discrete status flags: 0x01 = kicked.
   \                     osalMemStat:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    187          
    188          #if OSALMEM_METRICS
    189          static uint16 blkMax;  // Max cnt of all blocks ever seen at once.
    190          static uint16 blkCnt;  // Current cnt of all blocks.
    191          static uint16 blkFree; // Current cnt of free blocks.
    192          static uint16 memAlo;  // Current total memory allocated.
    193          static uint16 memMax;  // Max total memory ever allocated at once.
    194          #endif
    195          
    196          #if OSALMEM_PROFILER
    197          #define OSALMEM_PROMAX  8
    198          /* The profiling buckets must differ by at least OSALMEM_MIN_BLKSZ; the
    199           * last bucket must equal the max alloc size. Set the bucket sizes to
    200           * whatever sizes necessary to show how your application is using memory.
    201           */
    202          static uint16 proCnt[OSALMEM_PROMAX] = {
    203          OSALMEM_SMALL_BLKSZ, 48, 112, 176, 192, 224, 256, 65535 };
    204          static uint16 proCur[OSALMEM_PROMAX] = { 0 };
    205          static uint16 proMax[OSALMEM_PROMAX] = { 0 };
    206          static uint16 proTot[OSALMEM_PROMAX] = { 0 };
    207          static uint16 proSmallBlkMiss;
    208          #endif
    209          
    210          /* ------------------------------------------------------------------------------------------------
    211           *                                           Global Variables
    212           * ------------------------------------------------------------------------------------------------
    213           */
    214          
    215          #ifdef DPRINTF_HEAPTRACE
    216          extern int dprintf(const char *fmt, ...);
    217          #endif /* DPRINTF_HEAPTRACE */
    218          
    219          /**************************************************************************************************
    220           * @fn          osal_mem_init
    221           *
    222           * @brief       This function is the OSAL heap memory management initialization callback.
    223           *
    224           * input parameters
    225           *
    226           * None.
    227           *
    228           * output parameters
    229           *
    230           * None.
    231           *
    232           * @return      None.
    233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    234          void osal_mem_init(void)
   \                     osal_mem_init:
    235          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    236            HAL_ASSERT(((OSALMEM_MIN_BLKSZ % OSALMEM_HDRSZ) == 0));
    237            HAL_ASSERT(((OSALMEM_LL_BLKSZ % OSALMEM_HDRSZ) == 0));
    238            HAL_ASSERT(((OSALMEM_SMALL_BLKSZ % OSALMEM_HDRSZ) == 0));
    239          
    240          #if OSALMEM_PROFILER
    241            (void)osal_memset(theHeap, OSALMEM_INIT, MAXMEMHEAP);
    242          #endif
    243          
    244            // Setup a NULL block at the end of the heap for fast comparisons with zero.
    245            theHeap[OSALMEM_LASTBLK_IDX].val = 0;
   \   000004   90....       MOV       DPTR,#theHeap + 2046
   \   000007   7400         MOV       A,#0x0
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   A3           INC       DPTR
   \   00000B   7400         MOV       A,#0x0
   \   00000D   F0           MOVX      @DPTR,A
    246          
    247            // Setup the small-block bucket.
    248            ff1 = theHeap;
   \   00000E   90....       MOV       DPTR,#ff1
   \   000011   74..         MOV       A,#theHeap & 0xff
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   74..         MOV       A,#(theHeap >> 8) & 0xff
   \   000017   F0           MOVX      @DPTR,A
    249            ff1->val = OSALMEM_SMALLBLK_BUCKET;                   // Set 'len' & clear 'inUse' field.
   \   000018   90....       MOV       DPTR,#ff1
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F8           MOV       R0,A
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F583         MOV       DPH,A
   \   000021   8882         MOV       DPL,R0
   \   000023   7470         MOV       A,#0x70
   \   000025   F0           MOVX      @DPTR,A
   \   000026   A3           INC       DPTR
   \   000027   7402         MOV       A,#0x2
   \   000029   F0           MOVX      @DPTR,A
    250            // Set 'len' & 'inUse' fields - this is a 'zero data bytes' lifetime allocation to block the
    251            // small-block bucket from ever being coalesced with the wilderness.
    252            theHeap[OSALMEM_SMALLBLK_HDRCNT].val = (OSALMEM_HDRSZ | OSALMEM_IN_USE);
   \   00002A   90....       MOV       DPTR,#theHeap + 624
   \   00002D   7402         MOV       A,#0x2
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   7480         MOV       A,#-0x80
   \   000033   F0           MOVX      @DPTR,A
    253          
    254            // Setup the wilderness.
    255            theHeap[OSALMEM_BIGBLK_IDX].val = OSALMEM_BIGBLK_SZ;  // Set 'len' & clear 'inUse' field.
   \   000034   90....       MOV       DPTR,#theHeap + 626
   \   000037   748C         MOV       A,#-0x74
   \   000039   F0           MOVX      @DPTR,A
   \   00003A   A3           INC       DPTR
   \   00003B   7405         MOV       A,#0x5
   \   00003D   F0           MOVX      @DPTR,A
    256          
    257          #if ( OSALMEM_METRICS )
    258            /* Start with the small-block bucket and the wilderness - don't count the
    259             * end-of-heap NULL block nor the end-of-small-block NULL block.
    260             */
    261            blkCnt = blkFree = 2;
    262          #endif
    263          }
   \   00003E   D083         POP       DPH
   \   000040   D082         POP       DPL
   \   000042   02....       LJMP      ?BRET
    264          
    265          /**************************************************************************************************
    266           * @fn          osal_mem_kick
    267           *
    268           * @brief       This function is the OSAL task initialization callback.
    269           * @brief       Kick the ff1 pointer out past the long-lived OSAL Task blocks.
    270           *              Invoke this once after all long-lived blocks have been allocated -
    271           *              presently at the end of osal_init_system().
    272           *
    273           * input parameters
    274           *
    275           * None.
    276           *
    277           * output parameters
    278           *
    279           * None.
    280           *
    281           * @return      None.
    282           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    283          void osal_mem_kick(void)
   \                     osal_mem_kick:
    284          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    285            halIntState_t intState;
    286            osalMemHdr_t *tmp = osal_mem_alloc(1);
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A01         MOV       R2,#0x1
   \   000007   7B00         MOV       R3,#0x0
   \   000009   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000C   8A..         MOV       ?V2,R2
   \   00000E   8B..         MOV       ?V3,R3
   \   000010   AE..         MOV       R6,?V2
   \   000012   AF..         MOV       R7,?V3
    287          
    288            HAL_ASSERT((tmp != NULL));
   \   000014   EE           MOV       A,R6
   \   000015   4F           ORL       A,R7
   \   000016   7003         JNZ       ??osal_mem_kick_0
   \   000018                ; Setup parameters for call to function halAssertHandler
   \   000018   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    289            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \                     ??osal_mem_kick_0:
   \   00001B   A2AF         MOV       C,0xa8.7
   \   00001D   E4           CLR       A
   \   00001E   33           RLC       A
   \   00001F   F5..         MOV       ?V0,A
   \   000021   C2AF         CLR       0xa8.7
    290          
    291            /* All long-lived allocations have filled the LL block reserved in the small-block bucket.
    292             * Set 'osalMemStat' so searching for memory in this bucket from here onward will only be done
    293             * for sizes meeting the OSALMEM_SMALL_BLKSZ criteria.
    294             */
    295            ff1 = tmp - 1;       // Set 'ff1' to point to the first available memory after the LL block.
   \   000023   EE           MOV       A,R6
   \   000024   24FE         ADD       A,#-0x2
   \   000026   F8           MOV       R0,A
   \   000027   EF           MOV       A,R7
   \   000028   34FF         ADDC      A,#-0x1
   \   00002A   F9           MOV       R1,A
   \   00002B   90....       MOV       DPTR,#ff1
   \   00002E   E8           MOV       A,R0
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   E9           MOV       A,R1
   \   000032   F0           MOVX      @DPTR,A
    296            osal_mem_free(tmp);
   \   000033                ; Setup parameters for call to function osal_mem_free
   \   000033   EE           MOV       A,R6
   \   000034   FA           MOV       R2,A
   \   000035   EF           MOV       A,R7
   \   000036   FB           MOV       R3,A
   \   000037   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    297            osalMemStat = 0x01;  // Set 'osalMemStat' after the free because it enables memory profiling.
   \   00003A   90....       MOV       DPTR,#osalMemStat
   \   00003D   7401         MOV       A,#0x1
   \   00003F   F0           MOVX      @DPTR,A
    298          
    299            HAL_EXIT_CRITICAL_SECTION(intState);  // Re-enable interrupts.
   \   000040   E5..         MOV       A,?V0
   \   000042   A2E0         MOV       C,0xE0 /* A   */.0
   \   000044   92AF         MOV       0xa8.7,C
    300          }
   \   000046   7F04         MOV       R7,#0x4
   \   000048   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   00004B                REQUIRE _A_IEN0
    301          
    302          /**************************************************************************************************
    303           * @fn          osal_mem_alloc
    304           *
    305           * @brief       This function implements the OSAL dynamic memory allocation functionality.
    306           *
    307           * input parameters
    308           *
    309           * @param size - the number of bytes to allocate from the HEAP.
    310           *
    311           * output parameters
    312           *
    313           * None.
    314           *
    315           * @return      None.
    316           */
    317          #ifdef DPRINTF_OSALHEAPTRACE
    318          void *osal_mem_alloc_dbg( uint16 size, const char *fname, unsigned lnum )
    319          #else /* DPRINTF_OSALHEAPTRACE */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    320          void *osal_mem_alloc( uint16 size )
   \                     osal_mem_alloc:
    321          #endif /* DPRINTF_OSALHEAPTRACE */
    322          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   F8           MOV       R0,A
   \   000007   EB           MOV       A,R3
   \   000008   F9           MOV       R1,A
    323            osalMemHdr_t *prev = NULL;
   \   000009   7E00         MOV       R6,#0x0
   \   00000B   7F00         MOV       R7,#0x0
    324            osalMemHdr_t *hdr;
    325            halIntState_t intState;
    326            uint8 coal = 0;
   \   00000D   7C00         MOV       R4,#0x0
    327          
    328            size += OSALMEM_HDRSZ;
   \   00000F   E8           MOV       A,R0
   \   000010   2402         ADD       A,#0x2
   \   000012   F8           MOV       R0,A
   \   000013   E9           MOV       A,R1
   \   000014   3400         ADDC      A,#0x0
   \   000016   F9           MOV       R1,A
    329          
    330            // Calculate required bytes to add to 'size' to align to halDataAlign_t.
    331            if ( sizeof( halDataAlign_t ) == 2 )
    332            {
    333              size += (size & 0x01);
    334            }
    335            else if ( sizeof( halDataAlign_t ) != 1 )
    336            {
    337              const uint8 mod = size % sizeof( halDataAlign_t );
    338          
    339              if ( mod != 0 )
    340              {
    341                size += (sizeof( halDataAlign_t ) - mod);
    342              }
    343            }
    344          
    345            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000017   A2AF         MOV       C,0xa8.7
   \   000019   E4           CLR       A
   \   00001A   33           RLC       A
   \   00001B   FD           MOV       R5,A
   \   00001C   C2AF         CLR       0xa8.7
    346          
    347            // Smaller allocations are first attempted in the small-block bucket, and all long-lived
    348            // allocations are channeled into the LL block reserved within this bucket.
    349            if ((osalMemStat == 0) || (size <= OSALMEM_SMALL_BLKSZ))
   \   00001E   90....       MOV       DPTR,#osalMemStat
   \   000021   E0           MOVX      A,@DPTR
   \   000022   6009         JZ        ??osal_mem_alloc_0
   \   000024   C3           CLR       C
   \   000025   E8           MOV       A,R0
   \   000026   9411         SUBB      A,#0x11
   \   000028   E9           MOV       A,R1
   \   000029   9400         SUBB      A,#0x0
   \   00002B   5010         JNC       ??osal_mem_alloc_1
    350            {
    351              hdr = ff1;
   \                     ??osal_mem_alloc_0:
   \   00002D   90....       MOV       DPTR,#ff1
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F5..         MOV       ?V0,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F5..         MOV       ?V1,A
   \   000037   AA..         MOV       R2,?V0
   \   000039   AB..         MOV       R3,?V1
   \   00003B   8004         SJMP      ??osal_mem_alloc_2
    352            }
    353            else
    354            {
    355              hdr = (theHeap + OSALMEM_BIGBLK_IDX);
   \                     ??osal_mem_alloc_1:
   \   00003D   7A..         MOV       R2,#(theHeap + 114) & 0xff
   \   00003F   7B..         MOV       R3,#((theHeap + 626) >> 8) & 0xff
    356            }
    357          
    358            do
    359            {
    360              if ( hdr->hdr.inUse )
   \                     ??osal_mem_alloc_2:
   \   000041   8A82         MOV       DPL,R2
   \   000043   8B83         MOV       DPH,R3
   \   000045   E0           MOVX      A,@DPTR
   \   000046   5400         ANL       A,#0x0
   \   000048   F5..         MOV       ?V0,A
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   5480         ANL       A,#0x80
   \   00004E   F5..         MOV       ?V1,A
   \   000050   E5..         MOV       A,?V0
   \   000052   45..         ORL       A,?V1
   \   000054   6005         JZ        ??osal_mem_alloc_3
    361              {
    362                coal = 0;
   \   000056   7C00         MOV       R4,#0x0
   \   000058   02....       LJMP      ??osal_mem_alloc_4 & 0xFFFF
    363              }
    364              else
    365              {
    366                if ( coal != 0 )
   \                     ??osal_mem_alloc_3:
   \   00005B   EC           MOV       A,R4
   \   00005C   6067         JZ        ??osal_mem_alloc_5
    367                {
    368          #if ( OSALMEM_METRICS )
    369                  blkCnt--;
    370                  blkFree--;
    371          #endif
    372          
    373                  prev->hdr.len += hdr->hdr.len;
   \   00005E   8E82         MOV       DPL,R6
   \   000060   8F83         MOV       DPH,R7
   \   000062   E0           MOVX      A,@DPTR
   \   000063   F5..         MOV       ?V0,A
   \   000065   A3           INC       DPTR
   \   000066   E0           MOVX      A,@DPTR
   \   000067   F5..         MOV       ?V1,A
   \   000069   E5..         MOV       A,?V0
   \   00006B   5400         ANL       A,#0x0
   \   00006D   F5..         MOV       ?V2,A
   \   00006F   E5..         MOV       A,?V1
   \   000071   5480         ANL       A,#0x80
   \   000073   F5..         MOV       ?V3,A
   \   000075   8A82         MOV       DPL,R2
   \   000077   8B83         MOV       DPH,R3
   \   000079   E0           MOVX      A,@DPTR
   \   00007A   25..         ADD       A,?V0
   \   00007C   F5..         MOV       ?V0,A
   \   00007E   A3           INC       DPTR
   \   00007F   E0           MOVX      A,@DPTR
   \   000080   35..         ADDC      A,?V1
   \   000082   F5..         MOV       ?V1,A
   \   000084   E5..         MOV       A,?V0
   \   000086   54FF         ANL       A,#0xff
   \   000088   F5..         MOV       ?V0,A
   \   00008A   E5..         MOV       A,?V1
   \   00008C   547F         ANL       A,#0x7f
   \   00008E   F5..         MOV       ?V1,A
   \   000090   E5..         MOV       A,?V2
   \   000092   45..         ORL       A,?V0
   \   000094   F5..         MOV       ?V0,A
   \   000096   E5..         MOV       A,?V3
   \   000098   45..         ORL       A,?V1
   \   00009A   F5..         MOV       ?V1,A
   \   00009C   8E82         MOV       DPL,R6
   \   00009E   8F83         MOV       DPH,R7
   \   0000A0   E5..         MOV       A,?V0
   \   0000A2   F0           MOVX      @DPTR,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   E5..         MOV       A,?V1
   \   0000A6   F0           MOVX      @DPTR,A
    374          
    375                  if ( prev->hdr.len >= size )
   \   0000A7   8E82         MOV       DPL,R6
   \   0000A9   8F83         MOV       DPH,R7
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   54FF         ANL       A,#0xff
   \   0000AE   F5..         MOV       ?V0,A
   \   0000B0   A3           INC       DPTR
   \   0000B1   E0           MOVX      A,@DPTR
   \   0000B2   547F         ANL       A,#0x7f
   \   0000B4   F5..         MOV       ?V1,A
   \   0000B6   C3           CLR       C
   \   0000B7   E5..         MOV       A,?V0
   \   0000B9   98           SUBB      A,R0
   \   0000BA   E5..         MOV       A,?V1
   \   0000BC   99           SUBB      A,R1
   \   0000BD   4024         JC        ??osal_mem_alloc_4
    376                  {
    377                    hdr = prev;
   \   0000BF   EE           MOV       A,R6
   \   0000C0   FA           MOV       R2,A
   \   0000C1   EF           MOV       A,R7
   \   0000C2   FB           MOV       R3,A
    378                    break;
   \   0000C3   804F         SJMP      ??osal_mem_alloc_6
    379                  }
    380                }
    381                else
    382                {
    383                  if ( hdr->hdr.len >= size )
   \                     ??osal_mem_alloc_5:
   \   0000C5   8A82         MOV       DPL,R2
   \   0000C7   8B83         MOV       DPH,R3
   \   0000C9   E0           MOVX      A,@DPTR
   \   0000CA   54FF         ANL       A,#0xff
   \   0000CC   F5..         MOV       ?V0,A
   \   0000CE   A3           INC       DPTR
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   547F         ANL       A,#0x7f
   \   0000D2   F5..         MOV       ?V1,A
   \   0000D4   C3           CLR       C
   \   0000D5   E5..         MOV       A,?V0
   \   0000D7   98           SUBB      A,R0
   \   0000D8   E5..         MOV       A,?V1
   \   0000DA   99           SUBB      A,R1
   \   0000DB   5037         JNC       ??osal_mem_alloc_6
    384                  {
    385                    break;
    386                  }
    387          
    388                  coal = 1;
   \   0000DD   7C01         MOV       R4,#0x1
    389                  prev = hdr;
   \   0000DF   EA           MOV       A,R2
   \   0000E0   FE           MOV       R6,A
   \   0000E1   EB           MOV       A,R3
   \   0000E2   FF           MOV       R7,A
    390                }
    391              }
    392          
    393              hdr = (osalMemHdr_t *)((uint8 *)hdr + hdr->hdr.len);
   \                     ??osal_mem_alloc_4:
   \   0000E3   8A82         MOV       DPL,R2
   \   0000E5   8B83         MOV       DPH,R3
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   54FF         ANL       A,#0xff
   \   0000EA   F5..         MOV       ?V0,A
   \   0000EC   A3           INC       DPTR
   \   0000ED   E0           MOVX      A,@DPTR
   \   0000EE   547F         ANL       A,#0x7f
   \   0000F0   F5..         MOV       ?V1,A
   \   0000F2   EA           MOV       A,R2
   \   0000F3   25..         ADD       A,?V0
   \   0000F5   FA           MOV       R2,A
   \   0000F6   EB           MOV       A,R3
   \   0000F7   35..         ADDC      A,?V1
   \   0000F9   FB           MOV       R3,A
    394          
    395              if ( hdr->val == 0 )
   \   0000FA   8A82         MOV       DPL,R2
   \   0000FC   8B83         MOV       DPH,R3
   \   0000FE   E0           MOVX      A,@DPTR
   \   0000FF   F5..         MOV       ?V0,A
   \   000101   A3           INC       DPTR
   \   000102   E0           MOVX      A,@DPTR
   \   000103   F5..         MOV       ?V1,A
   \   000105   E5..         MOV       A,?V0
   \   000107   45..         ORL       A,?V1
   \   000109   7006         JNZ       ??osal_mem_alloc_7
    396              {
    397                hdr = NULL;
   \   00010B   7A00         MOV       R2,#0x0
   \   00010D   7B00         MOV       R3,#0x0
    398                break;
   \   00010F   8003         SJMP      ??osal_mem_alloc_6
    399              }
    400            } while (1);
   \                     ??osal_mem_alloc_7:
   \   000111   02....       LJMP      ??osal_mem_alloc_2 & 0xFFFF
    401          
    402            if ( hdr != NULL )
   \                     ??osal_mem_alloc_6:
   \   000114   EA           MOV       A,R2
   \   000115   4B           ORL       A,R3
   \   000116   7003         JNZ       $+5
   \   000118   02....       LJMP      ??osal_mem_alloc_8 & 0xFFFF
    403            {
    404              uint16 tmp = hdr->hdr.len - size;
   \   00011B   8A82         MOV       DPL,R2
   \   00011D   8B83         MOV       DPH,R3
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   54FF         ANL       A,#0xff
   \   000122   F5..         MOV       ?V0,A
   \   000124   A3           INC       DPTR
   \   000125   E0           MOVX      A,@DPTR
   \   000126   547F         ANL       A,#0x7f
   \   000128   F5..         MOV       ?V1,A
   \   00012A   E5..         MOV       A,?V0
   \   00012C   C3           CLR       C
   \   00012D   98           SUBB      A,R0
   \   00012E   F5..         MOV       ?V2,A
   \   000130   E5..         MOV       A,?V1
   \   000132   99           SUBB      A,R1
   \   000133   F5..         MOV       ?V3,A
    405          
    406              // Determine whether the threshold for splitting is met.
    407              if ( tmp >= OSALMEM_MIN_BLKSZ )
   \   000135   C3           CLR       C
   \   000136   E5..         MOV       A,?V2
   \   000138   9404         SUBB      A,#0x4
   \   00013A   E5..         MOV       A,?V3
   \   00013C   9400         SUBB      A,#0x0
   \   00013E   402C         JC        ??osal_mem_alloc_9
    408              {
    409                // Split the block before allocating it.
    410                osalMemHdr_t *next = (osalMemHdr_t *)((uint8 *)hdr + size);
   \   000140   EA           MOV       A,R2
   \   000141   28           ADD       A,R0
   \   000142   F5..         MOV       ?V0,A
   \   000144   EB           MOV       A,R3
   \   000145   39           ADDC      A,R1
   \   000146   F5..         MOV       ?V1,A
    411                next->val = tmp;                     // Set 'len' & clear 'inUse' field.
   \   000148   85..82       MOV       DPL,?V0
   \   00014B   85..83       MOV       DPH,?V1
   \   00014E   E5..         MOV       A,?V2
   \   000150   F0           MOVX      @DPTR,A
   \   000151   A3           INC       DPTR
   \   000152   E5..         MOV       A,?V3
   \   000154   F0           MOVX      @DPTR,A
    412                hdr->val = (size | OSALMEM_IN_USE);  // Set 'len' & 'inUse' field.
   \   000155   E8           MOV       A,R0
   \   000156   4400         ORL       A,#0x0
   \   000158   F5..         MOV       ?V4,A
   \   00015A   E9           MOV       A,R1
   \   00015B   4480         ORL       A,#0x80
   \   00015D   F5..         MOV       ?V5,A
   \   00015F   8A82         MOV       DPL,R2
   \   000161   8B83         MOV       DPH,R3
   \   000163   E5..         MOV       A,?V4
   \   000165   F0           MOVX      @DPTR,A
   \   000166   A3           INC       DPTR
   \   000167   E5..         MOV       A,?V5
   \   000169   F0           MOVX      @DPTR,A
   \   00016A   800D         SJMP      ??osal_mem_alloc_10
    413          
    414          #if ( OSALMEM_METRICS )
    415                blkCnt++;
    416                if ( blkMax < blkCnt )
    417                {
    418                  blkMax = blkCnt;
    419                }
    420                memAlo += size;
    421          #endif
    422              }
    423              else
    424              {
    425          #if ( OSALMEM_METRICS )
    426                memAlo += hdr->hdr.len;
    427                blkFree--;
    428          #endif
    429          
    430                hdr->hdr.inUse = TRUE;
   \                     ??osal_mem_alloc_9:
   \   00016C   8A82         MOV       DPL,R2
   \   00016E   8B83         MOV       DPH,R3
   \   000170   E0           MOVX      A,@DPTR
   \   000171   4400         ORL       A,#0x0
   \   000173   F0           MOVX      @DPTR,A
   \   000174   A3           INC       DPTR
   \   000175   E0           MOVX      A,@DPTR
   \   000176   4480         ORL       A,#0x80
   \   000178   F0           MOVX      @DPTR,A
    431              }
    432          
    433          #if ( OSALMEM_METRICS )
    434              if ( memMax < memAlo )
    435              {
    436                memMax = memAlo;
    437              }
    438          #endif
    439          
    440          #if ( OSALMEM_PROFILER )
    441          #if !OSALMEM_PROFILER_LL
    442              if (osalMemStat != 0)  // Don't profile until after the LL block is filled.
    443          #endif
    444              {
    445                uint8 idx;
    446          
    447                for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    448                {
    449                  if ( hdr->hdr.len <= proCnt[idx] )
    450                  {
    451                    break;
    452                  }
    453                }
    454                proCur[idx]++;
    455                if ( proMax[idx] < proCur[idx] )
    456                {
    457                  proMax[idx] = proCur[idx];
    458                }
    459                proTot[idx]++;
    460          
    461                /* A small-block could not be allocated in the small-block bucket.
    462                 * When this occurs significantly frequently, increase the size of the
    463                 * bucket in order to restore better worst case run times. Set the first
    464                 * profiling bucket size in proCnt[] to the small-block bucket size and
    465                 * divide proSmallBlkMiss by the corresponding proTot[] size to get % miss.
    466                 * Best worst case time on TrasmitApp was achieved at a 0-15% miss rate
    467                 * during steady state Tx load, 0% during idle and steady state Rx load.
    468                 */
    469                if ((hdr->hdr.len <= OSALMEM_SMALL_BLKSZ) && (hdr >= (theHeap + OSALMEM_BIGBLK_IDX)))
    470                {
    471                  proSmallBlkMiss++;
    472                }
    473              }
    474          
    475              (void)osal_memset((uint8 *)(hdr+1), OSALMEM_ALOC, (hdr->hdr.len - OSALMEM_HDRSZ));
    476          #endif
    477          
    478              if ((osalMemStat != 0) && (ff1 == hdr))
   \                     ??osal_mem_alloc_10:
   \   000179   90....       MOV       DPTR,#osalMemStat
   \   00017C   E0           MOVX      A,@DPTR
   \   00017D   6037         JZ        ??osal_mem_alloc_11
   \   00017F   90....       MOV       DPTR,#ff1
   \   000182   E0           MOVX      A,@DPTR
   \   000183   F5..         MOV       ?V0,A
   \   000185   A3           INC       DPTR
   \   000186   E0           MOVX      A,@DPTR
   \   000187   F5..         MOV       ?V1,A
   \   000189   EA           MOV       A,R2
   \   00018A   65..         XRL       A,?V0
   \   00018C   7003         JNZ       ??osal_mem_alloc_12
   \   00018E   EB           MOV       A,R3
   \   00018F   65..         XRL       A,?V1
   \                     ??osal_mem_alloc_12:
   \   000191   7023         JNZ       ??osal_mem_alloc_11
    479              {
    480                ff1 = (osalMemHdr_t *)((uint8 *)hdr + hdr->hdr.len);
   \   000193   8A82         MOV       DPL,R2
   \   000195   8B83         MOV       DPH,R3
   \   000197   E0           MOVX      A,@DPTR
   \   000198   54FF         ANL       A,#0xff
   \   00019A   F5..         MOV       ?V0,A
   \   00019C   A3           INC       DPTR
   \   00019D   E0           MOVX      A,@DPTR
   \   00019E   547F         ANL       A,#0x7f
   \   0001A0   F5..         MOV       ?V1,A
   \   0001A2   EA           MOV       A,R2
   \   0001A3   25..         ADD       A,?V0
   \   0001A5   F5..         MOV       ?V0,A
   \   0001A7   EB           MOV       A,R3
   \   0001A8   35..         ADDC      A,?V1
   \   0001AA   F5..         MOV       ?V1,A
   \   0001AC   90....       MOV       DPTR,#ff1
   \   0001AF   E5..         MOV       A,?V0
   \   0001B1   F0           MOVX      @DPTR,A
   \   0001B2   A3           INC       DPTR
   \   0001B3   E5..         MOV       A,?V1
   \   0001B5   F0           MOVX      @DPTR,A
    481              }
    482          
    483              hdr++;
   \                     ??osal_mem_alloc_11:
   \   0001B6   EA           MOV       A,R2
   \   0001B7   2402         ADD       A,#0x2
   \   0001B9   FA           MOV       R2,A
   \   0001BA   5001         JNC       ??osal_mem_alloc_8
   \   0001BC   0B           INC       R3
    484            }
    485          
    486            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_alloc_8:
   \   0001BD   ED           MOV       A,R5
   \   0001BE   A2E0         MOV       C,0xE0 /* A   */.0
   \   0001C0   92AF         MOV       0xa8.7,C
    487          
    488            HAL_ASSERT(((size_t)hdr % sizeof(halDataAlign_t)) == 0);
    489          
    490          #ifdef DPRINTF_OSALHEAPTRACE
    491            dprintf("osal_mem_alloc(%u)->%lx:%s:%u\n", size, (unsigned) hdr, fname, lnum);
    492          #endif /* DPRINTF_OSALHEAPTRACE */
    493            return (void *)hdr;
   \   0001C2   7F07         MOV       R7,#0x7
   \   0001C4   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   0001C7                REQUIRE _A_IEN0
    494          }
    495          
    496          /**************************************************************************************************
    497           * @fn          osal_mem_free
    498           *
    499           * @brief       This function implements the OSAL dynamic memory de-allocation functionality.
    500           *
    501           * input parameters
    502           *
    503           * @param ptr - A valid pointer (i.e. a pointer returned by osal_mem_alloc()) to the memory to free.
    504           *
    505           * output parameters
    506           *
    507           * None.
    508           *
    509           * @return      None.
    510           */
    511          #ifdef DPRINTF_OSALHEAPTRACE
    512          void osal_mem_free_dbg(void *ptr, const char *fname, unsigned lnum)
    513          #else /* DPRINTF_OSALHEAPTRACE */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    514          void osal_mem_free(void *ptr)
   \                     osal_mem_free:
    515          #endif /* DPRINTF_OSALHEAPTRACE */
    516          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    517            osalMemHdr_t *hdr = (osalMemHdr_t *)ptr - 1;
   \   000009   EE           MOV       A,R6
   \   00000A   24FE         ADD       A,#-0x2
   \   00000C   F5..         MOV       ?V0,A
   \   00000E   EF           MOV       A,R7
   \   00000F   34FF         ADDC      A,#-0x1
   \   000011   F5..         MOV       ?V1,A
    518            halIntState_t intState;
    519          
    520          #ifdef DPRINTF_OSALHEAPTRACE
    521            dprintf("osal_mem_free(%lx):%s:%u\n", (unsigned) ptr, fname, lnum);
    522          #endif /* DPRINTF_OSALHEAPTRACE */
    523          
    524            HAL_ASSERT(((uint8 *)ptr >= (uint8 *)theHeap) && ((uint8 *)ptr < (uint8 *)theHeap+MAXMEMHEAP));
   \   000013   C3           CLR       C
   \   000014   EE           MOV       A,R6
   \   000015   94..         SUBB      A,#theHeap & 0xff
   \   000017   EF           MOV       A,R7
   \   000018   94..         SUBB      A,#(theHeap >> 8) & 0xff
   \   00001A   4009         JC        ??osal_mem_free_0
   \   00001C   C3           CLR       C
   \   00001D   EE           MOV       A,R6
   \   00001E   94..         SUBB      A,#theHeap & 0xff
   \   000020   EF           MOV       A,R7
   \   000021   94..         SUBB      A,#((theHeap + 2048) >> 8) & 0xff
   \   000023   4003         JC        ??osal_mem_free_1
   \                     ??osal_mem_free_0:
   \   000025                ; Setup parameters for call to function halAssertHandler
   \   000025   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    525            HAL_ASSERT(hdr->hdr.inUse);
   \                     ??osal_mem_free_1:
   \   000028   85..82       MOV       DPL,?V0
   \   00002B   85..83       MOV       DPH,?V1
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   5400         ANL       A,#0x0
   \   000031   F8           MOV       R0,A
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   5480         ANL       A,#0x80
   \   000036   F9           MOV       R1,A
   \   000037   E8           MOV       A,R0
   \   000038   49           ORL       A,R1
   \   000039   7003         JNZ       ??osal_mem_free_2
   \   00003B                ; Setup parameters for call to function halAssertHandler
   \   00003B   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    526          
    527            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \                     ??osal_mem_free_2:
   \   00003E   A2AF         MOV       C,0xa8.7
   \   000040   E4           CLR       A
   \   000041   33           RLC       A
   \   000042   F5..         MOV       ?V2,A
   \   000044   C2AF         CLR       0xa8.7
    528            hdr->hdr.inUse = FALSE;
   \   000046   85..82       MOV       DPL,?V0
   \   000049   85..83       MOV       DPH,?V1
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   54FF         ANL       A,#0xff
   \   00004F   F0           MOVX      @DPTR,A
   \   000050   A3           INC       DPTR
   \   000051   E0           MOVX      A,@DPTR
   \   000052   547F         ANL       A,#0x7f
   \   000054   F0           MOVX      @DPTR,A
    529          
    530            if (ff1 > hdr)
   \   000055   90....       MOV       DPTR,#ff1
   \   000058   E0           MOVX      A,@DPTR
   \   000059   F8           MOV       R0,A
   \   00005A   A3           INC       DPTR
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   F9           MOV       R1,A
   \   00005D   C3           CLR       C
   \   00005E   E5..         MOV       A,?V0
   \   000060   98           SUBB      A,R0
   \   000061   E5..         MOV       A,?V1
   \   000063   99           SUBB      A,R1
   \   000064   500C         JNC       ??osal_mem_free_3
    531            {
    532              ff1 = hdr;
   \   000066   A8..         MOV       R0,?V0
   \   000068   A9..         MOV       R1,?V1
   \   00006A   90....       MOV       DPTR,#ff1
   \   00006D   E8           MOV       A,R0
   \   00006E   F0           MOVX      @DPTR,A
   \   00006F   A3           INC       DPTR
   \   000070   E9           MOV       A,R1
   \   000071   F0           MOVX      @DPTR,A
    533            }
    534          
    535          #if OSALMEM_PROFILER
    536          #if !OSALMEM_PROFILER_LL
    537            if (osalMemStat != 0)  // Don't profile until after the LL block is filled.
    538          #endif
    539            {
    540              uint8 idx;
    541          
    542              for (idx = 0; idx < OSALMEM_PROMAX; idx++)
    543              {
    544                if (hdr->hdr.len <= proCnt[idx])
    545                {
    546                  break;
    547                }
    548              }
    549          
    550              proCur[idx]--;
    551            }
    552          
    553            (void)osal_memset((uint8 *)(hdr+1), OSALMEM_REIN, (hdr->hdr.len - OSALMEM_HDRSZ) );
    554          #endif
    555          #if OSALMEM_METRICS
    556            memAlo -= hdr->hdr.len;
    557            blkFree++;
    558          #endif
    559          
    560            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_free_3:
   \   000072   E5..         MOV       A,?V2
   \   000074   A2E0         MOV       C,0xE0 /* A   */.0
   \   000076   92AF         MOV       0xa8.7,C
    561          }
   \   000078   7F03         MOV       R7,#0x3
   \   00007A   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   00007D                REQUIRE _A_IEN0
    562          
    563          #if OSALMEM_METRICS
    564          /*********************************************************************
    565           * @fn      osal_heap_block_max
    566           *
    567           * @brief   Return the maximum number of blocks ever allocated at once.
    568           *
    569           * @param   none
    570           *
    571           * @return  Maximum number of blocks ever allocated at once.
    572           */
    573          uint16 osal_heap_block_max( void )
    574          {
    575            return blkMax;
    576          }
    577          
    578          /*********************************************************************
    579           * @fn      osal_heap_block_cnt
    580           *
    581           * @brief   Return the current number of blocks now allocated.
    582           *
    583           * @param   none
    584           *
    585           * @return  Current number of blocks now allocated.
    586           */
    587          uint16 osal_heap_block_cnt( void )
    588          {
    589            return blkCnt;
    590          }
    591          
    592          /*********************************************************************
    593           * @fn      osal_heap_block_free
    594           *
    595           * @brief   Return the current number of free blocks.
    596           *
    597           * @param   none
    598           *
    599           * @return  Current number of free blocks.
    600           */
    601          uint16 osal_heap_block_free( void )
    602          {
    603            return blkFree;
    604          }
    605          
    606          /*********************************************************************
    607           * @fn      osal_heap_mem_used
    608           *
    609           * @brief   Return the current number of bytes allocated.
    610           *
    611           * @param   none
    612           *
    613           * @return  Current number of bytes allocated.
    614           */
    615          uint16 osal_heap_mem_used( void )
    616          {
    617            return memAlo;
    618          }
    619          #endif
    620          
    621          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    622          /*********************************************************************
    623           * @fn      osal_heap_high_water
    624           *
    625           * @brief   Return the highest byte ever allocated in the heap.
    626           *
    627           * @param   none
    628           *
    629           * @return  Highest number of bytes ever used by the stack.
    630           */
    631          uint16 osal_heap_high_water( void )
    632          {
    633          #if ( OSALMEM_METRICS )
    634            return memMax;
    635          #else
    636            return MAXMEMHEAP;
    637          #endif
    638          }
    639          #endif
    640          
    641          /**************************************************************************************************
    642          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     27   osal_mem_alloc
      0     23   osal_mem_free
        0     11   -> halAssertHandler
      2      0   osal_mem_init
      0     12   osal_mem_kick
        0     12   -> halAssertHandler
        0     12   -> osal_mem_alloc
        0     12   -> osal_mem_free


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  _A_IEN0
       2  ff1
       1  osalMemStat
     455  osal_mem_alloc
     125  osal_mem_free
      69  osal_mem_init
      75  osal_mem_kick
    2048  theHeap
      24  -- Other

 
   724 bytes in segment BANKED_CODE
    24 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
 2 051 bytes in segment XDATA_Z
 
    24 bytes of CODE     memory
     0 bytes of DATA     memory (+ 1 byte shared)
   724 bytes of HUGECODE memory
 2 051 bytes of XDATA    memory

Errors: none
Warnings: none
