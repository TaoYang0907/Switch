///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.30.1.6000 for 8051              05/Aug/2020  22:51:09
// Copyright 2004-2018 IAR Systems AB.
// PC-locked license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        D:\AA\Z-Stack 3.0.2\Components\osal\mcu\cc2530\OSAL_Nv.c
//    Command line       =  
//        -f C:\Users\sunli\AppData\Local\Temp\EW45CE.tmp ("D:\AA\Z-Stack
//        3.0.2\Components\osal\mcu\cc2530\OSAL_Nv.c" -D SECURE=1 -D
//        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D POWER_SAVING -D
//        NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D
//        xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
//        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
//        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
//        -D ZCL_GROUPS -D BDB_TL_INITIATOR -D INTER_PAN -lC "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
//        -lA "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
//        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj"
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
//        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0}
//        -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=0 -DQUEUED_POLL_RATE=0 -DRESPONSE_POLL_RATE=0
//        -DREJOIN_POLL_RATE=0 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
//        -DENABLE_LED4_DISABLE_S1) -f "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\" -I
//        "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\"
//        -I "D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
//        -On --require_prototypes --no_cse --no_unroll --no_inline
//        --no_code_motion --no_tbaa --no_cross_call)
//    Locale             =  Chinese (Simplified)_CHN.936
//    List file          =  
//        D:\AA\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List\OSAL_Nv.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME OSAL_Nv

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?V3
        EXTERN ?V4
        EXTERN ?V5
        EXTERN ?V6
        EXTERN ?V7
        EXTERN ?V8
        EXTERN ?V9
        EXTERN ?V10
        EXTERN ?V11
        EXTERN ?V12
        EXTERN ?V14
        EXTERN ?V15
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK8_X_TWO
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?US_SHR
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTACK_DISP102_8
        EXTERN __INIT_XDATA_Z

        FUNCTION `??calcChkB::?relay`,0203H
        FUNCTION `??calcChkF::?relay`,0203H
        FUNCTION `??compactPage::?relay`,0203H
        FUNCTION `??erasePage::?relay`,0203H
        FUNCTION `??findItem::?relay`,0203H
        FUNCTION `??hotItem::?relay`,0203H
        FUNCTION `??hotItemUpdate::?relay`,0203H
        FUNCTION `??initItem::?relay`,0203H
        FUNCTION `??initNV::?relay`,0203H
        FUNCTION `??initPage::?relay`,0203H
        PUBLIC `??osal_nv_delete::?relay`
        FUNCTION `??osal_nv_delete::?relay`,0203H
        PUBLIC `??osal_nv_init::?relay`
        FUNCTION `??osal_nv_init::?relay`,0203H
        PUBLIC `??osal_nv_item_init::?relay`
        FUNCTION `??osal_nv_item_init::?relay`,0203H
        PUBLIC `??osal_nv_item_len::?relay`
        FUNCTION `??osal_nv_item_len::?relay`,0203H
        PUBLIC `??osal_nv_read::?relay`
        FUNCTION `??osal_nv_read::?relay`,0203H
        PUBLIC `??osal_nv_write::?relay`
        FUNCTION `??osal_nv_write::?relay`,0203H
        FUNCTION `??setChk::?relay`,0203H
        FUNCTION `??setItem::?relay`,0203H
        FUNCTION `??setPageUse::?relay`,0203H
        FUNCTION `??writeBuf::?relay`,0203H
        FUNCTION `??writeItem::?relay`,0203H
        FUNCTION `??writeWord::?relay`,0203H
        FUNCTION `??writeWordH::?relay`,0203H
        FUNCTION `??writeWordM::?relay`,0203H
        FUNCTION `??xferBuf::?relay`,0203H
        PUBLIC _nvBuf
        FUNCTION calcChkB,0203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        FUNCTION calcChkF,0a1203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 22, STACK
        FUNCTION compactPage,0a1203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 31, STACK
        FUNCTION erasePage,021203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        FUNCTION findItem,0a1203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 14, STACK
        FUNCTION hotItem,0203H
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION hotItemUpdate,0a1203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 11, STACK
        FUNCTION initItem,0a1203H
        ARGFRAME XSTACK, 44, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 31, STACK
        FUNCTION initNV,0a1203H
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 22, STACK
        FUNCTION initPage,0a1203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 30, STACK
        PUBLIC osal_nv_delete
        FUNCTION osal_nv_delete,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC osal_nv_init
        FUNCTION osal_nv_init,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC osal_nv_item_init
        FUNCTION osal_nv_item_init,0a1203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME XSTACK, 18, STACK
        PUBLIC osal_nv_item_len
        FUNCTION osal_nv_item_len,0a1203H
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 24, STACK
        PUBLIC osal_nv_read
        FUNCTION osal_nv_read,0a1203H
        ARGFRAME XSTACK, 4, STACK
        LOCFRAME XSTACK, 22, STACK
        PUBLIC osal_nv_write
        FUNCTION osal_nv_write,0a1203H
        ARGFRAME XSTACK, 4, STACK
        LOCFRAME XSTACK, 46, STACK
        FUNCTION setChk,0a1203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 16, STACK
        FUNCTION setItem,0a1203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 22, STACK
        FUNCTION setPageUse,021203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 17, STACK
        FUNCTION writeBuf,0a1203H
        ARGFRAME XSTACK, 44, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 24, STACK
        FUNCTION writeItem,0a1203H
        ARGFRAME XSTACK, 31, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 30, STACK
        FUNCTION writeWord,0a1203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 16, STACK
        FUNCTION writeWordH,0a1203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 15, STACK
        FUNCTION writeWordM,0a1203H
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 15, STACK
        FUNCTION xferBuf,0a1203H
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 25, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
HalFlashErase       SYMBOL "HalFlashErase"
`??HalFlashErase::?relay` SYMBOL "?relay", HalFlashErase
HalFlashRead        SYMBOL "HalFlashRead"
`??HalFlashRead::?relay` SYMBOL "?relay", HalFlashRead
HalFlashWrite       SYMBOL "HalFlashWrite"
`??HalFlashWrite::?relay` SYMBOL "?relay", HalFlashWrite
OnBoard_CheckVoltage SYMBOL "OnBoard_CheckVoltage"
`??OnBoard_CheckVoltage::?relay` SYMBOL "?relay", OnBoard_CheckVoltage
osal_nv_delete      SYMBOL "osal_nv_delete"
`??osal_nv_delete::?relay` SYMBOL "?relay", osal_nv_delete
osal_nv_init        SYMBOL "osal_nv_init"
`??osal_nv_init::?relay` SYMBOL "?relay", osal_nv_init
osal_nv_item_init   SYMBOL "osal_nv_item_init"
`??osal_nv_item_init::?relay` SYMBOL "?relay", osal_nv_item_init
osal_nv_item_len    SYMBOL "osal_nv_item_len"
`??osal_nv_item_len::?relay` SYMBOL "?relay", osal_nv_item_len
osal_nv_read        SYMBOL "osal_nv_read"
`??osal_nv_read::?relay` SYMBOL "?relay", osal_nv_read
osal_nv_write       SYMBOL "osal_nv_write"
`??osal_nv_write::?relay` SYMBOL "?relay", osal_nv_write

        EXTERN `??HalFlashErase::?relay`
        FUNCTION `??HalFlashErase::?relay`,00H
        EXTERN `??HalFlashRead::?relay`
        FUNCTION `??HalFlashRead::?relay`,00H
        EXTERN `??HalFlashWrite::?relay`
        FUNCTION `??HalFlashWrite::?relay`,00H
        EXTERN `??OnBoard_CheckVoltage::?relay`
        FUNCTION `??OnBoard_CheckVoltage::?relay`,00H
        EXTERN HalFlashErase
        FUNCTION HalFlashErase,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN HalFlashRead
        FUNCTION HalFlashRead,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 44, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN HalFlashWrite
        FUNCTION HalFlashWrite,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN OnBoard_CheckVoltage
        FUNCTION OnBoard_CheckVoltage,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// D:\AA\Z-Stack 3.0.2\Components\osal\mcu\cc2530\OSAL_Nv.c
//    1 /******************************************************************************
//    2   Filename:       OSAL_Nv.c
//    3   Revised:        $Date: 2014-12-19 13:07:30 -0800 (Fri, 19 Dec 2014) $
//    4   Revision:       $Revision: 41556 $
//    5 
//    6   Description:    This module contains the OSAL non-volatile memory functions.
//    7 
//    8 
//    9   Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License"). You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product. Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 ******************************************************************************/
//   39 
//   40 /******************************************************************************
//   41   Notes:
//   42     - A trick buried deep in initPage() requires that the MSB of the NV Item Id
//   43       is to be reserved for use by this module.
//   44 ******************************************************************************/
//   45 
//   46 /*********************************************************************
//   47  * INCLUDES
//   48  */
//   49 
//   50 #include "hal_adc.h"
//   51 #include "hal_flash.h"
//   52 #include "hal_types.h"
//   53 #include "OSAL_Nv.h"
//   54 #include "ZComDef.h"
//   55 #ifdef HAL_MCU_CC2533
//   56 #include "hal_batmon.h"
//   57 #endif
//   58 #include "OnBoard.h"
//   59 
//   60 /*********************************************************************
//   61  * CONSTANTS
//   62  */
//   63 
//   64 #define OSAL_NV_PAGE_SIZE       HAL_FLASH_PAGE_SIZE
//   65 #define OSAL_NV_PAGES_USED      HAL_NV_PAGE_CNT
//   66 #define OSAL_NV_PAGE_BEG        HAL_NV_PAGE_BEG
//   67 #define OSAL_NV_PAGE_END       (OSAL_NV_PAGE_BEG + OSAL_NV_PAGES_USED - 1)
//   68 
//   69 #define OSAL_NV_ACTIVE          0x00
//   70 #define OSAL_NV_ERASED          0xFF
//   71 #define OSAL_NV_ERASED_ID       0xFFFF
//   72 #define OSAL_NV_ZEROED_ID       0x0000
//   73 // Reserve MSB of Id to signal a search for the "old" source copy (new write interrupted/failed.)
//   74 #define OSAL_NV_SOURCE_ID       0x8000
//   75 
//   76 // In case pages 0-1 are ever used, define a null page value.
//   77 #define OSAL_NV_PAGE_NULL       0
//   78 
//   79 // In case item Id 0 is ever used, define a null item value.
//   80 #define OSAL_NV_ITEM_NULL       0
//   81 
//   82 #define OSAL_NV_WORD_SIZE       HAL_FLASH_WORD_SIZE
//   83 
//   84 #define OSAL_NV_PAGE_HDR_OFFSET 0
//   85 
//   86 #define OSAL_NV_MAX_HOT         3

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//   87 static const uint16 hotIds[OSAL_NV_MAX_HOT] = {
hotIds:
        DATA16
        DW 130
        DW 58
        DW 59
//   88   ZCD_NV_NWKKEY,
//   89   ZCD_NV_NWK_ACTIVE_KEY_INFO,
//   90   ZCD_NV_NWK_ALTERN_KEY_INFO,
//   91 };
//   92 
//   93 /*********************************************************************
//   94  * MACROS
//   95  */
//   96 
//   97 #if (defined HAL_MCU_CC2530 || defined HAL_MCU_CC2531)
//   98 #define OSAL_NV_CHECK_BUS_VOLTAGE  OnBoard_CheckVoltage()
//   99 #elif defined HAL_MCU_CC2533
//  100 # define  OSAL_NV_CHECK_BUS_VOLTAGE  (HalBatMonRead( HAL_BATMON_MIN_FLASH ))
//  101 #else
//  102 # warning No implementation of a low Vdd check.
//  103 # define  OSAL_NV_CHECK_BUS_VOLTAGE
//  104 #endif
//  105 
//  106 #define OSAL_NV_DATA_SIZE( LEN )                      \ 
//  107   (((LEN) >= ((uint16)(65536UL - OSAL_NV_WORD_SIZE))) ? \ 
//  108              ((uint16)(65536UL - OSAL_NV_WORD_SIZE))  : \ 
//  109              ((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE))
//  110 
//  111 #define OSAL_NV_ITEM_SIZE( LEN )                                         \ 
//  112   (((LEN) >= ((uint16)(65536UL - OSAL_NV_WORD_SIZE - OSAL_NV_HDR_SIZE))) ? \ 
//  113              ((uint16)(65536UL - OSAL_NV_WORD_SIZE))                     : \ 
//  114   (((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE) + OSAL_NV_HDR_SIZE))
//  115 
//  116 #define COMPACT_PAGE_CLEANUP( COM_PG ) st ( \ 
//  117   /* In order to recover from a page compaction that is interrupted,\ 
//  118    * the logic in osal_nv_init() depends upon the following order:\ 
//  119    * 1. State of the target of compaction is changed to ePgInUse.\ 
//  120    * 2. Compacted page is erased.\ 
//  121    */\ 
//  122   setPageUse( pgRes, TRUE );  /* Mark the reserve page as being in use. */\ 
//  123   erasePage( (COM_PG) ); \ 
//  124   \ 
//  125   pgRes = (COM_PG);           /* Set the reserve page to be the newly erased page. */\ 
//  126 )
//  127 
//  128 /*********************************************************************
//  129  * TYPEDEFS
//  130  */
//  131 
//  132 typedef struct
//  133 {
//  134   uint16 id;
//  135   uint16 len;   // Enforce Flash-WORD size on len.
//  136   uint16 chk;   // Byte-wise checksum of the 'len' data bytes of the item.
//  137   uint16 stat;  // Item status.
//  138 } osalNvHdr_t;
//  139 // Struct member offsets.
//  140 #define OSAL_NV_HDR_ID    0
//  141 #define OSAL_NV_HDR_LEN   2
//  142 #define OSAL_NV_HDR_CHK   4
//  143 #define OSAL_NV_HDR_STAT  6
//  144 
//  145 #define OSAL_NV_HDR_ITEM  2  // Length of any item of a header struct.
//  146 #define OSAL_NV_HDR_SIZE  8
//  147 #define OSAL_NV_HDR_HALF (OSAL_NV_HDR_SIZE / 2)
//  148 
//  149 typedef struct
//  150 {
//  151   uint16 active;
//  152   uint16 inUse;
//  153   uint16 xfer;
//  154   uint16 spare;
//  155 } osalNvPgHdr_t;
//  156 // Struct member offsets.
//  157 #define OSAL_NV_PG_ACTIVE 0
//  158 #define OSAL_NV_PG_INUSE  2
//  159 #define OSAL_NV_PG_XFER   4
//  160 #define OSAL_NV_PG_SPARE  6
//  161 
//  162 #define OSAL_NV_PAGE_HDR_SIZE  8
//  163 #define OSAL_NV_PAGE_HDR_HALF (OSAL_NV_PAGE_HDR_SIZE / 2)
//  164 
//  165 typedef enum
//  166 {
//  167   eNvXfer,
//  168   eNvZero
//  169 } eNvHdrEnum;
//  170 
//  171 typedef enum
//  172 {
//  173   ePgActive,
//  174   ePgInUse,
//  175   ePgXfer,
//  176   ePgSpare
//  177 } ePgHdrEnum;
//  178 
//  179 /*********************************************************************
//  180  * GLOBAL VARIABLES
//  181  */
//  182 
//  183 #ifndef OAD_KEEP_NV_PAGES
//  184 // When NV pages are to remain intact during OAD download,
//  185 // the image itself should not include NV pages.
//  186 #pragma location="ZIGNV_ADDRESS_SPACE"

        RSEG ZIGNV_ADDRESS_SPACE:XDATA:REORDER:NOROOT(0)
        DATA8
//  187 __no_init uint8 _nvBuf[OSAL_NV_PAGES_USED * OSAL_NV_PAGE_SIZE];
_nvBuf:
        DS 12288
//  188 #pragma required=_nvBuf
//  189 #endif // OAD_KEEP_NV_PAGES
//  190 
//  191 /*********************************************************************
//  192  * LOCAL VARIABLES
//  193  */
//  194 
//  195 // Offset into the page of the first available erased space.

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  196 static uint16 pgOff[OSAL_NV_PAGES_USED];
pgOff:
        DS 12
        REQUIRE __INIT_XDATA_Z
        REQUIRE _nvBuf
//  197 
//  198 // Count of the bytes lost for the zeroed-out items.

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  199 static uint16 pgLost[OSAL_NV_PAGES_USED];
pgLost:
        DS 12
        REQUIRE __INIT_XDATA_Z
//  200 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  201 static uint8 pgRes;  // Page reserved for item compacting transfer.
pgRes:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  202 
//  203 // Saving ~100 code bytes to move a uint8* parameter/return value from findItem() to a global.

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  204 static uint8 findPg;
findPg:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  205 
//  206 // NV page and offsets for hot items.

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  207 static uint8 hotPg[OSAL_NV_MAX_HOT];
hotPg:
        DS 3
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  208 static uint16 hotOff[OSAL_NV_MAX_HOT];
hotOff:
        DS 6
        REQUIRE __INIT_XDATA_Z
//  209 
//  210 /*********************************************************************
//  211  * LOCAL FUNCTIONS
//  212  */
//  213 
//  214 static uint8  initNV( void );
//  215 
//  216 static void   setPageUse( uint8 pg, uint8 inUse );
//  217 static uint16 initPage( uint8 pg, uint16 id, uint8 findDups );
//  218 static void   erasePage( uint8 pg );
//  219 static uint8  compactPage( uint8 srcPg, uint16 skipId );
//  220 
//  221 static uint16 findItem( uint16 id );
//  222 static uint8  initItem( uint8 flag, uint16 id, uint16 len, void *buf );
//  223 static void   setItem( uint8 pg, uint16 offset, eNvHdrEnum stat );
//  224 static uint16 setChk( uint8 pg, uint16 offset, uint16 chk );
//  225 
//  226 static uint16 calcChkB( uint16 len, uint8 *buf );
//  227 static uint16 calcChkF( uint8 pg, uint16 offset, uint16 len );
//  228 
//  229 static void   writeWord( uint8 pg, uint16 offset, uint8 *buf );
//  230 static void   writeWordH( uint8 pg, uint16 offset, uint8 *buf );
//  231 static void   writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint16 cnt );
//  232 static void   writeBuf( uint8 pg, uint16 offset, uint16 len, uint8 *buf );
//  233 static void   xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len );
//  234 
//  235 static uint8  writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag );
//  236 static uint8  hotItem(uint16 id);
//  237 static void   hotItemUpdate(uint8 pg, uint16 off, uint16 id);
//  238 
//  239 /*********************************************************************
//  240  * @fn      initNV
//  241  *
//  242  * @brief   Initialize the NV flash pages.
//  243  *
//  244  * @param   none
//  245  *
//  246  * @return  TRUE
//  247  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  248 static uint8 initNV( void )
initNV:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function initNV
        CODE
//  249 {
        FUNCALL initNV, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, setPageUse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, compactPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, initPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, initPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV       A,#-0xc
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 8
        MOV       A,#-0x8
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  250   osalNvPgHdr_t pgHdr;
//  251   uint8 oldPg = OSAL_NV_PAGE_NULL;
        MOV       ?V0,#0x0
//  252   uint8 findDups = FALSE;
        MOV       R7,#0x0
//  253   uint8 pg;
//  254 
//  255   pgRes = OSAL_NV_PAGE_NULL;
        MOV       DPTR,#pgRes
        MOV       A,#0x0
        MOVX      @DPTR,A
//  256 
//  257   for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
        MOV       R6,#0x79
??initNV_0:
        MOV       A,R6
        CLR       C
        SUBB      A,#0x7f
        JNC       ??initNV_1
//  258   {
//  259     HalFlashRead(pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr), OSAL_NV_HDR_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V2,#0x8
        MOV       ?V3,#0x0
        MOV       R0,#?V2
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,#0x0
        MOV       R3,#0x0
        MOV       A,R6
        MOV       R1,A
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  260 
//  261     if ( pgHdr.active == OSAL_NV_ERASED_ID )
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??initNV_2
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??initNV_2:
        JNZ       ??initNV_3
//  262     {
//  263       if ( pgRes == OSAL_NV_PAGE_NULL )
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        JNZ       ??initNV_4
//  264       {
//  265         pgRes = pg;
        MOV       A,R6
        MOV       DPTR,#pgRes
        MOVX      @DPTR,A
        SJMP      ??initNV_5
//  266       }
//  267       else
//  268       {
//  269         setPageUse( pg, TRUE );
??initNV_4:
        ; Setup parameters for call to function setPageUse
        MOV       R2,#0x1
        MOV       A,R6
        MOV       R1,A
        LCALL     `??setPageUse::?relay`; Banked call to: setPageUse
        SJMP      ??initNV_5
//  270       }
//  271     }
//  272     // An Xfer from this page was in progress.
//  273     else if ( pgHdr.xfer != OSAL_NV_ERASED_ID )
??initNV_3:
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??initNV_6
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??initNV_6:
        JZ        ??initNV_5
//  274     {
//  275       oldPg = pg;
        MOV       ?V0,R6
//  276     }
//  277   }
??initNV_5:
        INC       R6
        SJMP      ??initNV_0
//  278 
//  279   // If a page compaction was interrupted before the old page was erased.
//  280   if ( oldPg != OSAL_NV_PAGE_NULL )
??initNV_1:
        MOV       A,?V0
        JZ        ??initNV_7
//  281   {
//  282     /* Interrupted compaction before the target of compaction was put in use;
//  283      * so erase the target of compaction and start again.
//  284      */
//  285     if ( pgRes != OSAL_NV_PAGE_NULL )
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        JZ        ??initNV_8
//  286     {
//  287       erasePage( pgRes );
        ; Setup parameters for call to function erasePage
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
//  288       (void)compactPage( oldPg, OSAL_NV_ITEM_NULL );
        ; Setup parameters for call to function compactPage
        MOV       R2,#0x0
        MOV       R3,#0x0
        MOV       R1,?V0
        LCALL     `??compactPage::?relay`; Banked call to: compactPage
        MOV       A,R1
        SJMP      ??initNV_9
//  289     }
//  290     /* Interrupted compaction after the target of compaction was put in use,
//  291      * but before the old page was erased; so erase it now and create a new reserve page.
//  292      */
//  293     else
//  294     {
//  295       erasePage( oldPg );
??initNV_8:
        ; Setup parameters for call to function erasePage
        MOV       R1,?V0
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
//  296       pgRes = oldPg;
        MOV       A,?V0
        MOV       DPTR,#pgRes
        MOVX      @DPTR,A
        SJMP      ??initNV_9
//  297     }
//  298   }
//  299   else if ( pgRes != OSAL_NV_PAGE_NULL )
??initNV_7:
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        JZ        ??initNV_9
//  300   {
//  301     erasePage( pgRes );  // The last page erase could have been interrupted by a power-cycle.
        ; Setup parameters for call to function erasePage
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
//  302   }
//  303   /* else if there is no reserve page, COMPACT_PAGE_CLEANUP() must have succeeded to put the old
//  304    * reserve page (i.e. the target of the compacted items) into use but got interrupted by a reset
//  305    * while trying to erase the page to be compacted. Such a page should only contain duplicate items
//  306    * (i.e. all items will be marked 'Xfer') and thus should have the lost count equal to the page
//  307    * size less the page header.
//  308    */
//  309 
//  310   for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
??initNV_9:
        MOV       R6,#0x79
??initNV_10:
        MOV       A,R6
        CLR       C
        SUBB      A,#0x7f
        JNC       ??initNV_11
//  311   {
//  312     // Calculate page offset and lost bytes - any "old" item triggers an N^2 re-scan from start.
//  313     if ( initPage( pg, OSAL_NV_ITEM_NULL, findDups ) != OSAL_NV_ITEM_NULL )
        ; Setup parameters for call to function initPage
        MOV       A,R7
        MOV       R4,A
        MOV       R2,#0x0
        MOV       R3,#0x0
        MOV       A,R6
        MOV       R1,A
        LCALL     `??initPage::?relay`; Banked call to: initPage
        MOV       ?V2,R2
        MOV       ?V3,R3
        MOV       A,?V2
        ORL       A,?V3
        JZ        ??initNV_12
//  314     {
//  315       findDups = TRUE;
        MOV       R7,#0x1
//  316       pg = (OSAL_NV_PAGE_BEG - 1);  // Pre-decrement so that loop increment will start over at zero.
        MOV       R6,#0x78
//  317       continue;
//  318     }
//  319   }
??initNV_12:
        INC       R6
        SJMP      ??initNV_10
//  320 
//  321   if (findDups)
??initNV_11:
        MOV       A,R7
        JZ        ??initNV_13
//  322   {
//  323     // Final pass to calculate page lost after invalidating duplicate items.
//  324     for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
        MOV       R6,#0x79
??initNV_14:
        MOV       A,R6
        CLR       C
        SUBB      A,#0x7f
        JNC       ??initNV_13
//  325     {
//  326       (void)initPage( pg, OSAL_NV_ITEM_NULL, FALSE );
        ; Setup parameters for call to function initPage
        MOV       R4,#0x0
        MOV       R2,#0x0
        MOV       R3,#0x0
        MOV       A,R6
        MOV       R1,A
        LCALL     `??initPage::?relay`; Banked call to: initPage
        MOV       ?V2,R2
        MOV       ?V3,R3
        MOV       R0,?V2
        MOV       R1,?V3
//  327     }
        INC       R6
        SJMP      ??initNV_14
//  328   }
//  329 
//  330   if ( pgRes == OSAL_NV_PAGE_NULL )
??initNV_13:
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        JZ        $+5
        LJMP      ??initNV_15 & 0xFFFF
//  331   {
//  332     uint8 idx, mostLost = 0;
        MOV       ?V2,#0x0
//  333 
//  334     for ( idx = 0; idx < OSAL_NV_PAGES_USED; idx++ )
        MOV       ?V1,#0x0
??initNV_16:
        MOV       A,?V1
        CLR       C
        SUBB      A,#0x6
        JC        $+5
        LJMP      ??initNV_17 & 0xFFFF
//  335     {
//  336       // Is this the page that was compacted?
//  337       if (pgLost[idx] == (OSAL_NV_PAGE_SIZE - OSAL_NV_PAGE_HDR_SIZE))
        MOV       A,?V1
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#pgLost & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(pgLost >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        XRL       A,#0xf8
        JNZ       ??initNV_18
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0x7
??initNV_18:
        JNZ       ??initNV_19
//  338       {
//  339         mostLost = idx;
        MOV       ?V2,?V1
//  340         break;
        SJMP      ??initNV_17
//  341       }
//  342       /* This check is not expected to be necessary because the above test should always succeed
//  343        * with an early loop exit.
//  344        */
//  345       else if (pgLost[idx] > pgLost[mostLost])
??initNV_19:
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#pgLost & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(pgLost >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        PUSH      DPL
          CFI CFA_SP SP+-1
        PUSH      DPH
          CFI CFA_SP SP+-2
        MOV       A,?V1
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#pgLost & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(pgLost >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        POP       DPH
          CFI CFA_SP SP+-1
        POP       DPL
          CFI CFA_SP SP+0
        CLR       C
        MOVX      A,@DPTR
        SUBB      A,R0
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,R1
        JNC       ??initNV_20
//  346       {
//  347         mostLost = idx;
        MOV       ?V2,?V1
//  348       }
//  349     }
??initNV_20:
        INC       ?V1
        LJMP      ??initNV_16 & 0xFFFF
//  350 
//  351     pgRes = mostLost + OSAL_NV_PAGE_BEG;
??initNV_17:
        MOV       A,#0x79
        ADD       A,?V2
        MOV       DPTR,#pgRes
        MOVX      @DPTR,A
//  352     erasePage( pgRes );  // The last page erase had been interrupted by a power-cycle.
        ; Setup parameters for call to function erasePage
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
//  353   }
//  354 
//  355   return TRUE;
??initNV_15:
        MOV       R1,#0x1
        MOV       A,#0x8
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV       R7,#0x4
        LJMP      ?BANKED_LEAVE_XDATA
//  356 }
          CFI EndBlock cfiBlock0
//  357 
//  358 /*********************************************************************
//  359  * @fn      setPageUse
//  360  *
//  361  * @brief   Set page header active/inUse state according to 'inUse'.
//  362  *
//  363  * @param   pg - Valid NV page to verify and init.
//  364  * @param   inUse - Boolean TRUE if inUse, FALSE if only active.
//  365  *
//  366  * @return  none
//  367  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  368 static void setPageUse( uint8 pg, uint8 inUse )
setPageUse:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function setPageUse
        CODE
//  369 {
        FUNCALL setPageUse, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 8
        MOV       A,#-0x8
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 17)
        MOV       A,R1
        MOV       R6,A
        MOV       A,R2
        MOV       R7,A
//  370   osalNvPgHdr_t pgHdr;
//  371 
//  372   pgHdr.active = OSAL_NV_ZEROED_ID;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
//  373 
//  374   if ( inUse )
        MOV       A,R7
        JZ        ??setPageUse_0
//  375   {
//  376     pgHdr.inUse = OSAL_NV_ZEROED_ID;
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOV       A,#0x0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
        SJMP      ??setPageUse_1
//  377   }
//  378   else
//  379   {
//  380     pgHdr.inUse = OSAL_NV_ERASED_ID;
??setPageUse_0:
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOV       A,#-0x1
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#-0x1
        MOVX      @DPTR,A
//  381   }
//  382 
//  383   writeWord( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8*)(&pgHdr) );
??setPageUse_1:
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R2,#0x0
        MOV       R3,#0x0
        MOV       A,R6
        MOV       R1,A
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
//  384 }
        MOV       A,#0x8
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 9)
        MOV       R7,#0x1
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock1
//  385 
//  386 /*********************************************************************
//  387  * @fn      initPage
//  388  *
//  389  * @brief   Walk the page items; calculate checksums, lost bytes & page offset.
//  390  *
//  391  * @param   pg - Valid NV page to verify and init.
//  392  * @param   id - Valid NV item Id to use function as a "findItem".
//  393  *               If set to NULL then just perform the page initialization.
//  394  * @param   findDups - TRUE on recursive call from initNV() to find and zero-out duplicate items
//  395  *                     left from a write that is interrupted by a reset/power-cycle.
//  396  *                     FALSE otherwise.
//  397  *
//  398  * @return  If 'id' is non-NULL and good checksums are found, return the offset
//  399  *          of the data corresponding to item Id; else OSAL_NV_ITEM_NULL.
//  400  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  401 static uint16 initPage( uint8 pg, uint16 id, uint8 findDups )
initPage:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function initPage
        CODE
//  402 {
        FUNCALL initPage, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initPage, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initPage, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initPage, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initPage, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        REQUIRE ?V10
        REQUIRE ?V11
        MOV       A,#-0x14
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 8
        MOV       A,#-0x8
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV       ?V2,R1
        MOV       ?V4,R2
        MOV       ?V5,R3
        MOV       ?V3,R4
//  403   uint16 offset = OSAL_NV_PAGE_HDR_SIZE;
        MOV       R6,#0x8
        MOV       R7,#0x0
//  404   uint16 sz, lost = 0;
        MOV       ?V0,#0x0
        MOV       ?V1,#0x0
//  405   osalNvHdr_t hdr;
//  406 
//  407   do
//  408   {
//  409     HalFlashRead(pg, offset, (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
??initPage_0:
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V6,#0x8
        MOV       ?V7,#0x0
        MOV       R0,#?V6
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V2
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
//  410 
//  411     if ( hdr.id == OSAL_NV_ERASED_ID )
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??initPage_1
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??initPage_1:
        JNZ       $+5
        LJMP      ??initPage_2 & 0xFFFF
//  412     {
//  413       break;
//  414     }
//  415 
//  416     // Get the actual size in bytes which is the ceiling(hdr.len)
//  417     sz = OSAL_NV_DATA_SIZE( hdr.len );
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        CLR       C
        MOVX      A,@DPTR
        SUBB      A,#-0x4
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,#-0x1
        JC        ??initPage_3
        MOV       ?V8,#-0x4
        MOV       ?V9,#-0x1
        SJMP      ??initPage_4
??initPage_3:
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        ADD       A,#0x3
        MOV       ?V8,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,#0x0
        MOV       ?V9,A
        MOV       A,#0x2
        MOV       R0,#?V8
        LCALL     ?US_SHR
        MOV       A,?V8
        MOV       B,#0x4
        MUL       AB
        XCH       A,?V8
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x4
        MOV       A,?V9
        MUL       AB
        ADD       A,R0
        MOV       ?V9,A
//  418 
//  419     // A bad 'len' write has blown away the rest of the page.
//  420     if (sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - offset))
??initPage_4:
        MOV       A,#-0x8
        CLR       C
        SUBB      A,R6
        MOV       R0,A
        MOV       A,#0x7
        SUBB      A,R7
        MOV       R1,A
        CLR       C
        MOV       A,R0
        SUBB      A,?V8
        MOV       A,R1
        SUBB      A,?V9
        JNC       ??initPage_5
//  421     {
//  422       lost += (OSAL_NV_PAGE_SIZE - offset);
        MOV       A,?V0
        ADD       A,#0x0
        MOV       ?V0,A
        MOV       A,?V1
        ADDC      A,#0x8
        MOV       ?V1,A
        CLR       C
        MOV       A,?V0
        SUBB      A,R6
        MOV       ?V0,A
        MOV       A,?V1
        SUBB      A,R7
        MOV       ?V1,A
//  423       offset = OSAL_NV_PAGE_SIZE;
        MOV       R6,#0x0
        MOV       R7,#0x8
//  424       break;
        LJMP      ??initPage_2 & 0xFFFF
//  425     }
//  426 
//  427     offset += OSAL_NV_HDR_SIZE;
??initPage_5:
        MOV       A,R6
        ADD       A,#0x8
        MOV       R6,A
        MOV       A,R7
        ADDC      A,#0x0
        MOV       R7,A
//  428 
//  429     if ( hdr.id != OSAL_NV_ZEROED_ID )
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,R0
        ORL       A,R1
        JNZ       $+5
        LJMP      ??initPage_6 & 0xFFFF
//  430     {
//  431       /* This trick allows function to do double duty for findItem() without
//  432        * compromising its essential functionality at powerup initialization.
//  433        */
//  434       if ( id != OSAL_NV_ITEM_NULL )
        MOV       A,?V4
        ORL       A,?V5
        JZ        ??initPage_7
//  435       {
//  436         /* This trick allows asking to find the old/transferred item in case
//  437          * of a successful new item write that gets interrupted before the
//  438          * old item can be zeroed out.
//  439          */
//  440         if ( (id & 0x7fff) == hdr.id )
        MOV       A,?V4
        ANL       A,#0xff
        MOV       R0,A
        MOV       A,?V5
        ANL       A,#0x7f
        MOV       R1,A
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??initPage_8
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??initPage_8:
        JZ        $+5
        LJMP      ??initPage_9 & 0xFFFF
//  441         {
//  442           if ( (((id & OSAL_NV_SOURCE_ID) == 0) && (hdr.stat == OSAL_NV_ERASED_ID)) ||
//  443                (((id & OSAL_NV_SOURCE_ID) != 0) && (hdr.stat != OSAL_NV_ERASED_ID)) )
        MOV       A,?V4
        ANL       A,#0x0
        MOV       R0,A
        MOV       A,?V5
        ANL       A,#0x80
        MOV       R1,A
        MOV       A,R0
        ORL       A,R1
        JNZ       ??initPage_10
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??initPage_11
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??initPage_11:
        JZ        ??initPage_12
??initPage_10:
        MOV       A,?V4
        ANL       A,#0x0
        MOV       R0,A
        MOV       A,?V5
        ANL       A,#0x80
        MOV       R1,A
        MOV       A,R0
        ORL       A,R1
        JNZ       $+5
        LJMP      ??initPage_9 & 0xFFFF
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??initPage_13
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??initPage_13:
        JNZ       $+5
        LJMP      ??initPage_9 & 0xFFFF
//  444           {
//  445             return offset;
??initPage_12:
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LJMP      ??initPage_14 & 0xFFFF
//  446           }
//  447         }
//  448       }
//  449       // When invoked from the osal_nv_init(), verify checksums and find & zero any duplicates.
//  450       else
//  451       {
//  452         if ( hdr.chk == calcChkF( pg, offset, hdr.len ) )
??initPage_7:
        ; Setup parameters for call to function calcChkF
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V2
        LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
        MOV       ?V6,R2
        MOV       ?V7,R3
        MOV       R0,?V6
        MOV       R1,?V7
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??initPage_15
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??initPage_15:
        JNZ       ??initPage_16
//  453         {
//  454           if ( findDups )
        MOV       A,?V3
        JZ        ??initPage_17
//  455           {
//  456             if ( hdr.stat == OSAL_NV_ERASED_ID )
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??initPage_18
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??initPage_18:
        JNZ       ??initPage_9
//  457             {
//  458               /* The trick of setting the MSB of the item Id causes the logic
//  459                * immediately above to return a valid page only if the header 'stat'
//  460                * indicates that it was the older item being transferred.
//  461                */
//  462               uint16 off = findItem( (hdr.id | OSAL_NV_SOURCE_ID) );
        ; Setup parameters for call to function findItem
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        ORL       A,#0x0
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        ORL       A,#0x80
        MOV       R3,A
        LCALL     `??findItem::?relay`; Banked call to: findItem
        MOV       ?V10,R2
        MOV       ?V11,R3
        MOV       ?V6,?V10
        MOV       ?V7,?V11
//  463 
//  464               if ( off != OSAL_NV_ITEM_NULL )
        MOV       A,?V6
        ORL       A,?V7
        JZ        ??initPage_9
//  465               {
//  466                 setItem( findPg, off, eNvZero );  // Mark old duplicate as invalid.
        ; Setup parameters for call to function setItem
        MOV       R4,#0x1
        MOV       R2,?V6
        MOV       R3,?V7
        MOV       DPTR,#findPg
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??setItem::?relay`; Banked call to: setItem
        SJMP      ??initPage_9
//  467               }
//  468             }
//  469           }
//  470           // Any "old" item immediately exits and triggers the N^2 exhaustive initialization.
//  471           else if ( hdr.stat != OSAL_NV_ERASED_ID )
??initPage_17:
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??initPage_19
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??initPage_19:
        JZ        ??initPage_9
//  472           {
//  473             return OSAL_NV_ERASED_ID;
        MOV       R2,#-0x1
        MOV       R3,#-0x1
        LJMP      ??initPage_14 & 0xFFFF
//  474           }
//  475         }
//  476         else
//  477         {
//  478           setItem( pg, offset, eNvZero );  // Mark bad checksum as invalid.
??initPage_16:
        ; Setup parameters for call to function setItem
        MOV       R4,#0x1
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V2
        LCALL     `??setItem::?relay`; Banked call to: setItem
//  479           lost += (OSAL_NV_HDR_SIZE + sz);
        MOV       A,?V8
        ADD       A,#0x8
        MOV       R0,A
        CLR       A
        ADDC      A,?V9
        MOV       R1,A
        MOV       A,?V0
        ADD       A,R0
        MOV       ?V0,A
        MOV       A,?V1
        ADDC      A,R1
        MOV       ?V1,A
        SJMP      ??initPage_9
//  480         }
//  481       }
//  482     }
//  483     else
//  484     {
//  485       lost += (OSAL_NV_HDR_SIZE + sz);
??initPage_6:
        MOV       A,?V8
        ADD       A,#0x8
        MOV       R0,A
        CLR       A
        ADDC      A,?V9
        MOV       R1,A
        MOV       A,?V0
        ADD       A,R0
        MOV       ?V0,A
        MOV       A,?V1
        ADDC      A,R1
        MOV       ?V1,A
//  486     }
//  487     offset += sz;
??initPage_9:
        MOV       A,R6
        ADD       A,?V8
        MOV       R6,A
        MOV       A,R7
        ADDC      A,?V9
        MOV       R7,A
//  488 
//  489   } while (offset < (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE));
        CLR       C
        MOV       A,R6
        SUBB      A,#-0x8
        MOV       A,R7
        SUBB      A,#0x7
        JNC       $+5
        LJMP      ??initPage_0 & 0xFFFF
//  490 
//  491   pgOff[pg - OSAL_NV_PAGE_BEG] = offset;
??initPage_2:
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOV       A,R6
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R7
        MOVX      @DPTR,A
//  492   pgLost[pg - OSAL_NV_PAGE_BEG] = lost;
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgLost + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgLost - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOV       A,?V0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,?V1
        MOVX      @DPTR,A
//  493 
//  494   return OSAL_NV_ITEM_NULL;
        MOV       R2,#0x0
        MOV       R3,#0x0
??initPage_14:
        MOV       A,#0x8
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV       R7,#0xc
        LJMP      ?BANKED_LEAVE_XDATA
//  495 }
          CFI EndBlock cfiBlock2
//  496 
//  497 /*********************************************************************
//  498  * @fn      erasePage
//  499  *
//  500  * @brief   Erases a page in Flash.
//  501  *
//  502  * @param   pg - Valid NV page to erase.
//  503  *
//  504  * @return  none
//  505  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  506 static void erasePage( uint8 pg )
erasePage:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function erasePage
        CODE
//  507 {
        FUNCALL erasePage, HalFlashErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV       A,R1
        MOV       R6,A
//  508   HalFlashErase(pg);
        ; Setup parameters for call to function HalFlashErase
        MOV       A,R6
        MOV       R1,A
        LCALL     `??HalFlashErase::?relay`; Banked call to: HalFlashErase
//  509 
//  510   pgOff[pg - OSAL_NV_PAGE_BEG] = OSAL_NV_PAGE_HDR_SIZE;
        MOV       A,R6
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOV       A,#0x8
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
//  511   pgLost[pg - OSAL_NV_PAGE_BEG] = 0;
        MOV       A,R6
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgLost + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgLost - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOV       A,#0x0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
//  512 }
        MOV       R7,#0x1
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock3
//  513 
//  514 /*********************************************************************
//  515  * @fn      compactPage
//  516  *
//  517  * @brief   Compacts the page specified.
//  518  *
//  519  * @param   srcPg - Valid NV page to erase.
//  520  * @param   skipId - Item Id to not compact.
//  521  *
//  522  * @return  TRUE if valid items from 'srcPg' are successully compacted onto the 'pgRes';
//  523  *          FALSE otherwise.
//  524  *          Note that on a failure, this could loop, re-erasing the 'pgRes' and re-compacting with
//  525  *          the risk of infinitely looping on HAL flash failure.
//  526  *          Worst case scenario: HAL flash starts failing in general, perhaps low Vdd?
//  527  *          All page compactions will fail which will cause all osal_nv_write() calls to return
//  528  *          NV_OPER_FAILED.
//  529  *          Eventually, all pages in use may also be in the state of "pending compaction" where
//  530  *          the page header member OSAL_NV_PG_XFER is zeroed out.
//  531  *          During this "HAL flash brown-out", the code will run and OTA should work (until low Vdd
//  532  *          causes an actual chip brown-out, of course.) Although no new NV items will be created
//  533  *          or written, the last value written with a return value of SUCCESS can continue to be
//  534  *          read successfully.
//  535  *          If eventually HAL flash starts working again, all of the pages marked as
//  536  *          "pending compaction" may or may not be eventually compacted. But, initNV() will
//  537  *          deterministically clean-up one page pending compaction per power-cycle
//  538  *          (if HAL flash is working.) Nevertheless, one erased reserve page will be maintained
//  539  *          through such a scenario.
//  540  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  541 static uint8 compactPage( uint8 srcPg, uint16 skipId )
compactPage:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function compactPage
        CODE
//  542 {
        FUNCALL compactPage, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, writeItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, xferBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 31, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 31, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, setChk
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, hotItemUpdate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, setPageUse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        MOV       A,#-0x12
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 9
        MOV       A,#-0x9
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 27)
        MOV       ?V0,R1
        MOV       ?V2,R2
        MOV       ?V3,R3
//  543   uint16 srcOff;
//  544   uint8 rtrn;
//  545 
//  546   // To minimize code size, only check for a clean page here where it's absolutely required.
//  547   for (srcOff = 0; srcOff < OSAL_NV_PAGE_SIZE; srcOff++)
        MOV       R6,#0x0
        MOV       R7,#0x0
??compactPage_0:
        CLR       C
        MOV       A,R6
        SUBB      A,#0x0
        MOV       A,R7
        SUBB      A,#0x8
        JNC       ??compactPage_1
//  548   {
//  549     HalFlashRead(pgRes, srcOff, &rtrn, 1);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V4,#0x1
        MOV       ?V5,#0x0
        MOV       R0,#?V4
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 29)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 27)
//  550     if (rtrn != OSAL_NV_ERASED)
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        XRL       A,#0xff
        JZ        ??compactPage_2
//  551     {
//  552       erasePage(pgRes);
        ; Setup parameters for call to function erasePage
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
//  553       return FALSE;
        MOV       R1,#0x0
        LJMP      ??compactPage_3 & 0xFFFF
//  554     }
//  555   }
??compactPage_2:
        INC       R6
        MOV       A,R6
        JNZ       ??compactPage_0
        INC       R7
        SJMP      ??compactPage_0
//  556 
//  557   srcOff = OSAL_NV_PAGE_HDR_SIZE;
??compactPage_1:
        MOV       R6,#0x8
        MOV       R7,#0x0
//  558   rtrn = TRUE;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x1
        MOVX      @DPTR,A
//  559 
//  560   while ( srcOff < (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE ) )
??compactPage_4:
        CLR       C
        MOV       A,R6
        SUBB      A,#-0x8
        MOV       A,R7
        SUBB      A,#0x7
        JC        $+5
        LJMP      ??compactPage_5 & 0xFFFF
//  561   {
//  562     osalNvHdr_t hdr;
//  563     uint16 sz, dstOff = pgOff[pgRes-OSAL_NV_PAGE_BEG];
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       ?V6,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V7,A
//  564 
//  565     HalFlashRead(srcPg, srcOff, (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V8,#0x8
        MOV       ?V9,#0x0
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 29)
        MOV       A,#0x3
        LCALL     ?XSTACK_DISP102_8
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V0
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 27)
//  566 
//  567     if ( hdr.id == OSAL_NV_ERASED_ID )
        MOV       A,#0x1
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??compactPage_6
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??compactPage_6:
        JNZ       $+5
        LJMP      ??compactPage_5 & 0xFFFF
//  568     {
//  569       break;
//  570     }
//  571 
//  572     // Get the actual size in bytes which is the ceiling(hdr.len)
//  573     sz = OSAL_NV_DATA_SIZE( hdr.len );
        MOV       A,#0x3
        LCALL     ?XSTACK_DISP0_8
        CLR       C
        MOVX      A,@DPTR
        SUBB      A,#-0x4
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,#-0x1
        JC        ??compactPage_7
        MOV       ?V4,#-0x4
        MOV       ?V5,#-0x1
        SJMP      ??compactPage_8
??compactPage_7:
        MOV       A,#0x3
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        ADD       A,#0x3
        MOV       ?V4,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,#0x0
        MOV       ?V5,A
        MOV       A,#0x2
        MOV       R0,#?V4
        LCALL     ?US_SHR
        MOV       A,?V4
        MOV       B,#0x4
        MUL       AB
        XCH       A,?V4
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x4
        MOV       A,?V5
        MUL       AB
        ADD       A,R0
        MOV       ?V5,A
//  574 
//  575     if ( sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - srcOff) )
??compactPage_8:
        MOV       A,#-0x8
        CLR       C
        SUBB      A,R6
        MOV       R0,A
        MOV       A,#0x7
        SUBB      A,R7
        MOV       R1,A
        CLR       C
        MOV       A,R0
        SUBB      A,?V4
        MOV       A,R1
        SUBB      A,?V5
        JNC       $+5
        LJMP      ??compactPage_5 & 0xFFFF
//  576     {
//  577       break;
//  578     }
//  579 
//  580     if ( sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - dstOff) )
        MOV       A,#-0x8
        CLR       C
        SUBB      A,?V6
        MOV       R0,A
        MOV       A,#0x7
        SUBB      A,?V7
        MOV       R1,A
        CLR       C
        MOV       A,R0
        SUBB      A,?V4
        MOV       A,R1
        SUBB      A,?V5
        JNC       ??compactPage_9
//  581     {
//  582       rtrn = FALSE;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x0
        MOVX      @DPTR,A
//  583       break;
        LJMP      ??compactPage_5 & 0xFFFF
//  584     }
//  585 
//  586     srcOff += OSAL_NV_HDR_SIZE;
??compactPage_9:
        MOV       A,R6
        ADD       A,#0x8
        MOV       R6,A
        MOV       A,R7
        ADDC      A,#0x0
        MOV       R7,A
//  587 
//  588     if ( (hdr.id != OSAL_NV_ZEROED_ID) && (hdr.id != skipId) )
        MOV       A,#0x1
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,R0
        ORL       A,R1
        JNZ       $+5
        LJMP      ??compactPage_10 & 0xFFFF
        MOV       A,#0x1
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,?V2
        JNZ       ??compactPage_11
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,?V3
??compactPage_11:
        JNZ       $+5
        LJMP      ??compactPage_10 & 0xFFFF
//  589     {
//  590       if ( hdr.chk == calcChkF( srcPg, srcOff, hdr.len ) )
        ; Setup parameters for call to function calcChkF
        MOV       A,#0x3
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V0
        LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
        MOV       ?V8,R2
        MOV       ?V9,R3
        MOV       R0,?V8
        MOV       R1,?V9
        MOV       A,#0x5
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??compactPage_12
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??compactPage_12:
        JZ        $+5
        LJMP      ??compactPage_10 & 0xFFFF
//  591       {
//  592         /* Prevent excessive re-writes to item header caused by numerous, rapid, & successive
//  593          * OSAL_Nv interruptions caused by resets.
//  594          */
//  595         if ( hdr.stat == OSAL_NV_ERASED_ID )
        MOV       A,#0x7
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??compactPage_13
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??compactPage_13:
        JNZ       ??compactPage_14
//  596         {
//  597           setItem( srcPg, srcOff, eNvXfer );
        ; Setup parameters for call to function setItem
        MOV       R4,#0x0
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V0
        LCALL     `??setItem::?relay`; Banked call to: setItem
//  598         }
//  599 
//  600         if ( writeItem( pgRes, hdr.id, hdr.len, NULL, FALSE ) )
??compactPage_14:
        ; Setup parameters for call to function writeItem
        MOV       ?V1,#0x0
        MOV       R0,#?V1
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 28)
        CLR       A
        MOV       ?V8,A
        MOV       ?V9,A
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R3,A
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??writeItem::?relay`; Banked call to: writeItem
        MOV       A,#0x3
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 27)
        MOV       A,R1
        JNZ       $+5
        LJMP      ??compactPage_15 & 0xFFFF
//  601         {
//  602           dstOff += OSAL_NV_HDR_SIZE;
        MOV       A,?V6
        ADD       A,#0x8
        MOV       ?V6,A
        MOV       A,?V7
        ADDC      A,#0x0
        MOV       ?V7,A
//  603           xferBuf( srcPg, srcOff, pgRes, dstOff, sz );
        ; Setup parameters for call to function xferBuf
        MOV       R0,#?V4
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 29)
        MOV       R0,#?V6
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 31)
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R4,A
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V0
        LCALL     `??xferBuf::?relay`; Banked call to: xferBuf
        MOV       A,#0x4
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 27)
//  604           // Calculate and write the new checksum.
//  605           if (hdr.chk == calcChkF(pgRes, dstOff, hdr.len))
        ; Setup parameters for call to function calcChkF
        MOV       A,#0x3
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       R2,?V6
        MOV       R3,?V7
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
        MOV       ?V8,R2
        MOV       ?V9,R3
        MOV       R0,?V8
        MOV       R1,?V9
        MOV       A,#0x5
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??compactPage_16
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??compactPage_16:
        JNZ       ??compactPage_17
//  606           {
//  607             if ( hdr.chk != setChk( pgRes, dstOff, hdr.chk ) )
        ; Setup parameters for call to function setChk
        MOV       A,#0x5
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       R2,?V6
        MOV       R3,?V7
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??setChk::?relay`; Banked call to: setChk
        MOV       ?V8,R2
        MOV       ?V9,R3
        MOV       R0,?V8
        MOV       R1,?V9
        MOV       A,#0x5
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??compactPage_18
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??compactPage_18:
        JZ        ??compactPage_19
//  608             {
//  609               rtrn = FALSE;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x0
        MOVX      @DPTR,A
//  610               break;
        SJMP      ??compactPage_5
//  611             }
//  612             else
//  613             {
//  614               hotItemUpdate(pgRes, dstOff, hdr.id);
??compactPage_19:
        ; Setup parameters for call to function hotItemUpdate
        MOV       A,#0x1
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       R2,?V6
        MOV       R3,?V7
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??hotItemUpdate::?relay`; Banked call to: hotItemUpdate
        SJMP      ??compactPage_10
//  615             }
//  616           }
//  617           else
//  618           {
//  619             rtrn = FALSE;
??compactPage_17:
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x0
        MOVX      @DPTR,A
//  620             break;
        SJMP      ??compactPage_5
//  621           }
//  622         }
//  623         else
//  624         {
//  625           rtrn = FALSE;
??compactPage_15:
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x0
        MOVX      @DPTR,A
//  626           break;
        SJMP      ??compactPage_5
//  627         }
//  628       }
//  629     }
//  630 
//  631     srcOff += sz;
??compactPage_10:
        MOV       A,R6
        ADD       A,?V4
        MOV       R6,A
        MOV       A,R7
        ADDC      A,?V5
        MOV       R7,A
        LJMP      ??compactPage_4 & 0xFFFF
//  632   }
//  633 
//  634   if (rtrn == FALSE)
??compactPage_5:
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        JNZ       ??compactPage_20
//  635   {
//  636     erasePage(pgRes);
        ; Setup parameters for call to function erasePage
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
        SJMP      ??compactPage_21
//  637   }
//  638   else if (skipId == OSAL_NV_ITEM_NULL)
??compactPage_20:
        MOV       A,?V2
        ORL       A,?V3
        JNZ       ??compactPage_21
//  639   {
//  640     COMPACT_PAGE_CLEANUP(srcPg);
        ; Setup parameters for call to function setPageUse
        MOV       R2,#0x1
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??setPageUse::?relay`; Banked call to: setPageUse
        ; Setup parameters for call to function erasePage
        MOV       R1,?V0
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
        MOV       A,?V0
        MOV       DPTR,#pgRes
        MOVX      @DPTR,A
//  641   }
//  642   // else invoking function must cleanup.
//  643 
//  644   return rtrn;
??compactPage_21:
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        MOV       R1,A
??compactPage_3:
        MOV       A,#0x9
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV       R7,#0xa
        LJMP      ?BANKED_LEAVE_XDATA
//  645 }
          CFI EndBlock cfiBlock4
//  646 
//  647 /*********************************************************************
//  648  * @fn      findItem
//  649  *
//  650  * @brief   Find an item Id in NV and return the page and offset to its data.
//  651  *
//  652  * @param   id - Valid NV item Id.
//  653  *
//  654  * @return  Offset of data corresponding to item Id, if found;
//  655  *          otherwise OSAL_NV_ITEM_NULL.
//  656  *
//  657  *          The page containing the item, if found;
//  658  *          otherwise no valid assignment made - left equal to item Id.
//  659  *
//  660  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  661 static uint16 findItem( uint16 id )
findItem:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function findItem
        CODE
//  662 {
        FUNCALL findItem, initPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL findItem, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V4
        REQUIRE ?V5
        MOV       A,#-0xe
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
//  663   uint16 off;
//  664   uint8 pg;
//  665 
//  666   for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
        MOV       ?V2,#0x79
??findItem_0:
        MOV       A,?V2
        CLR       C
        SUBB      A,#0x7f
        JNC       ??findItem_1
//  667   {
//  668     if ( (off = initPage( pg, id, FALSE )) != OSAL_NV_ITEM_NULL )
        ; Setup parameters for call to function initPage
        MOV       R4,#0x0
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V2
        LCALL     `??initPage::?relay`; Banked call to: initPage
        MOV       ?V4,R2
        MOV       ?V5,R3
        MOV       R0,?V4
        MOV       R1,?V5
        MOV       ?V0,R0
        MOV       ?V1,R1
        MOV       A,R0
        ORL       A,R1
        JZ        ??findItem_2
//  669     {
//  670       findPg = pg;
        MOV       A,?V2
        MOV       DPTR,#findPg
        MOVX      @DPTR,A
//  671       return off;
        MOV       R2,?V0
        MOV       R3,?V1
        SJMP      ??findItem_3
//  672     }
//  673   }
??findItem_2:
        INC       ?V2
        SJMP      ??findItem_0
//  674 
//  675   // Now attempt to find the item as the "old" item of a failed/interrupted NV write.
//  676   if ( (id & OSAL_NV_SOURCE_ID) == 0 )
??findItem_1:
        MOV       A,R6
        ANL       A,#0x0
        MOV       R0,A
        MOV       A,R7
        ANL       A,#0x80
        MOV       R1,A
        MOV       A,R0
        ORL       A,R1
        JNZ       ??findItem_4
//  677   {
//  678     return findItem( id | OSAL_NV_SOURCE_ID );
        ; Setup parameters for call to function findItem
        MOV       A,R6
        ORL       A,#0x0
        MOV       R2,A
        MOV       A,R7
        ORL       A,#0x80
        MOV       R3,A
        LCALL     `??findItem::?relay`; Banked call to: findItem
        SJMP      ??findItem_3
//  679   }
//  680   else
//  681   {
//  682     findPg = OSAL_NV_PAGE_NULL;
??findItem_4:
        MOV       DPTR,#findPg
        MOV       A,#0x0
        MOVX      @DPTR,A
//  683     return OSAL_NV_ITEM_NULL;
        MOV       R2,#0x0
        MOV       R3,#0x0
??findItem_3:
        MOV       R7,#0x6
        LJMP      ?BANKED_LEAVE_XDATA
//  684   }
//  685 }
          CFI EndBlock cfiBlock5
//  686 
//  687 /*********************************************************************
//  688  * @fn      initItem
//  689  *
//  690  * @brief   An NV item is created and initialized with the data passed to the function, if any.
//  691  *
//  692  * @param   flag - TRUE if the 'buf' parameter contains data for the call to writeItem().
//  693  *                 (i.e. if invoked from osal_nv_item_init() ).
//  694  *                 FALSE if writeItem() should just write the header and the 'buf' parameter
//  695  *                 is ok to use as a return value of the page number to be cleaned with
//  696  *                 COMPACT_PAGE_CLEANUP().
//  697  *                 (i.e. if invoked from osal_nv_write() ).
//  698  * @param   id  - Valid NV item Id.
//  699  * @param   len - Item data length.
//  700  * @param  *buf - Pointer to item initalization data. Set to NULL if none.
//  701  *
//  702  * @return  The OSAL Nv page number if item write and read back checksums ok;
//  703  *          OSAL_NV_PAGE_NULL otherwise.
//  704  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  705 static uint8 initItem( uint8 flag, uint16 id, uint16 len, void *buf )
initItem:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function initItem
        CODE
//  706 {
        FUNCALL initItem, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initItem, writeWordH
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initItem, compactPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initItem, writeItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 31, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 31, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initItem, setPageUse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initItem, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initItem, writeItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 31, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 31, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        MOV       A,#-0x12
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 10
        MOV       A,#-0xa
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV       ?V1,R1
        MOV       ?V4,R2
        MOV       ?V5,R3
        MOV       ?V2,R4
        MOV       ?V3,R5
        MOV       A,#0x1c
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V6,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V7,A
//  707   uint16 sz = OSAL_NV_ITEM_SIZE( len );
        CLR       C
        MOV       A,?V2
        SUBB      A,#-0xc
        MOV       A,?V3
        SUBB      A,#-0x1
        JC        ??initItem_0
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#-0x4
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#-0x1
        MOVX      @DPTR,A
        SJMP      ??initItem_1
??initItem_0:
        MOV       A,?V2
        ADD       A,#0x3
        MOV       ?V8,A
        CLR       A
        ADDC      A,?V3
        MOV       ?V9,A
        MOV       A,#0x2
        MOV       R0,#?V8
        LCALL     ?US_SHR
        MOV       A,?V8
        MOV       B,#0x4
        MUL       AB
        XCH       A,?V8
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x4
        MOV       A,?V9
        MUL       AB
        ADD       A,R0
        MOV       ?V9,A
        MOV       A,?V8
        ADD       A,#0x8
        MOV       R0,A
        CLR       A
        ADDC      A,?V9
        MOV       R1,A
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,R0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R1
        MOVX      @DPTR,A
//  708   uint8 rtrn = OSAL_NV_PAGE_NULL;
??initItem_1:
        MOV       R7,#0x0
//  709   uint8 cnt = OSAL_NV_PAGES_USED;
        MOV       ?V0,#0x6
//  710   uint8 pg = pgRes+1;  // Set to 1 after the reserve page to even wear across all available pages.
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        ADD       A,#0x1
        MOV       R6,A
//  711 
//  712   do {
//  713     if (pg >= OSAL_NV_PAGE_BEG+OSAL_NV_PAGES_USED)
??initItem_2:
        MOV       A,R6
        CLR       C
        SUBB      A,#0x7f
        JC        ??initItem_3
//  714     {
//  715       pg = OSAL_NV_PAGE_BEG;
        MOV       R6,#0x79
//  716     }
//  717     if ( pg != pgRes )
??initItem_3:
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        XRL       A,R6
        JZ        ??initItem_4
//  718     {
//  719       uint8 idx = pg - OSAL_NV_PAGE_BEG;
        MOV       A,#-0x79
        ADD       A,R6
        MOV       R4,A
//  720       if ( sz <= (OSAL_NV_PAGE_SIZE - pgOff[idx] + pgLost[idx]) )
        MOV       A,R4
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#pgOff & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(pgOff >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,#0x0
        CLR       C
        SUBB      A,R0
        MOV       R0,A
        MOV       A,#0x8
        SUBB      A,R1
        MOV       R1,A
        MOV       A,R4
        MOV       R2,A
        MOV       R3,#0x0
        MOV       A,R2
        MOV       B,#0x2
        MUL       AB
        XCH       A,R2
        MOV       R5,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R5
        MOV       R5,A
        MOV       B,#0x2
        MOV       A,R3
        MUL       AB
        ADD       A,R5
        MOV       R3,A
        MOV       A,#pgLost & 0xff
        ADD       A,R2
        MOV       DPL,A
        MOV       A,#(pgLost >> 8) & 0xff
        ADDC      A,R3
        MOV       DPH,A
        MOVX      A,@DPTR
        ADD       A,R0
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,R1
        MOV       R3,A
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        CLR       C
        MOV       A,R2
        SUBB      A,R0
        MOV       A,R3
        SUBB      A,R1
        JNC       ??initItem_5
//  721       {
//  722         break;
//  723       }
//  724     }
//  725     pg++;
??initItem_4:
        INC       R6
//  726   } while (--cnt);
        DEC       ?V0
        MOV       A,?V0
        JZ        $+5
        LJMP      ??initItem_2 & 0xFFFF
//  727 
//  728   if (cnt)
??initItem_5:
        MOV       A,?V0
        JNZ       $+5
        LJMP      ??initItem_6 & 0xFFFF
//  729   {
//  730     // Item fits if an old page is compacted.
//  731     if ( sz > (OSAL_NV_PAGE_SIZE - pgOff[pg - OSAL_NV_PAGE_BEG]) )
        MOV       A,R6
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,#0x0
        CLR       C
        SUBB      A,R0
        MOV       R2,A
        MOV       A,#0x8
        SUBB      A,R1
        MOV       R3,A
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        CLR       C
        MOV       A,R2
        SUBB      A,R0
        MOV       A,R3
        SUBB      A,R1
        JC        $+5
        LJMP      ??initItem_7 & 0xFFFF
//  732     {
//  733       osalNvPgHdr_t pgHdr;
//  734 
//  735       /* Prevent excessive re-writes to page header caused by numerous, rapid, & successive
//  736        * OSAL_Nv interruptions caused by resets.
//  737        */
//  738       HalFlashRead(pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr), OSAL_NV_PAGE_HDR_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V8,#0x8
        MOV       ?V9,#0x0
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,#0x0
        MOV       R3,#0x0
        MOV       A,R6
        MOV       R1,A
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
//  739       if ( pgHdr.xfer == OSAL_NV_ERASED_ID )
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??initItem_8
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??initItem_8:
        JNZ       ??initItem_9
//  740       {
//  741         // Mark the old page as being in process of compaction.
//  742         sz = OSAL_NV_ZEROED_ID;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
//  743         writeWordH( pg, OSAL_NV_PG_XFER, (uint8*)(&sz) );
        ; Setup parameters for call to function writeWordH
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R2,#0x4
        MOV       R3,#0x0
        MOV       A,R6
        MOV       R1,A
        LCALL     `??writeWordH::?relay`; Banked call to: writeWordH
//  744       }
//  745 
//  746       /* First the old page is compacted, then the new item will be the last one written to what
//  747        * had been the reserved page.
//  748        */
//  749       if (compactPage( pg, id ))
??initItem_9:
        ; Setup parameters for call to function compactPage
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       A,R6
        MOV       R1,A
        LCALL     `??compactPage::?relay`; Banked call to: compactPage
        MOV       A,R1
        JZ        ??initItem_6
//  750       {
//  751         if ( writeItem( pgRes, id, len, buf, flag ) )
        ; Setup parameters for call to function writeItem
        MOV       A,?V1
        MOV       ?V8,A
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 29)
        MOV       R0,#?V6
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 31)
        MOV       R4,?V2
        MOV       R5,?V3
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??writeItem::?relay`; Banked call to: writeItem
        MOV       A,#0x3
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV       A,R1
        JZ        ??initItem_10
//  752         {
//  753           rtrn = pgRes;
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R7,A
//  754         }
//  755 
//  756         if ( flag == FALSE )
??initItem_10:
        MOV       A,?V1
        JNZ       ??initItem_11
//  757         {
//  758           /* Overload 'buf' as an OUT parameter to pass back to the calling function
//  759            * the old page to be cleaned up.
//  760            */
//  761           *(uint8 *)buf = pg;
        MOV       A,R6
        PUSH      A
          CFI CFA_SP SP+-1
        MOV       DPL,?V6
        MOV       DPH,?V7
        POP       A
          CFI CFA_SP SP+0
        MOVX      @DPTR,A
        SJMP      ??initItem_6
//  762         }
//  763         else
//  764         {
//  765           /* Safe to do the compacted page cleanup even if writeItem() above failed because the
//  766            * item does not yet exist since this call with flag==TRUE is from osal_nv_item_init().
//  767            */
//  768           COMPACT_PAGE_CLEANUP( pg );
??initItem_11:
        ; Setup parameters for call to function setPageUse
        MOV       R2,#0x1
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??setPageUse::?relay`; Banked call to: setPageUse
        ; Setup parameters for call to function erasePage
        MOV       A,R6
        MOV       R1,A
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
        MOV       A,R6
        MOV       DPTR,#pgRes
        MOVX      @DPTR,A
        SJMP      ??initItem_6
//  769         }
//  770       }
//  771     }
//  772     else
//  773     {
//  774       if ( writeItem( pg, id, len, buf, flag ) )
??initItem_7:
        ; Setup parameters for call to function writeItem
        MOV       A,?V1
        MOV       ?V8,A
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 29)
        MOV       R0,#?V6
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 31)
        MOV       R4,?V2
        MOV       R5,?V3
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       A,R6
        MOV       R1,A
        LCALL     `??writeItem::?relay`; Banked call to: writeItem
        MOV       A,#0x3
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV       A,R1
        JZ        ??initItem_6
//  775       {
//  776         rtrn = pg;
        MOV       A,R6
        MOV       R7,A
//  777       }
//  778     }
//  779   }
//  780 
//  781   return rtrn;
??initItem_6:
        MOV       A,R7
        MOV       R1,A
        MOV       A,#0xa
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV       R7,#0xa
        LJMP      ?BANKED_LEAVE_XDATA
//  782 }
          CFI EndBlock cfiBlock6
//  783 
//  784 /*********************************************************************
//  785  * @fn      setItem
//  786  *
//  787  * @brief   Set an item Id or status to mark its state.
//  788  *
//  789  * @param   pg - Valid NV page.
//  790  * @param   offset - Valid offset into the page of the item data - the header
//  791  *                   offset is calculated from this.
//  792  * @param   stat - Valid enum value for the item status.
//  793  *
//  794  * @return  none
//  795  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  796 static void setItem( uint8 pg, uint16 offset, eNvHdrEnum stat )
setItem:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function setItem
        CODE
//  797 {
        FUNCALL setItem, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL setItem, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL setItem, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV       A,#-0xc
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 8
        MOV       A,#-0x8
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV       ?V2,R1
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
        MOV       ?V3,R4
//  798   osalNvHdr_t hdr;
//  799 
//  800   offset -= OSAL_NV_HDR_SIZE;
        MOV       A,R6
        ADD       A,#-0x8
        MOV       R6,A
        MOV       A,R7
        ADDC      A,#-0x1
        MOV       R7,A
//  801   HalFlashRead(pg, offset, (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V0,#0x8
        MOV       ?V1,#0x0
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V2
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  802 
//  803   if ( stat == eNvXfer )
        MOV       A,?V3
        JNZ       ??setItem_0
//  804   {
//  805     hdr.stat = OSAL_NV_ACTIVE;
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOV       A,#0x0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
//  806     /* Write status to flash. Total of 4 bytes written to Flash 
//  807      * ( 2 bytes of checksum and 2 bytes of status) 
//  808      */
//  809     writeWord( pg, offset+OSAL_NV_HDR_CHK, (uint8*)(&(hdr.chk)) );
        ; Setup parameters for call to function writeWord
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOV       R4,DPL
        MOV       R5,DPH
        MOV       A,R6
        ADD       A,#0x4
        MOV       R2,A
        CLR       A
        ADDC      A,R7
        MOV       R3,A
        MOV       R1,?V2
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
        LJMP      ??setItem_1 & 0xFFFF
//  810   }
//  811   else // if ( stat == eNvZero )
//  812   {
//  813     uint16 sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
//  814                                                                           OSAL_NV_HDR_SIZE;
??setItem_0:
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        ADD       A,#0x3
        MOV       ?V0,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,#0x0
        MOV       ?V1,A
        MOV       A,#0x2
        MOV       R0,#?V0
        LCALL     ?US_SHR
        MOV       A,?V0
        MOV       B,#0x4
        MUL       AB
        XCH       A,?V0
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x4
        MOV       A,?V1
        MUL       AB
        ADD       A,R0
        MOV       ?V1,A
        MOV       A,?V0
        ADD       A,#0x8
        MOV       ?V0,A
        JNC       ??setItem_2
        INC       ?V1
//  815     hdr.id = 0;
??setItem_2:
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
//  816     writeWord( pg, offset, (uint8 *)(&hdr) );
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V2
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
//  817     pgLost[pg-OSAL_NV_PAGE_BEG] += sz;
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgLost + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgLost - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        ADD       A,?V0
        MOVX      @DPTR,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,?V1
        MOVX      @DPTR,A
//  818   }
//  819 }
??setItem_1:
        MOV       A,#0x8
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV       R7,#0x4
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock7
//  820 
//  821 /*********************************************************************
//  822  * @fn      setChk
//  823  *
//  824  * @brief   Set the item header checksum given the data buffer offset.
//  825  *
//  826  * @param   pg - Valid NV page.
//  827  * @param   offset - Valid offset into the page of the item data - the header
//  828  *                   offset is calculated from this.
//  829  * @param   chk - The checksum to set.
//  830  *
//  831  * @return  The checksum read back.
//  832  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  833 static uint16 setChk( uint8 pg, uint16 offset, uint16 chk )
setChk:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function setChk
        CODE
//  834 {
        FUNCALL setChk, writeWordH
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL setChk, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V2
        REQUIRE ?V3
        MOV       A,#-0xc
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 2
        MOV       A,#-0x2
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,R4
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R5
        MOVX      @DPTR,A
        MOV       ?V0,R1
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
//  835   offset -= OSAL_NV_WORD_SIZE;
        MOV       A,R6
        ADD       A,#-0x4
        MOV       R6,A
        MOV       A,R7
        ADDC      A,#-0x1
        MOV       R7,A
//  836   writeWordH( pg, offset, (uint8 *)&chk );
        ; Setup parameters for call to function writeWordH
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V0
        LCALL     `??writeWordH::?relay`; Banked call to: writeWordH
//  837   HalFlashRead( pg, offset, (uint8 *)(&chk), sizeof( chk ) );
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V2,#0x2
        MOV       ?V3,#0x0
        MOV       R0,#?V2
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V0
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  838 
//  839   return chk;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R3,A
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV       R7,#0x4
        LJMP      ?BANKED_LEAVE_XDATA
//  840 }
          CFI EndBlock cfiBlock8
//  841 
//  842 /*********************************************************************
//  843  * @fn      calcChkB
//  844  *
//  845  * @brief   Calculates the data checksum over the 'buf' parameter.
//  846  *
//  847  * @param   len - Byte count of the data to be checksummed.
//  848  * @param   buf - Data buffer to be checksummed.
//  849  *
//  850  * @return  Calculated checksum of the data bytes.
//  851  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  852 static uint16 calcChkB( uint16 len, uint8 *buf )
calcChkB:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function calcChkB
        CODE
//  853 {
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV       A,R2
        MOV       R0,A
        MOV       A,R3
        MOV       R1,A
        MOV       DPL,R4
        MOV       DPH,R5
//  854   uint8 fill = len % OSAL_NV_WORD_SIZE;
        MOV       A,R0
        ANL       A,#0x3
        MOV       R6,A
//  855   uint16 chk;
//  856 
//  857   if ( !buf )
        MOV       A,DPL
        ORL       A,DPH
        JNZ       ??calcChkB_0
//  858   {
//  859     chk = len * OSAL_NV_ERASED;
        MOV       A,R0
        MOV       R4,A
        MOV       A,R1
        MOV       R5,A
        MOV       A,R4
        MOV       B,#-0x1
        MUL       AB
        XCH       A,R4
        MOV       R7,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R7
        MOV       R7,A
        MOV       B,#-0x1
        MOV       A,R5
        MUL       AB
        ADD       A,R7
        MOV       R5,A
        MOV       A,R4
        MOV       R2,A
        MOV       A,R5
        MOV       R3,A
        SJMP      ??calcChkB_1
//  860   }
//  861   else
//  862   {
//  863     chk = 0;
??calcChkB_0:
        MOV       R2,#0x0
        MOV       R3,#0x0
//  864     while ( len-- )
??calcChkB_2:
        MOV       A,R0
        MOV       R4,A
        MOV       A,R1
        MOV       R5,A
        MOV       A,R4
        ADD       A,#-0x1
        MOV       R0,A
        MOV       A,R5
        ADDC      A,#-0x1
        MOV       R1,A
        MOV       A,R4
        ORL       A,R5
        JZ        ??calcChkB_1
//  865     {
//  866       chk += *buf++;
        MOVX      A,@DPTR
        MOV       R4,A
        MOV       R5,#0x0
        MOV       A,R2
        ADD       A,R4
        MOV       R2,A
        MOV       A,R3
        ADDC      A,R5
        MOV       R3,A
        INC       DPTR
        SJMP      ??calcChkB_2
//  867     }
//  868   }
//  869 
//  870   // calcChkF() will calculate over OSAL_NV_WORD_SIZE alignment.
//  871   if ( fill )
??calcChkB_1:
        MOV       A,R6
        JZ        ??calcChkB_3
//  872   {
//  873     chk += (OSAL_NV_WORD_SIZE - fill) * OSAL_NV_ERASED;
        MOV       A,R6
        MOV       R4,A
        MOV       R5,#0x0
        MOV       A,#0x4
        CLR       C
        SUBB      A,R4
        MOV       R4,A
        MOV       A,#0x0
        SUBB      A,R5
        MOV       R5,A
        MOV       A,R4
        MOV       B,#-0x1
        MUL       AB
        XCH       A,R4
        MOV       R7,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R7
        MOV       R7,A
        MOV       B,#-0x1
        MOV       A,R5
        MUL       AB
        ADD       A,R7
        MOV       R5,A
        MOV       A,R2
        ADD       A,R4
        MOV       R2,A
        MOV       A,R3
        ADDC      A,R5
        MOV       R3,A
//  874   }
//  875 
//  876   return chk;
??calcChkB_3:
        MOV       R7,#0x1
        LJMP      ?BANKED_LEAVE_XDATA
//  877 }
          CFI EndBlock cfiBlock9
//  878 
//  879 /*********************************************************************
//  880  * @fn      calcChkF
//  881  *
//  882  * @brief   Calculates the data checksum by reading the data bytes from NV.
//  883  *
//  884  * @param   pg - A valid NV Flash page.
//  885  * @param   offset - A valid offset into the page.
//  886  * @param   len - Byte count of the data to be checksummed.
//  887  *
//  888  * @return  Calculated checksum of the data bytes.
//  889  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  890 static uint16 calcChkF( uint8 pg, uint16 offset, uint16 len )
calcChkF:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function calcChkF
        CODE
//  891 {
        FUNCALL calcChkF, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV       A,#-0x10
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 4
        MOV       A,#-0x4
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV       ?V5,R1
        MOV       ?V2,R2
        MOV       ?V3,R3
        MOV       A,R4
        MOV       R6,A
        MOV       A,R5
        MOV       R7,A
//  892   uint16 chk = 0;
        MOV       ?V0,#0x0
        MOV       ?V1,#0x0
//  893 
//  894   len = (len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE;
        MOV       A,R6
        ADD       A,#0x3
        MOV       ?V6,A
        CLR       A
        ADDC      A,R7
        MOV       ?V7,A
        MOV       A,#0x2
        MOV       R0,#?V6
        LCALL     ?US_SHR
        MOV       R6,?V6
        MOV       R7,?V7
//  895 
//  896   while ( len-- )
??calcChkF_0:
        MOV       A,R6
        MOV       R0,A
        MOV       A,R7
        MOV       R1,A
        MOV       A,R0
        ADD       A,#-0x1
        MOV       R6,A
        MOV       A,R1
        ADDC      A,#-0x1
        MOV       R7,A
        MOV       A,R0
        ORL       A,R1
        JZ        ??calcChkF_1
//  897   {
//  898     uint8 cnt, tmp[OSAL_NV_WORD_SIZE];
//  899 
//  900     HalFlashRead(pg, offset, tmp, OSAL_NV_WORD_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V6,#0x4
        MOV       ?V7,#0x0
        MOV       R0,#?V6
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,?V2
        MOV       R3,?V3
        MOV       R1,?V5
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  901     offset += OSAL_NV_WORD_SIZE;
        MOV       A,?V2
        ADD       A,#0x4
        MOV       ?V2,A
        MOV       A,?V3
        ADDC      A,#0x0
        MOV       ?V3,A
//  902 
//  903     for ( cnt = 0; cnt < OSAL_NV_WORD_SIZE; cnt++ )
        MOV       ?V4,#0x0
??calcChkF_2:
        MOV       A,?V4
        CLR       C
        SUBB      A,#0x4
        JNC       ??calcChkF_0
//  904     {
//  905       chk += tmp[cnt];
        MOV       A,?V4
        MOV       R0,A
        MOV       R1,#0x0
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,DPL
        ADD       A,R0
        MOV       DPL,A
        MOV       A,DPH
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,?V0
        ADD       A,R0
        MOV       ?V0,A
        MOV       A,?V1
        ADDC      A,R1
        MOV       ?V1,A
//  906     }
        INC       ?V4
        SJMP      ??calcChkF_2
//  907   }
//  908 
//  909   return chk;
??calcChkF_1:
        MOV       R2,?V0
        MOV       R3,?V1
        MOV       A,#0x4
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 16)
        MOV       R7,#0x8
        LJMP      ?BANKED_LEAVE_XDATA
//  910 }
          CFI EndBlock cfiBlock10
//  911 
//  912 /*********************************************************************
//  913  * @fn      writeWord
//  914  *
//  915  * @brief   Writes a Flash-WORD to NV.
//  916  *
//  917  * @param   pg - A valid NV Flash page.
//  918  * @param   offset - A valid offset into the page.
//  919  * @param   buf - Pointer to source buffer.
//  920  *
//  921  * @return  none
//  922  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  923 static void writeWord( uint8 pg, uint16 offset, uint8 *buf )
writeWord:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function writeWord
        CODE
//  924 {
        FUNCALL writeWord, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V4
        REQUIRE ?V5
        MOV       A,#-0xe
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV       ?V2,R1
        MOV       ?V0,R2
        MOV       ?V1,R3
        MOV       A,R4
        MOV       R6,A
        MOV       A,R5
        MOV       R7,A
//  925   offset = (offset / HAL_FLASH_WORD_SIZE) +
//  926           ((uint16)pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
        MOV       A,#0x2
        MOV       R0,#?V0
        LCALL     ?US_SHR
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x0
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x2
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x0
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,?V0
        ADD       A,R0
        MOV       ?V0,A
        MOV       A,?V1
        ADDC      A,R1
        MOV       ?V1,A
//  927 
//  928   HalFlashWrite(offset, buf, 1);
        ; Setup parameters for call to function HalFlashWrite
        MOV       ?V4,#0x1
        MOV       ?V5,#0x0
        MOV       R0,#?V4
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV       A,R6
        MOV       R4,A
        MOV       A,R7
        MOV       R5,A
        MOV       R2,?V0
        MOV       R3,?V1
        LCALL     `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  929 }
        MOV       R7,#0x6
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock11
//  930 
//  931 /*********************************************************************
//  932  * @fn      writeWordM
//  933  *
//  934  * @brief   Writes multiple Flash-WORDs to NV.
//  935  *
//  936  * @param   pg - A valid NV Flash page.
//  937  * @param   offset - A valid offset into the page.
//  938  * @param   buf - Pointer to source buffer.
//  939  * @param   cnt - Number of 4-byte blocks to write.
//  940  *
//  941  * @return  none
//  942  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  943 static void writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint16 cnt )
writeWordM:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function writeWordM
        CODE
//  944 {
        FUNCALL writeWordM, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        MOV       A,#-0xd
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 13)
        ; Saved register size: 13
        ; Auto size: 0
        MOV       ?V4,R1
        MOV       ?V2,R2
        MOV       ?V3,R3
        MOV       A,R4
        MOV       R6,A
        MOV       A,R5
        MOV       R7,A
        MOV       A,#0xd
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V1,A
//  945   offset = (offset / HAL_FLASH_WORD_SIZE) +
//  946           ((uint16)pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
        MOV       A,#0x2
        MOV       R0,#?V2
        LCALL     ?US_SHR
        MOV       A,?V4
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x0
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x2
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x0
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,?V2
        ADD       A,R0
        MOV       ?V2,A
        MOV       A,?V3
        ADDC      A,R1
        MOV       ?V3,A
//  947   HalFlashWrite(offset, buf, cnt);
        ; Setup parameters for call to function HalFlashWrite
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 15)
        MOV       A,R6
        MOV       R4,A
        MOV       A,R7
        MOV       R5,A
        MOV       R2,?V2
        MOV       R3,?V3
        LCALL     `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 13)
//  948 }
        MOV       R7,#0x5
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock12
//  949 
//  950 /*********************************************************************
//  951  * @fn      writeWordH
//  952  *
//  953  * @brief   Writes the 1st half of a Flash-WORD to NV (filling 2nd half with 0xffff).
//  954  *
//  955  * @param   pg - A valid NV Flash page.
//  956  * @param   offset - A valid offset into the page.
//  957  * @param   buf - Pointer to source buffer.
//  958  *
//  959  * @return  none
//  960  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  961 static void writeWordH( uint8 pg, uint16 offset, uint8 *buf )
writeWordH:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function writeWordH
        CODE
//  962 {
        FUNCALL writeWordH, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV       A,#-0xb
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 4
        MOV       A,#-0x4
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 15)
        MOV       ?V2,R1
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
        MOV       ?V0,R4
        MOV       ?V1,R5
//  963   uint8 tmp[4];
//  964 
//  965   tmp[0] = buf[0];
        MOV       DPL,?V0
        MOV       DPH,?V1
        MOVX      A,@DPTR
        PUSH      A
          CFI CFA_SP SP+-1
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        POP       A
          CFI CFA_SP SP+0
        MOVX      @DPTR,A
//  966   tmp[1] = buf[1];
        MOV       DPL,?V0
        MOV       DPH,?V1
        INC       DPTR
        MOVX      A,@DPTR
        PUSH      A
          CFI CFA_SP SP+-1
        MOV       A,#0x1
        LCALL     ?XSTACK_DISP0_8
        POP       A
          CFI CFA_SP SP+0
        MOVX      @DPTR,A
//  967   tmp[2] = OSAL_NV_ERASED;
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOV       A,#-0x1
        MOVX      @DPTR,A
//  968   tmp[3] = OSAL_NV_ERASED;
        MOV       A,#0x3
        LCALL     ?XSTACK_DISP0_8
        MOV       A,#-0x1
        MOVX      @DPTR,A
//  969 
//  970   writeWord( pg, offset, tmp );
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V2
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
//  971 }
        MOV       A,#0x4
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
        MOV       R7,#0x3
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock13
//  972 
//  973 /*********************************************************************
//  974  * @fn      writeBuf
//  975  *
//  976  * @brief   Writes a data buffer to NV.
//  977  *
//  978  * @param   dstPg - A valid NV Flash page.
//  979  * @param   offset - A valid offset into the page.
//  980  * @param   len  - Byte count of the data to write.
//  981  * @param   buf  - The data to write.
//  982  *
//  983  * @return  TRUE if data buf checksum matches read back checksum, else FALSE.
//  984  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  985 static void writeBuf( uint8 dstPg, uint16 dstOff, uint16 len, uint8 *buf )
writeBuf:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function writeBuf
        CODE
//  986 {
        FUNCALL writeBuf, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeBuf, writeWordM
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeBuf, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        MOV       A,#-0x12
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 4
        MOV       A,#-0x4
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
        MOV       A,R1
        MOV       R7,A
        MOV       ?V4,R2
        MOV       ?V5,R3
        MOV       ?V6,R4
        MOV       ?V7,R5
        MOV       A,#0x16
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V1,A
//  987   uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
        MOV       A,?V4
        ANL       A,#0x3
        MOV       R6,A
//  988   uint8 tmp[OSAL_NV_WORD_SIZE];
//  989 
//  990   if ( rem )
        MOV       A,R6
        JNZ       $+5
        LJMP      ??writeBuf_0 & 0xFFFF
//  991   {
//  992     dstOff = (dstOff / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
        MOV       A,#0x2
        MOV       R0,#?V4
        LCALL     ?US_SHR
        MOV       A,?V4
        MOV       B,#0x4
        MUL       AB
        XCH       A,?V4
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x4
        MOV       A,?V5
        MUL       AB
        ADD       A,R0
        MOV       ?V5,A
//  993     HalFlashRead(dstPg, dstOff, tmp, OSAL_NV_WORD_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V2,#0x4
        MOV       ?V3,#0x0
        MOV       R0,#?V2
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 24)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       A,R7
        MOV       R1,A
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
//  994 
//  995     while ( (rem < OSAL_NV_WORD_SIZE) && len )
??writeBuf_1:
        MOV       A,R6
        CLR       C
        SUBB      A,#0x4
        JNC       ??writeBuf_2
        MOV       A,?V6
        ORL       A,?V7
        JZ        ??writeBuf_2
//  996     {
//  997       tmp[rem++] = *buf++;
        MOV       DPL,?V0
        MOV       DPH,?V1
        MOVX      A,@DPTR
        PUSH      A
          CFI CFA_SP SP+-1
        MOV       A,R6
        MOV       R0,A
        MOV       R1,#0x0
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,DPL
        ADD       A,R0
        MOV       DPL,A
        MOV       A,DPH
        ADDC      A,R1
        MOV       DPH,A
        POP       A
          CFI CFA_SP SP+0
        MOVX      @DPTR,A
        MOV       DPL,?V0
        MOV       DPH,?V1
        INC       DPTR
        MOV       ?V0,DPL
        MOV       ?V1,DPH
        INC       R6
//  998       len--;
        MOV       A,?V6
        ADD       A,#-0x1
        MOV       ?V6,A
        MOV       A,?V7
        ADDC      A,#-0x1
        MOV       ?V7,A
        SJMP      ??writeBuf_1
//  999     }
// 1000 
// 1001     writeWord( dstPg, dstOff, tmp );
??writeBuf_2:
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       A,R7
        MOV       R1,A
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
// 1002     dstOff += OSAL_NV_WORD_SIZE;
        MOV       A,?V4
        ADD       A,#0x4
        MOV       ?V4,A
        MOV       A,?V5
        ADDC      A,#0x0
        MOV       ?V5,A
// 1003   }
// 1004 
// 1005   rem = len % OSAL_NV_WORD_SIZE;
??writeBuf_0:
        MOV       A,?V6
        ANL       A,#0x3
        MOV       R6,A
// 1006   len /= OSAL_NV_WORD_SIZE;
        MOV       ?V2,?V6
        MOV       ?V3,?V7
        MOV       A,#0x2
        MOV       R0,#?V2
        LCALL     ?US_SHR
        MOV       ?V6,?V2
        MOV       ?V7,?V3
// 1007 
// 1008   if ( len )
        MOV       A,?V6
        ORL       A,?V7
        JZ        ??writeBuf_3
// 1009   {
// 1010     writeWordM( dstPg, dstOff, buf, len );
        ; Setup parameters for call to function writeWordM
        MOV       R0,#?V6
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 24)
        MOV       R4,?V0
        MOV       R5,?V1
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       A,R7
        MOV       R1,A
        LCALL     `??writeWordM::?relay`; Banked call to: writeWordM
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
// 1011     dstOff += OSAL_NV_WORD_SIZE * len;
        MOV       R0,?V6
        MOV       R1,?V7
        MOV       A,R0
        MOV       B,#0x4
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x4
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,?V4
        ADD       A,R0
        MOV       ?V4,A
        MOV       A,?V5
        ADDC      A,R1
        MOV       ?V5,A
// 1012     buf += OSAL_NV_WORD_SIZE * len;
        MOV       R0,?V6
        MOV       R1,?V7
        MOV       A,R0
        MOV       B,#0x4
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x4
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,?V0
        ADD       A,R0
        MOV       ?V0,A
        MOV       A,?V1
        ADDC      A,R1
        MOV       ?V1,A
// 1013   }
// 1014 
// 1015   if ( rem )
??writeBuf_3:
        MOV       A,R6
        JZ        ??writeBuf_4
// 1016   {
// 1017     uint8 idx = 0;
        MOV       ?V2,#0x0
// 1018     HalFlashRead(dstPg, dstOff, tmp, OSAL_NV_WORD_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V8,#0x4
        MOV       ?V9,#0x0
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 24)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       A,R7
        MOV       R1,A
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
// 1019     while ( rem-- )
??writeBuf_5:
        MOV       ?V3,R6
        MOV       A,#-0x1
        ADD       A,?V3
        MOV       R6,A
        MOV       A,?V3
        JZ        ??writeBuf_6
// 1020     {
// 1021       tmp[idx++] = *buf++;
        MOV       DPL,?V0
        MOV       DPH,?V1
        MOVX      A,@DPTR
        PUSH      A
          CFI CFA_SP SP+-1
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,DPL
        ADD       A,R0
        MOV       DPL,A
        MOV       A,DPH
        ADDC      A,R1
        MOV       DPH,A
        POP       A
          CFI CFA_SP SP+0
        MOVX      @DPTR,A
        MOV       DPL,?V0
        MOV       DPH,?V1
        INC       DPTR
        MOV       ?V0,DPL
        MOV       ?V1,DPH
        INC       ?V2
        SJMP      ??writeBuf_5
// 1022     }
// 1023     writeWord( dstPg, dstOff, tmp );
??writeBuf_6:
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       A,R7
        MOV       R1,A
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
// 1024   }
// 1025 }
??writeBuf_4:
        MOV       A,#0x4
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV       R7,#0xa
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock14
// 1026 
// 1027 /*********************************************************************
// 1028  * @fn      xferBuf
// 1029  *
// 1030  * @brief   Xfers an NV buffer from one location to another, enforcing OSAL_NV_WORD_SIZE writes.
// 1031  *
// 1032  * @return  none
// 1033  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1034 static void xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len )
xferBuf:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function xferBuf
        CODE
// 1035 {
        FUNCALL xferBuf, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        REQUIRE ?V10
        MOV       A,#-0x13
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 19)
        ; Saved register size: 19
        ; Auto size: 4
        MOV       A,#-0x4
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 23)
        MOV       ?V10,R1
        MOV       ?V4,R2
        MOV       ?V5,R3
        MOV       ?V7,R4
        MOV       A,#0x17
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V1,A
        MOV       A,#0x19
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R6,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R7,A
// 1036   uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
        MOV       A,?V0
        ANL       A,#0x3
        MOV       ?V2,A
// 1037   uint8 tmp[OSAL_NV_WORD_SIZE];
// 1038 
// 1039   if ( rem )
        MOV       A,?V2
        JNZ       $+5
        LJMP      ??xferBuf_0 & 0xFFFF
// 1040   {
// 1041     dstOff -= rem;
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        CLR       C
        MOV       A,?V0
        SUBB      A,R0
        MOV       ?V0,A
        MOV       A,?V1
        SUBB      A,R1
        MOV       ?V1,A
// 1042     HalFlashRead(dstPg, dstOff, tmp, OSAL_NV_WORD_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V8,#0x4
        MOV       ?V9,#0x0
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 25)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,?V0
        MOV       R3,?V1
        MOV       R1,?V7
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 23)
// 1043 
// 1044     while ( (rem < OSAL_NV_WORD_SIZE) && len )
??xferBuf_1:
        MOV       A,?V2
        CLR       C
        SUBB      A,#0x4
        JNC       ??xferBuf_2
        MOV       A,R6
        ORL       A,R7
        JZ        ??xferBuf_2
// 1045     {
// 1046       HalFlashRead(srcPg, srcOff, tmp+rem, 1);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V8,#0x1
        MOV       ?V9,#0x0
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 25)
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOV       A,DPL
        ADD       A,R0
        MOV       R4,A
        MOV       A,DPH
        ADDC      A,R1
        MOV       R5,A
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       R1,?V10
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 23)
// 1047       srcOff++;
        INC       ?V4
        MOV       A,?V4
        JNZ       ??xferBuf_3
        INC       ?V5
// 1048       rem++;
??xferBuf_3:
        INC       ?V2
// 1049       len--;
        MOV       A,R6
        ADD       A,#-0x1
        MOV       R6,A
        MOV       A,R7
        ADDC      A,#-0x1
        MOV       R7,A
        SJMP      ??xferBuf_1
// 1050     }
// 1051 
// 1052     writeWord( dstPg, dstOff, tmp );
??xferBuf_2:
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R2,?V0
        MOV       R3,?V1
        MOV       R1,?V7
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
// 1053     dstOff += OSAL_NV_WORD_SIZE;
        MOV       A,?V0
        ADD       A,#0x4
        MOV       ?V0,A
        MOV       A,?V1
        ADDC      A,#0x0
        MOV       ?V1,A
// 1054   }
// 1055 
// 1056   rem = len % OSAL_NV_WORD_SIZE;
??xferBuf_0:
        MOV       A,R6
        ANL       A,#0x3
        MOV       ?V2,A
// 1057   len /= OSAL_NV_WORD_SIZE;
        MOV       ?V8,R6
        MOV       ?V9,R7
        MOV       A,#0x2
        MOV       R0,#?V8
        LCALL     ?US_SHR
        MOV       R6,?V8
        MOV       R7,?V9
// 1058 
// 1059   while ( len-- )
??xferBuf_4:
        MOV       A,R6
        MOV       R0,A
        MOV       A,R7
        MOV       R1,A
        MOV       A,R0
        ADD       A,#-0x1
        MOV       R6,A
        MOV       A,R1
        ADDC      A,#-0x1
        MOV       R7,A
        MOV       A,R0
        ORL       A,R1
        JZ        ??xferBuf_5
// 1060   {
// 1061     HalFlashRead(srcPg, srcOff, tmp, OSAL_NV_WORD_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V8,#0x4
        MOV       ?V9,#0x0
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 25)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       R1,?V10
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 23)
// 1062     srcOff += OSAL_NV_WORD_SIZE;
        MOV       A,?V4
        ADD       A,#0x4
        MOV       ?V4,A
        MOV       A,?V5
        ADDC      A,#0x0
        MOV       ?V5,A
// 1063     writeWord( dstPg, dstOff, tmp );
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R2,?V0
        MOV       R3,?V1
        MOV       R1,?V7
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
// 1064     dstOff += OSAL_NV_WORD_SIZE;
        MOV       A,?V0
        ADD       A,#0x4
        MOV       ?V0,A
        MOV       A,?V1
        ADDC      A,#0x0
        MOV       ?V1,A
        SJMP      ??xferBuf_4
// 1065   }
// 1066 
// 1067   if ( rem )
??xferBuf_5:
        MOV       A,?V2
        JZ        ??xferBuf_6
// 1068   {
// 1069     uint8 idx = 0;
        MOV       ?V3,#0x0
// 1070     HalFlashRead(dstPg, dstOff, tmp, OSAL_NV_WORD_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V8,#0x4
        MOV       ?V9,#0x0
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 25)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,?V0
        MOV       R3,?V1
        MOV       R1,?V7
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 23)
// 1071     while ( rem-- )
??xferBuf_7:
        MOV       ?V6,?V2
        MOV       A,#-0x1
        ADD       A,?V6
        MOV       ?V2,A
        MOV       A,?V6
        JZ        ??xferBuf_8
// 1072     {
// 1073       HalFlashRead(srcPg, srcOff, tmp+idx, 1);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V8,#0x1
        MOV       ?V9,#0x0
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 25)
        MOV       A,?V3
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOV       A,DPL
        ADD       A,R0
        MOV       R4,A
        MOV       A,DPH
        ADDC      A,R1
        MOV       R5,A
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       R1,?V10
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 23)
// 1074       srcOff++;
        INC       ?V4
        MOV       A,?V4
        JNZ       ??xferBuf_9
        INC       ?V5
// 1075       idx++;
??xferBuf_9:
        INC       ?V3
        SJMP      ??xferBuf_7
// 1076     }
// 1077     writeWord( dstPg, dstOff, tmp );
??xferBuf_8:
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R2,?V0
        MOV       R3,?V1
        MOV       R1,?V7
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
// 1078   }
// 1079 }
??xferBuf_6:
        MOV       A,#0x4
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 19)
        MOV       R7,#0xb
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock15
// 1080 
// 1081 /*********************************************************************
// 1082  * @fn      writeItem
// 1083  *
// 1084  * @brief   Writes an item header/data combo to the specified NV page.
// 1085  *
// 1086  * @param   pg - Valid NV Flash page.
// 1087  * @param   id - Valid NV item Id.
// 1088  * @param   len  - Byte count of the data to write.
// 1089  * @param   buf  - The data to write. If NULL, no data/checksum write.
// 1090  * @param   flag - TRUE if the checksum should be written, FALSE otherwise.
// 1091  *
// 1092  * @return  TRUE if header/data to write matches header/data read back, else FALSE.
// 1093  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1094 static uint8 writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag )
writeItem:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function writeItem
        CODE
// 1095 {
        FUNCALL writeItem, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, calcChkB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, writeBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, setChk
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, hotItemUpdate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        REQUIRE ?V10
        REQUIRE ?V11
        MOV       A,#-0x14
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 8
        MOV       A,#-0x8
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV       ?V0,R1
        MOV       ?V8,R2
        MOV       ?V9,R3
        MOV       A,R4
        MOV       R6,A
        MOV       A,R5
        MOV       R7,A
        MOV       A,#0x1c
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V6,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V7,A
        MOV       A,#0x1e
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V4,A
// 1096   uint16 offset = pgOff[pg-OSAL_NV_PAGE_BEG];
        MOV       A,?V0
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       ?V2,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V3,A
// 1097   uint8 rtrn = FALSE;
        MOV       ?V1,#0x0
// 1098   osalNvHdr_t hdr;
// 1099 
// 1100   hdr.id = id;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,?V8
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,?V9
        MOVX      @DPTR,A
// 1101   hdr.len = len;
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOV       A,R6
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R7
        MOVX      @DPTR,A
// 1102 
// 1103   writeWord( pg, offset, (uint8 *)&hdr );
        ; Setup parameters for call to function writeWord
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R2,?V2
        MOV       R3,?V3
        MOV       R1,?V0
        LCALL     `??writeWord::?relay`; Banked call to: writeWord
// 1104   HalFlashRead(pg, offset, (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V10,#0x8
        MOV       ?V11,#0x0
        MOV       R0,#?V10
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,?V2
        MOV       R3,?V3
        MOV       R1,?V0
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
// 1105 
// 1106   if ( (hdr.id == id) && (hdr.len == len) )
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        XRL       A,?V8
        JNZ       ??writeItem_0
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,?V9
??writeItem_0:
        JZ        $+5
        LJMP      ??writeItem_1 & 0xFFFF
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R6
        JNZ       ??writeItem_2
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R7
??writeItem_2:
        JZ        $+5
        LJMP      ??writeItem_1 & 0xFFFF
// 1107   {
// 1108     if ( flag )
        MOV       A,?V4
        JNZ       $+5
        LJMP      ??writeItem_3 & 0xFFFF
// 1109     {
// 1110       hdr.chk = calcChkB( len, buf );
        ; Setup parameters for call to function calcChkB
        MOV       R4,?V6
        MOV       R5,?V7
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LCALL     `??calcChkB::?relay`; Banked call to: calcChkB
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOV       A,R2
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R3
        MOVX      @DPTR,A
// 1111 
// 1112       offset += OSAL_NV_HDR_SIZE;
        MOV       A,?V2
        ADD       A,#0x8
        MOV       ?V2,A
        MOV       A,?V3
        ADDC      A,#0x0
        MOV       ?V3,A
// 1113       if ( buf != NULL )
        MOV       A,?V6
        ORL       A,?V7
        JZ        ??writeItem_4
// 1114       {
// 1115         writeBuf( pg, offset, len, buf );
        ; Setup parameters for call to function writeBuf
        MOV       R0,#?V6
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV       A,R6
        MOV       R4,A
        MOV       A,R7
        MOV       R5,A
        MOV       R2,?V2
        MOV       R3,?V3
        MOV       R1,?V0
        LCALL     `??writeBuf::?relay`; Banked call to: writeBuf
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
// 1116       }
// 1117 
// 1118       if ( hdr.chk == calcChkF( pg, offset, len ) )
??writeItem_4:
        ; Setup parameters for call to function calcChkF
        MOV       A,R6
        MOV       R4,A
        MOV       A,R7
        MOV       R5,A
        MOV       R2,?V2
        MOV       R3,?V3
        MOV       R1,?V0
        LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
        MOV       ?V10,R2
        MOV       ?V11,R3
        MOV       R0,?V10
        MOV       R1,?V11
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??writeItem_5
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??writeItem_5:
        JNZ       ??writeItem_6
// 1119       {
// 1120         if ( hdr.chk == setChk( pg, offset, hdr.chk ) )
        ; Setup parameters for call to function setChk
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       R2,?V2
        MOV       R3,?V3
        MOV       R1,?V0
        LCALL     `??setChk::?relay`; Banked call to: setChk
        MOV       ?V10,R2
        MOV       ?V11,R3
        MOV       R0,?V10
        MOV       R1,?V11
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??writeItem_7
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??writeItem_7:
        JNZ       ??writeItem_6
// 1121         {
// 1122           hotItemUpdate(pg, offset, hdr.id);
        ; Setup parameters for call to function hotItemUpdate
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       R2,?V2
        MOV       R3,?V3
        MOV       R1,?V0
        LCALL     `??hotItemUpdate::?relay`; Banked call to: hotItemUpdate
// 1123           rtrn = TRUE;
        MOV       ?V1,#0x1
        SJMP      ??writeItem_6
// 1124         }
// 1125       }
// 1126     }
// 1127     else
// 1128     {
// 1129       rtrn = TRUE;
??writeItem_3:
        MOV       ?V1,#0x1
// 1130     }
// 1131 
// 1132     len = OSAL_NV_ITEM_SIZE( hdr.len );
??writeItem_6:
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        CLR       C
        MOVX      A,@DPTR
        SUBB      A,#-0xc
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,#-0x1
        JC        ??writeItem_8
        MOV       R6,#-0x4
        MOV       R7,#-0x1
        LJMP      ??writeItem_9 & 0xFFFF
??writeItem_8:
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        ADD       A,#0x3
        MOV       ?V10,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,#0x0
        MOV       ?V11,A
        MOV       A,#0x2
        MOV       R0,#?V10
        LCALL     ?US_SHR
        MOV       A,?V10
        MOV       B,#0x4
        MUL       AB
        XCH       A,?V10
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x4
        MOV       A,?V11
        MUL       AB
        ADD       A,R0
        MOV       ?V11,A
        MOV       A,?V10
        ADD       A,#0x8
        MOV       R6,A
        CLR       A
        ADDC      A,?V11
        MOV       R7,A
        LJMP      ??writeItem_9 & 0xFFFF
// 1133   }
// 1134   else
// 1135   {
// 1136     len = OSAL_NV_ITEM_SIZE( hdr.len );
??writeItem_1:
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        CLR       C
        MOVX      A,@DPTR
        SUBB      A,#-0xc
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,#-0x1
        JC        ??writeItem_10
        MOV       R6,#-0x4
        MOV       R7,#-0x1
        SJMP      ??writeItem_11
??writeItem_10:
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        ADD       A,#0x3
        MOV       ?V10,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,#0x0
        MOV       ?V11,A
        MOV       A,#0x2
        MOV       R0,#?V10
        LCALL     ?US_SHR
        MOV       A,?V10
        MOV       B,#0x4
        MUL       AB
        XCH       A,?V10
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x4
        MOV       A,?V11
        MUL       AB
        ADD       A,R0
        MOV       ?V11,A
        MOV       A,?V10
        ADD       A,#0x8
        MOV       R6,A
        CLR       A
        ADDC      A,?V11
        MOV       R7,A
// 1137 
// 1138     if (len > (OSAL_NV_PAGE_SIZE - pgOff[pg - OSAL_NV_PAGE_BEG]))
??writeItem_11:
        MOV       A,?V0
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,#0x0
        CLR       C
        SUBB      A,R0
        MOV       R0,A
        MOV       A,#0x8
        SUBB      A,R1
        MOV       R1,A
        CLR       C
        MOV       A,R0
        SUBB      A,R6
        MOV       A,R1
        SUBB      A,R7
        JNC       ??writeItem_12
// 1139     {
// 1140       len = (OSAL_NV_PAGE_SIZE - pgOff[pg - OSAL_NV_PAGE_BEG]);
        MOV       A,?V0
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,#0x0
        CLR       C
        SUBB      A,R0
        MOV       R0,A
        MOV       A,#0x8
        SUBB      A,R1
        MOV       R1,A
        MOV       A,R0
        MOV       R6,A
        MOV       A,R1
        MOV       R7,A
// 1141     }
// 1142 
// 1143     pgLost[pg - OSAL_NV_PAGE_BEG] += len;
??writeItem_12:
        MOV       A,?V0
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgLost + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgLost - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        ADD       A,R6
        MOVX      @DPTR,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,R7
        MOVX      @DPTR,A
// 1144   }
// 1145   pgOff[pg - OSAL_NV_PAGE_BEG] += len;
??writeItem_9:
        MOV       A,?V0
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        ADD       A,R6
        MOVX      @DPTR,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,R7
        MOVX      @DPTR,A
// 1146 
// 1147   return rtrn;
        MOV       R1,?V1
        MOV       A,#0x8
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV       R7,#0xc
        LJMP      ?BANKED_LEAVE_XDATA
// 1148 }
          CFI EndBlock cfiBlock16
// 1149 
// 1150 /*********************************************************************
// 1151  * @fn      hotItem
// 1152  *
// 1153  * @brief   Look for the parameter 'id' in the hot items array.
// 1154  *
// 1155  * @param   id - A valid NV item Id.
// 1156  *
// 1157  * @return  A valid index into the hot items if the item is hot; OSAL_NV_MAX_HOT if not.
// 1158  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1159 static uint8 hotItem(uint16 id)
hotItem:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function hotItem
        CODE
// 1160 {
        PUSH      DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH      DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1161   uint8 hotIdx;
// 1162 
// 1163   for (hotIdx = 0; hotIdx < OSAL_NV_MAX_HOT; hotIdx++)
        MOV       R1,#0x0
??hotItem_0:
        MOV       A,R1
        CLR       C
        SUBB      A,#0x3
        JNC       ??hotItem_1
// 1164   {
// 1165     if (hotIds[hotIdx] == id)
        MOV       A,R1
        MOV       R4,A
        MOV       R5,#0x0
        MOV       A,R4
        MOV       B,#0x2
        MUL       AB
        XCH       A,R4
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x2
        MOV       A,R5
        MUL       AB
        ADD       A,R0
        MOV       R5,A
        MOV       A,#hotIds & 0xff
        ADD       A,R4
        MOV       DPL,A
        MOV       A,#(hotIds >> 8) & 0xff
        ADDC      A,R5
        MOV       DPH,A
        MOVX      A,@DPTR
        XRL       A,R2
        JNZ       ??hotItem_2
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R3
??hotItem_2:
        JZ        ??hotItem_1
// 1166     {
// 1167       break;
// 1168     }
// 1169   }
        INC       R1
        SJMP      ??hotItem_0
// 1170 
// 1171   return hotIdx;
??hotItem_1:
        POP       DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP       DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP      ?BRET
// 1172 }
          CFI EndBlock cfiBlock17
// 1173 
// 1174 /*********************************************************************
// 1175  * @fn      hotItemUpdate
// 1176  *
// 1177  * @brief   If the parameter 'id' is a hot item, update the corresponding hot item data.
// 1178  *
// 1179  * @param   pg - The new NV page corresponding to the hot item.
// 1180  * @param   off - The new NV page offset corresponding to the hot item.
// 1181  * @param   id - A valid NV item Id.
// 1182  *
// 1183  * @return  none
// 1184  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1185 static void hotItemUpdate(uint8 pg, uint16 off, uint16 id)
hotItemUpdate:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function hotItemUpdate
        CODE
// 1186 {
        FUNCALL hotItemUpdate, hotItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV       A,#-0xb
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
        MOV       ?V2,R1
        MOV       ?V0,R2
        MOV       ?V1,R3
        MOV       A,R4
        MOV       R6,A
        MOV       A,R5
        MOV       R7,A
// 1187   uint8 hotIdx = hotItem(id);
        ; Setup parameters for call to function hotItem
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LCALL     `??hotItem::?relay`; Banked call to: hotItem
        MOV       A,R1
        MOV       R2,A
// 1188 
// 1189   if (hotIdx < OSAL_NV_MAX_HOT)
        MOV       A,R2
        CLR       C
        SUBB      A,#0x3
        JNC       ??hotItemUpdate_0
// 1190   {
// 1191     {
// 1192       hotPg[hotIdx] = pg;
        MOV       A,?V2
        PUSH      A
          CFI CFA_SP SP+-1
        MOV       A,R2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,#hotPg & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(hotPg >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        POP       A
          CFI CFA_SP SP+0
        MOVX      @DPTR,A
// 1193       hotOff[hotIdx] = off;
        MOV       A,R2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R3,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R3
        MOV       R3,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R3
        MOV       R1,A
        MOV       A,#hotOff & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(hotOff >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOV       A,?V0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,?V1
        MOVX      @DPTR,A
// 1194     }
// 1195   }
// 1196 }
??hotItemUpdate_0:
        MOV       R7,#0x3
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock18
// 1197 
// 1198 /*********************************************************************
// 1199  * @fn      osal_nv_init
// 1200  *
// 1201  * @brief   Initialize NV service.
// 1202  *
// 1203  * @param   p - Not used.
// 1204  *
// 1205  * @return  none
// 1206  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1207 void osal_nv_init( void *p )
osal_nv_init:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function osal_nv_init
        CODE
// 1208 {
        FUNCALL osal_nv_init, initNV
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
// 1209   (void)p;  // Suppress Lint warning.
// 1210   (void)initNV();  // Always returns TRUE after pages have been erased.
        ; Setup parameters for call to function initNV
        LCALL     `??initNV::?relay`; Banked call to: initNV
        MOV       A,R1
// 1211 }
        MOV       R7,#0x1
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock19
// 1212 
// 1213 /*********************************************************************
// 1214  * @fn      osal_nv_item_init
// 1215  *
// 1216  * @brief   If the NV item does not already exist, it is created and
// 1217  *          initialized with the data passed to the function, if any.
// 1218  *          This function must be called before calling osal_nv_read() or
// 1219  *          osal_nv_write().
// 1220  *
// 1221  * @param   id  - Valid NV item Id.
// 1222  * @param   len - Item length.
// 1223  * @param  *buf - Pointer to item initalization data. Set to NULL if none.
// 1224  *
// 1225  * @return  NV_ITEM_UNINIT - Id did not exist and was created successfully.
// 1226  *          SUCCESS        - Id already existed, no action taken.
// 1227  *          NV_OPER_FAILED - Failure to find or create Id.
// 1228  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1229 uint8 osal_nv_item_init( uint16 id, uint16 len, void *buf )
osal_nv_item_init:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function osal_nv_item_init
        CODE
// 1230 {
        FUNCALL osal_nv_item_init, hotItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_init, OnBoard_CheckVoltage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_init, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_init, hotItemUpdate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_init, initItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV       A,#-0x10
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
        MOV       ?V2,R4
        MOV       ?V3,R5
        MOV       A,#0x10
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V5,A
// 1231   uint16 offset;
// 1232 
// 1233   if ( ( hotItem( id ) < OSAL_NV_MAX_HOT ) && ( !OSAL_NV_CHECK_BUS_VOLTAGE ) )
        ; Setup parameters for call to function hotItem
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LCALL     `??hotItem::?relay`; Banked call to: hotItem
        MOV       A,R1
        CLR       C
        SUBB      A,#0x3
        JNC       ??osal_nv_item_init_0
        ; Setup parameters for call to function OnBoard_CheckVoltage
        LCALL     `??OnBoard_CheckVoltage::?relay`; Banked call to: OnBoard_CheckVoltage
        MOV       A,R1
        JNZ       ??osal_nv_item_init_0
// 1234   {
// 1235     return NV_OPER_FAILED;
        MOV       R1,#0xa
        SJMP      ??osal_nv_item_init_1
// 1236   }
// 1237   else if ((offset = findItem(id)) != OSAL_NV_ITEM_NULL)
??osal_nv_item_init_0:
        ; Setup parameters for call to function findItem
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LCALL     `??findItem::?relay`; Banked call to: findItem
        MOV       ?V6,R2
        MOV       ?V7,R3
        MOV       R0,?V6
        MOV       R1,?V7
        MOV       ?V0,R0
        MOV       ?V1,R1
        MOV       A,R0
        ORL       A,R1
        JZ        ??osal_nv_item_init_2
// 1238   {
// 1239     // Re-populate the NV hot item data if the corresponding items are already established.
// 1240     hotItemUpdate(findPg, offset, id);
        ; Setup parameters for call to function hotItemUpdate
        MOV       A,R6
        MOV       R4,A
        MOV       A,R7
        MOV       R5,A
        MOV       R2,?V0
        MOV       R3,?V1
        MOV       DPTR,#findPg
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??hotItemUpdate::?relay`; Banked call to: hotItemUpdate
// 1241 
// 1242     return SUCCESS;
        MOV       R1,#0x0
        SJMP      ??osal_nv_item_init_1
// 1243   }
// 1244   else if ( initItem( TRUE, id, len, buf ) != OSAL_NV_PAGE_NULL )
??osal_nv_item_init_2:
        ; Setup parameters for call to function initItem
        MOV       R0,#?V4
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 18)
        MOV       R4,?V2
        MOV       R5,?V3
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,#0x1
        LCALL     `??initItem::?relay`; Banked call to: initItem
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 16)
        MOV       A,R1
        JZ        ??osal_nv_item_init_3
// 1245   {
// 1246     return NV_ITEM_UNINIT;
        MOV       R1,#0x9
        SJMP      ??osal_nv_item_init_1
// 1247   }
// 1248   else
// 1249   {
// 1250     return NV_OPER_FAILED;
??osal_nv_item_init_3:
        MOV       R1,#0xa
??osal_nv_item_init_1:
        MOV       R7,#0x8
        LJMP      ?BANKED_LEAVE_XDATA
// 1251   }
// 1252 }
          CFI EndBlock cfiBlock20
// 1253 
// 1254 /*********************************************************************
// 1255  * @fn      osal_nv_item_len
// 1256  *
// 1257  * @brief   Get the data length of the item stored in NV memory.
// 1258  *
// 1259  * @param   id  - Valid NV item Id.
// 1260  *
// 1261  * @return  Item length, if found; zero otherwise.
// 1262  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1263 uint16 osal_nv_item_len( uint16 id )
osal_nv_item_len:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function osal_nv_item_len
        CODE
// 1264 {
        FUNCALL osal_nv_item_len, hotItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_len, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_len, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V4
        REQUIRE ?V5
        MOV       A,#-0xe
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 8
        MOV       A,#-0x8
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
        MOV       ?V0,R2
        MOV       ?V1,R3
// 1265   osalNvHdr_t hdr;
// 1266   uint16 offset;
// 1267   uint8 hotIdx;
// 1268 
// 1269   if ((hotIdx = hotItem(id)) < OSAL_NV_MAX_HOT)
        ; Setup parameters for call to function hotItem
        MOV       R2,?V0
        MOV       R3,?V1
        LCALL     `??hotItem::?relay`; Banked call to: hotItem
        MOV       A,R1
        MOV       R0,A
        MOV       ?V2,R0
        MOV       A,R0
        CLR       C
        SUBB      A,#0x3
        JNC       ??osal_nv_item_len_0
// 1270   {
// 1271     findPg = hotPg[hotIdx];
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,#hotPg & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(hotPg >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       DPTR,#findPg
        MOVX      @DPTR,A
// 1272     offset = hotOff[hotIdx];
        MOV       A,?V2
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#hotOff & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(hotOff >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R6,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R7,A
        SJMP      ??osal_nv_item_len_1
// 1273   }
// 1274   else if ((offset = findItem(id)) == OSAL_NV_ITEM_NULL)
??osal_nv_item_len_0:
        ; Setup parameters for call to function findItem
        MOV       R2,?V0
        MOV       R3,?V1
        LCALL     `??findItem::?relay`; Banked call to: findItem
        MOV       ?V4,R2
        MOV       ?V5,R3
        MOV       R0,?V4
        MOV       R1,?V5
        MOV       A,R0
        MOV       R6,A
        MOV       A,R1
        MOV       R7,A
        MOV       A,R0
        ORL       A,R1
        JNZ       ??osal_nv_item_len_1
// 1275   {
// 1276     return 0;
        MOV       R2,#0x0
        MOV       R3,#0x0
        SJMP      ??osal_nv_item_len_2
// 1277   }
// 1278 
// 1279   HalFlashRead(findPg, (offset - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
??osal_nv_item_len_1:
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V4,#0x8
        MOV       ?V5,#0x0
        MOV       R0,#?V4
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 24)
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP102_8
        MOV       A,R6
        ADD       A,#-0x8
        MOV       R2,A
        MOV       A,R7
        ADDC      A,#-0x1
        MOV       R3,A
        MOV       DPTR,#findPg
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
// 1280   return hdr.len;
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R3,A
??osal_nv_item_len_2:
        MOV       A,#0x8
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        MOV       R7,#0x6
        LJMP      ?BANKED_LEAVE_XDATA
// 1281 }
          CFI EndBlock cfiBlock21
// 1282 
// 1283 /*********************************************************************
// 1284  * @fn      osal_nv_write
// 1285  *
// 1286  * @brief   Write a data item to NV. Function can write an entire item to NV or
// 1287  *          an element of an item by indexing into the item with an offset.
// 1288  *
// 1289  * @param   id  - Valid NV item Id.
// 1290  * @param   ndx - Index offset into item
// 1291  * @param   len - Length of data to write.
// 1292  * @param  *buf - Data to write.
// 1293  *
// 1294  * @return  SUCCESS if successful, NV_ITEM_UNINIT if item did not
// 1295  *          exist in NV and offset is non-zero, NV_OPER_FAILED if failure.
// 1296  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1297 uint8 osal_nv_write( uint16 id, uint16 ndx, uint16 len, void *buf )
osal_nv_write:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function osal_nv_write
        CODE
// 1298 {
        FUNCALL osal_nv_write, OnBoard_CheckVoltage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 44, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 44, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 44, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 44, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, initItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 44, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 44, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, xferBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, writeBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 44, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 44, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, xferBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, setChk
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, hotItemUpdate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, setPageUse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        REQUIRE ?V10
        REQUIRE ?V11
        REQUIRE ?V12
        REQUIRE ?V14
        REQUIRE ?V15
        MOV       A,#-0x18
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 18
        MOV       A,#-0x12
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 42)
        MOV       A,#0x10
        LCALL     ?XSTACK_DISP0_8
        MOV       A,R2
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R3
        MOVX      @DPTR,A
        MOV       ?V8,R4
        MOV       ?V9,R5
        MOV       A,#0x2a
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V14,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V15,A
// 1299   uint8 rtrn = SUCCESS;
        MOV       ?V7,#0x0
// 1300 
// 1301   if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
        ; Setup parameters for call to function OnBoard_CheckVoltage
        LCALL     `??OnBoard_CheckVoltage::?relay`; Banked call to: OnBoard_CheckVoltage
        MOV       A,R1
        JNZ       ??osal_nv_write_0
// 1302   {
// 1303     return NV_OPER_FAILED;
        MOV       R1,#0xa
        LJMP      ??osal_nv_write_1 & 0xFFFF
// 1304   }
// 1305   else if ( len != 0 )
??osal_nv_write_0:
        MOV       A,?V14
        ORL       A,?V15
        JNZ       $+5
        LJMP      ??osal_nv_write_2 & 0xFFFF
// 1306   {
// 1307     osalNvHdr_t hdr;
// 1308     uint16 origOff, srcOff;
// 1309     uint16 cnt, chk;
// 1310     uint8 *ptr, srcPg;
// 1311 
// 1312     origOff = srcOff = findItem( id );
        ; Setup parameters for call to function findItem
        MOV       A,#0x10
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R3,A
        LCALL     `??findItem::?relay`; Banked call to: findItem
        MOV       ?V0,R2
        MOV       ?V1,R3
        MOV       R0,?V0
        MOV       R1,?V1
        MOV       ?V4,R0
        MOV       ?V5,R1
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOV       A,R0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R1
        MOVX      @DPTR,A
// 1313     srcPg = findPg;
        MOV       DPTR,#findPg
        MOVX      A,@DPTR
        MOV       ?V12,A
// 1314     if ( srcOff == OSAL_NV_ITEM_NULL )
        MOV       A,?V4
        ORL       A,?V5
        JNZ       ??osal_nv_write_3
// 1315     {
// 1316       return NV_ITEM_UNINIT;
        MOV       R1,#0x9
        LJMP      ??osal_nv_write_1 & 0xFFFF
// 1317     }
// 1318 
// 1319     HalFlashRead(srcPg, (srcOff - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
??osal_nv_write_3:
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V0,#0x8
        MOV       ?V1,#0x0
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 44)
        MOV       A,#0xa
        LCALL     ?XSTACK_DISP102_8
        MOV       A,?V4
        ADD       A,#-0x8
        MOV       R2,A
        MOV       A,?V5
        ADDC      A,#-0x1
        MOV       R3,A
        MOV       R1,?V12
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 42)
// 1320     if ( hdr.len < (ndx + len) )
        MOV       A,#0xa
        LCALL     ?XSTACK_DISP0_8
        MOV       A,?V8
        ADD       A,?V14
        MOV       R0,A
        MOV       A,?V9
        ADDC      A,?V15
        MOV       R1,A
        CLR       C
        MOVX      A,@DPTR
        SUBB      A,R0
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,R1
        JNC       ??osal_nv_write_4
// 1321     {
// 1322       return NV_OPER_FAILED;
        MOV       R1,#0xa
        LJMP      ??osal_nv_write_1 & 0xFFFF
// 1323     }
// 1324 
// 1325     srcOff += ndx;
??osal_nv_write_4:
        MOV       A,?V4
        ADD       A,?V8
        MOV       ?V4,A
        MOV       A,?V5
        ADDC      A,?V9
        MOV       ?V5,A
// 1326     ptr = buf;
        MOV       A,#0x2c
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOV       A,R0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R1
        MOVX      @DPTR,A
// 1327     cnt = len;
        MOV       ?V2,?V14
        MOV       ?V3,?V15
// 1328     chk = 0;
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOV       A,#0x0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
// 1329     while ( cnt-- )
??osal_nv_write_5:
        MOV       R0,?V2
        MOV       R1,?V3
        MOV       A,R0
        ADD       A,#-0x1
        MOV       ?V2,A
        MOV       A,R1
        ADDC      A,#-0x1
        MOV       ?V3,A
        MOV       A,R0
        ORL       A,R1
        JNZ       $+5
        LJMP      ??osal_nv_write_6 & 0xFFFF
// 1330     {
// 1331       uint8 tmp;
// 1332       HalFlashRead(srcPg, srcOff, &tmp, 1);
        ; Setup parameters for call to function HalFlashRead
        MOV       ?V0,#0x1
        MOV       ?V1,#0x0
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 44)
        MOV       A,#0x3
        LCALL     ?XSTACK_DISP102_8
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       R1,?V12
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 42)
// 1333       if ( tmp != *ptr )
        MOV       A,#0x1
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       DPH,A
        MOV       DPL,R0
        MOVX      A,@DPTR
        XRL       A,R1
        JZ        ??osal_nv_write_7
// 1334       {
// 1335         chk = 1;  // Mark that at least one byte is different.
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOV       A,#0x1
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,#0x0
        MOVX      @DPTR,A
// 1336         // Calculate expected checksum after transferring old data and writing new data.
// 1337         hdr.chk -= tmp;
        MOV       A,#0x1
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,#0xc
        LCALL     ?XSTACK_DISP0_8
        CLR       C
        MOVX      A,@DPTR
        SUBB      A,R0
        MOVX      @DPTR,A
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,R1
        MOVX      @DPTR,A
// 1338         hdr.chk += *ptr;
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       DPH,A
        MOV       DPL,R0
        MOVX      A,@DPTR
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,#0xc
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        ADD       A,R0
        MOVX      @DPTR,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,R1
        MOVX      @DPTR,A
// 1339       }
// 1340       srcOff++;
??osal_nv_write_7:
        INC       ?V4
        MOV       A,?V4
        JNZ       ??osal_nv_write_8
        INC       ?V5
// 1341       ptr++;
??osal_nv_write_8:
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        ADD       A,#0x1
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,#0x0
        MOV       R1,A
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP0_8
        MOV       A,R0
        MOVX      @DPTR,A
        INC       DPTR
        MOV       A,R1
        MOVX      @DPTR,A
        LJMP      ??osal_nv_write_5 & 0xFFFF
// 1342     }
// 1343 
// 1344     if ( chk != 0 )  // If the buffer to write is different in one or more bytes.
??osal_nv_write_6:
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       A,R0
        ORL       A,R1
        JNZ       $+5
        LJMP      ??osal_nv_write_2 & 0xFFFF
// 1345     {
// 1346       uint8 comPg = OSAL_NV_PAGE_NULL;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOV       A,#0x0
        MOVX      @DPTR,A
// 1347       uint8 dstPg = initItem( FALSE, id, hdr.len, &comPg );
        ; Setup parameters for call to function initItem
        MOV       R0,?XSP + 0
        MOV       R1,?XSP + 1
        MOV       ?V0,R0
        MOV       ?V1,R1
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 44)
        MOV       A,#0xc
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       A,#0x12
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R3,A
        MOV       R1,#0x0
        LCALL     `??initItem::?relay`; Banked call to: initItem
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 42)
        MOV       A,R1
        MOV       ?V6,A
// 1348 
// 1349       if ( dstPg != OSAL_NV_PAGE_NULL )
        MOV       A,?V6
        JNZ       $+5
        LJMP      ??osal_nv_write_9 & 0xFFFF
// 1350       {
// 1351         uint16 tmp = OSAL_NV_DATA_SIZE( hdr.len );
        MOV       A,#0xa
        LCALL     ?XSTACK_DISP0_8
        CLR       C
        MOVX      A,@DPTR
        SUBB      A,#-0x4
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,#-0x1
        JC        ??osal_nv_write_10
        MOV       ?V0,#-0x4
        MOV       ?V1,#-0x1
        SJMP      ??osal_nv_write_11
??osal_nv_write_10:
        MOV       A,#0xa
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        ADD       A,#0x3
        MOV       ?V0,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,#0x0
        MOV       ?V1,A
        MOV       A,#0x2
        MOV       R0,#?V0
        LCALL     ?US_SHR
        MOV       A,?V0
        MOV       B,#0x4
        MUL       AB
        XCH       A,?V0
        MOV       R0,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R0
        MOV       R0,A
        MOV       B,#0x4
        MOV       A,?V1
        MUL       AB
        ADD       A,R0
        MOV       ?V1,A
// 1352         uint16 dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
??osal_nv_write_11:
        MOV       A,?V6
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        CLR       C
        SUBB      A,?V0
        MOV       R6,A
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,?V1
        MOV       R7,A
// 1353         srcOff = origOff;
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V5,A
// 1354 
// 1355         /* Prevent excessive re-writes to item header caused by numerous, rapid, & successive
// 1356          * OSAL_Nv interruptions caused by resets.
// 1357          */
// 1358         if ( hdr.stat == OSAL_NV_ERASED_ID )
        MOV       A,#0xe
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,#0xff
        JNZ       ??osal_nv_write_12
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,#0xff
??osal_nv_write_12:
        JNZ       ??osal_nv_write_13
// 1359         {
// 1360           setItem( srcPg, srcOff, eNvXfer );
        ; Setup parameters for call to function setItem
        MOV       R4,#0x0
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       R1,?V12
        LCALL     `??setItem::?relay`; Banked call to: setItem
// 1361         }
// 1362 
// 1363         xferBuf( srcPg, srcOff, dstPg, dstOff, ndx );
??osal_nv_write_13:
        ; Setup parameters for call to function xferBuf
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 44)
        MOV       ?V10,R6
        MOV       ?V11,R7
        MOV       R0,#?V10
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 46)
        MOV       R4,?V6
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       R1,?V12
        LCALL     `??xferBuf::?relay`; Banked call to: xferBuf
        MOV       A,#0x4
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 42)
// 1364         srcOff += ndx;
        MOV       A,?V4
        ADD       A,?V8
        MOV       ?V4,A
        MOV       A,?V5
        ADDC      A,?V9
        MOV       ?V5,A
// 1365         dstOff += ndx;
        MOV       A,R6
        ADD       A,?V8
        MOV       R6,A
        MOV       A,R7
        ADDC      A,?V9
        MOV       R7,A
// 1366 
// 1367         writeBuf( dstPg, dstOff, len, buf );
        ; Setup parameters for call to function writeBuf
        MOV       A,#0x2c
        LCALL     ?XSTACK_DISP0_8
        LCALL     ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 44)
        MOV       R4,?V14
        MOV       R5,?V15
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V6
        LCALL     `??writeBuf::?relay`; Banked call to: writeBuf
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 42)
// 1368         srcOff += len;
        MOV       A,?V4
        ADD       A,?V14
        MOV       ?V4,A
        MOV       A,?V5
        ADDC      A,?V15
        MOV       ?V5,A
// 1369         dstOff += len;
        MOV       A,R6
        ADD       A,?V14
        MOV       R6,A
        MOV       A,R7
        ADDC      A,?V15
        MOV       R7,A
// 1370 
// 1371         xferBuf( srcPg, srcOff, dstPg, dstOff, (hdr.len-ndx-len) );
        ; Setup parameters for call to function xferBuf
        MOV       A,#0xa
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        CLR       C
        SUBB      A,?V8
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,?V9
        MOV       R1,A
        MOV       A,R0
        CLR       C
        SUBB      A,?V14
        MOV       ?V10,A
        MOV       A,R1
        SUBB      A,?V15
        MOV       ?V11,A
        MOV       R0,#?V10
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 44)
        MOV       ?V10,R6
        MOV       ?V11,R7
        MOV       R0,#?V10
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 46)
        MOV       R4,?V6
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       R1,?V12
        LCALL     `??xferBuf::?relay`; Banked call to: xferBuf
        MOV       A,#0x4
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 42)
// 1372 
// 1373         // Calculate and write the new checksum.
// 1374         dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
        MOV       A,?V6
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#(pgOff + 14) & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#((pgOff - 242) >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        CLR       C
        SUBB      A,?V0
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        SUBB      A,?V1
        MOV       R1,A
        MOV       A,R0
        MOV       R6,A
        MOV       A,R1
        MOV       R7,A
// 1375 
// 1376         if ( hdr.chk == calcChkF( dstPg, dstOff, hdr.len ) )
        ; Setup parameters for call to function calcChkF
        MOV       A,#0xa
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V6
        LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
        MOV       ?V10,R2
        MOV       ?V11,R3
        MOV       R0,?V10
        MOV       R1,?V11
        MOV       A,#0xc
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??osal_nv_write_14
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??osal_nv_write_14:
        JNZ       ??osal_nv_write_15
// 1377         {
// 1378           if ( hdr.chk != setChk( dstPg, dstOff, hdr.chk ) )
        ; Setup parameters for call to function setChk
        MOV       A,#0xc
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V6
        LCALL     `??setChk::?relay`; Banked call to: setChk
        MOV       ?V10,R2
        MOV       ?V11,R3
        MOV       R0,?V10
        MOV       R1,?V11
        MOV       A,#0xc
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        XRL       A,R0
        JNZ       ??osal_nv_write_16
        INC       DPTR
        MOVX      A,@DPTR
        XRL       A,R1
??osal_nv_write_16:
        JZ        ??osal_nv_write_17
// 1379           {
// 1380             rtrn = NV_OPER_FAILED;
        MOV       ?V7,#0xa
        SJMP      ??osal_nv_write_18
// 1381           }
// 1382           else
// 1383           {
// 1384             hotItemUpdate(dstPg, dstOff, hdr.id);
??osal_nv_write_17:
        ; Setup parameters for call to function hotItemUpdate
        MOV       A,#0x8
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R5,A
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        MOV       R1,?V6
        LCALL     `??hotItemUpdate::?relay`; Banked call to: hotItemUpdate
        SJMP      ??osal_nv_write_18
// 1385           }
// 1386         }
// 1387         else
// 1388         {
// 1389           rtrn = NV_OPER_FAILED;
??osal_nv_write_15:
        MOV       ?V7,#0xa
        SJMP      ??osal_nv_write_18
// 1390         }
// 1391       }
// 1392       else
// 1393       {
// 1394         rtrn = NV_OPER_FAILED;
??osal_nv_write_9:
        MOV       ?V7,#0xa
// 1395       }
// 1396 
// 1397       if ( comPg != OSAL_NV_PAGE_NULL )
??osal_nv_write_18:
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        JZ        ??osal_nv_write_19
// 1398       {
// 1399         /* Even though the page compaction succeeded, if the new item is coming from the compacted
// 1400          * page and writing the new value failed, then the compaction must be aborted.
// 1401          */
// 1402         if ( (srcPg == comPg) && (rtrn == NV_OPER_FAILED) )
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        XRL       A,?V12
        JNZ       ??osal_nv_write_20
        MOV       A,#0xa
        XRL       A,?V7
        JNZ       ??osal_nv_write_20
// 1403         {
// 1404           erasePage( pgRes );
        ; Setup parameters for call to function erasePage
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
        SJMP      ??osal_nv_write_19
// 1405         }
// 1406         else
// 1407         {
// 1408           COMPACT_PAGE_CLEANUP( comPg );
??osal_nv_write_20:
        ; Setup parameters for call to function setPageUse
        MOV       R2,#0x1
        MOV       DPTR,#pgRes
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??setPageUse::?relay`; Banked call to: setPageUse
        ; Setup parameters for call to function erasePage
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??erasePage::?relay`; Banked call to: erasePage
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        MOV       DPTR,#pgRes
        MOVX      @DPTR,A
// 1409         }
// 1410       }
// 1411 
// 1412       /* Zero of the old item must wait until after compact page cleanup has finished - if the item
// 1413        * is zeroed before and cleanup is interrupted by a power-cycle, the new item can be lost.
// 1414        */
// 1415       if ( (srcPg != comPg) && (rtrn != NV_OPER_FAILED) )
??osal_nv_write_19:
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      A,@DPTR
        XRL       A,?V12
        JZ        ??osal_nv_write_2
        MOV       A,#0xa
        XRL       A,?V7
        JZ        ??osal_nv_write_2
// 1416       {
// 1417         setItem( srcPg, origOff, eNvZero );
        ; Setup parameters for call to function setItem
        MOV       R4,#0x1
        MOV       A,#0x6
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R3,A
        MOV       R1,?V12
        LCALL     `??setItem::?relay`; Banked call to: setItem
// 1418       }
// 1419     }
// 1420   }
// 1421 
// 1422   return rtrn;
??osal_nv_write_2:
        MOV       R1,?V7
??osal_nv_write_1:
        MOV       A,#0x12
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV       R7,#0x10
        LJMP      ?BANKED_LEAVE_XDATA
// 1423 }
          CFI EndBlock cfiBlock22
// 1424 
// 1425 /*********************************************************************
// 1426  * @fn      osal_nv_read
// 1427  *
// 1428  * @brief   Read data from NV. This function can be used to read an entire item from NV or
// 1429  *          an element of an item by indexing into the item with an offset.
// 1430  *          Read data is copied into *buf.
// 1431  *
// 1432  * @param   id  - Valid NV item Id.
// 1433  * @param   ndx - Index offset into item
// 1434  * @param   len - Length of data to read.
// 1435  * @param  *buf - Data is read into this buffer.
// 1436  *
// 1437  * @return  SUCCESS if NV data was copied to the parameter 'buf'.
// 1438  *          Otherwise, NV_OPER_FAILED for failure.
// 1439  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1440 uint8 osal_nv_read( uint16 id, uint16 ndx, uint16 len, void *buf )
osal_nv_read:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function osal_nv_read
        CODE
// 1441 {
        FUNCALL osal_nv_read, hotItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_read, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_read, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_read, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        REQUIRE ?V10
        REQUIRE ?V11
        MOV       A,#-0x14
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 0
        MOV       ?V2,R2
        MOV       ?V3,R3
        MOV       A,R4
        MOV       R6,A
        MOV       A,R5
        MOV       R7,A
        MOV       A,#0x14
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V8,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V9,A
        MOV       A,#0x16
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       ?V4,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       ?V5,A
// 1442   uint16 offset;
// 1443   uint8 hotIdx;
// 1444 
// 1445   if ((hotIdx = hotItem(id)) < OSAL_NV_MAX_HOT)
        ; Setup parameters for call to function hotItem
        MOV       R2,?V2
        MOV       R3,?V3
        LCALL     `??hotItem::?relay`; Banked call to: hotItem
        MOV       A,R1
        MOV       R0,A
        MOV       ?V0,R0
        MOV       A,R0
        CLR       C
        SUBB      A,#0x3
        JNC       ??osal_nv_read_0
// 1446   {
// 1447     HalFlashRead(hotPg[hotIdx], hotOff[hotIdx]+ndx, buf, len);
        ; Setup parameters for call to function HalFlashRead
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV       R4,?V4
        MOV       R5,?V5
        MOV       A,?V0
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,R0
        MOV       B,#0x2
        MUL       AB
        XCH       A,R0
        MOV       R2,B
        MOV       B,#0x0
        MUL       AB
        ADD       A,R2
        MOV       R2,A
        MOV       B,#0x2
        MOV       A,R1
        MUL       AB
        ADD       A,R2
        MOV       R1,A
        MOV       A,#hotOff & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(hotOff >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        ADD       A,R6
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        ADDC      A,R7
        MOV       R3,A
        MOV       A,?V0
        MOV       R0,A
        MOV       R1,#0x0
        MOV       A,#hotPg & 0xff
        ADD       A,R0
        MOV       DPL,A
        MOV       A,#(hotPg >> 8) & 0xff
        ADDC      A,R1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
// 1448     return SUCCESS;
        MOV       R1,#0x0
        SJMP      ??osal_nv_read_1
// 1449   }
// 1450 
// 1451   if ((offset = findItem(id)) == OSAL_NV_ITEM_NULL)
??osal_nv_read_0:
        ; Setup parameters for call to function findItem
        MOV       R2,?V2
        MOV       R3,?V3
        LCALL     `??findItem::?relay`; Banked call to: findItem
        MOV       ?V10,R2
        MOV       ?V11,R3
        MOV       R0,?V10
        MOV       R1,?V11
        MOV       ?V6,R0
        MOV       ?V7,R1
        MOV       A,R0
        ORL       A,R1
        JNZ       ??osal_nv_read_2
// 1452   {
// 1453     return NV_OPER_FAILED;
        MOV       R1,#0xa
        SJMP      ??osal_nv_read_1
// 1454   }
// 1455   else
// 1456   {
// 1457     HalFlashRead(findPg, offset+ndx, buf, len);
??osal_nv_read_2:
        ; Setup parameters for call to function HalFlashRead
        MOV       R0,#?V8
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV       R4,?V4
        MOV       R5,?V5
        MOV       A,?V6
        ADD       A,R6
        MOV       R2,A
        MOV       A,?V7
        ADDC      A,R7
        MOV       R3,A
        MOV       DPTR,#findPg
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
// 1458     return SUCCESS;
        MOV       R1,#0x0
??osal_nv_read_1:
        MOV       R7,#0xc
        LJMP      ?BANKED_LEAVE_XDATA
// 1459   }
// 1460 }
          CFI EndBlock cfiBlock23
// 1461 
// 1462 /*********************************************************************
// 1463  * @fn      osal_nv_delete
// 1464  *
// 1465  * @brief   Delete item from NV. This function will fail if the length
// 1466  *          parameter does not match the length of the item in NV.
// 1467  *
// 1468  * @param   id  - Valid NV item Id.
// 1469  * @param   len - Length of item to delete.
// 1470  *
// 1471  * @return  SUCCESS if item was deleted,
// 1472  *          NV_ITEM_UNINIT if item did not exist in NV,
// 1473  *          NV_BAD_ITEM_LEN if length parameter not correct,
// 1474  *          NV_OPER_FAILED if attempted deletion failed.
// 1475  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1476 uint8 osal_nv_delete( uint16 id, uint16 len )
osal_nv_delete:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function osal_nv_delete
        CODE
// 1477 {
        FUNCALL osal_nv_delete, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_delete, osal_nv_item_len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_delete, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_delete, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV       A,#-0x10
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
        MOV       ?V2,R4
        MOV       ?V3,R5
// 1478   uint16 length;
// 1479   uint16 offset;
// 1480 
// 1481   offset = findItem( id );
        ; Setup parameters for call to function findItem
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LCALL     `??findItem::?relay`; Banked call to: findItem
        MOV       ?V6,R2
        MOV       ?V7,R3
        MOV       ?V4,?V6
        MOV       ?V5,?V7
// 1482   if ( offset == OSAL_NV_ITEM_NULL )
        MOV       A,?V4
        ORL       A,?V5
        JNZ       ??osal_nv_delete_0
// 1483   {
// 1484     // NV item does not exist
// 1485     return NV_ITEM_UNINIT;
        MOV       R1,#0x9
        SJMP      ??osal_nv_delete_1
// 1486   }
// 1487 
// 1488   length = osal_nv_item_len( id );
??osal_nv_delete_0:
        ; Setup parameters for call to function osal_nv_item_len
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
        MOV       ?V6,R2
        MOV       ?V7,R3
        MOV       ?V0,?V6
        MOV       ?V1,?V7
// 1489   if ( length != len )
        MOV       A,?V2
        XRL       A,?V0
        JNZ       ??osal_nv_delete_2
        MOV       A,?V3
        XRL       A,?V1
??osal_nv_delete_2:
        JZ        ??osal_nv_delete_3
// 1490   {
// 1491     // NV item has different length
// 1492     return NV_BAD_ITEM_LEN;
        MOV       R1,#0xc
        SJMP      ??osal_nv_delete_1
// 1493   }
// 1494 
// 1495   // Set item header ID to zero to 'delete' the item
// 1496   setItem( findPg, offset, eNvZero );
??osal_nv_delete_3:
        ; Setup parameters for call to function setItem
        MOV       R4,#0x1
        MOV       R2,?V4
        MOV       R3,?V5
        MOV       DPTR,#findPg
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??setItem::?relay`; Banked call to: setItem
// 1497 
// 1498   // Verify that item has been removed
// 1499   offset = findItem( id );
        ; Setup parameters for call to function findItem
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LCALL     `??findItem::?relay`; Banked call to: findItem
        MOV       ?V6,R2
        MOV       ?V7,R3
        MOV       ?V4,?V6
        MOV       ?V5,?V7
// 1500   if ( offset != OSAL_NV_ITEM_NULL )
        MOV       A,?V4
        ORL       A,?V5
        JZ        ??osal_nv_delete_4
// 1501   {
// 1502     // Still there
// 1503     return NV_OPER_FAILED;
        MOV       R1,#0xa
        SJMP      ??osal_nv_delete_1
// 1504   }
// 1505   else
// 1506   {
// 1507     // Yes, it's gone
// 1508     return SUCCESS;
??osal_nv_delete_4:
        MOV       R1,#0x0
??osal_nv_delete_1:
        MOV       R7,#0x8
        LJMP      ?BANKED_LEAVE_XDATA
// 1509   }
// 1510 }
          CFI EndBlock cfiBlock24

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??initNV::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    initNV

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??setPageUse::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    setPageUse

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??initPage::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    initPage

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??erasePage::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    erasePage

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??compactPage::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    compactPage

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??findItem::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    findItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??initItem::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    initItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??setItem::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    setItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??setChk::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    setChk

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??calcChkB::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    calcChkB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??calcChkF::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    calcChkF

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??writeWord::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    writeWord

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??writeWordM::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    writeWordM

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??writeWordH::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    writeWordH

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??writeBuf::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    writeBuf

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??xferBuf::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    xferBuf

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??writeItem::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    writeItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??hotItem::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    hotItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??hotItemUpdate::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    hotItemUpdate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??osal_nv_init::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    osal_nv_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??osal_nv_item_init::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    osal_nv_item_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??osal_nv_item_len::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    osal_nv_item_len

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??osal_nv_write::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    osal_nv_write

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??osal_nv_read::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    osal_nv_read

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??osal_nv_delete::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    osal_nv_delete

        END
// 1511 
// 1512 /*********************************************************************
// 1513  */
// 
//  7 098 bytes in segment BANKED_CODE
//    150 bytes in segment BANK_RELAYS
//      6 bytes in segment XDATA_ROM_C
//     35 bytes in segment XDATA_Z
// 12 288 bytes in segment ZIGNV_ADDRESS_SPACE
// 
//    150 bytes of CODE     memory
//      6 bytes of CONST    memory
//  7 098 bytes of HUGECODE memory
// 12 323 bytes of XDATA    memory
//
//Errors: none
//Warnings: none
