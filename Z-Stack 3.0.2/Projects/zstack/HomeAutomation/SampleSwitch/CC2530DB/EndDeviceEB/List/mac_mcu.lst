###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               31/Jul/2020  11:47:20
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack
#        3.0.2\Components\mac\low_level\srf04\single_chip\mac_mcu.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EWB65C.tmp ("D:\AA\Z-Stack
#        3.0.2\Components\mac\low_level\srf04\single_chip\mac_mcu.c" -D
#        SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D POWER_SAVING
#        -D NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D
#        xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_GROUPS -D BDB_TL_INITIATOR -D INTER_PAN -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\" -I
#        "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -On --require_prototypes --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_cross_call)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List\mac_mcu.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj\mac_mcu.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Components\mac\low_level\srf04\single_chip\mac_mcu.c
      1          /**************************************************************************************************
      2            Filename:       mac_mcu.c
      3            Revised:        $Date: 2015-02-17 14:17:44 -0800 (Tue, 17 Feb 2015) $
      4            Revision:       $Revision: 42683 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_defs.h"
     47          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIRQF1
   \                     RFIRQF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x94
   \   unsigned char volatile __sfr T2CTRL
   \                     T2CTRL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2IRQF
   \                     T2IRQF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2M0
   \                     T2M0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2M1
   \                     T2M1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2MOVF0
   \                     T2MOVF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa5
   \   unsigned char volatile __sfr T2MOVF1
   \                     T2MOVF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa6
   \   unsigned char volatile __sfr T2MOVF2
   \                     T2MOVF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa7
   \   unsigned char volatile __sfr T2IRQM
   \                     T2IRQM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa9
   \   unsigned char volatile __sfr IP0
   \                     IP0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb9
   \   unsigned char volatile __sfr IP1
   \                     IP1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbc
   \   unsigned char volatile __sfr RNDL
   \                     RNDL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbd
   \   unsigned char volatile __sfr RNDH
   \                     RNDH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbf
   \   unsigned char volatile __sfr RFERRF
   \                     RFERRF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2MSEL
   \                     T2MSEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe9
   \   unsigned char volatile __sfr RFIRQF0
   \                     RFIRQF0:
   \   000000                DS 1
     48          
     49          /* low-level specific */
     50          #include "mac_rx.h"
     51          #include "mac_tx.h"
     52          #include "mac_backoff_timer.h"
     53          #include "mac_csp_tx.h"
     54          #include "mac_rx_onoff.h"
     55          #include "mac_low_level.h"
     56          
     57          /* target specific */
     58          #include "mac_mcu.h"
     59          #include "mac_radio_defs.h"
     60          
     61          /* debug */
     62          #include "mac_assert.h"
     63          
     64          /* high level */
     65          #include "mac_pib.h"
     66          
     67          /* ------------------------------------------------------------------------------------------------
     68           *                                           Defines
     69           * ------------------------------------------------------------------------------------------------
     70           */
     71          
     72          /* for optimized indexing of uint32's */
     73          #if HAL_MCU_LITTLE_ENDIAN()
     74          #define UINT32_NDX0   0
     75          #define UINT32_NDX1   1
     76          #define UINT32_NDX2   2
     77          #define UINT32_NDX3   3
     78          #else
     79          #define UINT32_NDX0   3
     80          #define UINT32_NDX1   2
     81          #define UINT32_NDX2   1
     82          #define UINT32_NDX3   0
     83          #endif
     84          
     85          /* ------------------------------------------------------------------------------------------------
     86          *                                        Global Functions
     87          * ------------------------------------------------------------------------------------------------
     88          */
     89          
     90          /* ------------------------------------------------------------------------------------------------
     91           *                                        Local Variables
     92           * ------------------------------------------------------------------------------------------------
     93           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     94          uint8       macChipVersion = 0;
   \                     macChipVersion:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     95          static int8 maxRssi;
   \                     maxRssi:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     96          static uint32 prevAccumulatedOverflowCount = 0;
   \                     prevAccumulatedOverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     97          static bool updateRolloverflag = FALSE;
   \                     updateRolloverflag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     98          static uint32 prevoverflowCount = 0;
   \                     prevoverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     99          
    100          
    101          /*
    102           *  This number is used to calculate the precision count for OSAL timer update. In Beacon mode,
    103           *  the overflow count may be initialized to zero or to a constant. The "skip" in overflow count
    104           *  needs to be accounted for in this variable.
    105           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    106          static uint32 accumulatedOverflowCount = 0;
   \                     accumulatedOverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    107          
    108          /* Function pointer for the random seed callback */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    109          static macRNGFcn_t pRandomSeedCB = NULL;
   \                     pRandomSeedCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    110          /* ------------------------------------------------------------------------------------------------
    111           *                                       Local Prototypes
    112           * ------------------------------------------------------------------------------------------------
    113           */
    114          static void mcuRecordMaxRssiIsr(void);
    115          static uint32 macMcuOverflowGetCompare(void);
    116          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn);
    117          
    118          
    119          /**************************************************************************************************
    120           * @fn          MAC_SetRandomSeedCB
    121           *
    122           * @brief       Set the function pointer for the random seed callback.
    123           *
    124           * @param       pCBFcn - function pointer of the random seed callback
    125           *
    126           * @return      none
    127           **************************************************************************************************
    128           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    129          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn)
   \                     MAC_SetRandomSeedCB:
    130          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    131            pRandomSeedCB = pCBFcn;
   \   000004   90....       MOV       DPTR,#pRandomSeedCB
   \   000007   EA           MOV       A,R2
   \   000008   F0           MOVX      @DPTR,A
   \   000009   A3           INC       DPTR
   \   00000A   EB           MOV       A,R3
   \   00000B   F0           MOVX      @DPTR,A
    132          }
   \   00000C   D083         POP       DPH
   \   00000E   D082         POP       DPL
   \   000010   02....       LJMP      ?BRET
    133          
    134          /**************************************************************************************************
    135           * @fn          macMcuInit
    136           *
    137           * @brief       Initialize the MCU.
    138           *
    139           * @param       none
    140           *
    141           * @return      none
    142           **************************************************************************************************
    143           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    144          MAC_INTERNAL_API void macMcuInit(void)
   \                     macMcuInit:
    145          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV       A,#-0x20
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    146            halIntState_t  s;
    147          
    148            /* This CORR_THR value should be changed to 0x14 before attempting RX. Testing has shown that
    149             * too many false frames are received if the reset value is used. Make it more likely to detect
    150             * sync by removing the requirement that both symbols in the SFD must have a correlation value
    151             * above the correlation threshold, and make sync word detection less likely by raising the
    152             * correlation threshold.
    153             */
    154            MDMCTRL1 = CORR_THR;
   \   00000A   9061A9       MOV       DPTR,#0x61a9
   \   00000D   7414         MOV       A,#0x14
   \   00000F   F0           MOVX      @DPTR,A
    155          
    156          #ifdef FEATURE_CC253X_LOW_POWER_RX
    157            /* Reduce RX power consumption current to 20mA at the cost of some sensitivity
    158             * Note: This feature can be applied to CC2530 and CC2533 only.
    159             */
    160            RXCTRL = 0x00;
    161            FSCTRL = 0x50;
    162          #else
    163            /* tuning adjustments for optimal radio performance; details available in datasheet */
    164            RXCTRL = 0x3F;
   \   000010   9061AB       MOV       DPTR,#0x61ab
   \   000013   743F         MOV       A,#0x3f
   \   000015   F0           MOVX      @DPTR,A
    165            
    166            /* Adjust current in synthesizer; details available in datasheet. */
    167            FSCTRL = 0x55;
   \   000016   9061AC       MOV       DPTR,#0x61ac
   \   000019   7455         MOV       A,#0x55
   \   00001B   F0           MOVX      @DPTR,A
    168          #endif /* #ifdef FEATURE_CC253X_LOW_POWER_RX */ 
    169          
    170          #if !(defined HAL_PA_LNA || defined HAL_PA_LNA_CC2590 || \
    171                defined HAL_PA_LNA_SE2431L || defined HAL_PA_LNA_CC2592)
    172            /* Raises the CCA threshold from about -108 dBm to about -80 dBm input level.
    173             */
    174            CCACTRL0 = CCA_THR;
   \   00001C   906196       MOV       DPTR,#0x6196
   \   00001F   74FC         MOV       A,#-0x4
   \   000021   F0           MOVX      @DPTR,A
    175          #endif
    176          
    177            /* Makes sync word detection less likely by requiring two zero symbols before the sync word.
    178             * details available in datasheet.
    179             */
    180            MDMCTRL0 = 0x85;
   \   000022   9061A8       MOV       DPTR,#0x61a8
   \   000025   7485         MOV       A,#-0x7b
   \   000027   F0           MOVX      @DPTR,A
    181          
    182            /* In order to make a single library build, CC2533 specific accesses need to
    183             * be detected by reading the Chip ID
    184             */
    185            if ((*(uint8 *)(P_INFOPAGE+0x03) == 0x95) || (*(uint8 *)(P_INFOPAGE+0x03) == 0x34))
   \   000028   907803       MOV       DPTR,#0x7803
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   6495         XRL       A,#0x95
   \   00002E   6008         JZ        ??macMcuInit_0
   \   000030   907803       MOV       DPTR,#0x7803
   \   000033   E0           MOVX      A,@DPTR
   \   000034   6434         XRL       A,#0x34
   \   000036   700C         JNZ       ??macMcuInit_1
    186            {
    187              /* In case the device is a 2533, just update the IVCTRL regoster which is 2533 specific */
    188              #define IVCTRL          XREG( 0x6265 )
    189              IVCTRL = 0xF;
   \                     ??macMcuInit_0:
   \   000038   906265       MOV       DPTR,#0x6265
   \   00003B   740F         MOV       A,#0xf
   \   00003D   F0           MOVX      @DPTR,A
    190              CCACTRL0 = CCA_THR_CC2533; 
   \   00003E   906196       MOV       DPTR,#0x6196
   \   000041   74F8         MOV       A,#-0x8
   \   000043   F0           MOVX      @DPTR,A
    191            }
    192          
    193            /* Adjust current in VCO; details available in datasheet. */
    194          #ifdef FEATURE_VCO_ALTERNATE_SETTING
    195            FSCAL1 = 0x80;
    196          #else
    197            FSCAL1 = 0x00;
   \                     ??macMcuInit_1:
   \   000044   9061AE       MOV       DPTR,#0x61ae
   \   000047   7400         MOV       A,#0x0
   \   000049   F0           MOVX      @DPTR,A
    198          #endif
    199          
    200            /* Adjust target value for AGC control loop; details available in datasheet. */
    201            AGCCTRL1 = 0x15;
   \   00004A   9061B2       MOV       DPTR,#0x61b2
   \   00004D   7415         MOV       A,#0x15
   \   00004F   F0           MOVX      @DPTR,A
    202          
    203            /* Disable source address matching an autopend for now */
    204            SRCMATCH = 0;
   \   000050   906182       MOV       DPTR,#0x6182
   \   000053   7400         MOV       A,#0x0
   \   000055   F0           MOVX      @DPTR,A
    205          
    206            /* Tune ADC performance, details available in datasheet. */
    207            ADCTEST0 = 0x10;
   \   000056   9061B5       MOV       DPTR,#0x61b5
   \   000059   7410         MOV       A,#0x10
   \   00005B   F0           MOVX      @DPTR,A
    208            ADCTEST1 = 0x0E;
   \   00005C   9061B6       MOV       DPTR,#0x61b6
   \   00005F   740E         MOV       A,#0xe
   \   000061   F0           MOVX      @DPTR,A
    209            ADCTEST2 = 0x03;
   \   000062   9061B7       MOV       DPTR,#0x61b7
   \   000065   7403         MOV       A,#0x3
   \   000067   F0           MOVX      @DPTR,A
    210          
    211            /* Sets TX anti-aliasing filter to appropriate bandwidth.
    212             * Reduces spurious emissions close to signal.
    213             */
    214            TXFILTCFG = TXFILTCFG_RESET_VALUE;
   \   000068   9061FA       MOV       DPTR,#0x61fa
   \   00006B   7409         MOV       A,#0x9
   \   00006D   F0           MOVX      @DPTR,A
    215          
    216            /* disable the CSPT register compare function */
    217            CSPT = 0xFF;
   \   00006E   9061E5       MOV       DPTR,#0x61e5
   \   000071   74FF         MOV       A,#-0x1
   \   000073   F0           MOVX      @DPTR,A
    218          
    219            /* enable general RF interrupts */
    220            IEN2 |= RFIE;
   \   000074   439A01       ORL       0x9a,#0x1
    221          
    222            /* enable general REERR interrupts */
    223            IEN0 |= RFERRIE;
   \   000077   D2A8         SETB      0xa8.0
    224          
    225            /* set RF interrupts one notch above lowest priority (four levels available) */
    226            IP0 |=  IP_RFERR_RF_DMA_BV;
   \   000079   43A901       ORL       0xa9,#0x1
    227            IP1 &= ~IP_RFERR_RF_DMA_BV;
   \   00007C   53B9FE       ANL       0xb9,#0xfe
    228          
    229            /* set T2 interrupts one notch above lowest priority (four levels available)
    230             * This effectively turned off nested interrupt between T2 and RF.
    231             */
    232            IP0 |=  IP_RXTX0_T2_BV;
   \   00007F   43A904       ORL       0xa9,#0x4
    233            IP1 &= ~IP_RXTX0_T2_BV;
   \   000082   53B9FB       ANL       0xb9,#0xfb
    234          
    235            /* read chip version */
    236            macChipVersion = CHVER;
   \   000085   906249       MOV       DPTR,#0x6249
   \   000088   E0           MOVX      A,@DPTR
   \   000089   90....       MOV       DPTR,#macChipVersion
   \   00008C   F0           MOVX      @DPTR,A
    237          
    238            /*-------------------------------------------------------------------------------
    239             *  Initialize MAC timer.
    240             */
    241          
    242            /* set timer rollover */
    243            HAL_ENTER_CRITICAL_SECTION(s);
   \   00008D   A2AF         MOV       C,0xa8.7
   \   00008F   E4           CLR       A
   \   000090   33           RLC       A
   \   000091   F5..         MOV       ?V0,A
   \   000093   C2AF         CLR       0xa8.7
    244            MAC_MCU_T2_ACCESS_PERIOD_VALUE();
   \   000095   75C302       MOV       0xc3,#0x2
    245            T2M0 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() & 0xFF;
   \   000098   75A200       MOV       0xa2,#0x0
    246            T2M1 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() >> 8;
   \   00009B   75A328       MOV       0xa3,#0x28
    247            HAL_EXIT_CRITICAL_SECTION(s);
   \   00009E   E5..         MOV       A,?V0
   \   0000A0   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000A2   92AF         MOV       0xa8.7,C
    248          
    249            /* start timer */
    250            MAC_RADIO_TIMER_WAKE_UP();
   \                     ??macMcuInit_2:
   \   0000A4   E59E         MOV       A,0x9e
   \   0000A6   70FC         JNZ       ??macMcuInit_2
   \   0000A8   439403       ORL       0x94,#0x3
   \                     ??macMcuInit_3:
   \   0000AB   E594         MOV       A,0x94
   \   0000AD   A2E2         MOV       C,0xE0 /* A   */.2
   \   0000AF   50FA         JNC       ??macMcuInit_3
    251          
    252            /* Enable latch mode and T2 SYNC start. OSAL timer is based on MAC timer.
    253             * The SYNC start msut be on when POWER_SAVING is on for this design to work.
    254             */
    255            T2CTRL |= (LATCH_MODE | TIMER2_SYNC);
   \   0000B1   43940A       ORL       0x94,#0xa
    256          
    257            /* enable timer interrupts */
    258            T2IE = 1;
   \   0000B4   D2BA         SETB      0xb8.2
    259          
    260           /*----------------------------------------------------------------------------------------------
    261            *  Initialize random seed value.
    262            */
    263          
    264            /*
    265             *  Set radio for infinite reception.  Once radio reaches this state,
    266             *  it will stay in receive mode regardless RF activity.
    267             */
    268            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_INFINITE_RECEPTION;
   \   0000B6   906189       MOV       DPTR,#0x6189
   \   0000B9   7448         MOV       A,#0x48
   \   0000BB   F0           MOVX      @DPTR,A
    269          
    270            /* turn on the receiver */
    271            macRxOn();
   \   0000BC                ; Setup parameters for call to function macRxOn
   \   0000BC   12....       LCALL     `??macRxOn::?relay`; Banked call to: macRxOn
    272          
    273            /*
    274             *  Wait for radio to reach infinite reception state by checking RSSI valid flag.
    275             *  Once it does, the least significant bit of ADTSTH should be pretty random.
    276             */
    277            while (!(RSSISTAT & 0x01));
   \                     ??macMcuInit_4:
   \   0000BF   906199       MOV       DPTR,#0x6199
   \   0000C2   E0           MOVX      A,@DPTR
   \   0000C3   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000C5   50F8         JNC       ??macMcuInit_4
    278          
    279            /* put 16 random bits into the seed value */
    280            {
    281              uint16 rndSeed;
    282              uint8  i;
    283              rndSeed = 0;
   \   0000C7   7800         MOV       R0,#0x0
   \   0000C9   7900         MOV       R1,#0x0
    284          
    285              for(i=0; i<16; i++)
   \   0000CB   7A00         MOV       R2,#0x0
   \                     ??macMcuInit_5:
   \   0000CD   EA           MOV       A,R2
   \   0000CE   C3           CLR       C
   \   0000CF   9410         SUBB      A,#0x10
   \   0000D1   501A         JNC       ??macMcuInit_6
    286              {
    287                /* use most random bit of analog to digital receive conversion to populate the random seed */
    288                rndSeed = (rndSeed << 1) | (RFRND & 0x01);
   \   0000D3   E8           MOV       A,R0
   \   0000D4   28           ADD       A,R0
   \   0000D5   F8           MOV       R0,A
   \   0000D6   E9           MOV       A,R1
   \   0000D7   33           RLC       A
   \   0000D8   F9           MOV       R1,A
   \   0000D9   9061A7       MOV       DPTR,#0x61a7
   \   0000DC   E0           MOVX      A,@DPTR
   \   0000DD   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000DF   E4           CLR       A
   \   0000E0   33           RLC       A
   \   0000E1   FC           MOV       R4,A
   \   0000E2   7D00         MOV       R5,#0x0
   \   0000E4   E8           MOV       A,R0
   \   0000E5   4C           ORL       A,R4
   \   0000E6   F8           MOV       R0,A
   \   0000E7   E9           MOV       A,R1
   \   0000E8   4D           ORL       A,R5
   \   0000E9   F9           MOV       R1,A
    289              }
   \   0000EA   0A           INC       R2
   \   0000EB   80E0         SJMP      ??macMcuInit_5
    290          
    291              /*
    292               *  The seed value must not be zero or 0x0380 (0x8003 in the polynomial).  If it is, the psuedo
    293               *  random sequence won’t be random.  There is an extremely small chance this seed could randomly
    294               *  be zero or 0x0380.  The following check makes sure this does not happen.
    295               */
    296              if (rndSeed == 0x0000 || rndSeed == 0x0380)
   \                     ??macMcuInit_6:
   \   0000ED   E8           MOV       A,R0
   \   0000EE   49           ORL       A,R1
   \   0000EF   600A         JZ        ??macMcuInit_7
   \   0000F1   7480         MOV       A,#-0x80
   \   0000F3   68           XRL       A,R0
   \   0000F4   7003         JNZ       ??macMcuInit_8
   \   0000F6   7403         MOV       A,#0x3
   \   0000F8   69           XRL       A,R1
   \                     ??macMcuInit_8:
   \   0000F9   7004         JNZ       ??macMcuInit_9
    297              {
    298                rndSeed = 0xBABE; /* completely arbitrary "random" value */
   \                     ??macMcuInit_7:
   \   0000FB   78BE         MOV       R0,#-0x42
   \   0000FD   79BA         MOV       R1,#-0x46
    299              }
    300          
    301              /*
    302               *  Two writes to RNDL will set the random seed.  A write to RNDL copies current contents
    303               *  of RNDL to RNDH before writing new the value to RNDL.
    304               */
    305              RNDL = rndSeed & 0xFF;
   \                     ??macMcuInit_9:
   \   0000FF   E8           MOV       A,R0
   \   000100   F5BC         MOV       0xbc,A
    306              RNDL = rndSeed >> 8;
   \   000102   E4           CLR       A
   \   000103   C9           XCH       A,R1
   \   000104   F8           MOV       R0,A
   \   000105   E8           MOV       A,R0
   \   000106   F5BC         MOV       0xbc,A
    307            }
    308          
    309            /* Read MAC_RANDOM_SEED_LEN*8 random bits and store them in flash for
    310             * future use in random key generation for CBKE key establishment
    311             */
    312            if( pRandomSeedCB )
   \   000108   90....       MOV       DPTR,#pRandomSeedCB
   \   00010B   E0           MOVX      A,@DPTR
   \   00010C   F8           MOV       R0,A
   \   00010D   A3           INC       DPTR
   \   00010E   E0           MOVX      A,@DPTR
   \   00010F   F9           MOV       R1,A
   \   000110   E8           MOV       A,R0
   \   000111   49           ORL       A,R1
   \   000112   6052         JZ        ??macMcuInit_10
    313            {
    314              uint8 randomSeed[MAC_RANDOM_SEED_LEN];
    315              uint8 i,j;
    316          
    317              for(i = 0; i < MAC_RANDOM_SEED_LEN; i++)
   \   000114   7F00         MOV       R7,#0x0
   \                     ??macMcuInit_11:
   \   000116   EF           MOV       A,R7
   \   000117   C3           CLR       C
   \   000118   9420         SUBB      A,#0x20
   \   00011A   5038         JNC       ??macMcuInit_12
    318              {
    319                uint8 rndByte = 0;
   \   00011C   7800         MOV       R0,#0x0
    320                for(j = 0; j < 8; j++)
   \   00011E   7E00         MOV       R6,#0x0
   \                     ??macMcuInit_13:
   \   000120   EE           MOV       A,R6
   \   000121   C3           CLR       C
   \   000122   9408         SUBB      A,#0x8
   \   000124   5011         JNC       ??macMcuInit_14
    321                {
    322                  /* use most random bit of analog to digital receive conversion to
    323                     populate the random seed */
    324                  rndByte = (rndByte << 1) | (RFRND & 0x01);
   \   000126   9061A7       MOV       DPTR,#0x61a7
   \   000129   E0           MOVX      A,@DPTR
   \   00012A   A2E0         MOV       C,0xE0 /* A   */.0
   \   00012C   E4           CLR       A
   \   00012D   33           RLC       A
   \   00012E   F9           MOV       R1,A
   \   00012F   E8           MOV       A,R0
   \   000130   C3           CLR       C
   \   000131   33           RLC       A
   \   000132   49           ORL       A,R1
   \   000133   F8           MOV       R0,A
    325                }
   \   000134   0E           INC       R6
   \   000135   80E9         SJMP      ??macMcuInit_13
    326                randomSeed[i] = rndByte;
   \                     ??macMcuInit_14:
   \   000137   E8           MOV       A,R0
   \   000138   C0E0         PUSH      A
   \   00013A   EF           MOV       A,R7
   \   00013B   F8           MOV       R0,A
   \   00013C   7900         MOV       R1,#0x0
   \   00013E   85..82       MOV       DPL,?XSP + 0
   \   000141   85..83       MOV       DPH,?XSP + 1
   \   000144   E582         MOV       A,DPL
   \   000146   28           ADD       A,R0
   \   000147   F582         MOV       DPL,A
   \   000149   E583         MOV       A,DPH
   \   00014B   39           ADDC      A,R1
   \   00014C   F583         MOV       DPH,A
   \   00014E   D0E0         POP       A
   \   000150   F0           MOVX      @DPTR,A
    327          
    328              }
   \   000151   0F           INC       R7
   \   000152   80C2         SJMP      ??macMcuInit_11
    329              pRandomSeedCB( randomSeed );
   \                     ??macMcuInit_12:
   \   000154                ; Setup parameters for indirect call
   \   000154   AA..         MOV       R2,?XSP + 0
   \   000156   AB..         MOV       R3,?XSP + 1
   \   000158   90....       MOV       DPTR,#pRandomSeedCB
   \   00015B   E0           MOVX      A,@DPTR
   \   00015C   F8           MOV       R0,A
   \   00015D   A3           INC       DPTR
   \   00015E   E0           MOVX      A,@DPTR
   \   00015F   F583         MOV       DPH,A
   \   000161   8882         MOV       DPL,R0
   \   000163   12....       LCALL     ?CALL_IND
    330            }
    331          
    332            /* turn off the receiver */
    333            macRxOff();
   \                     ??macMcuInit_10:
   \   000166                ; Setup parameters for call to function macRxOff
   \   000166   12....       LCALL     `??macRxOff::?relay`; Banked call to: macRxOff
    334          
    335            /* take receiver out of infinite reception mode; set back to normal operation */
    336            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_NORMAL_OPERATION;
   \   000169   906189       MOV       DPTR,#0x6189
   \   00016C   7440         MOV       A,#0x40
   \   00016E   F0           MOVX      @DPTR,A
    337          
    338            /* Turn on autoack */
    339            MAC_RADIO_TURN_ON_AUTO_ACK();
   \   00016F   906189       MOV       DPTR,#0x6189
   \   000172   E0           MOVX      A,@DPTR
   \   000173   D2E5         SETB      0xE0 /* A   */.5
   \   000175   F0           MOVX      @DPTR,A
    340          
    341            /* Initialize SRCEXTPENDEN and SRCSHORTPENDEN to zeros */
    342            MAC_RADIO_SRC_MATCH_INIT_EXTPENDEN();
   \   000176   906164       MOV       DPTR,#0x6164
   \   000179   7400         MOV       A,#0x0
   \   00017B   F0           MOVX      @DPTR,A
   \   00017C   906165       MOV       DPTR,#0x6165
   \   00017F   7400         MOV       A,#0x0
   \   000181   F0           MOVX      @DPTR,A
   \   000182   906166       MOV       DPTR,#0x6166
   \   000185   7400         MOV       A,#0x0
   \   000187   F0           MOVX      @DPTR,A
    343            MAC_RADIO_SRC_MATCH_INIT_SHORTPENDEN();
   \   000188   906167       MOV       DPTR,#0x6167
   \   00018B   7400         MOV       A,#0x0
   \   00018D   F0           MOVX      @DPTR,A
   \   00018E   906168       MOV       DPTR,#0x6168
   \   000191   7400         MOV       A,#0x0
   \   000193   F0           MOVX      @DPTR,A
   \   000194   906169       MOV       DPTR,#0x6169
   \   000197   7400         MOV       A,#0x0
   \   000199   F0           MOVX      @DPTR,A
    344          }
   \   00019A   7420         MOV       A,#0x20
   \   00019C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00019F   7F01         MOV       R7,#0x1
   \   0001A1   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   0001A4                REQUIRE IEN2
   \   0001A4                REQUIRE _A_IEN0
   \   0001A4                REQUIRE IP0
   \   0001A4                REQUIRE IP1
   \   0001A4                REQUIRE T2MSEL
   \   0001A4                REQUIRE T2M0
   \   0001A4                REQUIRE T2M1
   \   0001A4                REQUIRE CLKCONSTA
   \   0001A4                REQUIRE T2CTRL
   \   0001A4                REQUIRE _A_IEN1
   \   0001A4                REQUIRE RNDL
    345          
    346          
    347          /**************************************************************************************************
    348           * @fn          macMcuRandomByte
    349           *
    350           * @brief       Returns a random byte using a special hardware feature that generates new
    351           *              random values based on the truly random seed set earlier.
    352           *
    353           * @param       none
    354           *
    355           * @return      a random byte
    356           **************************************************************************************************
    357           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    358          MAC_INTERNAL_API uint8 macMcuRandomByte(void)
   \                     macMcuRandomByte:
    359          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    360            /* clock the random generator to get a new random value */
    361            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   E5B4         MOV       A,0xb4
   \   000002   54F3         ANL       A,#0xf3
   \   000004   4404         ORL       A,#0x4
   \   000006   F5B4         MOV       0xb4,A
    362          
    363            /* return new randomized value from hardware */
    364            return(RNDH);
   \   000008   E5BD         MOV       A,0xbd
   \   00000A   F9           MOV       R1,A
   \   00000B   02....       LJMP      ?BRET
   \   00000E                REQUIRE ADCCON1
   \   00000E                REQUIRE RNDH
    365          }
    366          
    367          
    368          /**************************************************************************************************
    369           * @fn          macMcuRandomWord
    370           *
    371           * @brief       Returns a random word using a special hardware feature that generates new
    372           *              random values based on the truly random seed set earlier.
    373           *
    374           * @param       none
    375           *
    376           * @return      a random word
    377           **************************************************************************************************
    378           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    379          MAC_INTERNAL_API uint16 macMcuRandomWord(void)
   \                     macMcuRandomWord:
    380          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    381            uint16 random_word;
    382          
    383            /* clock the random generator to get a new random value */
    384            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   E5B4         MOV       A,0xb4
   \   000002   54F3         ANL       A,#0xf3
   \   000004   4404         ORL       A,#0x4
   \   000006   F5B4         MOV       0xb4,A
    385          
    386            /* read random word */
    387            random_word  = (RNDH << 8);
   \   000008   A9BD         MOV       R1,0xbd
   \   00000A   E9           MOV       A,R1
   \   00000B   F9           MOV       R1,A
   \   00000C   E4           CLR       A
   \   00000D   F8           MOV       R0,A
   \   00000E   E8           MOV       A,R0
   \   00000F   FA           MOV       R2,A
   \   000010   E9           MOV       A,R1
   \   000011   FB           MOV       R3,A
    388            random_word +=  RNDL;
   \   000012   E5BC         MOV       A,0xbc
   \   000014   F8           MOV       R0,A
   \   000015   7900         MOV       R1,#0x0
   \   000017   EA           MOV       A,R2
   \   000018   28           ADD       A,R0
   \   000019   FA           MOV       R2,A
   \   00001A   EB           MOV       A,R3
   \   00001B   39           ADDC      A,R1
   \   00001C   FB           MOV       R3,A
    389          
    390            /* return new randomized value from hardware */
    391            return(random_word);
   \   00001D   02....       LJMP      ?BRET
   \   000020                REQUIRE ADCCON1
   \   000020                REQUIRE RNDH
   \   000020                REQUIRE RNDL
    392          }
    393          
    394          
    395          /**************************************************************************************************
    396           * @fn          macMcuTimerForceDelay
    397           *
    398           * @brief       Delay the timer by the requested number of ticks.
    399           *
    400           * @param       none
    401           *
    402           * @return      none
    403           **************************************************************************************************
    404           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    405          MAC_INTERNAL_API void macMcuTimerForceDelay(uint16 x)
   \                     macMcuTimerForceDelay:
    406          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    407            halIntState_t  s;
    408          
    409            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A2AF         MOV       C,0xa8.7
   \   000002   E4           CLR       A
   \   000003   33           RLC       A
   \   000004   FC           MOV       R4,A
   \   000005   C2AF         CLR       0xa8.7
    410            MAC_MCU_T2_ACCESS_COUNT_VALUE();
   \   000007   75C300       MOV       0xc3,#0x0
    411            T2M0 = (x) & 0xFF;
   \   00000A   EA           MOV       A,R2
   \   00000B   F5A2         MOV       0xa2,A
    412            T2M1 = (x) >> 8;
   \   00000D   EA           MOV       A,R2
   \   00000E   F8           MOV       R0,A
   \   00000F   EB           MOV       A,R3
   \   000010   F9           MOV       R1,A
   \   000011   E4           CLR       A
   \   000012   C9           XCH       A,R1
   \   000013   F8           MOV       R0,A
   \   000014   E8           MOV       A,R0
   \   000015   F5A3         MOV       0xa3,A
    413            HAL_EXIT_CRITICAL_SECTION(s);
   \   000017   EC           MOV       A,R4
   \   000018   A2E0         MOV       C,0xE0 /* A   */.0
   \   00001A   92AF         MOV       0xa8.7,C
    414          }
   \   00001C   02....       LJMP      ?BRET
   \   00001F                REQUIRE _A_IEN0
   \   00001F                REQUIRE T2MSEL
   \   00001F                REQUIRE T2M0
   \   00001F                REQUIRE T2M1
    415          
    416          /**************************************************************************************************
    417           * @fn          macMcuTimerCapture
    418           *
    419           * @brief       Returns the last timer capture.  This capture should have occurred at the
    420           *              receive time of the last frame (the last time SFD transitioned to active).
    421           *
    422           * @param       none
    423           *
    424           * @return      last capture of hardware timer (full 16-bit value)
    425           **************************************************************************************************
    426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    427          MAC_INTERNAL_API uint16 macMcuTimerCapture(void)
   \                     macMcuTimerCapture:
    428          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    429            uint16         timerCapture;
    430            halIntState_t  s;
    431          
    432            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A2AF         MOV       C,0xa8.7
   \   000002   E4           CLR       A
   \   000003   33           RLC       A
   \   000004   FC           MOV       R4,A
   \   000005   C2AF         CLR       0xa8.7
    433            MAC_MCU_T2_ACCESS_CAPTURE_VALUE();
   \   000007   75C301       MOV       0xc3,#0x1
    434            timerCapture = T2M1 << 8;
   \   00000A   A9A3         MOV       R1,0xa3
   \   00000C   E9           MOV       A,R1
   \   00000D   F9           MOV       R1,A
   \   00000E   E4           CLR       A
   \   00000F   F8           MOV       R0,A
   \   000010   E8           MOV       A,R0
   \   000011   FA           MOV       R2,A
   \   000012   E9           MOV       A,R1
   \   000013   FB           MOV       R3,A
    435            timerCapture |= T2M0;
   \   000014   E5A2         MOV       A,0xa2
   \   000016   F8           MOV       R0,A
   \   000017   7900         MOV       R1,#0x0
   \   000019   E8           MOV       A,R0
   \   00001A   4A           ORL       A,R2
   \   00001B   FA           MOV       R2,A
   \   00001C   E9           MOV       A,R1
   \   00001D   4B           ORL       A,R3
   \   00001E   FB           MOV       R3,A
    436            HAL_EXIT_CRITICAL_SECTION(s);
   \   00001F   EC           MOV       A,R4
   \   000020   A2E0         MOV       C,0xE0 /* A   */.0
   \   000022   92AF         MOV       0xa8.7,C
    437          
    438            return (timerCapture);
   \   000024   02....       LJMP      ?BRET
   \   000027                REQUIRE _A_IEN0
   \   000027                REQUIRE T2MSEL
   \   000027                REQUIRE T2M1
   \   000027                REQUIRE T2M0
    439          }
    440          
    441          
    442          /**************************************************************************************************
    443           * @fn          macMcuOverflowCount
    444           *
    445           * @brief       Returns the value of the overflow counter which is a special hardware feature.
    446           *              The overflow count actually is 24 bits of information.
    447           *
    448           * @param       none
    449           *
    450           * @return      value of overflow counter
    451           **************************************************************************************************
    452           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    453          MAC_INTERNAL_API uint32 macMcuOverflowCount(void)
   \                     macMcuOverflowCount:
    454          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV       A,#-0x4
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    455            uint32         overflowCount;
    456            halIntState_t  s;
    457          
    458            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    459          
    460            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   A2AF         MOV       C,0xa8.7
   \   00000B   E4           CLR       A
   \   00000C   33           RLC       A
   \   00000D   F9           MOV       R1,A
   \   00000E   C2AF         CLR       0xa8.7
    461          
    462            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    463            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000010   75C300       MOV       0xc3,#0x0
    464          
    465            /* Latch the entire T2MOVFx first by reading T2M0. */
    466            T2M0;
   \   000013   A8A2         MOV       R0,0xa2+0x0
    467            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   000015   E5A4         MOV       A,0xa4
   \   000017   C0E0         PUSH      A
   \   000019   85..82       MOV       DPL,?XSP + 0
   \   00001C   85..83       MOV       DPH,?XSP + 1
   \   00001F   D0E0         POP       A
   \   000021   F0           MOVX      @DPTR,A
    468            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
   \   000022   E5A5         MOV       A,0xa5
   \   000024   C0E0         PUSH      A
   \   000026   7401         MOV       A,#0x1
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   D0E0         POP       A
   \   00002D   F0           MOVX      @DPTR,A
    469            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
   \   00002E   E5A6         MOV       A,0xa6
   \   000030   C0E0         PUSH      A
   \   000032   7402         MOV       A,#0x2
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   D0E0         POP       A
   \   000039   F0           MOVX      @DPTR,A
    470            ((uint8 *)&overflowCount)[UINT32_NDX3] = 0;
   \   00003A   7403         MOV       A,#0x3
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   7400         MOV       A,#0x0
   \   000041   F0           MOVX      @DPTR,A
    471            HAL_EXIT_CRITICAL_SECTION(s);
   \   000042   E9           MOV       A,R1
   \   000043   A2E0         MOV       C,0xE0 /* A   */.0
   \   000045   92AF         MOV       0xa8.7,C
    472          
    473            return (overflowCount);
   \   000047   85..82       MOV       DPL,?XSP + 0
   \   00004A   85..83       MOV       DPH,?XSP + 1
   \   00004D   12....       LCALL     ?XLOAD_R2345
   \   000050   7404         MOV       A,#0x4
   \   000052   12....       LCALL     ?DEALLOC_XSTACK8
   \   000055   D083         POP       DPH
   \   000057   D082         POP       DPL
   \   000059   02....       LJMP      ?BRET
   \   00005C                REQUIRE _A_IEN0
   \   00005C                REQUIRE T2MSEL
   \   00005C                REQUIRE T2M0
   \   00005C                REQUIRE T2MOVF0
   \   00005C                REQUIRE T2MOVF1
   \   00005C                REQUIRE T2MOVF2
    474          }
    475          
    476          
    477          /**************************************************************************************************
    478           * @fn          macMcuOverflowCapture
    479           *
    480           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    481           *              captures the overflow counter when the regular hardware timer is captured.
    482           *
    483           * @param       none
    484           *
    485           * @return      last capture of overflow count
    486           **************************************************************************************************
    487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    488          MAC_INTERNAL_API uint32 macMcuOverflowCapture(void)
   \                     macMcuOverflowCapture:
    489          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV       A,#-0x4
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    490            uint32         overflowCapture;
    491            halIntState_t  s;
    492          
    493            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    494            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   A2AF         MOV       C,0xa8.7
   \   00000B   E4           CLR       A
   \   00000C   33           RLC       A
   \   00000D   F8           MOV       R0,A
   \   00000E   C2AF         CLR       0xa8.7
    495            MAC_MCU_T2_ACCESS_OVF_CAPTURE_VALUE();
   \   000010   75C310       MOV       0xc3,#0x10
    496            ((uint8 *)&overflowCapture)[UINT32_NDX0] = T2MOVF0;
   \   000013   E5A4         MOV       A,0xa4
   \   000015   C0E0         PUSH      A
   \   000017   85..82       MOV       DPL,?XSP + 0
   \   00001A   85..83       MOV       DPH,?XSP + 1
   \   00001D   D0E0         POP       A
   \   00001F   F0           MOVX      @DPTR,A
    497            ((uint8 *)&overflowCapture)[UINT32_NDX1] = T2MOVF1;
   \   000020   E5A5         MOV       A,0xa5
   \   000022   C0E0         PUSH      A
   \   000024   7401         MOV       A,#0x1
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   D0E0         POP       A
   \   00002B   F0           MOVX      @DPTR,A
    498            ((uint8 *)&overflowCapture)[UINT32_NDX2] = T2MOVF2;
   \   00002C   E5A6         MOV       A,0xa6
   \   00002E   C0E0         PUSH      A
   \   000030   7402         MOV       A,#0x2
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   D0E0         POP       A
   \   000037   F0           MOVX      @DPTR,A
    499            ((uint8 *)&overflowCapture)[UINT32_NDX3] = 0;
   \   000038   7403         MOV       A,#0x3
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   7400         MOV       A,#0x0
   \   00003F   F0           MOVX      @DPTR,A
    500            HAL_EXIT_CRITICAL_SECTION(s);
   \   000040   E8           MOV       A,R0
   \   000041   A2E0         MOV       C,0xE0 /* A   */.0
   \   000043   92AF         MOV       0xa8.7,C
    501          
    502            return (overflowCapture);
   \   000045   85..82       MOV       DPL,?XSP + 0
   \   000048   85..83       MOV       DPH,?XSP + 1
   \   00004B   12....       LCALL     ?XLOAD_R2345
   \   00004E   7404         MOV       A,#0x4
   \   000050   12....       LCALL     ?DEALLOC_XSTACK8
   \   000053   D083         POP       DPH
   \   000055   D082         POP       DPL
   \   000057   02....       LJMP      ?BRET
   \   00005A                REQUIRE _A_IEN0
   \   00005A                REQUIRE T2MSEL
   \   00005A                REQUIRE T2MOVF0
   \   00005A                REQUIRE T2MOVF1
   \   00005A                REQUIRE T2MOVF2
    503          }
    504          
    505          
    506          /**************************************************************************************************
    507           * @fn          macMcuOverflowSetCount
    508           *
    509           * @brief       Sets the value of the hardware overflow counter.
    510           *
    511           * @param       count - new overflow count value
    512           *
    513           * @return      none
    514           **************************************************************************************************
    515           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    516          MAC_INTERNAL_API void macMcuOverflowSetCount(uint32 count)
   \                     macMcuOverflowSetCount:
    517          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
    518            halIntState_t  s;
    519          
    520            MAC_ASSERT(! (count >> 24) );   /* illegal count value */
   \   00001B   85..82       MOV       DPL,?XSP + 0
   \   00001E   85..83       MOV       DPH,?XSP + 1
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?L_MOV_X
   \   000026   90....       MOV       DPTR,#__Constant_ff000000
   \   000029   78..         MOV       R0,#?V0
   \   00002B   12....       LCALL     ?L_AND_X
   \   00002E   E5..         MOV       A,?V0
   \   000030   45..         ORL       A,?V1
   \   000032   45..         ORL       A,?V2
   \   000034   45..         ORL       A,?V3
   \   000036   6003         JZ        ??macMcuOverflowSetCount_0
   \   000038                ; Setup parameters for call to function halAssertHandler
   \   000038   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    521          
    522            /* save the current overflow count */
    523            accumulatedOverflowCount += macMcuOverflowCount();
   \                     ??macMcuOverflowSetCount_0:
   \   00003B                ; Setup parameters for call to function macMcuOverflowCount
   \   00003B   12....       LCALL     `??macMcuOverflowCount::?relay`; Banked call to: macMcuOverflowCount
   \   00003E   8A..         MOV       ?V0,R2
   \   000040   8B..         MOV       ?V1,R3
   \   000042   8C..         MOV       ?V2,R4
   \   000044   8D..         MOV       ?V3,R5
   \   000046   90....       MOV       DPTR,#accumulatedOverflowCount
   \   000049   78..         MOV       R0,#?V0
   \   00004B   12....       LCALL     ?L_ADD_TO_X
    524          
    525            /* deduct the initial count */
    526            accumulatedOverflowCount -= count;
   \   00004E   85..82       MOV       DPL,?XSP + 0
   \   000051   85..83       MOV       DPH,?XSP + 1
   \   000054   78..         MOV       R0,#?V0
   \   000056   12....       LCALL     ?L_MOV_X
   \   000059   90....       MOV       DPTR,#accumulatedOverflowCount
   \   00005C   78..         MOV       R0,#?V0
   \   00005E   12....       LCALL     ?L_SUB_FROM_X
    527          
    528            HAL_ENTER_CRITICAL_SECTION(s);
   \   000061   A2AF         MOV       C,0xa8.7
   \   000063   E4           CLR       A
   \   000064   33           RLC       A
   \   000065   FE           MOV       R6,A
   \   000066   C2AF         CLR       0xa8.7
    529            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000068   75C300       MOV       0xc3,#0x0
    530          
    531            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    532            /* T2OF2 must be written last */
    533            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   00006B   85..82       MOV       DPL,?XSP + 0
   \   00006E   85..83       MOV       DPH,?XSP + 1
   \   000071   E0           MOVX      A,@DPTR
   \   000072   F5A4         MOV       0xa4,A
    534            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   000074   7401         MOV       A,#0x1
   \   000076   12....       LCALL     ?XSTACK_DISP0_8
   \   000079   E0           MOVX      A,@DPTR
   \   00007A   F5A5         MOV       0xa5,A
    535            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   00007C   7402         MOV       A,#0x2
   \   00007E   12....       LCALL     ?XSTACK_DISP0_8
   \   000081   E0           MOVX      A,@DPTR
   \   000082   F5A6         MOV       0xa6,A
    536            HAL_EXIT_CRITICAL_SECTION(s);
   \   000084   EE           MOV       A,R6
   \   000085   A2E0         MOV       C,0xE0 /* A   */.0
   \   000087   92AF         MOV       0xa8.7,C
    537          }
   \   000089   7404         MOV       A,#0x4
   \   00008B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00008E   7F04         MOV       R7,#0x4
   \   000090   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   000093                REQUIRE _A_IEN0
   \   000093                REQUIRE T2MSEL
   \   000093                REQUIRE T2MOVF0
   \   000093                REQUIRE T2MOVF1
   \   000093                REQUIRE T2MOVF2
    538          
    539          
    540          /**************************************************************************************************
    541           * @fn          macMcuOverflowSetCompare
    542           *
    543           * @brief       Set overflow count compare value.  An interrupt is triggered when the overflow
    544           *              count equals this compare value.
    545           *
    546           * @param       count - overflow count compare value
    547           *
    548           * @return      none
    549           **************************************************************************************************
    550           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    551          MAC_INTERNAL_API void macMcuOverflowSetCompare(uint32 count)
   \                     macMcuOverflowSetCompare:
    552          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
    553            halIntState_t  s;
    554            uint8 enableCompareInt = 0;
   \   00001B   7E00         MOV       R6,#0x0
    555          
    556            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
   \   00001D   85..82       MOV       DPL,?XSP + 0
   \   000020   85..83       MOV       DPH,?XSP + 1
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?L_MOV_X
   \   000028   90....       MOV       DPTR,#__Constant_ff000000
   \   00002B   78..         MOV       R0,#?V0
   \   00002D   12....       LCALL     ?L_AND_X
   \   000030   E5..         MOV       A,?V0
   \   000032   45..         ORL       A,?V1
   \   000034   45..         ORL       A,?V2
   \   000036   45..         ORL       A,?V3
   \   000038   6003         JZ        ??macMcuOverflowSetCompare_0
   \   00003A                ; Setup parameters for call to function halAssertHandler
   \   00003A   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    557          
    558            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_0:
   \   00003D   A2AF         MOV       C,0xa8.7
   \   00003F   E4           CLR       A
   \   000040   33           RLC       A
   \   000041   FF           MOV       R7,A
   \   000042   C2AF         CLR       0xa8.7
    559          
    560            /*  Disable overflow compare interrupts. */
    561            if (T2IRQM & TIMER2_OVF_COMPARE1M)
   \   000044   E5A7         MOV       A,0xa7
   \   000046   A2E4         MOV       C,0xE0 /* A   */.4
   \   000048   5005         JNC       ??macMcuOverflowSetCompare_1
    562            {
    563              enableCompareInt = 1;
   \   00004A   7E01         MOV       R6,#0x1
    564              T2IRQM &= ~TIMER2_OVF_COMPARE1M;
   \   00004C   53A7EF       ANL       0xa7,#0xef
    565            }
    566          
    567            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
   \                     ??macMcuOverflowSetCompare_1:
   \   00004F   75C330       MOV       0xc3,#0x30
    568          
    569            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    570            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   000052   85..82       MOV       DPL,?XSP + 0
   \   000055   85..83       MOV       DPH,?XSP + 1
   \   000058   E0           MOVX      A,@DPTR
   \   000059   F5A4         MOV       0xa4,A
    571            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00005B   7401         MOV       A,#0x1
   \   00005D   12....       LCALL     ?XSTACK_DISP0_8
   \   000060   E0           MOVX      A,@DPTR
   \   000061   F5A5         MOV       0xa5,A
    572            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000063   7402         MOV       A,#0x2
   \   000065   12....       LCALL     ?XSTACK_DISP0_8
   \   000068   E0           MOVX      A,@DPTR
   \   000069   F5A6         MOV       0xa6,A
    573          
    574            /*
    575             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    576             *  in case a false match was generated as the multi-byte compare value was written.
    577             */
    578            T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   00006B   75A1EF       MOV       0xa1,#-0x11
    579          
    580            /* re-enable overflow compare interrupts if they were previously enabled */
    581            if (enableCompareInt)
   \   00006E   EE           MOV       A,R6
   \   00006F   6003         JZ        ??macMcuOverflowSetCompare_2
    582            {
    583              T2IRQM |= TIMER2_OVF_COMPARE1M;
   \   000071   43A710       ORL       0xa7,#0x10
    584            }
    585          
    586            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_2:
   \   000074   EF           MOV       A,R7
   \   000075   A2E0         MOV       C,0xE0 /* A   */.0
   \   000077   92AF         MOV       0xa8.7,C
    587          }
   \   000079   7404         MOV       A,#0x4
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007E   7F04         MOV       R7,#0x4
   \   000080   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   000083                REQUIRE _A_IEN0
   \   000083                REQUIRE T2IRQM
   \   000083                REQUIRE T2MSEL
   \   000083                REQUIRE T2MOVF0
   \   000083                REQUIRE T2MOVF1
   \   000083                REQUIRE T2MOVF2
   \   000083                REQUIRE T2IRQF
    588          
    589          
    590          /**************************************************************************************************
    591           * @fn          macMcuOverflowSetPeriod
    592           *
    593           * @brief       Set overflow count period value.  An interrupt is triggered when the overflow
    594           *              count equals this period value.
    595           *
    596           * @param       count - overflow count compare value
    597           *
    598           * @return      none
    599           **************************************************************************************************
    600           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    601          MAC_INTERNAL_API void macMcuOverflowSetPeriod(uint32 count)
   \                     macMcuOverflowSetPeriod:
    602          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   EC           MOV       A,R4
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   ED           MOV       A,R5
   \   00001A   F0           MOVX      @DPTR,A
    603            halIntState_t  s;
    604            uint8 enableCompareInt = 0;
   \   00001B   7E00         MOV       R6,#0x0
    605          
    606            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
   \   00001D   85..82       MOV       DPL,?XSP + 0
   \   000020   85..83       MOV       DPH,?XSP + 1
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?L_MOV_X
   \   000028   90....       MOV       DPTR,#__Constant_ff000000
   \   00002B   78..         MOV       R0,#?V0
   \   00002D   12....       LCALL     ?L_AND_X
   \   000030   E5..         MOV       A,?V0
   \   000032   45..         ORL       A,?V1
   \   000034   45..         ORL       A,?V2
   \   000036   45..         ORL       A,?V3
   \   000038   6003         JZ        ??macMcuOverflowSetPeriod_0
   \   00003A                ; Setup parameters for call to function halAssertHandler
   \   00003A   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    607          
    608            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetPeriod_0:
   \   00003D   A2AF         MOV       C,0xa8.7
   \   00003F   E4           CLR       A
   \   000040   33           RLC       A
   \   000041   FF           MOV       R7,A
   \   000042   C2AF         CLR       0xa8.7
    609          
    610            /*  Disable overflow compare interrupts. */
    611            if (T2IRQM & TIMER2_OVF_PERM)
   \   000044   E5A7         MOV       A,0xa7
   \   000046   A2E3         MOV       C,0xE0 /* A   */.3
   \   000048   5005         JNC       ??macMcuOverflowSetPeriod_1
    612            {
    613              enableCompareInt = 1;
   \   00004A   7E01         MOV       R6,#0x1
    614              T2IRQM &= ~TIMER2_OVF_PERM;
   \   00004C   53A7F7       ANL       0xa7,#0xf7
    615            }
    616          
    617            MAC_MCU_T2_ACCESS_OVF_PERIOD_VALUE();
   \                     ??macMcuOverflowSetPeriod_1:
   \   00004F   75C320       MOV       0xc3,#0x20
    618          
    619            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    620            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   000052   85..82       MOV       DPL,?XSP + 0
   \   000055   85..83       MOV       DPH,?XSP + 1
   \   000058   E0           MOVX      A,@DPTR
   \   000059   F5A4         MOV       0xa4,A
    621            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00005B   7401         MOV       A,#0x1
   \   00005D   12....       LCALL     ?XSTACK_DISP0_8
   \   000060   E0           MOVX      A,@DPTR
   \   000061   F5A5         MOV       0xa5,A
    622            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000063   7402         MOV       A,#0x2
   \   000065   12....       LCALL     ?XSTACK_DISP0_8
   \   000068   E0           MOVX      A,@DPTR
   \   000069   F5A6         MOV       0xa6,A
    623          
    624            /*
    625             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    626             *  in case a false match was generated as the multi-byte compare value was written.
    627             */
    628            T2IRQF &= ~TIMER2_OVF_PERF;
   \   00006B   53A1F7       ANL       0xa1,#0xf7
    629          
    630            /* re-enable overflow compare interrupts if they were previously enabled */
    631            if (enableCompareInt)
   \   00006E   EE           MOV       A,R6
   \   00006F   6003         JZ        ??macMcuOverflowSetPeriod_2
    632            {
    633              T2IRQM |= TIMER2_OVF_PERM;
   \   000071   43A708       ORL       0xa7,#0x8
    634            }
    635            halSetMaxSleepLoopTime(count);
   \                     ??macMcuOverflowSetPeriod_2:
   \   000074                ; Setup parameters for call to function halSetMaxSleepLoopTime
   \   000074   85..82       MOV       DPL,?XSP + 0
   \   000077   85..83       MOV       DPH,?XSP + 1
   \   00007A   12....       LCALL     ?XLOAD_R2345
   \   00007D   12....       LCALL     `??halSetMaxSleepLoopTime::?relay`; Banked call to: halSetMaxSleepLoopTime
    636            HAL_EXIT_CRITICAL_SECTION(s);
   \   000080   EF           MOV       A,R7
   \   000081   A2E0         MOV       C,0xE0 /* A   */.0
   \   000083   92AF         MOV       0xa8.7,C
    637          }
   \   000085   7404         MOV       A,#0x4
   \   000087   12....       LCALL     ?DEALLOC_XSTACK8
   \   00008A   7F04         MOV       R7,#0x4
   \   00008C   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   00008F                REQUIRE _A_IEN0
   \   00008F                REQUIRE T2IRQM
   \   00008F                REQUIRE T2MSEL
   \   00008F                REQUIRE T2MOVF0
   \   00008F                REQUIRE T2MOVF1
   \   00008F                REQUIRE T2MOVF2
   \   00008F                REQUIRE T2IRQF
    638          
    639          
    640          /**************************************************************************************************
    641           * @fn          macMcuOverflowGetCompare
    642           *
    643           * @brief       Get overflow count compare value.
    644           *
    645           * @param       none
    646           *
    647           * @return      overflow count compare value
    648           **************************************************************************************************
    649           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    650          MAC_INTERNAL_API uint32 macMcuOverflowGetCompare(void)
   \                     macMcuOverflowGetCompare:
    651          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV       A,#-0x4
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    652            halIntState_t  s;
    653            uint32         compare;
    654          
    655            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   A2AF         MOV       C,0xa8.7
   \   00000B   E4           CLR       A
   \   00000C   33           RLC       A
   \   00000D   F8           MOV       R0,A
   \   00000E   C2AF         CLR       0xa8.7
    656          
    657            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
   \   000010   75C330       MOV       0xc3,#0x30
    658          
    659            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    660            ((uint8 *)&compare)[UINT32_NDX0] = T2MOVF0;
   \   000013   E5A4         MOV       A,0xa4
   \   000015   C0E0         PUSH      A
   \   000017   85..82       MOV       DPL,?XSP + 0
   \   00001A   85..83       MOV       DPH,?XSP + 1
   \   00001D   D0E0         POP       A
   \   00001F   F0           MOVX      @DPTR,A
    661            ((uint8 *)&compare)[UINT32_NDX1] = T2MOVF1;
   \   000020   E5A5         MOV       A,0xa5
   \   000022   C0E0         PUSH      A
   \   000024   7401         MOV       A,#0x1
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   D0E0         POP       A
   \   00002B   F0           MOVX      @DPTR,A
    662            ((uint8 *)&compare)[UINT32_NDX2] = T2MOVF2;
   \   00002C   E5A6         MOV       A,0xa6
   \   00002E   C0E0         PUSH      A
   \   000030   7402         MOV       A,#0x2
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   D0E0         POP       A
   \   000037   F0           MOVX      @DPTR,A
    663            ((uint8 *)&compare)[UINT32_NDX3] = 0;
   \   000038   7403         MOV       A,#0x3
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   7400         MOV       A,#0x0
   \   00003F   F0           MOVX      @DPTR,A
    664          
    665            HAL_EXIT_CRITICAL_SECTION(s);
   \   000040   E8           MOV       A,R0
   \   000041   A2E0         MOV       C,0xE0 /* A   */.0
   \   000043   92AF         MOV       0xa8.7,C
    666          
    667            return(compare);
   \   000045   85..82       MOV       DPL,?XSP + 0
   \   000048   85..83       MOV       DPH,?XSP + 1
   \   00004B   12....       LCALL     ?XLOAD_R2345
   \   00004E   7404         MOV       A,#0x4
   \   000050   12....       LCALL     ?DEALLOC_XSTACK8
   \   000053   D083         POP       DPH
   \   000055   D082         POP       DPL
   \   000057   02....       LJMP      ?BRET
   \   00005A                REQUIRE _A_IEN0
   \   00005A                REQUIRE T2MSEL
   \   00005A                REQUIRE T2MOVF0
   \   00005A                REQUIRE T2MOVF1
   \   00005A                REQUIRE T2MOVF2
    668          }
    669          
    670          
    671          /**************************************************************************************************
    672           * @fn          macMcuTimer2Isr
    673           *
    674           * @brief       Interrupt service routine for timer2, the MAC timer.
    675           *
    676           * @param       none
    677           *
    678           * @return      none
    679           **************************************************************************************************
    680           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    681          HAL_ISR_FUNCTION( macMcuTimer2Isr, T2_VECTOR )
   \                     macMcuTimer2Isr:
    682          {
   \   000000                REQUIRE ?V0
   \   000000   C0E0         PUSH      A
   \   000002   74F2         MOV       A,#-0xe
   \   000004   12....       LCALL     ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    683            uint8 t2irqm;
    684            uint8 t2irqf;
    685          
    686            HAL_ENTER_ISR();
   \   000007   A2AF         MOV       C,0xa8.7
   \   000009   E4           CLR       A
   \   00000A   33           RLC       A
   \   00000B   FE           MOV       R6,A
   \   00000C   D2AF         SETB      0xa8.7
    687          
    688            t2irqm = T2IRQM;
   \   00000E   85A7..       MOV       ?V0,0xa7+0x0
    689            t2irqf = T2IRQF;
   \   000011   AFA1         MOV       R7,0xa1+0x0
    690          
    691            /*------------------------------------------------------------------------------------------------
    692             *  Overflow compare interrupt - triggers when then overflow counter is
    693             *  equal to the overflow compare register.
    694             */
    695            if ((t2irqf & TIMER2_OVF_COMPARE1F) & t2irqm)
   \   000013   EF           MOV       A,R7
   \   000014   55..         ANL       A,?V0
   \   000016   5410         ANL       A,#0x10
   \   000018   6006         JZ        ??macMcuTimer2Isr_0
    696            {
    697          
    698              /* call function for dealing with the timer compare interrupt */
    699              macBackoffTimerCompareIsr();
   \   00001A                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   00001A   12....       LCALL     `??macBackoffTimerCompareIsr::?relay`; Banked call to: macBackoffTimerCompareIsr
    700          
    701              /* clear overflow compare interrupt flag */
    702              T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   00001D   75A1EF       MOV       0xa1,#-0x11
    703            }
    704          
    705            /*------------------------------------------------------------------------------------------------
    706             *  Overflow compare interrupt - triggers when then overflow counter is
    707             *  equal to the overflow compare register.
    708             */
    709            if ((t2irqf & TIMER2_OVF_PERF) & t2irqm)
   \                     ??macMcuTimer2Isr_0:
   \   000020   EF           MOV       A,R7
   \   000021   55..         ANL       A,?V0
   \   000023   5408         ANL       A,#0x8
   \   000025   6008         JZ        ??macMcuTimer2Isr_1
    710            {
    711          
    712              /* call function for dealing with the timer compare interrupt */
    713              macBackoffTimerPeriodIsr();
   \   000027                ; Setup parameters for call to function macBackoffTimerPeriodIsr
   \   000027   12....       LCALL     `??macBackoffTimerPeriodIsr::?relay`; Banked call to: macBackoffTimerPeriodIsr
    714          
    715              /* clear overflow compare interrupt flag */
    716              T2IRQF = (TIMER2_OVF_PERF ^ 0xFF);
   \   00002A   75A1F7       MOV       0xa1,#-0x9
   \   00002D   8013         SJMP      ??macMcuTimer2Isr_2
    717            }
    718          
    719            /*------------------------------------------------------------------------------------------------
    720             *  Overflow interrupt - triggers when the hardware timer rolls over.
    721             */
    722            else if ((t2irqf & TIMER2_PERF) & t2irqm)
   \                     ??macMcuTimer2Isr_1:
   \   00002F   EF           MOV       A,R7
   \   000030   A2E0         MOV       C,0xE0 /* A   */.0
   \   000032   92F0         MOV       B.0,C
   \   000034   E5..         MOV       A,?V0
   \   000036   A2E0         MOV       C,0xE0 /* A   */.0
   \   000038   82F0         ANL       C,B.0
   \   00003A   5006         JNC       ??macMcuTimer2Isr_2
    723            {
    724              /* call energy detect interrupt function, this interrupt not used for any other functionality */
    725              mcuRecordMaxRssiIsr();
   \   00003C                ; Setup parameters for call to function mcuRecordMaxRssiIsr
   \   00003C   12....       LCALL     `??mcuRecordMaxRssiIsr::?relay`; Banked call to: mcuRecordMaxRssiIsr
    726          
    727              /* clear the interrupt flag */
    728              T2IRQF = (TIMER2_PERF ^ 0xFF);
   \   00003F   75A1FE       MOV       0xa1,#-0x2
    729            }
    730          
    731            CLEAR_SLEEP_MODE();
   \                     ??macMcuTimer2Isr_2:
   \   000042   75..00       MOV       halSleepPconValue,#0x0
    732            HAL_EXIT_ISR();
   \   000045   EE           MOV       A,R6
   \   000046   A2E0         MOV       C,0xE0 /* A   */.0
   \   000048   92AF         MOV       0xa8.7,C
    733          }
   \   00004A   7F01         MOV       R7,#0x1
   \   00004C   02....       LJMP      ?INTERRUPT_LEAVE_XSP
   \   00004F                REQUIRE _A_IEN0
   \   00004F                REQUIRE T2IRQM
   \   00004F                REQUIRE T2IRQF
    734          
    735          
    736          /**************************************************************************************************
    737           * @fn          macMcuTimer2OverflowWorkaround
    738           *
    739           * @brief       For CC2530, T2 interrupt won’t be generated when the current count is greater than
    740           *              the comparator. The interrupt is only generated when the current count is equal to
    741           *              the comparator. When the CC2530 is waking up from sleep, there is a small window
    742           *              that the count may be grater than the comparator, therefore, missing the interrupt.
    743           *              This workaround will call the T2 ISR when the current T2 count is greater than the
    744           *              comparator.
    745           *
    746           * @param       none
    747           *
    748           * @return      none
    749           **************************************************************************************************
    750           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    751          void macMcuTimer2OverflowWorkaround(void)
   \                     macMcuTimer2OverflowWorkaround:
    752          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    753            if (T2IRQM & TIMER2_OVF_COMPARE1F)
   \   000005   E5A7         MOV       A,0xa7
   \   000007   A2E4         MOV       C,0xE0 /* A   */.4
   \   000009   502B         JNC       ??macMcuTimer2OverflowWorkaround_0
    754            {
    755              /* T2 comapre 1 interrupt is enabled but T2 compare 1 intererrupt is not generated */
    756              if (!(T2IRQF & TIMER2_OVF_COMPARE1F))
   \   00000B   E5A1         MOV       A,0xa1
   \   00000D   A2E4         MOV       C,0xE0 /* A   */.4
   \   00000F   4025         JC        ??macMcuTimer2OverflowWorkaround_0
    757              {
    758                if (MAC_RADIO_BACKOFF_COUNT() > macMcuOverflowGetCompare())
   \   000011                ; Setup parameters for call to function macMcuOverflowGetCompare
   \   000011   12....       LCALL     `??macMcuOverflowGetCompare::?relay`; Banked call to: macMcuOverflowGetCompare
   \   000014   8A..         MOV       ?V0,R2
   \   000016   8B..         MOV       ?V1,R3
   \   000018   8C..         MOV       ?V2,R4
   \   00001A   8D..         MOV       ?V3,R5
   \   00001C                ; Setup parameters for call to function macMcuOverflowCount
   \   00001C   12....       LCALL     `??macMcuOverflowCount::?relay`; Banked call to: macMcuOverflowCount
   \   00001F   8A..         MOV       ?V4,R2
   \   000021   8B..         MOV       ?V5,R3
   \   000023   8C..         MOV       ?V6,R4
   \   000025   8D..         MOV       ?V7,R5
   \   000027   78..         MOV       R0,#?V4
   \   000029   79..         MOV       R1,#?V0
   \   00002B   12....       LCALL     ?UL_GT
   \   00002E   5006         JNC       ??macMcuTimer2OverflowWorkaround_0
    759                {
    760                  /* Set the flag to trigger the timer compare interrupt */
    761                  macBackoffTimerCompareIsr();
   \   000030                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   000030   12....       LCALL     `??macBackoffTimerCompareIsr::?relay`; Banked call to: macBackoffTimerCompareIsr
    762                  T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   000033   75A1EF       MOV       0xa1,#-0x11
    763                }
    764              }
    765            }
    766          }
   \                     ??macMcuTimer2OverflowWorkaround_0:
   \   000036   7F08         MOV       R7,#0x8
   \   000038   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   00003B                REQUIRE T2IRQM
   \   00003B                REQUIRE T2IRQF
    767          
    768          
    769          /**************************************************************************************************
    770           * @fn          macMcuPrecisionCount
    771           *
    772           * @brief       This function is used by higher layer to read a free running counter driven by
    773           *              MAC timer.
    774           *
    775           * @param       none
    776           *
    777           * @return      overflowCount
    778           **************************************************************************************************
    779           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    780          uint32 macMcuPrecisionCount(void)
   \                     macMcuPrecisionCount:
    781          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    782            uint32         overflowCount = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7400         MOV       A,#0x0
   \   000012   F0           MOVX      @DPTR,A
   \   000013   A3           INC       DPTR
   \   000014   7400         MOV       A,#0x0
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   7400         MOV       A,#0x0
   \   00001A   F0           MOVX      @DPTR,A
   \   00001B   A3           INC       DPTR
   \   00001C   7400         MOV       A,#0x0
   \   00001E   F0           MOVX      @DPTR,A
    783            halIntState_t  s;
    784          
    785            HAL_ENTER_CRITICAL_SECTION(s);
   \   00001F   A2AF         MOV       C,0xa8.7
   \   000021   E4           CLR       A
   \   000022   33           RLC       A
   \   000023   FE           MOV       R6,A
   \   000024   C2AF         CLR       0xa8.7
    786          
    787            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    788            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000026   75C300       MOV       0xc3,#0x0
    789          
    790            /* Latch the entire T2MOVFx first by reading T2M0.
    791             * T2M0 is discarded.
    792             */
    793            T2M0;
   \   000029   A9A2         MOV       R1,0xa2+0x0
    794            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   00002B   E5A4         MOV       A,0xa4
   \   00002D   C0E0         PUSH      A
   \   00002F   85..82       MOV       DPL,?XSP + 0
   \   000032   85..83       MOV       DPH,?XSP + 1
   \   000035   D0E0         POP       A
   \   000037   F0           MOVX      @DPTR,A
    795            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
   \   000038   E5A5         MOV       A,0xa5
   \   00003A   C0E0         PUSH      A
   \   00003C   7401         MOV       A,#0x1
   \   00003E   12....       LCALL     ?XSTACK_DISP0_8
   \   000041   D0E0         POP       A
   \   000043   F0           MOVX      @DPTR,A
    796            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
   \   000044   E5A6         MOV       A,0xa6
   \   000046   C0E0         PUSH      A
   \   000048   7402         MOV       A,#0x2
   \   00004A   12....       LCALL     ?XSTACK_DISP0_8
   \   00004D   D0E0         POP       A
   \   00004F   F0           MOVX      @DPTR,A
    797          
    798            /* the overflowCount needs to account for the accumulated overflow count in Beacon mode */
    799            overflowCount += accumulatedOverflowCount;
   \   000050   90....       MOV       DPTR,#accumulatedOverflowCount
   \   000053   78..         MOV       R0,#?V0
   \   000055   12....       LCALL     ?L_MOV_X
   \   000058   85..82       MOV       DPL,?XSP + 0
   \   00005B   85..83       MOV       DPH,?XSP + 1
   \   00005E   78..         MOV       R0,#?V0
   \   000060   12....       LCALL     ?L_ADD_TO_X
    800          
    801            /*
    802             * Workaround to take care of the case where a rollover just occured and the call to
    803             * macBackoffTimerPeriodIsr() hasn't yet occured or if one rollover occured during
    804             * sleep then update the accumulatedoverflowCount with the rollover
    805             */
    806            if((prevoverflowCount > overflowCount) && (prevAccumulatedOverflowCount == accumulatedOverflowCount))
   \   000063   90....       MOV       DPTR,#prevoverflowCount
   \   000066   78..         MOV       R0,#?V0
   \   000068   12....       LCALL     ?L_MOV_X
   \   00006B   85..82       MOV       DPL,?XSP + 0
   \   00006E   85..83       MOV       DPH,?XSP + 1
   \   000071   78..         MOV       R0,#?V0
   \   000073   12....       LCALL     ?UL_GT_X
   \   000076   5041         JNC       ??macMcuPrecisionCount_0
   \   000078   90....       MOV       DPTR,#accumulatedOverflowCount
   \   00007B   78..         MOV       R0,#?V0
   \   00007D   12....       LCALL     ?L_MOV_X
   \   000080   90....       MOV       DPTR,#prevAccumulatedOverflowCount
   \   000083   78..         MOV       R0,#?V0
   \   000085   12....       LCALL     ?L_EQ_X
   \   000088   702F         JNZ       ??macMcuPrecisionCount_0
    807            {
    808              accumulatedOverflowCount += macGetBackOffTimerRollover();
   \   00008A                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   00008A   12....       LCALL     `??macGetBackOffTimerRollover::?relay`; Banked call to: macGetBackOffTimerRollover
   \   00008D   8A..         MOV       ?V0,R2
   \   00008F   8B..         MOV       ?V1,R3
   \   000091   8C..         MOV       ?V2,R4
   \   000093   8D..         MOV       ?V3,R5
   \   000095   90....       MOV       DPTR,#accumulatedOverflowCount
   \   000098   78..         MOV       R0,#?V0
   \   00009A   12....       LCALL     ?L_ADD_TO_X
    809              overflowCount += macGetBackOffTimerRollover();
   \   00009D                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   00009D   12....       LCALL     `??macGetBackOffTimerRollover::?relay`; Banked call to: macGetBackOffTimerRollover
   \   0000A0   8A..         MOV       ?V0,R2
   \   0000A2   8B..         MOV       ?V1,R3
   \   0000A4   8C..         MOV       ?V2,R4
   \   0000A6   8D..         MOV       ?V3,R5
   \   0000A8   85..82       MOV       DPL,?XSP + 0
   \   0000AB   85..83       MOV       DPH,?XSP + 1
   \   0000AE   78..         MOV       R0,#?V0
   \   0000B0   12....       LCALL     ?L_ADD_TO_X
    810              /*don't update the rollover since it has been updated already */
    811              updateRolloverflag = TRUE;
   \   0000B3   90....       MOV       DPTR,#updateRolloverflag
   \   0000B6   7401         MOV       A,#0x1
   \   0000B8   F0           MOVX      @DPTR,A
    812            }
    813          
    814            /* store the current value of overflowcount and accumulatedOverflowCount */
    815            prevoverflowCount = overflowCount;
   \                     ??macMcuPrecisionCount_0:
   \   0000B9   85..82       MOV       DPL,?XSP + 0
   \   0000BC   85..83       MOV       DPH,?XSP + 1
   \   0000BF   12....       LCALL     ?XLOAD_R0123
   \   0000C2   90....       MOV       DPTR,#prevoverflowCount
   \   0000C5   12....       LCALL     ?XSTORE_R0123
    816            prevAccumulatedOverflowCount = accumulatedOverflowCount;
   \   0000C8   90....       MOV       DPTR,#accumulatedOverflowCount
   \   0000CB   12....       LCALL     ?XLOAD_R0123
   \   0000CE   90....       MOV       DPTR,#prevAccumulatedOverflowCount
   \   0000D1   12....       LCALL     ?XSTORE_R0123
    817          
    818            HAL_EXIT_CRITICAL_SECTION(s);
   \   0000D4   EE           MOV       A,R6
   \   0000D5   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000D7   92AF         MOV       0xa8.7,C
    819          
    820            return(overflowCount);
   \   0000D9   85..82       MOV       DPL,?XSP + 0
   \   0000DC   85..83       MOV       DPH,?XSP + 1
   \   0000DF   12....       LCALL     ?XLOAD_R2345
   \   0000E2   7404         MOV       A,#0x4
   \   0000E4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000E7   7F04         MOV       R7,#0x4
   \   0000E9   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   0000EC                REQUIRE _A_IEN0
   \   0000EC                REQUIRE T2MSEL
   \   0000EC                REQUIRE T2M0
   \   0000EC                REQUIRE T2MOVF0
   \   0000EC                REQUIRE T2MOVF1
   \   0000EC                REQUIRE T2MOVF2
    821          }
    822          
    823          
    824          /**************************************************************************************************
    825           * @fn          macMcuRfIsr
    826           *
    827           * @brief       Interrupt service routine that handles all RF interrupts.  There are a number
    828           *              of conditions "ganged" onto this one ISR so each condition must be tested for.
    829           *
    830           * @param       none
    831           *
    832           * @return      none
    833           **************************************************************************************************
    834           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    835          HAL_ISR_FUNCTION( macMcuRfIsr, RF_VECTOR )
   \                     macMcuRfIsr:
    836          {
   \   000000   C0E0         PUSH      A
   \   000002   74F2         MOV       A,#-0xe
   \   000004   12....       LCALL     ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    837            uint8 rfim;
    838          
    839            HAL_ENTER_ISR();
   \   000007   A2AF         MOV       C,0xa8.7
   \   000009   E4           CLR       A
   \   00000A   33           RLC       A
   \   00000B   FF           MOV       R7,A
   \   00000C   D2AF         SETB      0xa8.7
    840          
    841            rfim = RFIRQM1;
   \   00000E   9061A4       MOV       DPTR,#0x61a4
   \   000011   E0           MOVX      A,@DPTR
   \   000012   FE           MOV       R6,A
    842          
    843            /*  The CPU level RF interrupt flag must be cleared here (before clearing RFIRQFx).
    844             *  to allow the interrupts to be nested.
    845             */
    846            S1CON = 0x00;
   \   000013   759B00       MOV       0x9b,#0x0
    847          
    848            if ((RFIRQF1 & IRQ_CSP_MANINT) & rfim)
   \   000016   E591         MOV       A,0x91
   \   000018   5E           ANL       A,R6
   \   000019   5408         ANL       A,#0x8
   \   00001B   6008         JZ        ??macMcuRfIsr_0
    849            {
    850              /*
    851               *  Important!  Because of how the CSP programs are written, CSP_INT interrupts should
    852               *  be processed before CSP_STOP interrupts.  This becomes an issue when there are
    853               *  long critical sections.
    854               */
    855              /* clear flag */
    856              RFIRQF1 = (IRQ_CSP_MANINT ^ 0xFF);
   \   00001D   7591F7       MOV       0x91,#-0x9
    857              macCspTxIntIsr();
   \   000020                ; Setup parameters for call to function macCspTxIntIsr
   \   000020   12....       LCALL     `??macCspTxIntIsr::?relay`; Banked call to: macCspTxIntIsr
   \   000023   8026         SJMP      ??macMcuRfIsr_1
    858            }
    859            else if ((RFIRQF1 & IRQ_CSP_STOP) & rfim)
   \                     ??macMcuRfIsr_0:
   \   000025   E591         MOV       A,0x91
   \   000027   5E           ANL       A,R6
   \   000028   5410         ANL       A,#0x10
   \   00002A   6008         JZ        ??macMcuRfIsr_2
    860            {
    861              /* clear flag */
    862              RFIRQF1 = (IRQ_CSP_STOP ^ 0xFF);
   \   00002C   7591EF       MOV       0x91,#-0x11
    863              macCspTxStopIsr();
   \   00002F                ; Setup parameters for call to function macCspTxStopIsr
   \   00002F   12....       LCALL     `??macCspTxStopIsr::?relay`; Banked call to: macCspTxStopIsr
   \   000032   8017         SJMP      ??macMcuRfIsr_1
    864            }
    865            else if ((RFIRQF1 & IRQ_TXACKDONE) & rfim)
   \                     ??macMcuRfIsr_2:
   \   000034   E591         MOV       A,0x91
   \   000036   A2E0         MOV       C,0xE0 /* A   */.0
   \   000038   92F0         MOV       B.0,C
   \   00003A   EE           MOV       A,R6
   \   00003B   A2E0         MOV       C,0xE0 /* A   */.0
   \   00003D   82F0         ANL       C,B.0
   \   00003F   500A         JNC       ??macMcuRfIsr_1
    866            {
    867              /* disable interrupt - set up is for "one shot" operation */
    868              RFIRQM1 &= ~IM_TXACKDONE;
   \   000041   9061A4       MOV       DPTR,#0x61a4
   \   000044   E0           MOVX      A,@DPTR
   \   000045   C2E0         CLR       0xE0 /* A   */.0
   \   000047   F0           MOVX      @DPTR,A
    869              macRxAckTxDoneCallback();
   \   000048                ; Setup parameters for call to function macRxAckTxDoneCallback
   \   000048   12....       LCALL     `??macRxAckTxDoneCallback::?relay`; Banked call to: macRxAckTxDoneCallback
    870            }
    871          
    872            rfim = RFIRQM0;
   \                     ??macMcuRfIsr_1:
   \   00004B   9061A3       MOV       DPTR,#0x61a3
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   FE           MOV       R6,A
    873          
    874            /* process RFIRQF0 next */
    875            if ((RFIRQF0 & IRQ_FIFOP) & rfim)
   \   000050   E5E9         MOV       A,0xe9
   \   000052   5E           ANL       A,R6
   \   000053   5404         ANL       A,#0x4
   \   000055   600E         JZ        ??macMcuRfIsr_3
    876            {
    877              /* continue to execute interrup                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        t handler as long as FIFOP is active */
    878              do
    879              {
    880                macRxThresholdIsr();
   \                     ??macMcuRfIsr_4:
   \   000057                ; Setup parameters for call to function macRxThresholdIsr
   \   000057   12....       LCALL     `??macRxThresholdIsr::?relay`; Banked call to: macRxThresholdIsr
    881                RFIRQF0 = (IRQ_FIFOP ^ 0xFF);
   \   00005A   75E9FB       MOV       0xe9,#-0x5
    882              } while (FSMSTAT1 & FIFOP);
   \   00005D   906193       MOV       DPTR,#0x6193
   \   000060   E0           MOVX      A,@DPTR
   \   000061   A2E6         MOV       C,0xE0 /* A   */.6
   \   000063   40F2         JC        ??macMcuRfIsr_4
    883            }
    884          
    885            CLEAR_SLEEP_MODE();
   \                     ??macMcuRfIsr_3:
   \   000065   75..00       MOV       halSleepPconValue,#0x0
    886            HAL_EXIT_ISR();
   \   000068   EF           MOV       A,R7
   \   000069   A2E0         MOV       C,0xE0 /* A   */.0
   \   00006B   92AF         MOV       0xa8.7,C
    887          }
   \   00006D   7F01         MOV       R7,#0x1
   \   00006F   02....       LJMP      ?INTERRUPT_LEAVE_XSP
   \   000072                REQUIRE _A_IEN0
   \   000072                REQUIRE S1CON
   \   000072                REQUIRE RFIRQF1
   \   000072                REQUIRE RFIRQF0
    888          
    889          
    890          /**************************************************************************************************
    891           * @fn          macMcuRfErrIsr
    892           *
    893           * @brief       Interrupt service routine that handles all RF Error interrupts.  Only the RX FIFO
    894           *              overflow condition is handled.
    895           *
    896           * @param       none
    897           *
    898           * @return      none
    899           **************************************************************************************************
    900           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    901          HAL_ISR_FUNCTION( macMcuRfErrIsr, RFERR_VECTOR )
   \                     macMcuRfErrIsr:
    902          {
   \   000000   C0E0         PUSH      A
   \   000002   74F2         MOV       A,#-0xe
   \   000004   12....       LCALL     ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    903            uint8 rferrm;
    904          
    905            HAL_ENTER_ISR();
   \   000007   A2AF         MOV       C,0xa8.7
   \   000009   E4           CLR       A
   \   00000A   33           RLC       A
   \   00000B   FE           MOV       R6,A
   \   00000C   D2AF         SETB      0xa8.7
    906          
    907            rferrm = RFERRM;
   \   00000E   9061A5       MOV       DPTR,#0x61a5
   \   000011   E0           MOVX      A,@DPTR
   \   000012   FF           MOV       R7,A
    908          
    909            if ((RFERRF & RFERR_RXOVERF) & rferrm)
   \   000013   E5BF         MOV       A,0xbf
   \   000015   5F           ANL       A,R7
   \   000016   5404         ANL       A,#0x4
   \   000018   6006         JZ        ??macMcuRfErrIsr_0
    910            {
    911              RFERRF = (RFERR_RXOVERF ^ 0xFF);
   \   00001A   75BFFB       MOV       0xbf,#-0x5
    912              macRxFifoOverflowIsr();
   \   00001D                ; Setup parameters for call to function macRxFifoOverflowIsr
   \   00001D   12....       LCALL     `??macRxFifoOverflowIsr::?relay`; Banked call to: macRxFifoOverflowIsr
    913            }
    914          
    915            CLEAR_SLEEP_MODE();
   \                     ??macMcuRfErrIsr_0:
   \   000020   75..00       MOV       halSleepPconValue,#0x0
    916            HAL_EXIT_ISR();
   \   000023   EE           MOV       A,R6
   \   000024   A2E0         MOV       C,0xE0 /* A   */.0
   \   000026   92AF         MOV       0xa8.7,C
    917          }
   \   000028   7F01         MOV       R7,#0x1
   \   00002A   02....       LJMP      ?INTERRUPT_LEAVE_XSP
   \   00002D                REQUIRE _A_IEN0
   \   00002D                REQUIRE RFERRF
    918          
    919          
    920          /**************************************************************************************************
    921           * @fn          macMcuRecordMaxRssiStart
    922           *
    923           * @brief       Starts recording of the maximum received RSSI value.
    924           *
    925           * @param       none
    926           *
    927           * @return      none
    928           **************************************************************************************************
    929           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    930          MAC_INTERNAL_API void macMcuRecordMaxRssiStart(void)
   \                     macMcuRecordMaxRssiStart:
    931          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    932            /* start maximum recorded value at the lowest possible value */
    933            maxRssi = -128;
   \   000004   90....       MOV       DPTR,#maxRssi
   \   000007   7480         MOV       A,#-0x80
   \   000009   F0           MOVX      @DPTR,A
    934          
    935            /* enable timer overflow interrupt */
    936            T2IRQM |= TIMER2_PERM;
   \   00000A   43A701       ORL       0xa7,#0x1
    937          }
   \   00000D   D083         POP       DPH
   \   00000F   D082         POP       DPL
   \   000011   02....       LJMP      ?BRET
   \   000014                REQUIRE T2IRQM
    938          
    939          
    940          /**************************************************************************************************
    941           * @fn          macMcuRecordMaxRssiStop
    942           *
    943           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    944           *              received since starting the recording.
    945           *
    946           * @param       none
    947           *
    948           * @return      maximum received RSSI value
    949           **************************************************************************************************
    950           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    951          MAC_INTERNAL_API int8 macMcuRecordMaxRssiStop(void)
   \                     macMcuRecordMaxRssiStop:
    952          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    953            /* disable timer overflow interrupt */
    954            T2IRQM &= ~TIMER2_PERM;
   \   000004   53A7FE       ANL       0xa7,#0xfe
    955          
    956            return(maxRssi);
   \   000007   90....       MOV       DPTR,#maxRssi
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   F9           MOV       R1,A
   \   00000C   D083         POP       DPH
   \   00000E   D082         POP       DPL
   \   000010   02....       LJMP      ?BRET
   \   000013                REQUIRE T2IRQM
    957          }
    958          
    959          
    960          /*=================================================================================================
    961           * @fn          macMcuRecordMaxRssiIsr
    962           *
    963           * @brief       Interrupt service routine called during recording of max RSSI value.
    964           *
    965           * @param       none
    966           *
    967           * @return      none
    968           *=================================================================================================
    969           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    970          static void mcuRecordMaxRssiIsr(void)
   \                     mcuRecordMaxRssiIsr:
    971          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    972            int8 rssi;
    973          
    974            /* read latest RSSI value */
    975            rssi = RSSI;
   \   000004   906198       MOV       DPTR,#0x6198
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F8           MOV       R0,A
    976          
    977            /* if new RSSI value is greater than the maximum already received, it is the new maximum */
    978            if (rssi > maxRssi)
   \   000009   90....       MOV       DPTR,#maxRssi
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   C3           CLR       C
   \   00000E   98           SUBB      A,R0
   \   00000F   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000011   65D0         XRL       A,PSW
   \   000013   33           RLC       A
   \   000014   5005         JNC       ??mcuRecordMaxRssiIsr_0
    979            {
    980              maxRssi = rssi;
   \   000016   E8           MOV       A,R0
   \   000017   90....       MOV       DPTR,#maxRssi
   \   00001A   F0           MOVX      @DPTR,A
    981            }
    982          }
   \                     ??mcuRecordMaxRssiIsr_0:
   \   00001B   D083         POP       DPH
   \   00001D   D082         POP       DPL
   \   00001F   02....       LJMP      ?BRET
    983          
    984          
    985          /**************************************************************************************************
    986           * @fn          macMcuAccumulatedOverFlow
    987           *
    988           * @brief       This function is used to accumulate timer 2 overflow if applicable
    989           *              on the relevant platform
    990           *
    991           * @param       none
    992           *
    993           * @return      none
    994           **************************************************************************************************
    995           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    996          MAC_INTERNAL_API void macMcuAccumulatedOverFlow(void)
   \                     macMcuAccumulatedOverFlow:
    997          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    998            halIntState_t  s;
    999            HAL_ENTER_CRITICAL_SECTION(s);
   \   000005   A2AF         MOV       C,0xa8.7
   \   000007   E4           CLR       A
   \   000008   33           RLC       A
   \   000009   FE           MOV       R6,A
   \   00000A   C2AF         CLR       0xa8.7
   1000          
   1001            if(updateRolloverflag == FALSE)
   \   00000C   90....       MOV       DPTR,#updateRolloverflag
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   7015         JNZ       ??macMcuAccumulatedOverFlow_0
   1002            {
   1003              accumulatedOverflowCount += macGetBackOffTimerRollover();
   \   000012                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   000012   12....       LCALL     `??macGetBackOffTimerRollover::?relay`; Banked call to: macGetBackOffTimerRollover
   \   000015   8A..         MOV       ?V0,R2
   \   000017   8B..         MOV       ?V1,R3
   \   000019   8C..         MOV       ?V2,R4
   \   00001B   8D..         MOV       ?V3,R5
   \   00001D   90....       MOV       DPTR,#accumulatedOverflowCount
   \   000020   78..         MOV       R0,#?V0
   \   000022   12....       LCALL     ?L_ADD_TO_X
   \   000025   8006         SJMP      ??macMcuAccumulatedOverFlow_1
   1004            }
   1005            else
   1006            {
   1007              updateRolloverflag = FALSE;
   \                     ??macMcuAccumulatedOverFlow_0:
   \   000027   90....       MOV       DPTR,#updateRolloverflag
   \   00002A   7400         MOV       A,#0x0
   \   00002C   F0           MOVX      @DPTR,A
   1008            }
   1009          
   1010            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macMcuAccumulatedOverFlow_1:
   \   00002D   EE           MOV       A,R6
   \   00002E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000030   92AF         MOV       0xa8.7,C
   1011          }
   \   000032   7F04         MOV       R7,#0x4
   \   000034   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   000037                REQUIRE _A_IEN0

   \                                 In  segment INTVEC, offset 0x3, root
   \                     `??macMcuRfErrIsr::??INTVEC 3`:
   \   000003   02....       LJMP       (macMcuRfErrIsr)

   \                                 In  segment INTVEC, offset 0x53, root
   \                     `??macMcuTimer2Isr::??INTVEC 83`:
   \   000053   02....       LJMP       (macMcuTimer2Isr)

   \                                 In  segment INTVEC, offset 0x83, root
   \                     `??macMcuRfIsr::??INTVEC 131`:
   \   000083   02....       LJMP       (macMcuRfIsr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ff000000:
   \   000000   000000FF     DD 4278190080
   1012          
   1013          
   1014          /**************************************************************************************************
   1015           *                                  Compile Time Integrity Checks
   1016           **************************************************************************************************
   1017           */
   1018          #if ((IRQ_SFD != IM_SFD) || (IRQ_FIFOP != IM_FIFOP) || (IRQ_TXACKDONE != IM_TXACKDONE))
   1019          #error "ERROR: Compile time error with RFIRQFx vs RFIRQMx register defines."
   1020          #endif
   1021          
   1022          #if defined (FEATURE_CC253X_LOW_POWER_RX) && !(defined (HAL_MCU_CC2530) || defined (HAL_MCU_CC2533))
   1023          #error "ERROR: FEATURE_CC253X_LOW_POWER_RX can only be used with CC2530 or CC2533."
   1024          #endif
   1025          
   1026          /**************************************************************************************************
   1027          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   MAC_SetRandomSeedCB
      0     12   macMcuAccumulatedOverFlow
        0     12   -> macGetBackOffTimerRollover
      1     41   macMcuInit
        0     41   -> macRxOff
        0     41   -> macRxOn
      3      4   macMcuOverflowCapture
      3     20   macMcuOverflowCount
      3     20   macMcuOverflowGetCompare
      0     16   macMcuOverflowSetCompare
        0     16   -> halAssertHandler
      0     16   macMcuOverflowSetCount
        0     16   -> halAssertHandler
        0     16   -> macMcuOverflowCount
      0     16   macMcuOverflowSetPeriod
        0     16   -> halAssertHandler
        0     16   -> halSetMaxSleepLoopTime
      1     16   macMcuPrecisionCount
        0     16   -> macGetBackOffTimerRollover
      0      0   macMcuRandomByte
      0      0   macMcuRandomWord
      2      0   macMcuRecordMaxRssiStart
      2      0   macMcuRecordMaxRssiStop
      0     14   macMcuRfErrIsr
        0     14   -> macRxFifoOverflowIsr
      0     14   macMcuRfIsr
        0     14   -> macCspTxIntIsr
        0     14   -> macCspTxStopIsr
        0     14   -> macRxAckTxDoneCallback
        0     14   -> macRxThresholdIsr
      0     14   macMcuTimer2Isr
        0     14   -> macBackoffTimerCompareIsr
        0     14   -> macBackoffTimerPeriodIsr
        0     14   -> mcuRecordMaxRssiIsr
      0     16   macMcuTimer2OverflowWorkaround
        0     16   -> macBackoffTimerCompareIsr
        0     16   -> macMcuOverflowCount
        0     16   -> macMcuOverflowGetCompare
      0      0   macMcuTimerCapture
      0      0   macMcuTimerForceDelay
      2     14   mcuRecordMaxRssiIsr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ADCCON1
       1  CLKCONSTA
       1  IEN2
       1  IP0
       1  IP1
      19  MAC_SetRandomSeedCB
       1  RFERRF
       1  RFIRQF0
       1  RFIRQF1
       1  RNDH
       1  RNDL
       1  S1CON
       1  T2CTRL
       1  T2IRQF
       1  T2IRQM
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
       1  T2MOVF2
       1  T2MSEL
       1  _A_IEN0
       1  _A_IEN1
       4  __Constant_ff000000
       4  accumulatedOverflowCount
       1  macChipVersion
      55  macMcuAccumulatedOverFlow
     420  macMcuInit
      90  macMcuOverflowCapture
      92  macMcuOverflowCount
      90  macMcuOverflowGetCompare
     131  macMcuOverflowSetCompare
     147  macMcuOverflowSetCount
     143  macMcuOverflowSetPeriod
     236  macMcuPrecisionCount
      14  macMcuRandomByte
      32  macMcuRandomWord
      20  macMcuRecordMaxRssiStart
      19  macMcuRecordMaxRssiStop
      45  macMcuRfErrIsr
       3  macMcuRfErrIsr::??INTVEC 3
     114  macMcuRfIsr
       3  macMcuRfIsr::??INTVEC 131
      79  macMcuTimer2Isr
       3  macMcuTimer2Isr::??INTVEC 83
      59  macMcuTimer2OverflowWorkaround
      39  macMcuTimerCapture
      31  macMcuTimerForceDelay
       1  maxRssi
      34  mcuRecordMaxRssiIsr
       2  pRandomSeedCB
       4  prevAccumulatedOverflowCount
       4  prevoverflowCount
       1  updateRolloverflag
     108  -- Other

 
 1 671 bytes in segment BANKED_CODE
   108 bytes in segment BANK_RELAYS
     9 bytes in segment INTVEC
   238 bytes in segment NEAR_CODE
    22 bytes in segment SFR_AN
     4 bytes in segment XDATA_ROM_C
    17 bytes in segment XDATA_Z
 
   346 bytes of CODE     memory (+  9 bytes shared)
     0 bytes of CONST    memory (+  4 bytes shared)
     0 bytes of DATA     memory (+ 22 bytes shared)
 1 671 bytes of HUGECODE memory
    17 bytes of XDATA    memory

Errors: none
Warnings: none
