###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               30/Jul/2020  16:03:41
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  D:\AA\Z-Stack 3.0.2\Components\stack\zcl\zcl.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EW869.tmp ("D:\AA\Z-Stack
#        3.0.2\Components\stack\zcl\zcl.c" -D SECURE=1 -D TC_LINKKEY_JOIN -D
#        NV_INIT -D NV_RESTORE -D xPOWER_SAVING -D NWK_AUTO_POLL -D xZTOOL_P1
#        -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D LCD_SUPPORTED=DEBUG -D
#        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_DISCOVER -D ZCL_WRITE -D
#        ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF -D ZCL_GROUPS -D
#        BDB_TL_INITIATOR -D INTER_PAN -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\" -I
#        "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -On --require_prototypes --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_cross_call)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List\zcl.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj\zcl.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2015-09-09 11:51:49 -0700 (Wed, 09 Sep 2015) $
      4            Revision:       $Revision: 44489 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          #include "APS.h"
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52             
     53          #ifdef BDB_REPORTING
     54            #include "bdb_Reporting.h"
     55          #endif
     56          #include "bdb_interface.h"
     57          
     58          #include "zcl_green_power.h"
     59          
     60             
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          /*** Frame Control ***/
     65          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     66          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     67          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     68          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     69          
     70          /*** Attribute Access Control ***/
     71          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     72          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     73          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     74          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     75          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     76          #define zcl_AccessClient( a )         ( (a) & ACCESS_CLIENT )
     77          
     78          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     79          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     80          
     81          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     82                                                  (zclHdr).fc.manuSpecific == 0          && \
     83                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     84          
     85          // Commands that have corresponding responses (ZCL_CMD_WRITE_NO_RSP, does not have response, but must not send default response)
     86          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     87                                                  (cmd) == ZCL_CMD_WRITE                  || \
     88                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     89                                                  (cmd) == ZCL_CMD_WRITE_NO_RSP           || \
     90                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     91                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     92                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     93                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     94                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     95                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     96                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     97          #define  ZCL_VALID_MIN_HEADER_LEN  3
     98          
     99          /*********************************************************************
    100           * CONSTANTS
    101           */
    102          
    103          /*********************************************************************
    104           * TYPEDEFS
    105           */
    106          typedef struct zclLibPlugin
    107          {
    108            struct zclLibPlugin *next;
    109            uint16              startClusterID;    // starting cluster ID
    110            uint16              endClusterID;      // ending cluster ID
    111            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    112          } zclLibPlugin_t;
    113          
    114          // Command record list
    115          typedef struct zclCmdRecsList
    116          {
    117            struct zclCmdRecsList *pNext;
    118            uint8                 endpoint;
    119            uint8                 numCommands;
    120            CONST zclCommandRec_t *pCmdRecs;
    121          } zclCmdRecsList_t;
    122          
    123          
    124          // Cluster option list item
    125          typedef struct zclClusterOptionList
    126          {
    127            struct zclClusterOptionList *next;
    128            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    129            uint8                       numOptions; // Number of the following records
    130            zclOptionRec_t              *options;   // option records
    131          } zclClusterOptionList;
    132          
    133          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    134          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    135          
    136          typedef struct
    137          {
    138            zclParseInProfileCmd_t   pfnParseInProfile;
    139            zclProcessInProfileCmd_t pfnProcessInProfile;
    140          } zclCmdItems_t;
    141          
    142          
    143          // List record for external handler for unhandled ZCL Foundation commands/rsps
    144          typedef struct zclExternalFoundationHandlerList
    145          {
    146              struct zclExternalFoundationHandlerList *next;
    147              uint8 zcl_ExternalTaskID;
    148              uint8 zcl_ExternalEndPoint;
    149          } zclExternalFoundationHandlerList;
    150          
    151          
    152          /*********************************************************************
    153           * GLOBAL VARIABLES
    154           */
    155          
    156          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    158          #endif
    159          
    160          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    161          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    162          
    163          // ZCL Sequence number
    164          //uint8 zcl_SeqNum = 0x00;  //Not longer used, refer to bdb_getZCLFrameCounter() in bdb_interface.h

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    165          uint8 zcl_InSeqNum = 0x00;
   \                     zcl_InSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    166          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    167          uint8 zcl_radius = AF_DEFAULT_RADIUS;
   \                     zcl_radius:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_radius>`
   \   000001                REQUIRE __INIT_XDATA_I
    168          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    169          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    170          
    171          /*********************************************************************
    172           * EXTERNAL VARIABLES
    173           */
    174          
    175          /*********************************************************************
    176           * EXTERNAL FUNCTIONS
    177           */
    178          
    179          /*********************************************************************
    180           * LOCAL VARIABLES
    181           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    182          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    183          
    184          #if defined ( ZCL_DISCOVER )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    185            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
   \                     gpCmdList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    186          #endif
    187          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    189          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    190          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    191          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    192          
    193          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    194          static zclExternalFoundationHandlerList *externalEndPointHandlerList = (zclExternalFoundationHandlerList *)NULL;
   \                     externalEndPointHandlerList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    195          #endif
    196          
    197          /*********************************************************************
    198           * LOCAL FUNCTIONS
    199           */
    200          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    201          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    202          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    203          
    204          #if !defined ( ZCL_STANDALONE )
    205          static uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId );
    206          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg );
    207          #endif // !defined ( ZCL_STANDALONE )
    208          
    209          #if defined ( ZCL_DISCOVER )
    210            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    211          #endif
    212          
    213          zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    214          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    215          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    216          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    217          
    218          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    219          
    220          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    221          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    222          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    223          #endif // ZCL_READ || ZCL_WRITE
    224          
    225          #ifdef ZCL_READ
    226          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    227          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    228          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    229                                                   uint8 *pAttrData, uint16 *pDataLen );
    230          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    231          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    232          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    233          #endif // ZCL_READ
    234          
    235          #ifdef ZCL_WRITE
    236          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    237                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    238          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    239                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    240          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    241          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    242          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    243          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    244          #endif // ZCL_WRITE
    245          
    246          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    247          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    248          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    249          #endif
    250          
    251          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    252          
    253          #ifdef ZCL_DISCOVER
    254          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    255          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    256          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    257          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    258          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    259          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    260          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    261          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    262          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    263          #endif // ZCL_DISCOVER
    264          
    265          /*********************************************************************
    266           * Parse Profile Command Function Table
    267           */
    268          

   \                                 In  segment CODE_C, align 1
    269          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW `??zclParseInReadCmd::?relay`
   \   000002   ....         DW `??zclProcessInReadCmd::?relay`
   \   000004   ....         DW `??zclParseInReadRspCmd::?relay`
   \   000006   ....         DW `??zcl_HandleExternal::?relay`
   \   000008   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000A   ....         DW `??zclProcessInWriteCmd::?relay`
   \   00000C   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000E   ....         DW `??zclProcessInWriteUndividedCmd::?relay`
   \   000010   ....         DW `??zclParseInWriteRspCmd::?relay`
   \   000012   ....         DW `??zcl_HandleExternal::?relay`
   \   000014   ....         DW `??zclParseInWriteCmd::?relay`
   \   000016   ....         DW `??zclProcessInWriteCmd::?relay`
   \   000018   0000         DW 0H
   \   00001A   0000         DW 0H
   \   00001C   0000         DW 0H
   \   00001E   0000         DW 0H
   \   000020   0000         DW 0H
   \   000022   0000         DW 0H
   \   000024   0000         DW 0H
   \   000026   0000         DW 0H
   \   000028   0000         DW 0H
   \   00002A   0000         DW 0H
   \   00002C   ....         DW `??zclParseInDefaultRspCmd::?relay`
   \   00002E   ....         DW `??zcl_HandleExternal::?relay`
   \   000030   ....         DW `??zclParseInDiscAttrsCmd::?relay`
   \   000032   ....         DW `??zclProcessInDiscAttrs::?relay`
   \   000034   ....         DW `??zclParseInDiscAttrsRspCmd::?relay`
   \   000036   ....         DW `??zcl_HandleExternal::?relay`
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   ....         DW `??zclParseInDiscCmdsCmd::?relay`
   \   000046   ....         DW `??zclProcessInDiscCmd::?relay`
   \   000048   ....         DW `??zclParseInDiscCmdsRspCmd::?relay`
   \   00004A   ....         DW `??zcl_HandleExternal::?relay`
   \   00004C   ....         DW `??zclParseInDiscCmdsCmd::?relay`
   \   00004E   ....         DW `??zclProcessInDiscCmd::?relay`
   \   000050   ....         DW `??zclParseInDiscCmdsRspCmd::?relay`
   \   000052   ....         DW `??zcl_HandleExternal::?relay`
   \   000054   ....         DW `??zclParseInDiscAttrsCmd::?relay`
   \   000056   ....         DW `??zclProcessInDiscAttrs::?relay`
   \   000058   ....         DW `??zclParseInDiscAttrsExtRspCmd::?relay`
   \   00005A   ....         DW `??zcl_HandleExternal::?relay`
    270          {
    271          #ifdef ZCL_READ
    272            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    273            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    274          #else
    275            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    276            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    277          #endif // ZCL_READ
    278          
    279          #ifdef ZCL_WRITE
    280            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    281            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    282            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    283            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    284          #else
    285            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    287            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    288            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    289          #endif // ZCL_WRITE
    290          
    291          #ifdef ZCL_REPORTING_DEVICE
    292              /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    293          #else
    294              /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    295          #endif
    296          
    297          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    298              /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    299          #else
    300              /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    301          #endif
    302          
    303          #ifdef ZCL_REPORTING_DEVICE
    304              /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    305          #else
    306              /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    307          #endif
    308          
    309          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    310              /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    311          #else
    312              /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    313          #endif
    314          
    315          #ifdef ZCL_REPORT_DESTINATION_DEVICE
    316              /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    317          #else
    318              /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    319          #endif
    320          
    321            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    322          
    323          #ifdef ZCL_DISCOVER
    324            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    325            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    326            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    327            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    328            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    329            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    330            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    331            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    332            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    333            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    334            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    335          #else
    336            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    337            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    338            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    339            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    340            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    341            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    342            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    343            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    344            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    345            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    346            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    347          #endif // ZCL_DISCOVER
    348          };
    349          
    350          /*********************************************************************
    351           * PUBLIC FUNCTIONS
    352           *********************************************************************/
    353          
    354          #if !defined ( ZCL_STANDALONE )
    355          /*********************************************************************
    356           * @fn          zcl_Init
    357           *
    358           * @brief       Initialization function for the zcl layer.
    359           *
    360           * @param       task_id - ZCL task id
    361           *
    362           * @return      none
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    365          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    366            zcl_TaskID = task_id;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#zcl_TaskID
   \   000008   F0           MOVX      @DPTR,A
    367          }
   \   000009   D083         POP       DPH
   \   00000B   D082         POP       DPL
   \   00000D   02....       LJMP      ?BRET
    368          #endif
    369          
    370          #if !defined ( ZCL_STANDALONE )
    371          /*********************************************************************
    372           * @fn          zcl_event_loop
    373           *
    374           * @brief       Event Loop Processor for zcl.
    375           *
    376           * @param       task_id - task id
    377           * @param       events - event bitmap
    378           *
    379           * @return      unprocessed events
    380           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    381          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    382          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V2,R2
   \   000009   8B..         MOV       ?V3,R3
    383            uint8 *msgPtr;
    384          
    385            (void)task_id;  // Intentionally unreferenced parameter
    386          
    387            if ( events & SYS_EVENT_MSG )
   \   00000B   E5..         MOV       A,?V2
   \   00000D   5400         ANL       A,#0x0
   \   00000F   F8           MOV       R0,A
   \   000010   E5..         MOV       A,?V3
   \   000012   5480         ANL       A,#0x80
   \   000014   F9           MOV       R1,A
   \   000015   E8           MOV       A,R0
   \   000016   49           ORL       A,R1
   \   000017   6071         JZ        ??zcl_event_loop_0
    388            {
    389              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000019                ; Setup parameters for call to function osal_msg_receive
   \   000019   90....       MOV       DPTR,#zcl_TaskID
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   F9           MOV       R1,A
   \   00001E   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   000021   8A..         MOV       ?V0,R2
   \   000023   8B..         MOV       ?V1,R3
   \   000025   AE..         MOV       R6,?V0
   \   000027   AF..         MOV       R7,?V1
    390              while ( msgPtr != NULL )
   \                     ??zcl_event_loop_1:
   \   000029   EE           MOV       A,R6
   \   00002A   4F           ORL       A,R7
   \   00002B   6051         JZ        ??zcl_event_loop_2
    391              {
    392                uint8 dealloc = TRUE;
   \   00002D   75..01       MOV       ?V0,#0x1
    393          
    394                if ( *msgPtr == AF_INCOMING_MSG_CMD )
   \   000030   8E82         MOV       DPL,R6
   \   000032   8F83         MOV       DPH,R7
   \   000034   E0           MOVX      A,@DPTR
   \   000035   641A         XRL       A,#0x1a
   \   000037   700A         JNZ       ??zcl_event_loop_3
    395                {
    396                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \   000039                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000039   EE           MOV       A,R6
   \   00003A   FA           MOV       R2,A
   \   00003B   EF           MOV       A,R7
   \   00003C   FB           MOV       R3,A
   \   00003D   12....       LCALL     `??zcl_ProcessMessageMSG::?relay`; Banked call to: zcl_ProcessMessageMSG
   \   000040   E9           MOV       A,R1
   \   000041   801D         SJMP      ??zcl_event_loop_4
    397                }
    398                else
    399                {
    400                  uint8 taskID;
    401                  taskID = zcl_getExternalFoundationHandler( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_3:
   \   000043                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000043   EE           MOV       A,R6
   \   000044   FA           MOV       R2,A
   \   000045   EF           MOV       A,R7
   \   000046   FB           MOV       R3,A
   \   000047   12....       LCALL     `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   00004A   E9           MOV       A,R1
   \   00004B   F5..         MOV       ?V1,A
    402          
    403                  if ( taskID != TASK_NO_TASK )
   \   00004D   74FF         MOV       A,#-0x1
   \   00004F   65..         XRL       A,?V1
   \   000051   600D         JZ        ??zcl_event_loop_4
    404                  {
    405                    // send it to another task to process.
    406                    osal_msg_send( taskID, msgPtr );
   \   000053                ; Setup parameters for call to function osal_msg_send
   \   000053   EE           MOV       A,R6
   \   000054   FA           MOV       R2,A
   \   000055   EF           MOV       A,R7
   \   000056   FB           MOV       R3,A
   \   000057   A9..         MOV       R1,?V1
   \   000059   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   00005C   E9           MOV       A,R1
    407                    dealloc = FALSE;
   \   00005D   75..00       MOV       ?V0,#0x0
    408                  }
    409                }
    410          
    411                // Release the memory
    412                if ( dealloc )
   \                     ??zcl_event_loop_4:
   \   000060   E5..         MOV       A,?V0
   \   000062   6008         JZ        ??zcl_event_loop_5
    413                {
    414                  osal_msg_deallocate( msgPtr );
   \   000064                ; Setup parameters for call to function osal_msg_deallocate
   \   000064   EE           MOV       A,R6
   \   000065   FA           MOV       R2,A
   \   000066   EF           MOV       A,R7
   \   000067   FB           MOV       R3,A
   \   000068   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \   00006B   E9           MOV       A,R1
    415                }
    416          
    417                // Next
    418                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_5:
   \   00006C                ; Setup parameters for call to function osal_msg_receive
   \   00006C   90....       MOV       DPTR,#zcl_TaskID
   \   00006F   E0           MOVX      A,@DPTR
   \   000070   F9           MOV       R1,A
   \   000071   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   000074   8A..         MOV       ?V6,R2
   \   000076   8B..         MOV       ?V7,R3
   \   000078   AE..         MOV       R6,?V6
   \   00007A   AF..         MOV       R7,?V7
   \   00007C   80AB         SJMP      ??zcl_event_loop_1
    419              }
    420          
    421              // return unprocessed events
    422              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_2:
   \   00007E   E5..         MOV       A,?V2
   \   000080   6400         XRL       A,#0x0
   \   000082   FA           MOV       R2,A
   \   000083   E5..         MOV       A,?V3
   \   000085   6480         XRL       A,#0x80
   \   000087   FB           MOV       R3,A
   \   000088   8004         SJMP      ??zcl_event_loop_6
    423            }
    424          
    425          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
    426            if ( events & ZCL_DATABUF_SEND )
    427            {
    428              gpNotificationMsg_t *gpNotification = NULL;
    429              gpCmdPayloadMsg_t *pCmdPayloadMsgCurr = NULL;
    430              gpd_ID_t gpd_ID;
    431              uint8 *pgpdid;
    432              uint8 entry[PROXY_TBL_ENTRY_LEN];
    433              uint8 appId;
    434              uint8 nwkSeqNum;
    435              uint8 apsSecNum;
    436              uint16 nwkAddr;
    437              
    438              gpNotification = gp_GetHeadNotificationMsg( );
    439              
    440              if ( gpNotification == NULL )
    441              {
    442                return 0;
    443              }
    444              
    445              pCmdPayloadMsgCurr = ( gpCmdPayloadMsg_t* ) gpNotification->pMsg ;
    446              appId = PROXY_TBL_GET_APPLICTION_ID((uint16)*pCmdPayloadMsgCurr->pMsg);
    447              
    448              // To save the NIB nwk sequense number and use the GP alias nwk sequence number
    449              // for the GP notification
    450              nwkSeqNum = _NIB.SequenceNum;
    451              _NIB.SequenceNum = pCmdPayloadMsgCurr->secNum;
    452              
    453              // To save the NIB nwk address and use the GP alias nwk address for the GP notification
    454              nwkAddr = _NIB.nwkDevAddress;
    455              
    456              if( appId == GP_OPT_APP_ID_GPD )
    457              {
    458                pgpdid = pCmdPayloadMsgCurr->pMsg + sizeof( uint16 );
    459                
    460                osal_memcpy( &_NIB.nwkDevAddress, pgpdid, sizeof(uint16) );
    461                gpd_ID.AppID = GP_OPT_APP_ID_GPD;
    462                osal_memcpy( &gpd_ID.GPDId.SrcID, pgpdid, sizeof( uint32 ) );
    463              }
    464              else if( appId == GP_OPT_APP_ID_IEEE )
    465              {
    466                pgpdid = pCmdPayloadMsgCurr->pMsg + Z_EXTADDR_LEN;
    467                
    468                osal_revmemcpy( &_NIB.nwkDevAddress,(pCmdPayloadMsgCurr->pMsg + Z_EXTADDR_LEN), sizeof(uint16) );
    469                
    470                gpd_ID.AppID = GP_OPT_APP_ID_IEEE;
    471          
    472                pgpdid = pCmdPayloadMsgCurr->pMsg + sizeof( uint16 );
    473                osal_memcpy( gpd_ID.GPDId.GPDExtAddr, pgpdid, Z_EXTADDR_LEN );
    474              }
    475              
    476              gp_getProxyTableByGpId(&gpd_ID, entry, NULL);
    477          
    478              if ( PROXY_TBL_GET_ASSIGNED_ALIAS( entry[PROXY_TBL_ENTRY_OPT + 1] ) )
    479              {
    480                _NIB.nwkDevAddress = 0;
    481                osal_memcpy( (uint8*)&_NIB.nwkDevAddress, &entry[PROXY_TBL_ENTRY_ALIAS], sizeof(uint16));
    482              }
    483              
    484              // save aps sequence number
    485              apsSecNum = APS_Counter;
    486              APS_Counter = pCmdPayloadMsgCurr->secNum;
    487              
    488              // Set nwk radius for zcl frame
    489              if ( entry[PROXY_TBL_ENTRY_GRP_RAD] != 0xFF)
    490              {
    491                zcl_radius =  entry[PROXY_TBL_ENTRY_GRP_RAD];
    492              }
    493              
    494              zcl_SendCommand( GREEN_POWER_INTERNAL_ENDPOINT, &gpNotification->addr, ZCL_CLUSTER_ID_GREEN_POWER,
    495                                    COMMAND_GP_NOTIFICATION, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    496                                    TRUE, 0,  bdb_getZCLFrameCounter(), pCmdPayloadMsgCurr->lenght, pCmdPayloadMsgCurr->pMsg );
    497              
    498              // restore nwk radius
    499              zcl_radius = AF_DEFAULT_RADIUS;
    500              
    501              // restore aps sequence number
    502              APS_Counter = apsSecNum;
    503               
    504              // Restore the NIB nwk sequence number
    505              _NIB.SequenceNum = nwkSeqNum;
    506              
    507              // Restore the NIB nwk address
    508              _NIB.nwkDevAddress = nwkAddr;
    509              
    510              gp_NotificationMsgClean( gp_GetPHeadNotification ( ) );
    511              
    512              if ( gp_GetHeadNotificationMsg ( ) != NULL )
    513              {
    514                osal_start_timerEx( zcl_TaskID, ZCL_DATABUF_SEND, 50 );
    515              }
    516            }
    517          #endif
    518          
    519            // Discard unknown events
    520            return 0;
   \                     ??zcl_event_loop_0:
   \   00008A   7A00         MOV       R2,#0x0
   \   00008C   7B00         MOV       R3,#0x0
   \                     ??zcl_event_loop_6:
   \   00008E   7F08         MOV       R7,#0x8
   \   000090   02....       LJMP      ?BANKED_LEAVE_XDATA
    521          }
    522          #endif
    523          
    524          #if !defined ( ZCL_STANDALONE )
    525          /*********************************************************************
    526           * @fn      zcl_registerForMsg
    527           *
    528           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    529           *          messages that aren't processed to one task (if a task is
    530           *          registered).
    531           *
    532           * @param   taskId - task Id of the Application where commands will be sent to
    533           *
    534           * @return  TRUE if task registeration successful, FALSE otherwise
    535           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    536          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    537          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    538            return zcl_addExternalFoundationHandler( taskId, AF_BROADCAST_ENDPOINT );
   \   000007                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000007   7AFF         MOV       R2,#-0x1
   \   000009   EE           MOV       A,R6
   \   00000A   F9           MOV       R1,A
   \   00000B   12....       LCALL     `??zcl_addExternalFoundationHandler::?relay`; Banked call to: zcl_addExternalFoundationHandler
   \   00000E   7F01         MOV       R7,#0x1
   \   000010   02....       LJMP      ?BANKED_LEAVE_XDATA
    539          }
    540          
    541          /*********************************************************************
    542           * @fn      zcl_registerForMsgExt
    543           *
    544           * @brief   This function enables a Task to register to recieve all
    545           *          incoming Foundation Command/Response messages, for a particular
    546           *          End Point, that aren't processed by ZCL.
    547           *
    548           *          NOTE: Any Task registered for a unique end point will take
    549           *          priority over any Task registered with the AF_BROADCAST_ENDPOINT
    550           *          value.  ie. If task A registers for End Point 1, task B registers
    551           *          for AF_BROADCAST_ENDPOINT,  commands addressed to End Point 1 will be
    552           *          sent to Task A and NOT Task B.
    553           *
    554           * @param   taskId - task Id of the Application where commands will be sent to
    555           * @param   endPointId - end point Id of interest
    556           *
    557           * @return  TRUE if task registeration successful, FALSE otherwise
    558           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    559          uint8 zcl_registerForMsgExt( uint8 taskId, uint8 endPointId  )
   \                     zcl_registerForMsgExt:
    560          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FF           MOV       R7,A
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
    561            return ( zcl_addExternalFoundationHandler( taskId, endPointId  ) );
   \   000009                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000009   EE           MOV       A,R6
   \   00000A   FA           MOV       R2,A
   \   00000B   EF           MOV       A,R7
   \   00000C   F9           MOV       R1,A
   \   00000D   12....       LCALL     `??zcl_addExternalFoundationHandler::?relay`; Banked call to: zcl_addExternalFoundationHandler
   \   000010   7F01         MOV       R7,#0x1
   \   000012   02....       LJMP      ?BANKED_LEAVE_XDATA
    562          }
    563          
    564          /*********************************************************************
    565           * @fn      zcl_addExternalFoundationHandler
    566           *
    567           * @brief   This function adds a record to the internal list of external
    568           *          handlers of unhandled incoming Foundation Command/Response messages.
    569           *
    570           * @param   taskId - task Id of the Application where commands will be sent to
    571           * @param   endPointId - end point Id of interest
    572           *
    573           * @return  TRUE if task registeration successful, FALSE otherwise
    574           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    575          uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId  )
   \                     zcl_addExternalFoundationHandler:
    576          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V5,R2
    577            zclExternalFoundationHandlerList *pNewItem;
    578            zclExternalFoundationHandlerList *pLoop;
    579            zclExternalFoundationHandlerList *pLoopPrev;
    580          
    581            // Fill in the new endpoint registrant list
    582            pNewItem = zcl_mem_alloc( sizeof( zclExternalFoundationHandlerList ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A04         MOV       R2,#0x4
   \   00000B   7B00         MOV       R3,#0x0
   \   00000D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   8A..         MOV       ?V6,R2
   \   000012   8B..         MOV       ?V7,R3
   \   000014   AE..         MOV       R6,?V6
   \   000016   AF..         MOV       R7,?V7
    583            if ( pNewItem == NULL )
   \   000018   EE           MOV       A,R6
   \   000019   4F           ORL       A,R7
   \   00001A   7005         JNZ       ??zcl_addExternalFoundationHandler_0
    584            {
    585              return ( false );
   \   00001C   7900         MOV       R1,#0x0
   \   00001E   02....       LJMP      ??zcl_addExternalFoundationHandler_1 & 0xFFFF
    586            }
    587          
    588            pNewItem->zcl_ExternalEndPoint = endPointId;
   \                     ??zcl_addExternalFoundationHandler_0:
   \   000021   E5..         MOV       A,?V5
   \   000023   C0E0         PUSH      A
   \   000025   8E82         MOV       DPL,R6
   \   000027   8F83         MOV       DPH,R7
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   D0E0         POP       A
   \   00002E   F0           MOVX      @DPTR,A
    589            pNewItem->zcl_ExternalTaskID = taskId;
   \   00002F   E5..         MOV       A,?V4
   \   000031   C0E0         PUSH      A
   \   000033   8E82         MOV       DPL,R6
   \   000035   8F83         MOV       DPH,R7
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   D0E0         POP       A
   \   00003B   F0           MOVX      @DPTR,A
    590            pNewItem->next = NULL;
   \   00003C   8E82         MOV       DPL,R6
   \   00003E   8F83         MOV       DPH,R7
   \   000040   7400         MOV       A,#0x0
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   7400         MOV       A,#0x0
   \   000046   F0           MOVX      @DPTR,A
    591          
    592            // Add to the list
    593            if ( externalEndPointHandlerList == NULL )
   \   000047   90....       MOV       DPTR,#externalEndPointHandlerList
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   F8           MOV       R0,A
   \   00004C   A3           INC       DPTR
   \   00004D   E0           MOVX      A,@DPTR
   \   00004E   F9           MOV       R1,A
   \   00004F   E8           MOV       A,R0
   \   000050   49           ORL       A,R1
   \   000051   700B         JNZ       ??zcl_addExternalFoundationHandler_2
    594            {
    595              externalEndPointHandlerList = pNewItem;
   \   000053   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000056   EE           MOV       A,R6
   \   000057   F0           MOVX      @DPTR,A
   \   000058   A3           INC       DPTR
   \   000059   EF           MOV       A,R7
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   02....       LJMP      ??zcl_addExternalFoundationHandler_3 & 0xFFFF
    596            }
    597            else
    598            {
    599              // make sure no one else tried to register for this endpoint
    600              pLoop = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_2:
   \   00005E   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000061   E0           MOVX      A,@DPTR
   \   000062   F8           MOV       R0,A
   \   000063   A3           INC       DPTR
   \   000064   E0           MOVX      A,@DPTR
   \   000065   F9           MOV       R1,A
   \   000066   88..         MOV       ?V2,R0
   \   000068   89..         MOV       ?V3,R1
    601              pLoopPrev = externalEndPointHandlerList;
   \   00006A   90....       MOV       DPTR,#externalEndPointHandlerList
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   F8           MOV       R0,A
   \   00006F   A3           INC       DPTR
   \   000070   E0           MOVX      A,@DPTR
   \   000071   F9           MOV       R1,A
   \   000072   88..         MOV       ?V0,R0
   \   000074   89..         MOV       ?V1,R1
    602          
    603              while ( pLoop != NULL )
   \                     ??zcl_addExternalFoundationHandler_4:
   \   000076   E5..         MOV       A,?V2
   \   000078   45..         ORL       A,?V3
   \   00007A   6030         JZ        ??zcl_addExternalFoundationHandler_5
    604              {
    605                if ( ( pLoop->zcl_ExternalEndPoint ) == endPointId )
   \   00007C   85..82       MOV       DPL,?V2
   \   00007F   85..83       MOV       DPH,?V3
   \   000082   A3           INC       DPTR
   \   000083   A3           INC       DPTR
   \   000084   A3           INC       DPTR
   \   000085   E0           MOVX      A,@DPTR
   \   000086   65..         XRL       A,?V5
   \   000088   700B         JNZ       ??zcl_addExternalFoundationHandler_6
    606                {
    607                  zcl_mem_free(pNewItem);
   \   00008A                ; Setup parameters for call to function osal_mem_free
   \   00008A   EE           MOV       A,R6
   \   00008B   FA           MOV       R2,A
   \   00008C   EF           MOV       A,R7
   \   00008D   FB           MOV       R3,A
   \   00008E   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    608                  return ( false );
   \   000091   7900         MOV       R1,#0x0
   \   000093   8050         SJMP      ??zcl_addExternalFoundationHandler_1
    609                }
    610                pLoopPrev = pLoop;
   \                     ??zcl_addExternalFoundationHandler_6:
   \   000095   A8..         MOV       R0,?V2
   \   000097   A9..         MOV       R1,?V3
   \   000099   88..         MOV       ?V0,R0
   \   00009B   89..         MOV       ?V1,R1
    611                pLoop = pLoop->next;
   \   00009D   85..82       MOV       DPL,?V2
   \   0000A0   85..83       MOV       DPH,?V3
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   F5..         MOV       ?V2,A
   \   0000A6   A3           INC       DPTR
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   F5..         MOV       ?V3,A
   \   0000AA   80CA         SJMP      ??zcl_addExternalFoundationHandler_4
    612              }
    613          
    614              if ( endPointId == AF_BROADCAST_ENDPOINT )
   \                     ??zcl_addExternalFoundationHandler_5:
   \   0000AC   74FF         MOV       A,#-0x1
   \   0000AE   65..         XRL       A,?V5
   \   0000B0   7018         JNZ       ??zcl_addExternalFoundationHandler_7
    615              {
    616                // put new registration at the end of the list
    617                pLoopPrev->next = pNewItem;
   \   0000B2   85..82       MOV       DPL,?V0
   \   0000B5   85..83       MOV       DPH,?V1
   \   0000B8   EE           MOV       A,R6
   \   0000B9   F0           MOVX      @DPTR,A
   \   0000BA   A3           INC       DPTR
   \   0000BB   EF           MOV       A,R7
   \   0000BC   F0           MOVX      @DPTR,A
    618                pNewItem->next = NULL;
   \   0000BD   8E82         MOV       DPL,R6
   \   0000BF   8F83         MOV       DPH,R7
   \   0000C1   7400         MOV       A,#0x0
   \   0000C3   F0           MOVX      @DPTR,A
   \   0000C4   A3           INC       DPTR
   \   0000C5   7400         MOV       A,#0x0
   \   0000C7   F0           MOVX      @DPTR,A
   \   0000C8   8019         SJMP      ??zcl_addExternalFoundationHandler_3
    619              }
    620              else
    621              {
    622                // put new registration at the front of the list
    623                zclExternalFoundationHandlerList *temp = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_7:
   \   0000CA   90....       MOV       DPTR,#externalEndPointHandlerList
   \   0000CD   E0           MOVX      A,@DPTR
   \   0000CE   F8           MOV       R0,A
   \   0000CF   A3           INC       DPTR
   \   0000D0   E0           MOVX      A,@DPTR
   \   0000D1   F9           MOV       R1,A
    624                externalEndPointHandlerList = pNewItem;
   \   0000D2   90....       MOV       DPTR,#externalEndPointHandlerList
   \   0000D5   EE           MOV       A,R6
   \   0000D6   F0           MOVX      @DPTR,A
   \   0000D7   A3           INC       DPTR
   \   0000D8   EF           MOV       A,R7
   \   0000D9   F0           MOVX      @DPTR,A
    625                pNewItem->next = temp;
   \   0000DA   8E82         MOV       DPL,R6
   \   0000DC   8F83         MOV       DPH,R7
   \   0000DE   E8           MOV       A,R0
   \   0000DF   F0           MOVX      @DPTR,A
   \   0000E0   A3           INC       DPTR
   \   0000E1   E9           MOV       A,R1
   \   0000E2   F0           MOVX      @DPTR,A
    626              }
    627            }
    628          
    629            return ( true );
   \                     ??zcl_addExternalFoundationHandler_3:
   \   0000E3   7901         MOV       R1,#0x1
   \                     ??zcl_addExternalFoundationHandler_1:
   \   0000E5   7F08         MOV       R7,#0x8
   \   0000E7   02....       LJMP      ?BANKED_LEAVE_XDATA
    630          
    631          }
    632          
    633          /*********************************************************************
    634           * @fn      zcl_getExternalFoundationHandler
    635           *
    636           * @brief   This function retrieves the Task ID of the task registered
    637           *          to received unhandled incoming Foundation Command/Response messages
    638           *          for a particular End Point ID.
    639           *
    640           * @param   pInMsg - recevied ZCL command
    641           *
    642           * @return  TASK ID of registered task.  If no task is reigistered, it returns
    643           *          TASK_NO_TASK.
    644           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    645          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg )
   \                     zcl_getExternalFoundationHandler:
    646          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    647            zclExternalFoundationHandlerList *pLoop;
    648            uint8 addressedEndPointId = pInMsg->endPoint;
   \   000005   EA           MOV       A,R2
   \   000006   2414         ADD       A,#0x14
   \   000008   F582         MOV       DPL,A
   \   00000A   E4           CLR       A
   \   00000B   3B           ADDC      A,R3
   \   00000C   F583         MOV       DPH,A
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   FE           MOV       R6,A
    649          
    650            // make sure no one else tried to register for this endpoint
    651            pLoop = externalEndPointHandlerList;
   \   000010   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F8           MOV       R0,A
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F9           MOV       R1,A
   \   000018   E8           MOV       A,R0
   \   000019   FC           MOV       R4,A
   \   00001A   E9           MOV       A,R1
   \   00001B   FD           MOV       R5,A
    652          
    653            while ( pLoop != NULL )
   \                     ??zcl_getExternalFoundationHandler_0:
   \   00001C   EC           MOV       A,R4
   \   00001D   4D           ORL       A,R5
   \   00001E   6030         JZ        ??zcl_getExternalFoundationHandler_1
    654            {
    655              if ( ( ( pLoop->zcl_ExternalEndPoint ) == addressedEndPointId ) ||
    656                   ( ( pLoop->zcl_ExternalEndPoint ) == AF_BROADCAST_ENDPOINT ) )
   \   000020   8C82         MOV       DPL,R4
   \   000022   8D83         MOV       DPH,R5
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6E           XRL       A,R6
   \   000029   600C         JZ        ??zcl_getExternalFoundationHandler_2
   \   00002B   8C82         MOV       DPL,R4
   \   00002D   8D83         MOV       DPH,R5
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   64FF         XRL       A,#0xff
   \   000035   700A         JNZ       ??zcl_getExternalFoundationHandler_3
    657              {
    658                return ( pLoop->zcl_ExternalTaskID );
   \                     ??zcl_getExternalFoundationHandler_2:
   \   000037   8C82         MOV       DPL,R4
   \   000039   8D83         MOV       DPH,R5
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   F9           MOV       R1,A
   \   00003F   8011         SJMP      ??zcl_getExternalFoundationHandler_4
    659              }
    660              pLoop = pLoop->next;
   \                     ??zcl_getExternalFoundationHandler_3:
   \   000041   8C82         MOV       DPL,R4
   \   000043   8D83         MOV       DPH,R5
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F8           MOV       R0,A
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   F9           MOV       R1,A
   \   00004A   E8           MOV       A,R0
   \   00004B   FC           MOV       R4,A
   \   00004C   E9           MOV       A,R1
   \   00004D   FD           MOV       R5,A
   \   00004E   80CC         SJMP      ??zcl_getExternalFoundationHandler_0
    661            }
    662          
    663            return ( TASK_NO_TASK );
   \                     ??zcl_getExternalFoundationHandler_1:
   \   000050   79FF         MOV       R1,#-0x1
   \                     ??zcl_getExternalFoundationHandler_4:
   \   000052   7F01         MOV       R7,#0x1
   \   000054   02....       LJMP      ?BANKED_LEAVE_XDATA
    664          }
    665          #endif
    666          
    667          #if !defined ( ZCL_STANDALONE )
    668          /*********************************************************************
    669           * @fn      zcl_HandleExternal
    670           *
    671           * @brief
    672           *
    673           * @param   pInMsg - incoming message to process
    674           *
    675           * @return  TRUE
    676           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    677          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    678          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
    679            zclIncomingMsg_t *pCmd;
    680            uint8 taskID;
    681          
    682            taskID = zcl_getExternalFoundationHandler( pInMsg->msg );
   \   000009                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000009   85..82       MOV       DPL,?V0
   \   00000C   85..83       MOV       DPH,?V1
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   FA           MOV       R2,A
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FB           MOV       R3,A
   \   000014   12....       LCALL     `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000017   E9           MOV       A,R1
   \   000018   F5..         MOV       ?V2,A
    683          
    684            if ( taskID == TASK_NO_TASK )
   \   00001A   74FF         MOV       A,#-0x1
   \   00001C   65..         XRL       A,?V2
   \   00001E   7005         JNZ       ??zcl_HandleExternal_0
    685            {
    686              return ( TRUE );
   \   000020   7901         MOV       R1,#0x1
   \   000022   02....       LJMP      ??zcl_HandleExternal_1 & 0xFFFF
    687            }
    688          
    689            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \                     ??zcl_HandleExternal_0:
   \   000025                ; Setup parameters for call to function osal_msg_allocate
   \   000025   7A19         MOV       R2,#0x19
   \   000027   7B00         MOV       R3,#0x0
   \   000029   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   00002C   8A..         MOV       ?V4,R2
   \   00002E   8B..         MOV       ?V5,R3
   \   000030   AE..         MOV       R6,?V4
   \   000032   AF..         MOV       R7,?V5
    690            if ( pCmd != NULL )
   \   000034   EE           MOV       A,R6
   \   000035   4F           ORL       A,R7
   \   000036   7003         JNZ       $+5
   \   000038   02....       LJMP      ??zcl_HandleExternal_2 & 0xFFFF
    691            {
    692              // fill in the message
    693              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   00003B   8E82         MOV       DPL,R6
   \   00003D   8F83         MOV       DPH,R7
   \   00003F   7434         MOV       A,#0x34
   \   000041   F0           MOVX      @DPTR,A
    694              pCmd->zclHdr    = pInMsg->hdr;
   \   000042   85..82       MOV       DPL,?V0
   \   000045   85..83       MOV       DPH,?V1
   \   000048   A3           INC       DPTR
   \   000049   A3           INC       DPTR
   \   00004A   EE           MOV       A,R6
   \   00004B   2402         ADD       A,#0x2
   \   00004D   FC           MOV       R4,A
   \   00004E   E4           CLR       A
   \   00004F   3F           ADDC      A,R7
   \   000050   FD           MOV       R5,A
   \   000051   7406         MOV       A,#0x6
   \   000053   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
    695              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000056   85..82       MOV       DPL,?V0
   \   000059   85..83       MOV       DPH,?V1
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F8           MOV       R0,A
   \   00005E   A3           INC       DPTR
   \   00005F   E0           MOVX      A,@DPTR
   \   000060   F583         MOV       DPH,A
   \   000062   8882         MOV       DPL,R0
   \   000064   A3           INC       DPTR
   \   000065   A3           INC       DPTR
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   E0           MOVX      A,@DPTR
   \   000069   F8           MOV       R0,A
   \   00006A   A3           INC       DPTR
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   F9           MOV       R1,A
   \   00006D   8E82         MOV       DPL,R6
   \   00006F   8F83         MOV       DPH,R7
   \   000071   A3           INC       DPTR
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   A3           INC       DPTR
   \   000078   A3           INC       DPTR
   \   000079   E8           MOV       A,R0
   \   00007A   F0           MOVX      @DPTR,A
   \   00007B   A3           INC       DPTR
   \   00007C   E9           MOV       A,R1
   \   00007D   F0           MOVX      @DPTR,A
    696              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \   00007E   85..82       MOV       DPL,?V0
   \   000081   85..83       MOV       DPH,?V1
   \   000084   E0           MOVX      A,@DPTR
   \   000085   F8           MOV       R0,A
   \   000086   A3           INC       DPTR
   \   000087   E0           MOVX      A,@DPTR
   \   000088   C8           XCH       A,R0
   \   000089   2406         ADD       A,#0x6
   \   00008B   F582         MOV       DPL,A
   \   00008D   C8           XCH       A,R0
   \   00008E   3400         ADDC      A,#0x0
   \   000090   F583         MOV       DPH,A
   \   000092   EE           MOV       A,R6
   \   000093   240A         ADD       A,#0xa
   \   000095   FC           MOV       R4,A
   \   000096   E4           CLR       A
   \   000097   3F           ADDC      A,R7
   \   000098   FD           MOV       R5,A
   \   000099   740C         MOV       A,#0xc
   \   00009B   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
    697              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   00009E   85..82       MOV       DPL,?V0
   \   0000A1   85..83       MOV       DPH,?V1
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   F8           MOV       R0,A
   \   0000A6   A3           INC       DPTR
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   C8           XCH       A,R0
   \   0000A9   2414         ADD       A,#0x14
   \   0000AB   F582         MOV       DPL,A
   \   0000AD   C8           XCH       A,R0
   \   0000AE   3400         ADDC      A,#0x0
   \   0000B0   F583         MOV       DPH,A
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   C0E0         PUSH      A
   \   0000B5   EE           MOV       A,R6
   \   0000B6   2416         ADD       A,#0x16
   \   0000B8   F582         MOV       DPL,A
   \   0000BA   E4           CLR       A
   \   0000BB   3F           ADDC      A,R7
   \   0000BC   F583         MOV       DPH,A
   \   0000BE   D0E0         POP       A
   \   0000C0   F0           MOVX      @DPTR,A
    698              pCmd->attrCmd   = pInMsg->attrCmd;
   \   0000C1   E5..         MOV       A,?V0
   \   0000C3   240C         ADD       A,#0xc
   \   0000C5   F582         MOV       DPL,A
   \   0000C7   E4           CLR       A
   \   0000C8   35..         ADDC      A,?V1
   \   0000CA   F583         MOV       DPH,A
   \   0000CC   E0           MOVX      A,@DPTR
   \   0000CD   F8           MOV       R0,A
   \   0000CE   A3           INC       DPTR
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   F9           MOV       R1,A
   \   0000D1   EE           MOV       A,R6
   \   0000D2   2417         ADD       A,#0x17
   \   0000D4   F582         MOV       DPL,A
   \   0000D6   E4           CLR       A
   \   0000D7   3F           ADDC      A,R7
   \   0000D8   F583         MOV       DPH,A
   \   0000DA   E8           MOV       A,R0
   \   0000DB   F0           MOVX      @DPTR,A
   \   0000DC   A3           INC       DPTR
   \   0000DD   E9           MOV       A,R1
   \   0000DE   F0           MOVX      @DPTR,A
    699              
    700          #ifdef BDB_REPORTING
    701              if(pCmd->zclHdr.commandID == ZCL_CMD_CONFIG_REPORT)
    702              {
    703                bdb_ProcessInConfigReportCmd(pCmd);
    704                osal_msg_deallocate((uint8*)pCmd);
    705                return TRUE;          
    706              }
    707              if(pCmd->zclHdr.commandID == ZCL_CMD_READ_REPORT_CFG)
    708              {
    709                bdb_ProcessInReadReportCfgCmd(pCmd);
    710                osal_msg_deallocate((uint8*)pCmd);
    711                return TRUE;
    712              }
    713          #endif
    714              // Application will free the attrCmd buffer
    715              pInMsg->attrCmd = NULL;
   \   0000DF   E5..         MOV       A,?V0
   \   0000E1   240C         ADD       A,#0xc
   \   0000E3   F582         MOV       DPL,A
   \   0000E5   E4           CLR       A
   \   0000E6   35..         ADDC      A,?V1
   \   0000E8   F583         MOV       DPH,A
   \   0000EA   7400         MOV       A,#0x0
   \   0000EC   F0           MOVX      @DPTR,A
   \   0000ED   A3           INC       DPTR
   \   0000EE   7400         MOV       A,#0x0
   \   0000F0   F0           MOVX      @DPTR,A
    716          
    717              /* send message through task message */
    718              osal_msg_send( taskID, (uint8 *)pCmd );
   \   0000F1                ; Setup parameters for call to function osal_msg_send
   \   0000F1   EE           MOV       A,R6
   \   0000F2   FA           MOV       R2,A
   \   0000F3   EF           MOV       A,R7
   \   0000F4   FB           MOV       R3,A
   \   0000F5   A9..         MOV       R1,?V2
   \   0000F7   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   0000FA   E9           MOV       A,R1
    719            }
    720          
    721            return ( TRUE );
   \                     ??zcl_HandleExternal_2:
   \   0000FB   7901         MOV       R1,#0x1
   \                     ??zcl_HandleExternal_1:
   \   0000FD   7F06         MOV       R7,#0x6
   \   0000FF   02....       LJMP      ?BANKED_LEAVE_XDATA
    722          }
    723          #endif
    724          
    725          
    726          /*********************************************************************
    727           * @fn          zcl_getRawAFMsg
    728           *
    729           * @brief       Call to get original unprocessed AF message
    730           *              (not parsed by ZCL).
    731           *
    732           *   NOTE:  This function can only be called during a ZCL callback function
    733           *          and the calling function must NOT change any data in the message.
    734           *
    735           * @param       none
    736           *
    737           * @return      pointer to original AF message, NULL if not processing
    738           *              AF message.
    739           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    740          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    741          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    742            return ( rawAFMsg );
   \   000004   90....       MOV       DPTR,#rawAFMsg
   \   000007   E0           MOVX      A,@DPTR
   \   000008   FA           MOV       R2,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   FB           MOV       R3,A
   \   00000C   D083         POP       DPH
   \   00000E   D082         POP       DPL
   \   000010   02....       LJMP      ?BRET
    743          }
    744          
    745          /*********************************************************************
    746           * @fn          zcl_getParsedTransSeqNum
    747           *
    748           * @brief       Call to the get the transaction sequence number from
    749           *              the incoming message.
    750           *
    751           *   NOTE:  This function can only be called during a ZCL callback function
    752           *          and the calling function must NOT change any data in the message.
    753           *
    754           * @param       none
    755           *
    756           * @return      transaction sequence number.
    757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    758          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    759          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    760            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV       DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009   D083         POP       DPH
   \   00000B   D082         POP       DPL
   \   00000D   02....       LJMP      ?BRET
    761          }
    762          
    763          /*********************************************************************
    764           * @fn          zcl_registerPlugin
    765           *
    766           * @brief       Add a Cluster Library handler
    767           *
    768           * @param       startClusterID - starting cluster ID
    769           * @param       endClusterID - ending cluster ID
    770           * @param       pfnHdlr - function pointer to incoming message handler
    771           *
    772           * @return      ZSuccess if OK
    773           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    774          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    775                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    776          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   8C..         MOV       ?V6,R4
   \   00000B   8D..         MOV       ?V7,R5
   \   00000D   7412         MOV       A,#0x12
   \   00000F   12....       LCALL     ?XSTACK_DISP0_8
   \   000012   E0           MOVX      A,@DPTR
   \   000013   F5..         MOV       ?V2,A
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F5..         MOV       ?V3,A
    777            zclLibPlugin_t *pNewItem;
    778            zclLibPlugin_t *pLoop;
    779          
    780            // Fill in the new profile list
    781            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   7A08         MOV       R2,#0x8
   \   00001B   7B00         MOV       R3,#0x0
   \   00001D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000020   8A..         MOV       ?V8,R2
   \   000022   8B..         MOV       ?V9,R3
   \   000024   AE..         MOV       R6,?V8
   \   000026   AF..         MOV       R7,?V9
    782            if ( pNewItem == NULL )
   \   000028   EE           MOV       A,R6
   \   000029   4F           ORL       A,R7
   \   00002A   7005         JNZ       ??zcl_registerPlugin_0
    783            {
    784              return (ZMemError);
   \   00002C   7910         MOV       R1,#0x10
   \   00002E   02....       LJMP      ??zcl_registerPlugin_1 & 0xFFFF
    785            }
    786          
    787            // Fill in the plugin record.
    788            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000031   8E82         MOV       DPL,R6
   \   000033   8F83         MOV       DPH,R7
   \   000035   7400         MOV       A,#0x0
   \   000037   F0           MOVX      @DPTR,A
   \   000038   A3           INC       DPTR
   \   000039   7400         MOV       A,#0x0
   \   00003B   F0           MOVX      @DPTR,A
    789            pNewItem->startClusterID = startClusterID;
   \   00003C   8E82         MOV       DPL,R6
   \   00003E   8F83         MOV       DPH,R7
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   E5..         MOV       A,?V0
   \   000044   F0           MOVX      @DPTR,A
   \   000045   A3           INC       DPTR
   \   000046   E5..         MOV       A,?V1
   \   000048   F0           MOVX      @DPTR,A
    790            pNewItem->endClusterID = endClusterID;
   \   000049   8E82         MOV       DPL,R6
   \   00004B   8F83         MOV       DPH,R7
   \   00004D   A3           INC       DPTR
   \   00004E   A3           INC       DPTR
   \   00004F   A3           INC       DPTR
   \   000050   A3           INC       DPTR
   \   000051   E5..         MOV       A,?V6
   \   000053   F0           MOVX      @DPTR,A
   \   000054   A3           INC       DPTR
   \   000055   E5..         MOV       A,?V7
   \   000057   F0           MOVX      @DPTR,A
    791            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   000058   8E82         MOV       DPL,R6
   \   00005A   8F83         MOV       DPH,R7
   \   00005C   A3           INC       DPTR
   \   00005D   A3           INC       DPTR
   \   00005E   A3           INC       DPTR
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   A3           INC       DPTR
   \   000062   E5..         MOV       A,?V2
   \   000064   F0           MOVX      @DPTR,A
   \   000065   A3           INC       DPTR
   \   000066   E5..         MOV       A,?V3
   \   000068   F0           MOVX      @DPTR,A
    792          
    793            // Find spot in list
    794            if (  plugins == NULL )
   \   000069   90....       MOV       DPTR,#plugins
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   F8           MOV       R0,A
   \   00006E   A3           INC       DPTR
   \   00006F   E0           MOVX      A,@DPTR
   \   000070   F9           MOV       R1,A
   \   000071   E8           MOV       A,R0
   \   000072   49           ORL       A,R1
   \   000073   700A         JNZ       ??zcl_registerPlugin_2
    795            {
    796              plugins = pNewItem;
   \   000075   90....       MOV       DPTR,#plugins
   \   000078   EE           MOV       A,R6
   \   000079   F0           MOVX      @DPTR,A
   \   00007A   A3           INC       DPTR
   \   00007B   EF           MOV       A,R7
   \   00007C   F0           MOVX      @DPTR,A
   \   00007D   8035         SJMP      ??zcl_registerPlugin_3
    797            }
    798            else
    799            {
    800              // Look for end of list
    801              pLoop = plugins;
   \                     ??zcl_registerPlugin_2:
   \   00007F   90....       MOV       DPTR,#plugins
   \   000082   E0           MOVX      A,@DPTR
   \   000083   F8           MOV       R0,A
   \   000084   A3           INC       DPTR
   \   000085   E0           MOVX      A,@DPTR
   \   000086   F9           MOV       R1,A
   \   000087   88..         MOV       ?V4,R0
   \   000089   89..         MOV       ?V5,R1
    802              while ( pLoop->next != NULL )
   \                     ??zcl_registerPlugin_4:
   \   00008B   85..82       MOV       DPL,?V4
   \   00008E   85..83       MOV       DPH,?V5
   \   000091   E0           MOVX      A,@DPTR
   \   000092   F8           MOV       R0,A
   \   000093   A3           INC       DPTR
   \   000094   E0           MOVX      A,@DPTR
   \   000095   F9           MOV       R1,A
   \   000096   E8           MOV       A,R0
   \   000097   49           ORL       A,R1
   \   000098   600F         JZ        ??zcl_registerPlugin_5
    803              {
    804                pLoop = pLoop->next;
   \   00009A   85..82       MOV       DPL,?V4
   \   00009D   85..83       MOV       DPH,?V5
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   F5..         MOV       ?V4,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   F5..         MOV       ?V5,A
   \   0000A7   80E2         SJMP      ??zcl_registerPlugin_4
    805              }
    806          
    807              // Put new item at end of list
    808              pLoop->next = pNewItem;
   \                     ??zcl_registerPlugin_5:
   \   0000A9   85..82       MOV       DPL,?V4
   \   0000AC   85..83       MOV       DPH,?V5
   \   0000AF   EE           MOV       A,R6
   \   0000B0   F0           MOVX      @DPTR,A
   \   0000B1   A3           INC       DPTR
   \   0000B2   EF           MOV       A,R7
   \   0000B3   F0           MOVX      @DPTR,A
    809            }
    810          
    811            return ( ZSuccess );
   \                     ??zcl_registerPlugin_3:
   \   0000B4   7900         MOV       R1,#0x0
   \                     ??zcl_registerPlugin_1:
   \   0000B6   7F0A         MOV       R7,#0xa
   \   0000B8   02....       LJMP      ?BANKED_LEAVE_XDATA
    812          }
    813          
    814          #ifdef ZCL_DISCOVER
    815          /*********************************************************************
    816           * @fn          zcl_registerCmdList
    817           *
    818           * @brief       Register a Command List with ZCL Foundation
    819           *
    820           * @param       endpoint - endpoint the attribute list belongs to
    821           * @param       newCmdList - array of command records
    822           *
    823           * @return      ZSuccess if OK
    824           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    825          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
   \                     zcl_registerCmdList:
    826          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V5,R2
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
    827            zclCmdRecsList_t *pNewItem;
    828            zclCmdRecsList_t *pLoop;
    829          
    830            // Fill in the new profile list
    831            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV       R2,#0x6
   \   00000F   7B00         MOV       R3,#0x0
   \   000011   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV       ?V6,R2
   \   000016   8B..         MOV       ?V7,R3
   \   000018   AE..         MOV       R6,?V6
   \   00001A   AF..         MOV       R7,?V7
    832            if ( pNewItem == NULL )
   \   00001C   EE           MOV       A,R6
   \   00001D   4F           ORL       A,R7
   \   00001E   7005         JNZ       ??zcl_registerCmdList_0
    833            {
    834              return (ZMemError);
   \   000020   7910         MOV       R1,#0x10
   \   000022   02....       LJMP      ??zcl_registerCmdList_1 & 0xFFFF
    835            }
    836          
    837            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
   \                     ??zcl_registerCmdList_0:
   \   000025   8E82         MOV       DPL,R6
   \   000027   8F83         MOV       DPH,R7
   \   000029   7400         MOV       A,#0x0
   \   00002B   F0           MOVX      @DPTR,A
   \   00002C   A3           INC       DPTR
   \   00002D   7400         MOV       A,#0x0
   \   00002F   F0           MOVX      @DPTR,A
    838            pNewItem->endpoint = endpoint;
   \   000030   E5..         MOV       A,?V4
   \   000032   C0E0         PUSH      A
   \   000034   8E82         MOV       DPL,R6
   \   000036   8F83         MOV       DPH,R7
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   D0E0         POP       A
   \   00003C   F0           MOVX      @DPTR,A
    839            pNewItem->numCommands = cmdListSize;
   \   00003D   E5..         MOV       A,?V5
   \   00003F   C0E0         PUSH      A
   \   000041   8E82         MOV       DPL,R6
   \   000043   8F83         MOV       DPH,R7
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   D0E0         POP       A
   \   00004A   F0           MOVX      @DPTR,A
    840            pNewItem->pCmdRecs = newCmdList;
   \   00004B   8E82         MOV       DPL,R6
   \   00004D   8F83         MOV       DPH,R7
   \   00004F   A3           INC       DPTR
   \   000050   A3           INC       DPTR
   \   000051   A3           INC       DPTR
   \   000052   A3           INC       DPTR
   \   000053   E5..         MOV       A,?V0
   \   000055   F0           MOVX      @DPTR,A
   \   000056   A3           INC       DPTR
   \   000057   E5..         MOV       A,?V1
   \   000059   F0           MOVX      @DPTR,A
    841          
    842            // Find spot in list
    843            if ( gpCmdList == NULL )
   \   00005A   90....       MOV       DPTR,#gpCmdList
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   F8           MOV       R0,A
   \   00005F   A3           INC       DPTR
   \   000060   E0           MOVX      A,@DPTR
   \   000061   F9           MOV       R1,A
   \   000062   E8           MOV       A,R0
   \   000063   49           ORL       A,R1
   \   000064   700A         JNZ       ??zcl_registerCmdList_2
    844            {
    845              gpCmdList = pNewItem;
   \   000066   90....       MOV       DPTR,#gpCmdList
   \   000069   EE           MOV       A,R6
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   A3           INC       DPTR
   \   00006C   EF           MOV       A,R7
   \   00006D   F0           MOVX      @DPTR,A
   \   00006E   8039         SJMP      ??zcl_registerCmdList_3
    846            }
    847            else
    848            {
    849              // Look for end of list
    850              pLoop = gpCmdList;
   \                     ??zcl_registerCmdList_2:
   \   000070   90....       MOV       DPTR,#gpCmdList
   \   000073   E0           MOVX      A,@DPTR
   \   000074   F8           MOV       R0,A
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   F9           MOV       R1,A
   \   000078   88..         MOV       ?V2,R0
   \   00007A   89..         MOV       ?V3,R1
    851              while ( pLoop->pNext != NULL )
   \                     ??zcl_registerCmdList_4:
   \   00007C   85..82       MOV       DPL,?V2
   \   00007F   85..83       MOV       DPH,?V3
   \   000082   E0           MOVX      A,@DPTR
   \   000083   F8           MOV       R0,A
   \   000084   A3           INC       DPTR
   \   000085   E0           MOVX      A,@DPTR
   \   000086   F9           MOV       R1,A
   \   000087   E8           MOV       A,R0
   \   000088   49           ORL       A,R1
   \   000089   600F         JZ        ??zcl_registerCmdList_5
    852              {
    853                pLoop = pLoop->pNext;
   \   00008B   85..82       MOV       DPL,?V2
   \   00008E   85..83       MOV       DPH,?V3
   \   000091   E0           MOVX      A,@DPTR
   \   000092   F5..         MOV       ?V2,A
   \   000094   A3           INC       DPTR
   \   000095   E0           MOVX      A,@DPTR
   \   000096   F5..         MOV       ?V3,A
   \   000098   80E2         SJMP      ??zcl_registerCmdList_4
    854              }
    855          
    856              // Put new item at end of list
    857              pLoop->pNext = pNewItem;
   \                     ??zcl_registerCmdList_5:
   \   00009A   EE           MOV       A,R6
   \   00009B   F8           MOV       R0,A
   \   00009C   EF           MOV       A,R7
   \   00009D   F9           MOV       R1,A
   \   00009E   85..82       MOV       DPL,?V2
   \   0000A1   85..83       MOV       DPH,?V3
   \   0000A4   E8           MOV       A,R0
   \   0000A5   F0           MOVX      @DPTR,A
   \   0000A6   A3           INC       DPTR
   \   0000A7   E9           MOV       A,R1
   \   0000A8   F0           MOVX      @DPTR,A
    858            }
    859          
    860            return ( ZSuccess );
   \                     ??zcl_registerCmdList_3:
   \   0000A9   7900         MOV       R1,#0x0
   \                     ??zcl_registerCmdList_1:
   \   0000AB   7F08         MOV       R7,#0x8
   \   0000AD   02....       LJMP      ?BANKED_LEAVE_XDATA
    861          }
    862          #endif  // ZCL_DISCOVER
    863          
    864          /*********************************************************************
    865           * @fn          zcl_registerAttrList
    866           *
    867           * @brief       Register an Attribute List with ZCL Foundation
    868           *
    869           * @param       endpoint - endpoint the attribute list belongs to
    870           * @param       numAttr - number of attributes in list
    871           * @param       newAttrList - array of Attribute records.
    872           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    873           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    874           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    875           *
    876           * @return      ZSuccess if OK
    877           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    878          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    879          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V5,R2
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
    880            zclAttrRecsList *pNewItem;
    881            zclAttrRecsList *pLoop;
    882          
    883            // Fill in the new profile list
    884            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV       R2,#0xa
   \   00000F   7B00         MOV       R3,#0x0
   \   000011   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV       ?V6,R2
   \   000016   8B..         MOV       ?V7,R3
   \   000018   AE..         MOV       R6,?V6
   \   00001A   AF..         MOV       R7,?V7
    885            if ( pNewItem == NULL )
   \   00001C   EE           MOV       A,R6
   \   00001D   4F           ORL       A,R7
   \   00001E   7005         JNZ       ??zcl_registerAttrList_0
    886            {
    887              return (ZMemError);
   \   000020   7910         MOV       R1,#0x10
   \   000022   02....       LJMP      ??zcl_registerAttrList_1 & 0xFFFF
    888            }
    889          
    890            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000025   8E82         MOV       DPL,R6
   \   000027   8F83         MOV       DPH,R7
   \   000029   7400         MOV       A,#0x0
   \   00002B   F0           MOVX      @DPTR,A
   \   00002C   A3           INC       DPTR
   \   00002D   7400         MOV       A,#0x0
   \   00002F   F0           MOVX      @DPTR,A
    891            pNewItem->endpoint = endpoint;
   \   000030   E5..         MOV       A,?V4
   \   000032   C0E0         PUSH      A
   \   000034   8E82         MOV       DPL,R6
   \   000036   8F83         MOV       DPH,R7
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   D0E0         POP       A
   \   00003C   F0           MOVX      @DPTR,A
    892            pNewItem->pfnReadWriteCB = NULL;
   \   00003D   8E82         MOV       DPL,R6
   \   00003F   8F83         MOV       DPH,R7
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   7400         MOV       A,#0x0
   \   000046   F0           MOVX      @DPTR,A
   \   000047   A3           INC       DPTR
   \   000048   7400         MOV       A,#0x0
   \   00004A   F0           MOVX      @DPTR,A
    893            pNewItem->numAttributes = numAttr;
   \   00004B   E5..         MOV       A,?V5
   \   00004D   C0E0         PUSH      A
   \   00004F   8E82         MOV       DPL,R6
   \   000051   8F83         MOV       DPH,R7
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   D0E0         POP       A
   \   00005C   F0           MOVX      @DPTR,A
    894            pNewItem->attrs = newAttrList;
   \   00005D   8E82         MOV       DPL,R6
   \   00005F   8F83         MOV       DPH,R7
   \   000061   A3           INC       DPTR
   \   000062   A3           INC       DPTR
   \   000063   A3           INC       DPTR
   \   000064   A3           INC       DPTR
   \   000065   A3           INC       DPTR
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   E5..         MOV       A,?V0
   \   00006B   F0           MOVX      @DPTR,A
   \   00006C   A3           INC       DPTR
   \   00006D   E5..         MOV       A,?V1
   \   00006F   F0           MOVX      @DPTR,A
    895          
    896            // Find spot in list
    897            if ( attrList == NULL )
   \   000070   90....       MOV       DPTR,#attrList
   \   000073   E0           MOVX      A,@DPTR
   \   000074   F8           MOV       R0,A
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   F9           MOV       R1,A
   \   000078   E8           MOV       A,R0
   \   000079   49           ORL       A,R1
   \   00007A   700A         JNZ       ??zcl_registerAttrList_2
    898            {
    899              attrList = pNewItem;
   \   00007C   90....       MOV       DPTR,#attrList
   \   00007F   EE           MOV       A,R6
   \   000080   F0           MOVX      @DPTR,A
   \   000081   A3           INC       DPTR
   \   000082   EF           MOV       A,R7
   \   000083   F0           MOVX      @DPTR,A
   \   000084   8039         SJMP      ??zcl_registerAttrList_3
    900            }
    901            else
    902            {
    903              // Look for end of list
    904              pLoop = attrList;
   \                     ??zcl_registerAttrList_2:
   \   000086   90....       MOV       DPTR,#attrList
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   F8           MOV       R0,A
   \   00008B   A3           INC       DPTR
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   F9           MOV       R1,A
   \   00008E   88..         MOV       ?V2,R0
   \   000090   89..         MOV       ?V3,R1
    905              while ( pLoop->next != NULL )
   \                     ??zcl_registerAttrList_4:
   \   000092   85..82       MOV       DPL,?V2
   \   000095   85..83       MOV       DPH,?V3
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F8           MOV       R0,A
   \   00009A   A3           INC       DPTR
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   F9           MOV       R1,A
   \   00009D   E8           MOV       A,R0
   \   00009E   49           ORL       A,R1
   \   00009F   600F         JZ        ??zcl_registerAttrList_5
    906              {
    907                pLoop = pLoop->next;
   \   0000A1   85..82       MOV       DPL,?V2
   \   0000A4   85..83       MOV       DPH,?V3
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   F5..         MOV       ?V2,A
   \   0000AA   A3           INC       DPTR
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   F5..         MOV       ?V3,A
   \   0000AE   80E2         SJMP      ??zcl_registerAttrList_4
    908              }
    909          
    910              // Put new item at end of list
    911              pLoop->next = pNewItem;
   \                     ??zcl_registerAttrList_5:
   \   0000B0   EE           MOV       A,R6
   \   0000B1   F8           MOV       R0,A
   \   0000B2   EF           MOV       A,R7
   \   0000B3   F9           MOV       R1,A
   \   0000B4   85..82       MOV       DPL,?V2
   \   0000B7   85..83       MOV       DPH,?V3
   \   0000BA   E8           MOV       A,R0
   \   0000BB   F0           MOVX      @DPTR,A
   \   0000BC   A3           INC       DPTR
   \   0000BD   E9           MOV       A,R1
   \   0000BE   F0           MOVX      @DPTR,A
    912            }
    913          
    914            return ( ZSuccess );
   \                     ??zcl_registerAttrList_3:
   \   0000BF   7900         MOV       R1,#0x0
   \                     ??zcl_registerAttrList_1:
   \   0000C1   7F08         MOV       R7,#0x8
   \   0000C3   02....       LJMP      ?BANKED_LEAVE_XDATA
    915          }
    916          
    917          /*********************************************************************
    918           * @fn          zcl_registerClusterOptionList
    919           *
    920           * @brief       Register a Cluster Option List with ZCL Foundation
    921           *
    922           * @param       endpoint - endpoint the option list belongs to
    923           * @param       numOption - number of options in list
    924           * @param       optionList - array of cluster option records.
    925           *
    926           *              NOTE: This API should be called to enable 'Application
    927           *                    Link Key' security and/or 'APS ACK' for a specific
    928           *                    Cluster. The 'Application Link Key' is discarded
    929           *                    if security isn't enabled on the device.
    930           *                    The default behavior is 'Network Key' when security
    931           *                    is enabled and no 'APS ACK' for the ZCL messages.
    932           *
    933           * @return      ZSuccess if OK
    934           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    935          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    936          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V5,R2
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
    937            zclClusterOptionList *pNewItem;
    938            zclClusterOptionList *pLoop;
    939          
    940            // Fill in the new profile list
    941            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV       R2,#0x6
   \   00000F   7B00         MOV       R3,#0x0
   \   000011   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV       ?V6,R2
   \   000016   8B..         MOV       ?V7,R3
   \   000018   AE..         MOV       R6,?V6
   \   00001A   AF..         MOV       R7,?V7
    942            if ( pNewItem == NULL )
   \   00001C   EE           MOV       A,R6
   \   00001D   4F           ORL       A,R7
   \   00001E   7005         JNZ       ??zcl_registerClusterOptionList_0
    943            {
    944              return (ZMemError);
   \   000020   7910         MOV       R1,#0x10
   \   000022   02....       LJMP      ??zcl_registerClusterOptionList_1 & 0xFFFF
    945            }
    946          
    947            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000025   8E82         MOV       DPL,R6
   \   000027   8F83         MOV       DPH,R7
   \   000029   7400         MOV       A,#0x0
   \   00002B   F0           MOVX      @DPTR,A
   \   00002C   A3           INC       DPTR
   \   00002D   7400         MOV       A,#0x0
   \   00002F   F0           MOVX      @DPTR,A
    948            pNewItem->endpoint = endpoint;
   \   000030   E5..         MOV       A,?V4
   \   000032   C0E0         PUSH      A
   \   000034   8E82         MOV       DPL,R6
   \   000036   8F83         MOV       DPH,R7
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   D0E0         POP       A
   \   00003C   F0           MOVX      @DPTR,A
    949            pNewItem->numOptions = numOption;
   \   00003D   E5..         MOV       A,?V5
   \   00003F   C0E0         PUSH      A
   \   000041   8E82         MOV       DPL,R6
   \   000043   8F83         MOV       DPH,R7
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   D0E0         POP       A
   \   00004A   F0           MOVX      @DPTR,A
    950            pNewItem->options = optionList;
   \   00004B   8E82         MOV       DPL,R6
   \   00004D   8F83         MOV       DPH,R7
   \   00004F   A3           INC       DPTR
   \   000050   A3           INC       DPTR
   \   000051   A3           INC       DPTR
   \   000052   A3           INC       DPTR
   \   000053   E5..         MOV       A,?V0
   \   000055   F0           MOVX      @DPTR,A
   \   000056   A3           INC       DPTR
   \   000057   E5..         MOV       A,?V1
   \   000059   F0           MOVX      @DPTR,A
    951          
    952            // Find spot in list
    953            if ( clusterOptionList == NULL )
   \   00005A   90....       MOV       DPTR,#clusterOptionList
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   F8           MOV       R0,A
   \   00005F   A3           INC       DPTR
   \   000060   E0           MOVX      A,@DPTR
   \   000061   F9           MOV       R1,A
   \   000062   E8           MOV       A,R0
   \   000063   49           ORL       A,R1
   \   000064   700A         JNZ       ??zcl_registerClusterOptionList_2
    954            {
    955              clusterOptionList = pNewItem;
   \   000066   90....       MOV       DPTR,#clusterOptionList
   \   000069   EE           MOV       A,R6
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   A3           INC       DPTR
   \   00006C   EF           MOV       A,R7
   \   00006D   F0           MOVX      @DPTR,A
   \   00006E   8039         SJMP      ??zcl_registerClusterOptionList_3
    956            }
    957            else
    958            {
    959              // Look for end of list
    960              pLoop = clusterOptionList;
   \                     ??zcl_registerClusterOptionList_2:
   \   000070   90....       MOV       DPTR,#clusterOptionList
   \   000073   E0           MOVX      A,@DPTR
   \   000074   F8           MOV       R0,A
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   F9           MOV       R1,A
   \   000078   88..         MOV       ?V2,R0
   \   00007A   89..         MOV       ?V3,R1
    961              while ( pLoop->next != NULL )
   \                     ??zcl_registerClusterOptionList_4:
   \   00007C   85..82       MOV       DPL,?V2
   \   00007F   85..83       MOV       DPH,?V3
   \   000082   E0           MOVX      A,@DPTR
   \   000083   F8           MOV       R0,A
   \   000084   A3           INC       DPTR
   \   000085   E0           MOVX      A,@DPTR
   \   000086   F9           MOV       R1,A
   \   000087   E8           MOV       A,R0
   \   000088   49           ORL       A,R1
   \   000089   600F         JZ        ??zcl_registerClusterOptionList_5
    962              {
    963                pLoop = pLoop->next;
   \   00008B   85..82       MOV       DPL,?V2
   \   00008E   85..83       MOV       DPH,?V3
   \   000091   E0           MOVX      A,@DPTR
   \   000092   F5..         MOV       ?V2,A
   \   000094   A3           INC       DPTR
   \   000095   E0           MOVX      A,@DPTR
   \   000096   F5..         MOV       ?V3,A
   \   000098   80E2         SJMP      ??zcl_registerClusterOptionList_4
    964              }
    965          
    966              // Put new item at end of list
    967              pLoop->next = pNewItem;
   \                     ??zcl_registerClusterOptionList_5:
   \   00009A   EE           MOV       A,R6
   \   00009B   F8           MOV       R0,A
   \   00009C   EF           MOV       A,R7
   \   00009D   F9           MOV       R1,A
   \   00009E   85..82       MOV       DPL,?V2
   \   0000A1   85..83       MOV       DPH,?V3
   \   0000A4   E8           MOV       A,R0
   \   0000A5   F0           MOVX      @DPTR,A
   \   0000A6   A3           INC       DPTR
   \   0000A7   E9           MOV       A,R1
   \   0000A8   F0           MOVX      @DPTR,A
    968            }
    969          
    970            return ( ZSuccess );
   \                     ??zcl_registerClusterOptionList_3:
   \   0000A9   7900         MOV       R1,#0x0
   \                     ??zcl_registerClusterOptionList_1:
   \   0000AB   7F08         MOV       R7,#0x8
   \   0000AD   02....       LJMP      ?BANKED_LEAVE_XDATA
    971          }
    972          
    973          /*********************************************************************
    974           * @fn          zcl_registerValidateAttrData
    975           *
    976           * @brief       Add a validation function for attribute data
    977           *
    978           * @param       pfnValidateAttrData - function pointer to validate routine
    979           *
    980           * @return      ZSuccess if OK
    981           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    982          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    983          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    984            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV       DPTR,#zcl_ValidateAttrDataCB
   \   000007   EA           MOV       A,R2
   \   000008   F0           MOVX      @DPTR,A
   \   000009   A3           INC       DPTR
   \   00000A   EB           MOV       A,R3
   \   00000B   F0           MOVX      @DPTR,A
    985          
    986            return ( ZSuccess );
   \   00000C   7900         MOV       R1,#0x0
   \   00000E   D083         POP       DPH
   \   000010   D082         POP       DPL
   \   000012   02....       LJMP      ?BRET
    987          }
    988          
    989          /*********************************************************************
    990           * @fn          zcl_registerReadWriteCB
    991           *
    992           * @brief       Register the application's callback function to read/write
    993           *              attribute data, and authorize read/write operation.
    994           *
    995           *              Note: The pfnReadWriteCB callback function is only required
    996           *                    when the attribute data format is unknown to ZCL. The
    997           *                    callback function gets called when the pointer 'dataPtr'
    998           *                    to the attribute value is NULL in the attribute database
    999           *                    registered with the ZCL.
   1000           *
   1001           *              Note: The pfnAuthorizeCB callback function is only required
   1002           *                    when the Read/Write operation on an attribute requires
   1003           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
   1004           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
   1005           *
   1006           * @param       endpoint - application's endpoint
   1007           * @param       pfnReadWriteCB - function pointer to read/write routine
   1008           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
   1009           *
   1010           * @return      ZSuccess if successful. ZFailure, otherwise.
   1011           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1012          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
   1013                                             zclAuthorizeCB_t pfnAuthorizeCB )
   1014          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   1015            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000F                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000F   A9..         MOV       R1,?V2
   \   000011   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000014   8A..         MOV       ?V4,R2
   \   000016   8B..         MOV       ?V5,R3
   \   000018   AA..         MOV       R2,?V4
   \   00001A   AB..         MOV       R3,?V5
   1016          
   1017            if ( pRec != NULL )
   \   00001C   EA           MOV       A,R2
   \   00001D   4B           ORL       A,R3
   \   00001E   6020         JZ        ??zcl_registerReadWriteCB_0
   1018            {
   1019              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   000020   8A82         MOV       DPL,R2
   \   000022   8B83         MOV       DPH,R3
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   E5..         MOV       A,?V0
   \   000029   F0           MOVX      @DPTR,A
   \   00002A   A3           INC       DPTR
   \   00002B   E5..         MOV       A,?V1
   \   00002D   F0           MOVX      @DPTR,A
   1020              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \   00002E   8A82         MOV       DPL,R2
   \   000030   8B83         MOV       DPH,R3
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   EE           MOV       A,R6
   \   000038   F0           MOVX      @DPTR,A
   \   000039   A3           INC       DPTR
   \   00003A   EF           MOV       A,R7
   \   00003B   F0           MOVX      @DPTR,A
   1021          
   1022              return ( ZSuccess );
   \   00003C   7900         MOV       R1,#0x0
   \   00003E   8002         SJMP      ??zcl_registerReadWriteCB_1
   1023            }
   1024          
   1025            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000040   7901         MOV       R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000042   7F06         MOV       R7,#0x6
   \   000044   02....       LJMP      ?BANKED_LEAVE_XDATA
   1026          }
   1027          
   1028          /*********************************************************************
   1029           * @fn      zcl_DeviceOperational
   1030           *
   1031           * @brief   Used to see whether or not the device can send or respond
   1032           *          to application level commands.
   1033           *
   1034           * @param   srcEP - source endpoint
   1035           * @param   clusterID - cluster ID
   1036           * @param   frameType - command type
   1037           * @param   cmd - command ID
   1038           *
   1039           * @return  TRUE if device is operational, FALSE otherwise
   1040           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1041          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
   1042                                              uint8 frameType, uint8 cmd, uint16 profileID )
   1043          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V2,R1
   \   00000C   EA           MOV       A,R2
   \   00000D   FE           MOV       R6,A
   \   00000E   EB           MOV       A,R3
   \   00000F   FF           MOV       R7,A
   \   000010   8C..         MOV       ?V0,R4
   \   000012   8D..         MOV       ?V1,R5
   1044            zclAttrRec_t attrRec;
   1045            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   7401         MOV       A,#0x1
   \   00001C   F0           MOVX      @DPTR,A
   1046          
   1047            (void)profileID;  // Intentionally unreferenced parameter
   1048          
   1049            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
   1050            // cannot send or respond to application level commands, other than commands
   1051            // to read or write attributes. Note that the Identify cluster cannot be
   1052            // disabled, and remains functional regardless of this setting.
   1053            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   00001D   E5..         MOV       A,?V0
   \   00001F   700B         JNZ       ??zcl_DeviceOperational_0
   \   000021   E5..         MOV       A,?V1
   \   000023   C3           CLR       C
   \   000024   9406         SUBB      A,#0x6
   \   000026   5004         JNC       ??zcl_DeviceOperational_0
   1054            {
   1055              return ( TRUE );
   \   000028   7901         MOV       R1,#0x1
   \   00002A   805F         SJMP      ??zcl_DeviceOperational_1
   1056            }
   1057          
   1058            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   00002C   7403         MOV       A,#0x3
   \   00002E   6E           XRL       A,R6
   \   00002F   7003         JNZ       ??zcl_DeviceOperational_2
   \   000031   7400         MOV       A,#0x0
   \   000033   6F           XRL       A,R7
   \                     ??zcl_DeviceOperational_2:
   \   000034   7004         JNZ       ??zcl_DeviceOperational_3
   1059            {
   1060              return ( TRUE );
   \   000036   7901         MOV       R1,#0x1
   \   000038   8051         SJMP      ??zcl_DeviceOperational_1
   1061            }
   1062          
   1063            // Is device enabled?
   1064            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
   1065                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \                     ??zcl_DeviceOperational_3:
   \   00003A                ; Setup parameters for call to function zclFindAttrRec
   \   00003A   7401         MOV       A,#0x1
   \   00003C   12....       LCALL     ?XSTACK_DISP100_8
   \   00003F   88..         MOV       ?V4,R0
   \   000041   89..         MOV       ?V5,R1
   \   000043   78..         MOV       R0,#?V4
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000048   7C12         MOV       R4,#0x12
   \   00004A   7D00         MOV       R5,#0x0
   \   00004C   7A00         MOV       R2,#0x0
   \   00004E   7B00         MOV       R3,#0x0
   \   000050   A9..         MOV       R1,?V2
   \   000052   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000055   7402         MOV       A,#0x2
   \   000057   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005A   E9           MOV       A,R1
   \   00005B   601D         JZ        ??zcl_DeviceOperational_4
   1066            {
   1067          #ifdef ZCL_READ
   1068              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   00005D                ; Setup parameters for call to function zclReadAttrData
   \   00005D   E4           CLR       A
   \   00005E   F5..         MOV       ?V4,A
   \   000060   F5..         MOV       ?V5,A
   \   000062   78..         MOV       R0,#?V4
   \   000064   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000067   7403         MOV       A,#0x3
   \   000069   12....       LCALL     ?XSTACK_DISP102_8
   \   00006C   7402         MOV       A,#0x2
   \   00006E   12....       LCALL     ?XSTACK_DISP101_8
   \   000071   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   000074   7402         MOV       A,#0x2
   \   000076   12....       LCALL     ?DEALLOC_XSTACK8
   \   000079   E9           MOV       A,R1
   1069          #endif
   1070            }
   1071          
   1072            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_4:
   \   00007A   85..82       MOV       DPL,?XSP + 0
   \   00007D   85..83       MOV       DPH,?XSP + 1
   \   000080   E0           MOVX      A,@DPTR
   \   000081   6401         XRL       A,#0x1
   \   000083   7004         JNZ       ??zcl_DeviceOperational_5
   \   000085   7901         MOV       R1,#0x1
   \   000087   8002         SJMP      ??zcl_DeviceOperational_1
   \                     ??zcl_DeviceOperational_5:
   \   000089   7900         MOV       R1,#0x0
   \                     ??zcl_DeviceOperational_1:
   \   00008B   7409         MOV       A,#0x9
   \   00008D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000090   7F06         MOV       R7,#0x6
   \   000092   02....       LJMP      ?BANKED_LEAVE_XDATA
   1073          }
   1074          
   1075          /*********************************************************************
   1076           * @fn      zcl_SendCommand
   1077           *
   1078           * @brief   Used to send Profile and Cluster Specific Command messages.
   1079           *
   1080           *          NOTE: The calling application is responsible for incrementing
   1081           *                the Sequence Number.
   1082           *
   1083           * @param   srcEp - source endpoint
   1084           * @param   destAddr - destination address
   1085           * @param   clusterID - cluster ID
   1086           * @param   cmd - command ID
   1087           * @param   specific - whether the command is Cluster Specific
   1088           * @param   direction - client/server direction of the command
   1089           * @param   disableDefaultRsp - disable Default Response command
   1090           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1091           * @param   seqNumber - identification number for the transaction
   1092           * @param   cmdFormatLen - length of the command to be sent
   1093           * @param   cmdFormat - command to be sent
   1094           *
   1095           * @return  ZSuccess if OK
   1096           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1097          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
   1098                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
   1099                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
   1100                                     uint16 cmdFormatLen, uint8 *cmdFormat )
   1101          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   7406         MOV       A,#0x6
   \   00000C   12....       LCALL     ?XSTACK_DISP0_8
   \   00000F   EA           MOV       A,R2
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   EB           MOV       A,R3
   \   000013   F0           MOVX      @DPTR,A
   \   000014   89..         MOV       ?V7,R1
   \   000016   EC           MOV       A,R4
   \   000017   FE           MOV       R6,A
   \   000018   ED           MOV       A,R5
   \   000019   FF           MOV       R7,A
   \   00001A   7422         MOV       A,#0x22
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   F5..         MOV       ?V8,A
   \   000022   7424         MOV       A,#0x24
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E0           MOVX      A,@DPTR
   \   000028   F5..         MOV       ?V15,A
   \   00002A   7425         MOV       A,#0x25
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   F5..         MOV       ?V14,A
   \   000032   7428         MOV       A,#0x28
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   E0           MOVX      A,@DPTR
   \   000038   F5..         MOV       ?V9,A
   1102            endPointDesc_t *epDesc;
   1103            zclFrameHdr_t hdr;
   1104            uint8 *msgBuf;
   1105            uint16 msgLen;
   1106            uint8 *pBuf;
   1107            uint8 options;
   1108            ZStatus_t status;
   1109          
   1110            epDesc = afFindEndPointDesc( srcEP );
   \   00003A                ; Setup parameters for call to function afFindEndPointDesc
   \   00003A   A9..         MOV       R1,?V7
   \   00003C   12....       LCALL     `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   00003F   8A..         MOV       ?V4,R2
   \   000041   8B..         MOV       ?V5,R3
   \   000043   85....       MOV       ?V10,?V4
   \   000046   85....       MOV       ?V11,?V5
   1111            if ( epDesc == NULL )
   \   000049   E5..         MOV       A,?V10
   \   00004B   45..         ORL       A,?V11
   \   00004D   7005         JNZ       ??zcl_SendCommand_0
   1112            {
   1113              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   00004F   7902         MOV       R1,#0x2
   \   000051   02....       LJMP      ??zcl_SendCommand_1 & 0xFFFF
   1114            }
   1115          
   1116          #if defined ( INTER_PAN )
   1117            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
   \                     ??zcl_SendCommand_0:
   \   000054                ; Setup parameters for call to function StubAPS_InterPan
   \   000054   7406         MOV       A,#0x6
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   F8           MOV       R0,A
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   C8           XCH       A,R0
   \   00005E   2409         ADD       A,#0x9
   \   000060   F582         MOV       DPL,A
   \   000062   C8           XCH       A,R0
   \   000063   3400         ADDC      A,#0x0
   \   000065   F583         MOV       DPH,A
   \   000067   E0           MOVX      A,@DPTR
   \   000068   F9           MOV       R1,A
   \   000069   7406         MOV       A,#0x6
   \   00006B   12....       LCALL     ?XSTACK_DISP0_8
   \   00006E   E0           MOVX      A,@DPTR
   \   00006F   F8           MOV       R0,A
   \   000070   A3           INC       DPTR
   \   000071   E0           MOVX      A,@DPTR
   \   000072   C8           XCH       A,R0
   \   000073   240A         ADD       A,#0xa
   \   000075   F582         MOV       DPL,A
   \   000077   C8           XCH       A,R0
   \   000078   3400         ADDC      A,#0x0
   \   00007A   F583         MOV       DPH,A
   \   00007C   E0           MOVX      A,@DPTR
   \   00007D   FA           MOV       R2,A
   \   00007E   A3           INC       DPTR
   \   00007F   E0           MOVX      A,@DPTR
   \   000080   FB           MOV       R3,A
   \   000081   12....       LCALL     `??StubAPS_InterPan::?relay`; Banked call to: StubAPS_InterPan
   \   000084   E9           MOV       A,R1
   \   000085   6005         JZ        ??zcl_SendCommand_2
   1118            {
   1119              options = AF_TX_OPTIONS_NONE;
   \   000087   75..00       MOV       ?V2,#0x0
   \   00008A   8036         SJMP      ??zcl_SendCommand_3
   1120            }
   1121            else
   1122          #endif
   1123            {
   1124              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_2:
   \   00008C                ; Setup parameters for call to function zclGetClusterOption
   \   00008C   EE           MOV       A,R6
   \   00008D   FA           MOV       R2,A
   \   00008E   EF           MOV       A,R7
   \   00008F   FB           MOV       R3,A
   \   000090   A9..         MOV       R1,?V7
   \   000092   12....       LCALL     `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   000095   E9           MOV       A,R1
   \   000096   F5..         MOV       ?V2,A
   1125          
   1126              // The cluster might not have been defined to use security but if this message
   1127              // is in response to another message that was using APS security this message
   1128              // will be sent with APS security
   1129              if ( !( options & AF_EN_SECURITY ) )
   \   000098   E5..         MOV       A,?V2
   \   00009A   A2E6         MOV       C,0xE0 /* A   */.6
   \   00009C   4024         JC        ??zcl_SendCommand_3
   1130              {
   1131                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   00009E                ; Setup parameters for call to function zcl_getRawAFMsg
   \   00009E   12....       LCALL     `??zcl_getRawAFMsg::?relay`; Banked call to: zcl_getRawAFMsg
   \   0000A1   8A..         MOV       ?V4,R2
   \   0000A3   8B..         MOV       ?V5,R3
   \   0000A5   A8..         MOV       R0,?V4
   \   0000A7   A9..         MOV       R1,?V5
   1132          
   1133                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \   0000A9   E8           MOV       A,R0
   \   0000AA   49           ORL       A,R1
   \   0000AB   6015         JZ        ??zcl_SendCommand_3
   \   0000AD   E8           MOV       A,R0
   \   0000AE   2419         ADD       A,#0x19
   \   0000B0   F582         MOV       DPL,A
   \   0000B2   E4           CLR       A
   \   0000B3   39           ADDC      A,R1
   \   0000B4   F583         MOV       DPH,A
   \   0000B6   E0           MOVX      A,@DPTR
   \   0000B7   6401         XRL       A,#0x1
   \   0000B9   7007         JNZ       ??zcl_SendCommand_3
   1134                {
   1135                  options |= AF_EN_SECURITY;
   \   0000BB   D3           SETB      C
   \   0000BC   E5..         MOV       A,?V2
   \   0000BE   92E6         MOV       0xE0 /* A   */.6,C
   \   0000C0   F5..         MOV       ?V2,A
   1136                }
   1137              }
   1138            }
   1139          
   1140            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_3:
   \   0000C2                ; Setup parameters for call to function osal_memset
   \   0000C2   7C06         MOV       R4,#0x6
   \   0000C4   7D00         MOV       R5,#0x0
   \   0000C6   7900         MOV       R1,#0x0
   \   0000C8   AA..         MOV       R2,?XSP + 0
   \   0000CA   AB..         MOV       R3,?XSP + 1
   \   0000CC   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1141          
   1142            // Not Profile wide command (like READ, WRITE)
   1143            if ( specific )
   \   0000CF   7423         MOV       A,#0x23
   \   0000D1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D4   E0           MOVX      A,@DPTR
   \   0000D5   6020         JZ        ??zcl_SendCommand_4
   1144            {
   1145              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   0000D7   85..82       MOV       DPL,?XSP + 0
   \   0000DA   85..83       MOV       DPH,?XSP + 1
   \   0000DD   E0           MOVX      A,@DPTR
   \   0000DE   54FC         ANL       A,#0xfc
   \   0000E0   F0           MOVX      @DPTR,A
   \   0000E1   A3           INC       DPTR
   \   0000E2   E0           MOVX      A,@DPTR
   \   0000E3   54FF         ANL       A,#0xff
   \   0000E5   F0           MOVX      @DPTR,A
   \   0000E6   85..82       MOV       DPL,?XSP + 0
   \   0000E9   85..83       MOV       DPH,?XSP + 1
   \   0000EC   E0           MOVX      A,@DPTR
   \   0000ED   4401         ORL       A,#0x1
   \   0000EF   F0           MOVX      @DPTR,A
   \   0000F0   A3           INC       DPTR
   \   0000F1   E0           MOVX      A,@DPTR
   \   0000F2   4400         ORL       A,#0x0
   \   0000F4   F0           MOVX      @DPTR,A
   \   0000F5   800F         SJMP      ??zcl_SendCommand_5
   1146            }
   1147            else
   1148            {
   1149              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_4:
   \   0000F7   85..82       MOV       DPL,?XSP + 0
   \   0000FA   85..83       MOV       DPH,?XSP + 1
   \   0000FD   E0           MOVX      A,@DPTR
   \   0000FE   54FC         ANL       A,#0xfc
   \   000100   F0           MOVX      @DPTR,A
   \   000101   A3           INC       DPTR
   \   000102   E0           MOVX      A,@DPTR
   \   000103   54FF         ANL       A,#0xff
   \   000105   F0           MOVX      @DPTR,A
   1150            }
   1151          
   1152            if ( ( epDesc->simpleDesc == NULL ) ||
   1153                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
   1154                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_SendCommand_5:
   \   000106   85..82       MOV       DPL,?V10
   \   000109   85..83       MOV       DPH,?V11
   \   00010C   A3           INC       DPTR
   \   00010D   A3           INC       DPTR
   \   00010E   A3           INC       DPTR
   \   00010F   A3           INC       DPTR
   \   000110   E0           MOVX      A,@DPTR
   \   000111   F8           MOV       R0,A
   \   000112   A3           INC       DPTR
   \   000113   E0           MOVX      A,@DPTR
   \   000114   F9           MOV       R1,A
   \   000115   E8           MOV       A,R0
   \   000116   49           ORL       A,R1
   \   000117   6037         JZ        ??zcl_SendCommand_6
   \   000119                ; Setup parameters for call to function zcl_DeviceOperational
   \   000119   85..82       MOV       DPL,?V10
   \   00011C   85..83       MOV       DPH,?V11
   \   00011F   A3           INC       DPTR
   \   000120   A3           INC       DPTR
   \   000121   A3           INC       DPTR
   \   000122   A3           INC       DPTR
   \   000123   E0           MOVX      A,@DPTR
   \   000124   F8           MOV       R0,A
   \   000125   A3           INC       DPTR
   \   000126   E0           MOVX      A,@DPTR
   \   000127   F583         MOV       DPH,A
   \   000129   8882         MOV       DPL,R0
   \   00012B   A3           INC       DPTR
   \   00012C   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00012F   AD..         MOV       R5,?V8
   \   000131   7402         MOV       A,#0x2
   \   000133   12....       LCALL     ?XSTACK_DISP0_8
   \   000136   E0           MOVX      A,@DPTR
   \   000137   F8           MOV       R0,A
   \   000138   A3           INC       DPTR
   \   000139   E0           MOVX      A,@DPTR
   \   00013A   F9           MOV       R1,A
   \   00013B   E8           MOV       A,R0
   \   00013C   5403         ANL       A,#0x3
   \   00013E   FC           MOV       R4,A
   \   00013F   EE           MOV       A,R6
   \   000140   FA           MOV       R2,A
   \   000141   EF           MOV       A,R7
   \   000142   FB           MOV       R3,A
   \   000143   A9..         MOV       R1,?V7
   \   000145   12....       LCALL     `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   000148   7402         MOV       A,#0x2
   \   00014A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00014D   E9           MOV       A,R1
   \   00014E   7005         JNZ       ??zcl_SendCommand_7
   1155            {
   1156              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_6:
   \   000150   7901         MOV       R1,#0x1
   \   000152   02....       LJMP      ??zcl_SendCommand_1 & 0xFFFF
   1157            }
   1158          
   1159            // Fill in the Maufacturer Code
   1160            if ( manuCode != 0 )
   \                     ??zcl_SendCommand_7:
   \   000155   7426         MOV       A,#0x26
   \   000157   12....       LCALL     ?XSTACK_DISP0_8
   \   00015A   E0           MOVX      A,@DPTR
   \   00015B   F8           MOV       R0,A
   \   00015C   A3           INC       DPTR
   \   00015D   E0           MOVX      A,@DPTR
   \   00015E   F9           MOV       R1,A
   \   00015F   E8           MOV       A,R0
   \   000160   49           ORL       A,R1
   \   000161   6023         JZ        ??zcl_SendCommand_8
   1161            {
   1162              hdr.fc.manuSpecific = 1;
   \   000163   85..82       MOV       DPL,?XSP + 0
   \   000166   85..83       MOV       DPH,?XSP + 1
   \   000169   E0           MOVX      A,@DPTR
   \   00016A   4404         ORL       A,#0x4
   \   00016C   F0           MOVX      @DPTR,A
   \   00016D   A3           INC       DPTR
   \   00016E   E0           MOVX      A,@DPTR
   \   00016F   4400         ORL       A,#0x0
   \   000171   F0           MOVX      @DPTR,A
   1163              hdr.manuCode = manuCode;
   \   000172   7426         MOV       A,#0x26
   \   000174   12....       LCALL     ?XSTACK_DISP0_8
   \   000177   E0           MOVX      A,@DPTR
   \   000178   F8           MOV       R0,A
   \   000179   A3           INC       DPTR
   \   00017A   E0           MOVX      A,@DPTR
   \   00017B   F9           MOV       R1,A
   \   00017C   7402         MOV       A,#0x2
   \   00017E   12....       LCALL     ?XSTACK_DISP0_8
   \   000181   E8           MOV       A,R0
   \   000182   F0           MOVX      @DPTR,A
   \   000183   A3           INC       DPTR
   \   000184   E9           MOV       A,R1
   \   000185   F0           MOVX      @DPTR,A
   1164            }
   1165          
   1166            // Set the Command Direction
   1167            if ( direction )
   \                     ??zcl_SendCommand_8:
   \   000186   E5..         MOV       A,?V15
   \   000188   6011         JZ        ??zcl_SendCommand_9
   1168            {
   1169              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00018A   85..82       MOV       DPL,?XSP + 0
   \   00018D   85..83       MOV       DPH,?XSP + 1
   \   000190   E0           MOVX      A,@DPTR
   \   000191   4408         ORL       A,#0x8
   \   000193   F0           MOVX      @DPTR,A
   \   000194   A3           INC       DPTR
   \   000195   E0           MOVX      A,@DPTR
   \   000196   4400         ORL       A,#0x0
   \   000198   F0           MOVX      @DPTR,A
   \   000199   800F         SJMP      ??zcl_SendCommand_10
   1170            }
   1171            else
   1172            {
   1173              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_9:
   \   00019B   85..82       MOV       DPL,?XSP + 0
   \   00019E   85..83       MOV       DPH,?XSP + 1
   \   0001A1   E0           MOVX      A,@DPTR
   \   0001A2   54F7         ANL       A,#0xf7
   \   0001A4   F0           MOVX      @DPTR,A
   \   0001A5   A3           INC       DPTR
   \   0001A6   E0           MOVX      A,@DPTR
   \   0001A7   54FF         ANL       A,#0xff
   \   0001A9   F0           MOVX      @DPTR,A
   1174            }
   1175          
   1176            // Set the Disable Default Response field
   1177            if ( disableDefaultRsp )
   \                     ??zcl_SendCommand_10:
   \   0001AA   E5..         MOV       A,?V14
   \   0001AC   6011         JZ        ??zcl_SendCommand_11
   1178            {
   1179              hdr.fc.disableDefaultRsp = 1;
   \   0001AE   85..82       MOV       DPL,?XSP + 0
   \   0001B1   85..83       MOV       DPH,?XSP + 1
   \   0001B4   E0           MOVX      A,@DPTR
   \   0001B5   4410         ORL       A,#0x10
   \   0001B7   F0           MOVX      @DPTR,A
   \   0001B8   A3           INC       DPTR
   \   0001B9   E0           MOVX      A,@DPTR
   \   0001BA   4400         ORL       A,#0x0
   \   0001BC   F0           MOVX      @DPTR,A
   \   0001BD   800F         SJMP      ??zcl_SendCommand_12
   1180            }
   1181            else
   1182            {
   1183              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_11:
   \   0001BF   85..82       MOV       DPL,?XSP + 0
   \   0001C2   85..83       MOV       DPH,?XSP + 1
   \   0001C5   E0           MOVX      A,@DPTR
   \   0001C6   54EF         ANL       A,#0xef
   \   0001C8   F0           MOVX      @DPTR,A
   \   0001C9   A3           INC       DPTR
   \   0001CA   E0           MOVX      A,@DPTR
   \   0001CB   54FF         ANL       A,#0xff
   \   0001CD   F0           MOVX      @DPTR,A
   1184            }
   1185          
   1186            // Fill in the Transaction Sequence Number
   1187            hdr.transSeqNum = seqNum;
   \                     ??zcl_SendCommand_12:
   \   0001CE   E5..         MOV       A,?V9
   \   0001D0   C0E0         PUSH      A
   \   0001D2   7404         MOV       A,#0x4
   \   0001D4   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D7   D0E0         POP       A
   \   0001D9   F0           MOVX      @DPTR,A
   1188          
   1189            // Fill in the command
   1190            hdr.commandID = cmd;
   \   0001DA   E5..         MOV       A,?V8
   \   0001DC   C0E0         PUSH      A
   \   0001DE   7405         MOV       A,#0x5
   \   0001E0   12....       LCALL     ?XSTACK_DISP0_8
   \   0001E3   D0E0         POP       A
   \   0001E5   F0           MOVX      @DPTR,A
   1191          
   1192            // calculate the needed buffer size
   1193            msgLen = zclCalcHdrSize( &hdr );
   \   0001E6                ; Setup parameters for call to function zclCalcHdrSize
   \   0001E6   AA..         MOV       R2,?XSP + 0
   \   0001E8   AB..         MOV       R3,?XSP + 1
   \   0001EA   12....       LCALL     `??zclCalcHdrSize::?relay`; Banked call to: zclCalcHdrSize
   \   0001ED   E9           MOV       A,R1
   \   0001EE   F8           MOV       R0,A
   \   0001EF   7900         MOV       R1,#0x0
   \   0001F1   88..         MOV       ?V0,R0
   \   0001F3   89..         MOV       ?V1,R1
   1194            msgLen += cmdFormatLen;
   \   0001F5   7429         MOV       A,#0x29
   \   0001F7   12....       LCALL     ?XSTACK_DISP0_8
   \   0001FA   E0           MOVX      A,@DPTR
   \   0001FB   25..         ADD       A,?V0
   \   0001FD   F5..         MOV       ?V0,A
   \   0001FF   A3           INC       DPTR
   \   000200   E0           MOVX      A,@DPTR
   \   000201   35..         ADDC      A,?V1
   \   000203   F5..         MOV       ?V1,A
   1195          
   1196            // Allocate the buffer needed
   1197            msgBuf = zcl_mem_alloc( msgLen );
   \   000205                ; Setup parameters for call to function osal_mem_alloc
   \   000205   AA..         MOV       R2,?V0
   \   000207   AB..         MOV       R3,?V1
   \   000209   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00020C   8A..         MOV       ?V4,R2
   \   00020E   8B..         MOV       ?V5,R3
   \   000210   85....       MOV       ?V12,?V4
   \   000213   85....       MOV       ?V13,?V5
   1198            if ( msgBuf != NULL )
   \   000216   E5..         MOV       A,?V12
   \   000218   45..         ORL       A,?V13
   \   00021A   7003         JNZ       $+5
   \   00021C   02....       LJMP      ??zcl_SendCommand_13 & 0xFFFF
   1199            {
   1200              // Fill in the ZCL Header
   1201              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   00021F                ; Setup parameters for call to function zclBuildHdr
   \   00021F   AC..         MOV       R4,?V12
   \   000221   AD..         MOV       R5,?V13
   \   000223   AA..         MOV       R2,?XSP + 0
   \   000225   AB..         MOV       R3,?XSP + 1
   \   000227   12....       LCALL     `??zclBuildHdr::?relay`; Banked call to: zclBuildHdr
   \   00022A   7408         MOV       A,#0x8
   \   00022C   12....       LCALL     ?XSTACK_DISP0_8
   \   00022F   EA           MOV       A,R2
   \   000230   F0           MOVX      @DPTR,A
   \   000231   A3           INC       DPTR
   \   000232   EB           MOV       A,R3
   \   000233   F0           MOVX      @DPTR,A
   1202          
   1203              // Fill in the command frame
   1204              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   000234                ; Setup parameters for call to function osal_memcpy
   \   000234   742B         MOV       A,#0x2b
   \   000236   12....       LCALL     ?XSTACK_DISP0_8
   \   000239   E0           MOVX      A,@DPTR
   \   00023A   F5..         MOV       ?V4,A
   \   00023C   A3           INC       DPTR
   \   00023D   E0           MOVX      A,@DPTR
   \   00023E   F5..         MOV       ?V5,A
   \   000240   75..00       MOV       ?V6,#0x0
   \   000243   78..         MOV       R0,#?V4
   \   000245   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000248   742C         MOV       A,#0x2c
   \   00024A   12....       LCALL     ?XSTACK_DISP0_8
   \   00024D   E0           MOVX      A,@DPTR
   \   00024E   FC           MOV       R4,A
   \   00024F   A3           INC       DPTR
   \   000250   E0           MOVX      A,@DPTR
   \   000251   FD           MOV       R5,A
   \   000252   740B         MOV       A,#0xb
   \   000254   12....       LCALL     ?XSTACK_DISP0_8
   \   000257   E0           MOVX      A,@DPTR
   \   000258   FA           MOV       R2,A
   \   000259   A3           INC       DPTR
   \   00025A   E0           MOVX      A,@DPTR
   \   00025B   FB           MOV       R3,A
   \   00025C   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00025F   7403         MOV       A,#0x3
   \   000261   12....       LCALL     ?DEALLOC_XSTACK8
   1205          
   1206              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
   1207                                       &APS_Counter, options, zcl_radius );
   \   000264                ; Setup parameters for call to function AF_DataRequest
   \   000264   90....       MOV       DPTR,#zcl_radius
   \   000267   E0           MOVX      A,@DPTR
   \   000268   F5..         MOV       ?V4,A
   \   00026A   78..         MOV       R0,#?V4
   \   00026C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00026F   75....       MOV       ?V4,#APS_Counter & 0xff
   \   000272   75....       MOV       ?V5,#(APS_Counter >> 8) & 0xff
   \   000275   78..         MOV       R0,#?V4
   \   000277   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00027A   78..         MOV       R0,#?V12
   \   00027C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00027F   78..         MOV       R0,#?V0
   \   000281   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000284   8E..         MOV       ?V4,R6
   \   000286   8F..         MOV       ?V5,R7
   \   000288   78..         MOV       R0,#?V4
   \   00028A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00028D   A9..         MOV       R1,?V2
   \   00028F   AC..         MOV       R4,?V10
   \   000291   AD..         MOV       R5,?V11
   \   000293   740F         MOV       A,#0xf
   \   000295   12....       LCALL     ?XSTACK_DISP0_8
   \   000298   E0           MOVX      A,@DPTR
   \   000299   FA           MOV       R2,A
   \   00029A   A3           INC       DPTR
   \   00029B   E0           MOVX      A,@DPTR
   \   00029C   FB           MOV       R3,A
   \   00029D   12....       LCALL     `??AF_DataRequest::?relay`; Banked call to: AF_DataRequest
   \   0002A0   7409         MOV       A,#0x9
   \   0002A2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002A5   E9           MOV       A,R1
   \   0002A6   F5..         MOV       ?V3,A
   1208              zcl_mem_free ( msgBuf );
   \   0002A8                ; Setup parameters for call to function osal_mem_free
   \   0002A8   AA..         MOV       R2,?V12
   \   0002AA   AB..         MOV       R3,?V13
   \   0002AC   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0002AF   8003         SJMP      ??zcl_SendCommand_14
   1209            }
   1210            else
   1211            {
   1212              status = ZMemError;
   \                     ??zcl_SendCommand_13:
   \   0002B1   75..10       MOV       ?V3,#0x10
   1213            }
   1214          
   1215            return ( status );
   \                     ??zcl_SendCommand_14:
   \   0002B4   A9..         MOV       R1,?V3
   \                     ??zcl_SendCommand_1:
   \   0002B6   740A         MOV       A,#0xa
   \   0002B8   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002BB   7F10         MOV       R7,#0x10
   \   0002BD   02....       LJMP      ?BANKED_LEAVE_XDATA
   1216          }
   1217          
   1218          #ifdef ZCL_READ
   1219          /*********************************************************************
   1220           * @fn      zcl_SendRead
   1221           *
   1222           * @brief   Send a Read command
   1223           *
   1224           * @param   srcEP - Application's endpoint
   1225           * @param   dstAddr - destination address
   1226           * @param   clusterID - cluster ID
   1227           * @param   readCmd - read command to be sent
   1228           * @param   direction - direction of the command
   1229           * @param   seqNum - transaction sequence number
   1230           *
   1231           * @return  ZSuccess if OK
   1232           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1233          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
   1234                                  uint16 clusterID, zclReadCmd_t *readCmd,
   1235                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
   1236          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   89..         MOV       ?V8,R1
   \   000017   8C..         MOV       ?V14,R4
   \   000019   8D..         MOV       ?V15,R5
   \   00001B   741A         MOV       A,#0x1a
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V6,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F5..         MOV       ?V7,A
   \   000027   741C         MOV       A,#0x1c
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F5..         MOV       ?V13,A
   \   00002F   741D         MOV       A,#0x1d
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F5..         MOV       ?V12,A
   \   000037   741E         MOV       A,#0x1e
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F5..         MOV       ?V9,A
   1237            uint16 dataLen;
   1238            uint8 *buf;
   1239            uint8 *pBuf;
   1240            ZStatus_t status;
   1241          
   1242            dataLen = readCmd->numAttr * 2; // Attribute ID
   \   00003F   85..82       MOV       DPL,?V6
   \   000042   85..83       MOV       DPH,?V7
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F8           MOV       R0,A
   \   000047   7900         MOV       R1,#0x0
   \   000049   E8           MOV       A,R0
   \   00004A   75F002       MOV       B,#0x2
   \   00004D   A4           MUL       AB
   \   00004E   C8           XCH       A,R0
   \   00004F   AAF0         MOV       R2,B
   \   000051   75F000       MOV       B,#0x0
   \   000054   A4           MUL       AB
   \   000055   2A           ADD       A,R2
   \   000056   FA           MOV       R2,A
   \   000057   75F002       MOV       B,#0x2
   \   00005A   E9           MOV       A,R1
   \   00005B   A4           MUL       AB
   \   00005C   2A           ADD       A,R2
   \   00005D   F9           MOV       R1,A
   \   00005E   E8           MOV       A,R0
   \   00005F   FE           MOV       R6,A
   \   000060   E9           MOV       A,R1
   \   000061   FF           MOV       R7,A
   1243          
   1244            buf = zcl_mem_alloc( dataLen );
   \   000062                ; Setup parameters for call to function osal_mem_alloc
   \   000062   EE           MOV       A,R6
   \   000063   FA           MOV       R2,A
   \   000064   EF           MOV       A,R7
   \   000065   FB           MOV       R3,A
   \   000066   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000069   8A..         MOV       ?V10,R2
   \   00006B   8B..         MOV       ?V11,R3
   \   00006D   85....       MOV       ?V4,?V10
   \   000070   85....       MOV       ?V5,?V11
   1245            if ( buf != NULL )
   \   000073   E5..         MOV       A,?V4
   \   000075   45..         ORL       A,?V5
   \   000077   7003         JNZ       $+5
   \   000079   02....       LJMP      ??zcl_SendRead_0 & 0xFFFF
   1246            {
   1247              uint8 i;
   1248          
   1249              // Load the buffer - serially
   1250              pBuf = buf;
   \   00007C   85....       MOV       ?V0,?V4
   \   00007F   85....       MOV       ?V1,?V5
   1251              for (i = 0; i < readCmd->numAttr; i++)
   \   000082   75..00       MOV       ?V3,#0x0
   \                     ??zcl_SendRead_1:
   \   000085   85..82       MOV       DPL,?V6
   \   000088   85..83       MOV       DPH,?V7
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   F8           MOV       R0,A
   \   00008D   E5..         MOV       A,?V3
   \   00008F   C3           CLR       C
   \   000090   98           SUBB      A,R0
   \   000091   4003         JC        $+5
   \   000093   02....       LJMP      ??zcl_SendRead_2 & 0xFFFF
   1252              {
   1253                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \   000096   E5..         MOV       A,?V3
   \   000098   F8           MOV       R0,A
   \   000099   7900         MOV       R1,#0x0
   \   00009B   E8           MOV       A,R0
   \   00009C   75F002       MOV       B,#0x2
   \   00009F   A4           MUL       AB
   \   0000A0   C8           XCH       A,R0
   \   0000A1   AAF0         MOV       R2,B
   \   0000A3   75F000       MOV       B,#0x0
   \   0000A6   A4           MUL       AB
   \   0000A7   2A           ADD       A,R2
   \   0000A8   FA           MOV       R2,A
   \   0000A9   75F002       MOV       B,#0x2
   \   0000AC   E9           MOV       A,R1
   \   0000AD   A4           MUL       AB
   \   0000AE   2A           ADD       A,R2
   \   0000AF   F9           MOV       R1,A
   \   0000B0   E5..         MOV       A,?V6
   \   0000B2   28           ADD       A,R0
   \   0000B3   F582         MOV       DPL,A
   \   0000B5   E5..         MOV       A,?V7
   \   0000B7   39           ADDC      A,R1
   \   0000B8   F583         MOV       DPH,A
   \   0000BA   A3           INC       DPTR
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   F8           MOV       R0,A
   \   0000BD   A3           INC       DPTR
   \   0000BE   E0           MOVX      A,@DPTR
   \   0000BF   F9           MOV       R1,A
   \   0000C0   E8           MOV       A,R0
   \   0000C1   C0E0         PUSH      A
   \   0000C3   85..82       MOV       DPL,?V0
   \   0000C6   85..83       MOV       DPH,?V1
   \   0000C9   D0E0         POP       A
   \   0000CB   F0           MOVX      @DPTR,A
   \   0000CC   85..82       MOV       DPL,?V0
   \   0000CF   85..83       MOV       DPH,?V1
   \   0000D2   A3           INC       DPTR
   \   0000D3   8582..       MOV       ?V0,DPL
   \   0000D6   8583..       MOV       ?V1,DPH
   1254                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \   0000D9   E5..         MOV       A,?V3
   \   0000DB   F8           MOV       R0,A
   \   0000DC   7900         MOV       R1,#0x0
   \   0000DE   E8           MOV       A,R0
   \   0000DF   75F002       MOV       B,#0x2
   \   0000E2   A4           MUL       AB
   \   0000E3   C8           XCH       A,R0
   \   0000E4   AAF0         MOV       R2,B
   \   0000E6   75F000       MOV       B,#0x0
   \   0000E9   A4           MUL       AB
   \   0000EA   2A           ADD       A,R2
   \   0000EB   FA           MOV       R2,A
   \   0000EC   75F002       MOV       B,#0x2
   \   0000EF   E9           MOV       A,R1
   \   0000F0   A4           MUL       AB
   \   0000F1   2A           ADD       A,R2
   \   0000F2   F9           MOV       R1,A
   \   0000F3   E5..         MOV       A,?V6
   \   0000F5   28           ADD       A,R0
   \   0000F6   F582         MOV       DPL,A
   \   0000F8   E5..         MOV       A,?V7
   \   0000FA   39           ADDC      A,R1
   \   0000FB   F583         MOV       DPH,A
   \   0000FD   A3           INC       DPTR
   \   0000FE   E0           MOVX      A,@DPTR
   \   0000FF   F8           MOV       R0,A
   \   000100   A3           INC       DPTR
   \   000101   E0           MOVX      A,@DPTR
   \   000102   F9           MOV       R1,A
   \   000103   E4           CLR       A
   \   000104   C9           XCH       A,R1
   \   000105   F8           MOV       R0,A
   \   000106   E8           MOV       A,R0
   \   000107   C0E0         PUSH      A
   \   000109   85..82       MOV       DPL,?V0
   \   00010C   85..83       MOV       DPH,?V1
   \   00010F   D0E0         POP       A
   \   000111   F0           MOVX      @DPTR,A
   \   000112   85..82       MOV       DPL,?V0
   \   000115   85..83       MOV       DPH,?V1
   \   000118   A3           INC       DPTR
   \   000119   8582..       MOV       ?V0,DPL
   \   00011C   8583..       MOV       ?V1,DPH
   1255              }
   \   00011F   05..         INC       ?V3
   \   000121   02....       LJMP      ??zcl_SendRead_1 & 0xFFFF
   1256          
   1257              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
   1258                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendRead_2:
   \   000124                ; Setup parameters for call to function zcl_SendCommand
   \   000124   78..         MOV       R0,#?V4
   \   000126   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000129   8E..         MOV       ?V10,R6
   \   00012B   8F..         MOV       ?V11,R7
   \   00012D   78..         MOV       R0,#?V10
   \   00012F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000132   E5..         MOV       A,?V9
   \   000134   F5..         MOV       ?V10,A
   \   000136   78..         MOV       R0,#?V10
   \   000138   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00013B   E4           CLR       A
   \   00013C   F5..         MOV       ?V10,A
   \   00013E   F5..         MOV       ?V11,A
   \   000140   78..         MOV       R0,#?V10
   \   000142   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000145   E5..         MOV       A,?V12
   \   000147   F5..         MOV       ?V10,A
   \   000149   78..         MOV       R0,#?V10
   \   00014B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00014E   E5..         MOV       A,?V13
   \   000150   F5..         MOV       ?V10,A
   \   000152   78..         MOV       R0,#?V10
   \   000154   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000157   75..00       MOV       ?V10,#0x0
   \   00015A   78..         MOV       R0,#?V10
   \   00015C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00015F   75..00       MOV       ?V10,#0x0
   \   000162   78..         MOV       R0,#?V10
   \   000164   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000167   AC..         MOV       R4,?V14
   \   000169   AD..         MOV       R5,?V15
   \   00016B   740B         MOV       A,#0xb
   \   00016D   12....       LCALL     ?XSTACK_DISP0_8
   \   000170   E0           MOVX      A,@DPTR
   \   000171   FA           MOV       R2,A
   \   000172   A3           INC       DPTR
   \   000173   E0           MOVX      A,@DPTR
   \   000174   FB           MOV       R3,A
   \   000175   A9..         MOV       R1,?V8
   \   000177   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00017A   740B         MOV       A,#0xb
   \   00017C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00017F   E9           MOV       A,R1
   \   000180   F5..         MOV       ?V2,A
   1259              zcl_mem_free( buf );
   \   000182                ; Setup parameters for call to function osal_mem_free
   \   000182   AA..         MOV       R2,?V4
   \   000184   AB..         MOV       R3,?V5
   \   000186   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000189   8003         SJMP      ??zcl_SendRead_3
   1260            }
   1261            else
   1262            {
   1263              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   00018B   75..10       MOV       ?V2,#0x10
   1264            }
   1265          
   1266            return ( status );
   \                     ??zcl_SendRead_3:
   \   00018E   A9..         MOV       R1,?V2
   \   000190   7402         MOV       A,#0x2
   \   000192   12....       LCALL     ?DEALLOC_XSTACK8
   \   000195   7F10         MOV       R7,#0x10
   \   000197   02....       LJMP      ?BANKED_LEAVE_XDATA
   1267          }
   1268          
   1269          /*********************************************************************
   1270           * @fn      zcl_SendReadRsp
   1271           *
   1272           * @brief   Send a Read Response command.
   1273           *
   1274           * @param   srcEP - Application's endpoint
   1275           * @param   dstAddr - destination address
   1276           * @param   clusterID - cluster ID
   1277           * @param   readRspCmd - read response command to be sent
   1278           * @param   direction - direction of the command
   1279           * @param   seqNum - transaction sequence number
   1280           *
   1281           * @return  ZSuccess if OK
   1282           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1283          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1284                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1285                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1286          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   7402         MOV       A,#0x2
   \   00000C   12....       LCALL     ?XSTACK_DISP0_8
   \   00000F   EA           MOV       A,R2
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   EB           MOV       A,R3
   \   000013   F0           MOVX      @DPTR,A
   \   000014   89..         MOV       ?V6,R1
   \   000016   8C..         MOV       ?V14,R4
   \   000018   8D..         MOV       ?V15,R5
   \   00001A   741C         MOV       A,#0x1c
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   F5..         MOV       ?V12,A
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F5..         MOV       ?V13,A
   \   000026   7420         MOV       A,#0x20
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   F5..         MOV       ?V7,A
   1287            uint8 *buf;
   1288            uint16 len = 0;
   \   00002E   7E00         MOV       R6,#0x0
   \   000030   7F00         MOV       R7,#0x0
   1289            ZStatus_t status;
   1290            uint8 i;
   1291          
   1292            // calculate the size of the command
   1293            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000032   75..00       MOV       ?V4,#0x0
   \                     ??zcl_SendReadRsp_0:
   \   000035   85..82       MOV       DPL,?V12
   \   000038   85..83       MOV       DPH,?V13
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   F8           MOV       R0,A
   \   00003D   E5..         MOV       A,?V4
   \   00003F   C3           CLR       C
   \   000040   98           SUBB      A,R0
   \   000041   4003         JC        $+5
   \   000043   02....       LJMP      ??zcl_SendReadRsp_1 & 0xFFFF
   1294            {
   1295              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \   000046   E5..         MOV       A,?V4
   \   000048   F8           MOV       R0,A
   \   000049   7900         MOV       R1,#0x0
   \   00004B   E8           MOV       A,R0
   \   00004C   75F006       MOV       B,#0x6
   \   00004F   A4           MUL       AB
   \   000050   C8           XCH       A,R0
   \   000051   AAF0         MOV       R2,B
   \   000053   75F000       MOV       B,#0x0
   \   000056   A4           MUL       AB
   \   000057   2A           ADD       A,R2
   \   000058   FA           MOV       R2,A
   \   000059   75F006       MOV       B,#0x6
   \   00005C   E9           MOV       A,R1
   \   00005D   A4           MUL       AB
   \   00005E   2A           ADD       A,R2
   \   00005F   F9           MOV       R1,A
   \   000060   E5..         MOV       A,?V12
   \   000062   28           ADD       A,R0
   \   000063   F582         MOV       DPL,A
   \   000065   E5..         MOV       A,?V13
   \   000067   39           ADDC      A,R1
   \   000068   F583         MOV       DPH,A
   \   00006A   A3           INC       DPTR
   \   00006B   8582..       MOV       ?V0,DPL
   \   00006E   8583..       MOV       ?V1,DPH
   1296          
   1297              len += 2 + 1; // Attribute ID + Status
   \   000071   EE           MOV       A,R6
   \   000072   2403         ADD       A,#0x3
   \   000074   FE           MOV       R6,A
   \   000075   EF           MOV       A,R7
   \   000076   3400         ADDC      A,#0x0
   \   000078   FF           MOV       R7,A
   1298          
   1299              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   000079   85..82       MOV       DPL,?V0
   \   00007C   85..83       MOV       DPH,?V1
   \   00007F   A3           INC       DPTR
   \   000080   A3           INC       DPTR
   \   000081   E0           MOVX      A,@DPTR
   \   000082   7063         JNZ       ??zcl_SendReadRsp_2
   1300              {
   1301                len++; // Attribute Data Type length
   \   000084   0E           INC       R6
   \   000085   EE           MOV       A,R6
   \   000086   7001         JNZ       ??zcl_SendReadRsp_3
   \   000088   0F           INC       R7
   1302          
   1303                // Attribute Data length
   1304                if ( statusRec->data != NULL )
   \                     ??zcl_SendReadRsp_3:
   \   000089   85..82       MOV       DPL,?V0
   \   00008C   85..83       MOV       DPH,?V1
   \   00008F   A3           INC       DPTR
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   E0           MOVX      A,@DPTR
   \   000094   F8           MOV       R0,A
   \   000095   A3           INC       DPTR
   \   000096   E0           MOVX      A,@DPTR
   \   000097   F9           MOV       R1,A
   \   000098   E8           MOV       A,R0
   \   000099   49           ORL       A,R1
   \   00009A   602B         JZ        ??zcl_SendReadRsp_4
   1305                {
   1306                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   \   00009C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00009C   85..82       MOV       DPL,?V0
   \   00009F   85..83       MOV       DPH,?V1
   \   0000A2   A3           INC       DPTR
   \   0000A3   A3           INC       DPTR
   \   0000A4   A3           INC       DPTR
   \   0000A5   A3           INC       DPTR
   \   0000A6   E0           MOVX      A,@DPTR
   \   0000A7   FA           MOV       R2,A
   \   0000A8   A3           INC       DPTR
   \   0000A9   E0           MOVX      A,@DPTR
   \   0000AA   FB           MOV       R3,A
   \   0000AB   85..82       MOV       DPL,?V0
   \   0000AE   85..83       MOV       DPH,?V1
   \   0000B1   A3           INC       DPTR
   \   0000B2   A3           INC       DPTR
   \   0000B3   A3           INC       DPTR
   \   0000B4   E0           MOVX      A,@DPTR
   \   0000B5   F9           MOV       R1,A
   \   0000B6   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000B9   8A..         MOV       ?V2,R2
   \   0000BB   8B..         MOV       ?V3,R3
   \   0000BD   EE           MOV       A,R6
   \   0000BE   25..         ADD       A,?V2
   \   0000C0   FE           MOV       R6,A
   \   0000C1   EF           MOV       A,R7
   \   0000C2   35..         ADDC      A,?V3
   \   0000C4   FF           MOV       R7,A
   \   0000C5   8020         SJMP      ??zcl_SendReadRsp_2
   1307                }
   1308                else
   1309                {
   1310                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_4:
   \   0000C7                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   0000C7   85..82       MOV       DPL,?V0
   \   0000CA   85..83       MOV       DPH,?V1
   \   0000CD   E0           MOVX      A,@DPTR
   \   0000CE   FC           MOV       R4,A
   \   0000CF   A3           INC       DPTR
   \   0000D0   E0           MOVX      A,@DPTR
   \   0000D1   FD           MOV       R5,A
   \   0000D2   AA..         MOV       R2,?V14
   \   0000D4   AB..         MOV       R3,?V15
   \   0000D6   A9..         MOV       R1,?V6
   \   0000D8   12....       LCALL     `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \   0000DB   8A..         MOV       ?V2,R2
   \   0000DD   8B..         MOV       ?V3,R3
   \   0000DF   EE           MOV       A,R6
   \   0000E0   25..         ADD       A,?V2
   \   0000E2   FE           MOV       R6,A
   \   0000E3   EF           MOV       A,R7
   \   0000E4   35..         ADDC      A,?V3
   \   0000E6   FF           MOV       R7,A
   1311                }
   1312              }
   1313            }
   \                     ??zcl_SendReadRsp_2:
   \   0000E7   05..         INC       ?V4
   \   0000E9   02....       LJMP      ??zcl_SendReadRsp_0 & 0xFFFF
   1314          
   1315            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_1:
   \   0000EC                ; Setup parameters for call to function osal_mem_alloc
   \   0000EC   EE           MOV       A,R6
   \   0000ED   FA           MOV       R2,A
   \   0000EE   EF           MOV       A,R7
   \   0000EF   FB           MOV       R3,A
   \   0000F0   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000F3   8A..         MOV       ?V0,R2
   \   0000F5   8B..         MOV       ?V1,R3
   \   0000F7   85....       MOV       ?V8,?V0
   \   0000FA   85....       MOV       ?V9,?V1
   1316            if ( buf != NULL )
   \   0000FD   E5..         MOV       A,?V8
   \   0000FF   45..         ORL       A,?V9
   \   000101   7003         JNZ       $+5
   \   000103   02....       LJMP      ??zcl_SendReadRsp_5 & 0xFFFF
   1317            {
   1318              // Load the buffer - serially
   1319              uint8 *pBuf = buf;
   \   000106   85....       MOV       ?V0,?V8
   \   000109   85....       MOV       ?V1,?V9
   1320          
   1321              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   00010C   75..00       MOV       ?V4,#0x0
   \                     ??zcl_SendReadRsp_6:
   \   00010F   85..82       MOV       DPL,?V12
   \   000112   85..83       MOV       DPH,?V13
   \   000115   E0           MOVX      A,@DPTR
   \   000116   F8           MOV       R0,A
   \   000117   E5..         MOV       A,?V4
   \   000119   C3           CLR       C
   \   00011A   98           SUBB      A,R0
   \   00011B   4003         JC        $+5
   \   00011D   02....       LJMP      ??zcl_SendReadRsp_7 & 0xFFFF
   1322              {
   1323                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \   000120   E5..         MOV       A,?V4
   \   000122   F8           MOV       R0,A
   \   000123   7900         MOV       R1,#0x0
   \   000125   E8           MOV       A,R0
   \   000126   75F006       MOV       B,#0x6
   \   000129   A4           MUL       AB
   \   00012A   C8           XCH       A,R0
   \   00012B   AAF0         MOV       R2,B
   \   00012D   75F000       MOV       B,#0x0
   \   000130   A4           MUL       AB
   \   000131   2A           ADD       A,R2
   \   000132   FA           MOV       R2,A
   \   000133   75F006       MOV       B,#0x6
   \   000136   E9           MOV       A,R1
   \   000137   A4           MUL       AB
   \   000138   2A           ADD       A,R2
   \   000139   F9           MOV       R1,A
   \   00013A   E5..         MOV       A,?V12
   \   00013C   28           ADD       A,R0
   \   00013D   F582         MOV       DPL,A
   \   00013F   E5..         MOV       A,?V13
   \   000141   39           ADDC      A,R1
   \   000142   F583         MOV       DPH,A
   \   000144   A3           INC       DPTR
   \   000145   8582..       MOV       ?V2,DPL
   \   000148   8583..       MOV       ?V3,DPH
   1324          
   1325                *pBuf++ = LO_UINT16( statusRec->attrID );
   \   00014B   85..82       MOV       DPL,?V2
   \   00014E   85..83       MOV       DPH,?V3
   \   000151   E0           MOVX      A,@DPTR
   \   000152   F8           MOV       R0,A
   \   000153   A3           INC       DPTR
   \   000154   E0           MOVX      A,@DPTR
   \   000155   F9           MOV       R1,A
   \   000156   E8           MOV       A,R0
   \   000157   C0E0         PUSH      A
   \   000159   85..82       MOV       DPL,?V0
   \   00015C   85..83       MOV       DPH,?V1
   \   00015F   D0E0         POP       A
   \   000161   F0           MOVX      @DPTR,A
   \   000162   85..82       MOV       DPL,?V0
   \   000165   85..83       MOV       DPH,?V1
   \   000168   A3           INC       DPTR
   \   000169   8582..       MOV       ?V0,DPL
   \   00016C   8583..       MOV       ?V1,DPH
   1326                *pBuf++ = HI_UINT16( statusRec->attrID );
   \   00016F   85..82       MOV       DPL,?V2
   \   000172   85..83       MOV       DPH,?V3
   \   000175   E0           MOVX      A,@DPTR
   \   000176   F8           MOV       R0,A
   \   000177   A3           INC       DPTR
   \   000178   E0           MOVX      A,@DPTR
   \   000179   F9           MOV       R1,A
   \   00017A   E4           CLR       A
   \   00017B   C9           XCH       A,R1
   \   00017C   F8           MOV       R0,A
   \   00017D   E8           MOV       A,R0
   \   00017E   C0E0         PUSH      A
   \   000180   85..82       MOV       DPL,?V0
   \   000183   85..83       MOV       DPH,?V1
   \   000186   D0E0         POP       A
   \   000188   F0           MOVX      @DPTR,A
   \   000189   85..82       MOV       DPL,?V0
   \   00018C   85..83       MOV       DPH,?V1
   \   00018F   A3           INC       DPTR
   \   000190   8582..       MOV       ?V0,DPL
   \   000193   8583..       MOV       ?V1,DPH
   1327                *pBuf++ = statusRec->status;
   \   000196   85..82       MOV       DPL,?V2
   \   000199   85..83       MOV       DPH,?V3
   \   00019C   A3           INC       DPTR
   \   00019D   A3           INC       DPTR
   \   00019E   E0           MOVX      A,@DPTR
   \   00019F   C0E0         PUSH      A
   \   0001A1   85..82       MOV       DPL,?V0
   \   0001A4   85..83       MOV       DPH,?V1
   \   0001A7   D0E0         POP       A
   \   0001A9   F0           MOVX      @DPTR,A
   \   0001AA   85..82       MOV       DPL,?V0
   \   0001AD   85..83       MOV       DPH,?V1
   \   0001B0   A3           INC       DPTR
   \   0001B1   8582..       MOV       ?V0,DPL
   \   0001B4   8583..       MOV       ?V1,DPH
   1328          
   1329                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   0001B7   85..82       MOV       DPL,?V2
   \   0001BA   85..83       MOV       DPH,?V3
   \   0001BD   A3           INC       DPTR
   \   0001BE   A3           INC       DPTR
   \   0001BF   E0           MOVX      A,@DPTR
   \   0001C0   6003         JZ        $+5
   \   0001C2   02....       LJMP      ??zcl_SendReadRsp_8 & 0xFFFF
   1330                {
   1331                  *pBuf++ = statusRec->dataType;
   \   0001C5   85..82       MOV       DPL,?V2
   \   0001C8   85..83       MOV       DPH,?V3
   \   0001CB   A3           INC       DPTR
   \   0001CC   A3           INC       DPTR
   \   0001CD   A3           INC       DPTR
   \   0001CE   E0           MOVX      A,@DPTR
   \   0001CF   C0E0         PUSH      A
   \   0001D1   85..82       MOV       DPL,?V0
   \   0001D4   85..83       MOV       DPH,?V1
   \   0001D7   D0E0         POP       A
   \   0001D9   F0           MOVX      @DPTR,A
   \   0001DA   85..82       MOV       DPL,?V0
   \   0001DD   85..83       MOV       DPH,?V1
   \   0001E0   A3           INC       DPTR
   \   0001E1   8582..       MOV       ?V0,DPL
   \   0001E4   8583..       MOV       ?V1,DPH
   1332          
   1333                  if ( statusRec->data != NULL )
   \   0001E7   85..82       MOV       DPL,?V2
   \   0001EA   85..83       MOV       DPH,?V3
   \   0001ED   A3           INC       DPTR
   \   0001EE   A3           INC       DPTR
   \   0001EF   A3           INC       DPTR
   \   0001F0   A3           INC       DPTR
   \   0001F1   E0           MOVX      A,@DPTR
   \   0001F2   F8           MOV       R0,A
   \   0001F3   A3           INC       DPTR
   \   0001F4   E0           MOVX      A,@DPTR
   \   0001F5   F9           MOV       R1,A
   \   0001F6   E8           MOV       A,R0
   \   0001F7   49           ORL       A,R1
   \   0001F8   602D         JZ        ??zcl_SendReadRsp_9
   1334                  {
   1335                    // Copy attribute data to the buffer to be sent out
   1336                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   \   0001FA                ; Setup parameters for call to function zclSerializeData
   \   0001FA   AC..         MOV       R4,?V0
   \   0001FC   AD..         MOV       R5,?V1
   \   0001FE   85..82       MOV       DPL,?V2
   \   000201   85..83       MOV       DPH,?V3
   \   000204   A3           INC       DPTR
   \   000205   A3           INC       DPTR
   \   000206   A3           INC       DPTR
   \   000207   A3           INC       DPTR
   \   000208   E0           MOVX      A,@DPTR
   \   000209   FA           MOV       R2,A
   \   00020A   A3           INC       DPTR
   \   00020B   E0           MOVX      A,@DPTR
   \   00020C   FB           MOV       R3,A
   \   00020D   85..82       MOV       DPL,?V2
   \   000210   85..83       MOV       DPH,?V3
   \   000213   A3           INC       DPTR
   \   000214   A3           INC       DPTR
   \   000215   A3           INC       DPTR
   \   000216   E0           MOVX      A,@DPTR
   \   000217   F9           MOV       R1,A
   \   000218   12....       LCALL     `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   00021B   8A..         MOV       ?V10,R2
   \   00021D   8B..         MOV       ?V11,R3
   \   00021F   85....       MOV       ?V0,?V10
   \   000222   85....       MOV       ?V1,?V11
   \   000225   8041         SJMP      ??zcl_SendReadRsp_8
   1337                  }
   1338                  else
   1339                  {
   1340                    uint16 dataLen;
   1341          
   1342                    // Read attribute data directly into the buffer to be sent out
   1343                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_9:
   \   000227                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000227   A8..         MOV       R0,?XSP + 0
   \   000229   A9..         MOV       R1,?XSP + 1
   \   00022B   88..         MOV       ?V10,R0
   \   00022D   89..         MOV       ?V11,R1
   \   00022F   78..         MOV       R0,#?V10
   \   000231   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000234   78..         MOV       R0,#?V0
   \   000236   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000239   85..82       MOV       DPL,?V2
   \   00023C   85..83       MOV       DPH,?V3
   \   00023F   E0           MOVX      A,@DPTR
   \   000240   FC           MOV       R4,A
   \   000241   A3           INC       DPTR
   \   000242   E0           MOVX      A,@DPTR
   \   000243   FD           MOV       R5,A
   \   000244   AA..         MOV       R2,?V14
   \   000246   AB..         MOV       R3,?V15
   \   000248   A9..         MOV       R1,?V6
   \   00024A   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   00024D   7404         MOV       A,#0x4
   \   00024F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000252   E9           MOV       A,R1
   1344                    pBuf += dataLen;
   \   000253   85..82       MOV       DPL,?XSP + 0
   \   000256   85..83       MOV       DPH,?XSP + 1
   \   000259   E0           MOVX      A,@DPTR
   \   00025A   F8           MOV       R0,A
   \   00025B   A3           INC       DPTR
   \   00025C   E0           MOVX      A,@DPTR
   \   00025D   F9           MOV       R1,A
   \   00025E   E5..         MOV       A,?V0
   \   000260   28           ADD       A,R0
   \   000261   F5..         MOV       ?V0,A
   \   000263   E5..         MOV       A,?V1
   \   000265   39           ADDC      A,R1
   \   000266   F5..         MOV       ?V1,A
   1345                  }
   1346                }
   1347              } // for loop
   \                     ??zcl_SendReadRsp_8:
   \   000268   05..         INC       ?V4
   \   00026A   02....       LJMP      ??zcl_SendReadRsp_6 & 0xFFFF
   1348          
   1349              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1350                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_7:
   \   00026D                ; Setup parameters for call to function zcl_SendCommand
   \   00026D   78..         MOV       R0,#?V8
   \   00026F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000272   8E..         MOV       ?V2,R6
   \   000274   8F..         MOV       ?V3,R7
   \   000276   78..         MOV       R0,#?V2
   \   000278   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00027B   E5..         MOV       A,?V7
   \   00027D   F5..         MOV       ?V2,A
   \   00027F   78..         MOV       R0,#?V2
   \   000281   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000284   E4           CLR       A
   \   000285   F5..         MOV       ?V2,A
   \   000287   F5..         MOV       ?V3,A
   \   000289   78..         MOV       R0,#?V2
   \   00028B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00028E   7426         MOV       A,#0x26
   \   000290   12....       LCALL     ?XSTACK_DISP0_8
   \   000293   E0           MOVX      A,@DPTR
   \   000294   F5..         MOV       ?V2,A
   \   000296   78..         MOV       R0,#?V2
   \   000298   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00029B   7426         MOV       A,#0x26
   \   00029D   12....       LCALL     ?XSTACK_DISP0_8
   \   0002A0   E0           MOVX      A,@DPTR
   \   0002A1   F5..         MOV       ?V2,A
   \   0002A3   78..         MOV       R0,#?V2
   \   0002A5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002A8   75..00       MOV       ?V2,#0x0
   \   0002AB   78..         MOV       R0,#?V2
   \   0002AD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002B0   75..01       MOV       ?V2,#0x1
   \   0002B3   78..         MOV       R0,#?V2
   \   0002B5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002B8   AC..         MOV       R4,?V14
   \   0002BA   AD..         MOV       R5,?V15
   \   0002BC   740D         MOV       A,#0xd
   \   0002BE   12....       LCALL     ?XSTACK_DISP0_8
   \   0002C1   E0           MOVX      A,@DPTR
   \   0002C2   FA           MOV       R2,A
   \   0002C3   A3           INC       DPTR
   \   0002C4   E0           MOVX      A,@DPTR
   \   0002C5   FB           MOV       R3,A
   \   0002C6   A9..         MOV       R1,?V6
   \   0002C8   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0002CB   740B         MOV       A,#0xb
   \   0002CD   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002D0   E9           MOV       A,R1
   \   0002D1   F5..         MOV       ?V5,A
   1351              zcl_mem_free( buf );
   \   0002D3                ; Setup parameters for call to function osal_mem_free
   \   0002D3   AA..         MOV       R2,?V8
   \   0002D5   AB..         MOV       R3,?V9
   \   0002D7   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0002DA   8003         SJMP      ??zcl_SendReadRsp_10
   1352            }
   1353            else
   1354            {
   1355              status = ZMemError;
   \                     ??zcl_SendReadRsp_5:
   \   0002DC   75..10       MOV       ?V5,#0x10
   1356            }
   1357          
   1358            return ( status );
   \                     ??zcl_SendReadRsp_10:
   \   0002DF   A9..         MOV       R1,?V5
   \   0002E1   7404         MOV       A,#0x4
   \   0002E3   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002E6   7F10         MOV       R7,#0x10
   \   0002E8   02....       LJMP      ?BANKED_LEAVE_XDATA
   1359          }
   1360          #endif // ZCL_READ
   1361          
   1362          #ifdef ZCL_WRITE
   1363          /*********************************************************************
   1364           * @fn      sendWriteRequest
   1365           *
   1366           * @brief   Send a Write command
   1367           *
   1368           * @param   dstAddr - destination address
   1369           * @param   clusterID - cluster ID
   1370           * @param   writeCmd - write command to be sent
   1371           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1372           * @param   direction - direction of the command
   1373           * @param   seqNum - transaction sequence number
   1374           *
   1375           * @return  ZSuccess if OK
   1376           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1377          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1378                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1379                                          uint8 disableDefaultRsp, uint8 seqNum )
   1380          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   7402         MOV       A,#0x2
   \   00000C   12....       LCALL     ?XSTACK_DISP0_8
   \   00000F   EA           MOV       A,R2
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   EB           MOV       A,R3
   \   000013   F0           MOVX      @DPTR,A
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   EC           MOV       A,R4
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   A3           INC       DPTR
   \   00001D   ED           MOV       A,R5
   \   00001E   F0           MOVX      @DPTR,A
   \   00001F   89..         MOV       ?V12,R1
   \   000021   741C         MOV       A,#0x1c
   \   000023   12....       LCALL     ?XSTACK_DISP0_8
   \   000026   E0           MOVX      A,@DPTR
   \   000027   F5..         MOV       ?V8,A
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F5..         MOV       ?V9,A
   \   00002D   741F         MOV       A,#0x1f
   \   00002F   12....       LCALL     ?XSTACK_DISP0_8
   \   000032   E0           MOVX      A,@DPTR
   \   000033   F5..         MOV       ?V15,A
   \   000035   7420         MOV       A,#0x20
   \   000037   12....       LCALL     ?XSTACK_DISP0_8
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   F5..         MOV       ?V14,A
   \   00003D   7421         MOV       A,#0x21
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   E0           MOVX      A,@DPTR
   \   000043   F5..         MOV       ?V13,A
   1381            uint8 *buf;
   1382            uint16 dataLen = 0;
   \   000045   7E00         MOV       R6,#0x0
   \   000047   7F00         MOV       R7,#0x0
   1383            ZStatus_t status;
   1384            uint8 i;
   1385          
   1386            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000049   75..00       MOV       ?V2,#0x0
   \                     ??zcl_SendWriteRequest_0:
   \   00004C   85..82       MOV       DPL,?V8
   \   00004F   85..83       MOV       DPH,?V9
   \   000052   E0           MOVX      A,@DPTR
   \   000053   F8           MOV       R0,A
   \   000054   E5..         MOV       A,?V2
   \   000056   C3           CLR       C
   \   000057   98           SUBB      A,R0
   \   000058   505E         JNC       ??zcl_SendWriteRequest_1
   1387            {
   1388              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   00005A   E5..         MOV       A,?V2
   \   00005C   F8           MOV       R0,A
   \   00005D   7900         MOV       R1,#0x0
   \   00005F   E8           MOV       A,R0
   \   000060   75F005       MOV       B,#0x5
   \   000063   A4           MUL       AB
   \   000064   C8           XCH       A,R0
   \   000065   AAF0         MOV       R2,B
   \   000067   75F000       MOV       B,#0x0
   \   00006A   A4           MUL       AB
   \   00006B   2A           ADD       A,R2
   \   00006C   FA           MOV       R2,A
   \   00006D   75F005       MOV       B,#0x5
   \   000070   E9           MOV       A,R1
   \   000071   A4           MUL       AB
   \   000072   2A           ADD       A,R2
   \   000073   F9           MOV       R1,A
   \   000074   E5..         MOV       A,?V8
   \   000076   28           ADD       A,R0
   \   000077   F582         MOV       DPL,A
   \   000079   E5..         MOV       A,?V9
   \   00007B   39           ADDC      A,R1
   \   00007C   F583         MOV       DPH,A
   \   00007E   A3           INC       DPTR
   \   00007F   8582..       MOV       ?V0,DPL
   \   000082   8583..       MOV       ?V1,DPH
   1389          
   1390              dataLen += 2 + 1; // Attribute ID + Attribute Type
   \   000085   EE           MOV       A,R6
   \   000086   2403         ADD       A,#0x3
   \   000088   FE           MOV       R6,A
   \   000089   EF           MOV       A,R7
   \   00008A   3400         ADDC      A,#0x0
   \   00008C   FF           MOV       R7,A
   1391          
   1392              // Attribute Data
   1393              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \   00008D                ; Setup parameters for call to function zclGetAttrDataLength
   \   00008D   85..82       MOV       DPL,?V0
   \   000090   85..83       MOV       DPH,?V1
   \   000093   A3           INC       DPTR
   \   000094   A3           INC       DPTR
   \   000095   A3           INC       DPTR
   \   000096   E0           MOVX      A,@DPTR
   \   000097   FA           MOV       R2,A
   \   000098   A3           INC       DPTR
   \   000099   E0           MOVX      A,@DPTR
   \   00009A   FB           MOV       R3,A
   \   00009B   85..82       MOV       DPL,?V0
   \   00009E   85..83       MOV       DPH,?V1
   \   0000A1   A3           INC       DPTR
   \   0000A2   A3           INC       DPTR
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   F9           MOV       R1,A
   \   0000A5   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000A8   8A..         MOV       ?V4,R2
   \   0000AA   8B..         MOV       ?V5,R3
   \   0000AC   EE           MOV       A,R6
   \   0000AD   25..         ADD       A,?V4
   \   0000AF   FE           MOV       R6,A
   \   0000B0   EF           MOV       A,R7
   \   0000B1   35..         ADDC      A,?V5
   \   0000B3   FF           MOV       R7,A
   1394            }
   \   0000B4   05..         INC       ?V2
   \   0000B6   8094         SJMP      ??zcl_SendWriteRequest_0
   1395          
   1396            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendWriteRequest_1:
   \   0000B8                ; Setup parameters for call to function osal_mem_alloc
   \   0000B8   EE           MOV       A,R6
   \   0000B9   FA           MOV       R2,A
   \   0000BA   EF           MOV       A,R7
   \   0000BB   FB           MOV       R3,A
   \   0000BC   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000BF   8A..         MOV       ?V0,R2
   \   0000C1   8B..         MOV       ?V1,R3
   \   0000C3   85....       MOV       ?V6,?V0
   \   0000C6   85....       MOV       ?V7,?V1
   1397            if ( buf != NULL )
   \   0000C9   E5..         MOV       A,?V6
   \   0000CB   45..         ORL       A,?V7
   \   0000CD   7003         JNZ       $+5
   \   0000CF   02....       LJMP      ??zcl_SendWriteRequest_2 & 0xFFFF
   1398            {
   1399              // Load the buffer - serially
   1400              uint8 *pBuf = buf;
   \   0000D2   85....       MOV       ?V0,?V6
   \   0000D5   85....       MOV       ?V1,?V7
   1401              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   0000D8   75..00       MOV       ?V2,#0x0
   \                     ??zcl_SendWriteRequest_3:
   \   0000DB   85..82       MOV       DPL,?V8
   \   0000DE   85..83       MOV       DPH,?V9
   \   0000E1   E0           MOVX      A,@DPTR
   \   0000E2   F8           MOV       R0,A
   \   0000E3   E5..         MOV       A,?V2
   \   0000E5   C3           CLR       C
   \   0000E6   98           SUBB      A,R0
   \   0000E7   4003         JC        $+5
   \   0000E9   02....       LJMP      ??zcl_SendWriteRequest_4 & 0xFFFF
   1402              {
   1403                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   0000EC   E5..         MOV       A,?V2
   \   0000EE   F8           MOV       R0,A
   \   0000EF   7900         MOV       R1,#0x0
   \   0000F1   E8           MOV       A,R0
   \   0000F2   75F005       MOV       B,#0x5
   \   0000F5   A4           MUL       AB
   \   0000F6   C8           XCH       A,R0
   \   0000F7   AAF0         MOV       R2,B
   \   0000F9   75F000       MOV       B,#0x0
   \   0000FC   A4           MUL       AB
   \   0000FD   2A           ADD       A,R2
   \   0000FE   FA           MOV       R2,A
   \   0000FF   75F005       MOV       B,#0x5
   \   000102   E9           MOV       A,R1
   \   000103   A4           MUL       AB
   \   000104   2A           ADD       A,R2
   \   000105   F9           MOV       R1,A
   \   000106   E5..         MOV       A,?V8
   \   000108   28           ADD       A,R0
   \   000109   F582         MOV       DPL,A
   \   00010B   E5..         MOV       A,?V9
   \   00010D   39           ADDC      A,R1
   \   00010E   F583         MOV       DPH,A
   \   000110   A3           INC       DPTR
   \   000111   8582..       MOV       ?V4,DPL
   \   000114   8583..       MOV       ?V5,DPH
   1404          
   1405                *pBuf++ = LO_UINT16( statusRec->attrID );
   \   000117   85..82       MOV       DPL,?V4
   \   00011A   85..83       MOV       DPH,?V5
   \   00011D   E0           MOVX      A,@DPTR
   \   00011E   F8           MOV       R0,A
   \   00011F   A3           INC       DPTR
   \   000120   E0           MOVX      A,@DPTR
   \   000121   F9           MOV       R1,A
   \   000122   E8           MOV       A,R0
   \   000123   C0E0         PUSH      A
   \   000125   85..82       MOV       DPL,?V0
   \   000128   85..83       MOV       DPH,?V1
   \   00012B   D0E0         POP       A
   \   00012D   F0           MOVX      @DPTR,A
   \   00012E   85..82       MOV       DPL,?V0
   \   000131   85..83       MOV       DPH,?V1
   \   000134   A3           INC       DPTR
   \   000135   8582..       MOV       ?V0,DPL
   \   000138   8583..       MOV       ?V1,DPH
   1406                *pBuf++ = HI_UINT16( statusRec->attrID );
   \   00013B   85..82       MOV       DPL,?V4
   \   00013E   85..83       MOV       DPH,?V5
   \   000141   E0           MOVX      A,@DPTR
   \   000142   F8           MOV       R0,A
   \   000143   A3           INC       DPTR
   \   000144   E0           MOVX      A,@DPTR
   \   000145   F9           MOV       R1,A
   \   000146   E4           CLR       A
   \   000147   C9           XCH       A,R1
   \   000148   F8           MOV       R0,A
   \   000149   E8           MOV       A,R0
   \   00014A   C0E0         PUSH      A
   \   00014C   85..82       MOV       DPL,?V0
   \   00014F   85..83       MOV       DPH,?V1
   \   000152   D0E0         POP       A
   \   000154   F0           MOVX      @DPTR,A
   \   000155   85..82       MOV       DPL,?V0
   \   000158   85..83       MOV       DPH,?V1
   \   00015B   A3           INC       DPTR
   \   00015C   8582..       MOV       ?V0,DPL
   \   00015F   8583..       MOV       ?V1,DPH
   1407                *pBuf++ = statusRec->dataType;
   \   000162   85..82       MOV       DPL,?V4
   \   000165   85..83       MOV       DPH,?V5
   \   000168   A3           INC       DPTR
   \   000169   A3           INC       DPTR
   \   00016A   E0           MOVX      A,@DPTR
   \   00016B   C0E0         PUSH      A
   \   00016D   85..82       MOV       DPL,?V0
   \   000170   85..83       MOV       DPH,?V1
   \   000173   D0E0         POP       A
   \   000175   F0           MOVX      @DPTR,A
   \   000176   85..82       MOV       DPL,?V0
   \   000179   85..83       MOV       DPH,?V1
   \   00017C   A3           INC       DPTR
   \   00017D   8582..       MOV       ?V0,DPL
   \   000180   8583..       MOV       ?V1,DPH
   1408          
   1409                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   \   000183                ; Setup parameters for call to function zclSerializeData
   \   000183   AC..         MOV       R4,?V0
   \   000185   AD..         MOV       R5,?V1
   \   000187   85..82       MOV       DPL,?V4
   \   00018A   85..83       MOV       DPH,?V5
   \   00018D   A3           INC       DPTR
   \   00018E   A3           INC       DPTR
   \   00018F   A3           INC       DPTR
   \   000190   E0           MOVX      A,@DPTR
   \   000191   FA           MOV       R2,A
   \   000192   A3           INC       DPTR
   \   000193   E0           MOVX      A,@DPTR
   \   000194   FB           MOV       R3,A
   \   000195   85..82       MOV       DPL,?V4
   \   000198   85..83       MOV       DPH,?V5
   \   00019B   A3           INC       DPTR
   \   00019C   A3           INC       DPTR
   \   00019D   E0           MOVX      A,@DPTR
   \   00019E   F9           MOV       R1,A
   \   00019F   12....       LCALL     `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   0001A2   8A..         MOV       ?V10,R2
   \   0001A4   8B..         MOV       ?V11,R3
   \   0001A6   85....       MOV       ?V0,?V10
   \   0001A9   85....       MOV       ?V1,?V11
   1410              }
   \   0001AC   05..         INC       ?V2
   \   0001AE   02....       LJMP      ??zcl_SendWriteRequest_3 & 0xFFFF
   1411          
   1412              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1413                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRequest_4:
   \   0001B1                ; Setup parameters for call to function zcl_SendCommand
   \   0001B1   78..         MOV       R0,#?V6
   \   0001B3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001B6   8E..         MOV       ?V4,R6
   \   0001B8   8F..         MOV       ?V5,R7
   \   0001BA   78..         MOV       R0,#?V4
   \   0001BC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001BF   E5..         MOV       A,?V13
   \   0001C1   F5..         MOV       ?V4,A
   \   0001C3   78..         MOV       R0,#?V4
   \   0001C5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C8   E4           CLR       A
   \   0001C9   F5..         MOV       ?V4,A
   \   0001CB   F5..         MOV       ?V5,A
   \   0001CD   78..         MOV       R0,#?V4
   \   0001CF   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001D2   E5..         MOV       A,?V14
   \   0001D4   F5..         MOV       ?V4,A
   \   0001D6   78..         MOV       R0,#?V4
   \   0001D8   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001DB   E5..         MOV       A,?V15
   \   0001DD   F5..         MOV       ?V4,A
   \   0001DF   78..         MOV       R0,#?V4
   \   0001E1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001E4   75..00       MOV       ?V4,#0x0
   \   0001E7   78..         MOV       R0,#?V4
   \   0001E9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001EC   7428         MOV       A,#0x28
   \   0001EE   12....       LCALL     ?XSTACK_DISP0_8
   \   0001F1   E0           MOVX      A,@DPTR
   \   0001F2   F5..         MOV       ?V4,A
   \   0001F4   78..         MOV       R0,#?V4
   \   0001F6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001F9   740B         MOV       A,#0xb
   \   0001FB   12....       LCALL     ?XSTACK_DISP0_8
   \   0001FE   E0           MOVX      A,@DPTR
   \   0001FF   FC           MOV       R4,A
   \   000200   A3           INC       DPTR
   \   000201   E0           MOVX      A,@DPTR
   \   000202   FD           MOV       R5,A
   \   000203   740D         MOV       A,#0xd
   \   000205   12....       LCALL     ?XSTACK_DISP0_8
   \   000208   E0           MOVX      A,@DPTR
   \   000209   FA           MOV       R2,A
   \   00020A   A3           INC       DPTR
   \   00020B   E0           MOVX      A,@DPTR
   \   00020C   FB           MOV       R3,A
   \   00020D   A9..         MOV       R1,?V12
   \   00020F   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000212   740B         MOV       A,#0xb
   \   000214   12....       LCALL     ?DEALLOC_XSTACK8
   \   000217   E9           MOV       A,R1
   \   000218   F5..         MOV       ?V3,A
   1414              zcl_mem_free( buf );
   \   00021A                ; Setup parameters for call to function osal_mem_free
   \   00021A   AA..         MOV       R2,?V6
   \   00021C   AB..         MOV       R3,?V7
   \   00021E   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000221   8003         SJMP      ??zcl_SendWriteRequest_5
   1415            }
   1416            else
   1417            {
   1418              status = ZMemError;
   \                     ??zcl_SendWriteRequest_2:
   \   000223   75..10       MOV       ?V3,#0x10
   1419            }
   1420          
   1421            return ( status);
   \                     ??zcl_SendWriteRequest_5:
   \   000226   A9..         MOV       R1,?V3
   \   000228   7404         MOV       A,#0x4
   \   00022A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00022D   7F10         MOV       R7,#0x10
   \   00022F   02....       LJMP      ?BANKED_LEAVE_XDATA
   1422          }
   1423          
   1424          /*********************************************************************
   1425           * @fn      zcl_SendWriteRsp
   1426           *
   1427           * @brief   Send a Write Response command
   1428           *
   1429           * @param   dstAddr - destination address
   1430           * @param   clusterID - cluster ID
   1431           * @param   wrtieRspCmd - write response command to be sent
   1432           * @param   direction - direction of the command
   1433           * @param   seqNum - transaction sequence number
   1434           *
   1435           * @return  ZSuccess if OK
   1436           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1437          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1438                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1439                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1440          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   89..         MOV       ?V8,R1
   \   000017   8C..         MOV       ?V14,R4
   \   000019   8D..         MOV       ?V15,R5
   \   00001B   741A         MOV       A,#0x1a
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V2,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F5..         MOV       ?V3,A
   \   000027   741C         MOV       A,#0x1c
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F5..         MOV       ?V13,A
   \   00002F   741D         MOV       A,#0x1d
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F5..         MOV       ?V12,A
   \   000037   741E         MOV       A,#0x1e
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F5..         MOV       ?V9,A
   1441            uint16 dataLen;
   1442            uint8 *buf;
   1443            ZStatus_t status;
   1444          
   1445            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \   00003F   85..82       MOV       DPL,?V2
   \   000042   85..83       MOV       DPH,?V3
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F8           MOV       R0,A
   \   000047   7900         MOV       R1,#0x0
   \   000049   E8           MOV       A,R0
   \   00004A   75F003       MOV       B,#0x3
   \   00004D   A4           MUL       AB
   \   00004E   C8           XCH       A,R0
   \   00004F   AAF0         MOV       R2,B
   \   000051   75F000       MOV       B,#0x0
   \   000054   A4           MUL       AB
   \   000055   2A           ADD       A,R2
   \   000056   FA           MOV       R2,A
   \   000057   75F003       MOV       B,#0x3
   \   00005A   E9           MOV       A,R1
   \   00005B   A4           MUL       AB
   \   00005C   2A           ADD       A,R2
   \   00005D   F9           MOV       R1,A
   \   00005E   E8           MOV       A,R0
   \   00005F   FE           MOV       R6,A
   \   000060   E9           MOV       A,R1
   \   000061   FF           MOV       R7,A
   1446          
   1447            buf = zcl_mem_alloc( dataLen );
   \   000062                ; Setup parameters for call to function osal_mem_alloc
   \   000062   EE           MOV       A,R6
   \   000063   FA           MOV       R2,A
   \   000064   EF           MOV       A,R7
   \   000065   FB           MOV       R3,A
   \   000066   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000069   8A..         MOV       ?V0,R2
   \   00006B   8B..         MOV       ?V1,R3
   \   00006D   85....       MOV       ?V6,?V0
   \   000070   85....       MOV       ?V7,?V1
   1448            if ( buf != NULL )
   \   000073   E5..         MOV       A,?V6
   \   000075   45..         ORL       A,?V7
   \   000077   7003         JNZ       $+5
   \   000079   02....       LJMP      ??zcl_SendWriteRsp_0 & 0xFFFF
   1449            {
   1450              // Load the buffer - serially
   1451              uint8 i;
   1452              uint8 *pBuf = buf;
   \   00007C   85....       MOV       ?V0,?V6
   \   00007F   85....       MOV       ?V1,?V7
   1453              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   000082   75..00       MOV       ?V4,#0x0
   \                     ??zcl_SendWriteRsp_1:
   \   000085   85..82       MOV       DPL,?V2
   \   000088   85..83       MOV       DPH,?V3
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   F8           MOV       R0,A
   \   00008D   E5..         MOV       A,?V4
   \   00008F   C3           CLR       C
   \   000090   98           SUBB      A,R0
   \   000091   4003         JC        $+5
   \   000093   02....       LJMP      ??zcl_SendWriteRsp_2 & 0xFFFF
   1454              {
   1455                *pBuf++ = writeRspCmd->attrList[i].status;
   \   000096   E5..         MOV       A,?V4
   \   000098   F8           MOV       R0,A
   \   000099   7900         MOV       R1,#0x0
   \   00009B   E8           MOV       A,R0
   \   00009C   75F003       MOV       B,#0x3
   \   00009F   A4           MUL       AB
   \   0000A0   C8           XCH       A,R0
   \   0000A1   AAF0         MOV       R2,B
   \   0000A3   75F000       MOV       B,#0x0
   \   0000A6   A4           MUL       AB
   \   0000A7   2A           ADD       A,R2
   \   0000A8   FA           MOV       R2,A
   \   0000A9   75F003       MOV       B,#0x3
   \   0000AC   E9           MOV       A,R1
   \   0000AD   A4           MUL       AB
   \   0000AE   2A           ADD       A,R2
   \   0000AF   F9           MOV       R1,A
   \   0000B0   E5..         MOV       A,?V2
   \   0000B2   28           ADD       A,R0
   \   0000B3   F582         MOV       DPL,A
   \   0000B5   E5..         MOV       A,?V3
   \   0000B7   39           ADDC      A,R1
   \   0000B8   F583         MOV       DPH,A
   \   0000BA   A3           INC       DPTR
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   C0E0         PUSH      A
   \   0000BE   85..82       MOV       DPL,?V0
   \   0000C1   85..83       MOV       DPH,?V1
   \   0000C4   D0E0         POP       A
   \   0000C6   F0           MOVX      @DPTR,A
   \   0000C7   85..82       MOV       DPL,?V0
   \   0000CA   85..83       MOV       DPH,?V1
   \   0000CD   A3           INC       DPTR
   \   0000CE   8582..       MOV       ?V0,DPL
   \   0000D1   8583..       MOV       ?V1,DPH
   1456                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \   0000D4   E5..         MOV       A,?V4
   \   0000D6   F8           MOV       R0,A
   \   0000D7   7900         MOV       R1,#0x0
   \   0000D9   E8           MOV       A,R0
   \   0000DA   75F003       MOV       B,#0x3
   \   0000DD   A4           MUL       AB
   \   0000DE   C8           XCH       A,R0
   \   0000DF   AAF0         MOV       R2,B
   \   0000E1   75F000       MOV       B,#0x0
   \   0000E4   A4           MUL       AB
   \   0000E5   2A           ADD       A,R2
   \   0000E6   FA           MOV       R2,A
   \   0000E7   75F003       MOV       B,#0x3
   \   0000EA   E9           MOV       A,R1
   \   0000EB   A4           MUL       AB
   \   0000EC   2A           ADD       A,R2
   \   0000ED   F9           MOV       R1,A
   \   0000EE   E5..         MOV       A,?V2
   \   0000F0   28           ADD       A,R0
   \   0000F1   F582         MOV       DPL,A
   \   0000F3   E5..         MOV       A,?V3
   \   0000F5   39           ADDC      A,R1
   \   0000F6   F583         MOV       DPH,A
   \   0000F8   A3           INC       DPTR
   \   0000F9   A3           INC       DPTR
   \   0000FA   E0           MOVX      A,@DPTR
   \   0000FB   F8           MOV       R0,A
   \   0000FC   A3           INC       DPTR
   \   0000FD   E0           MOVX      A,@DPTR
   \   0000FE   F9           MOV       R1,A
   \   0000FF   E8           MOV       A,R0
   \   000100   C0E0         PUSH      A
   \   000102   85..82       MOV       DPL,?V0
   \   000105   85..83       MOV       DPH,?V1
   \   000108   D0E0         POP       A
   \   00010A   F0           MOVX      @DPTR,A
   \   00010B   85..82       MOV       DPL,?V0
   \   00010E   85..83       MOV       DPH,?V1
   \   000111   A3           INC       DPTR
   \   000112   8582..       MOV       ?V0,DPL
   \   000115   8583..       MOV       ?V1,DPH
   1457                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   \   000118   E5..         MOV       A,?V4
   \   00011A   F8           MOV       R0,A
   \   00011B   7900         MOV       R1,#0x0
   \   00011D   E8           MOV       A,R0
   \   00011E   75F003       MOV       B,#0x3
   \   000121   A4           MUL       AB
   \   000122   C8           XCH       A,R0
   \   000123   AAF0         MOV       R2,B
   \   000125   75F000       MOV       B,#0x0
   \   000128   A4           MUL       AB
   \   000129   2A           ADD       A,R2
   \   00012A   FA           MOV       R2,A
   \   00012B   75F003       MOV       B,#0x3
   \   00012E   E9           MOV       A,R1
   \   00012F   A4           MUL       AB
   \   000130   2A           ADD       A,R2
   \   000131   F9           MOV       R1,A
   \   000132   E5..         MOV       A,?V2
   \   000134   28           ADD       A,R0
   \   000135   F582         MOV       DPL,A
   \   000137   E5..         MOV       A,?V3
   \   000139   39           ADDC      A,R1
   \   00013A   F583         MOV       DPH,A
   \   00013C   A3           INC       DPTR
   \   00013D   A3           INC       DPTR
   \   00013E   E0           MOVX      A,@DPTR
   \   00013F   F8           MOV       R0,A
   \   000140   A3           INC       DPTR
   \   000141   E0           MOVX      A,@DPTR
   \   000142   F9           MOV       R1,A
   \   000143   E4           CLR       A
   \   000144   C9           XCH       A,R1
   \   000145   F8           MOV       R0,A
   \   000146   E8           MOV       A,R0
   \   000147   C0E0         PUSH      A
   \   000149   85..82       MOV       DPL,?V0
   \   00014C   85..83       MOV       DPH,?V1
   \   00014F   D0E0         POP       A
   \   000151   F0           MOVX      @DPTR,A
   \   000152   85..82       MOV       DPL,?V0
   \   000155   85..83       MOV       DPH,?V1
   \   000158   A3           INC       DPTR
   \   000159   8582..       MOV       ?V0,DPL
   \   00015C   8583..       MOV       ?V1,DPH
   1458              }
   \   00015F   05..         INC       ?V4
   \   000161   02....       LJMP      ??zcl_SendWriteRsp_1 & 0xFFFF
   1459          
   1460              // If there's only a single status record and its status field is set to
   1461              // SUCCESS then omit the attribute ID field.
   1462              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \                     ??zcl_SendWriteRsp_2:
   \   000164   85..82       MOV       DPL,?V2
   \   000167   85..83       MOV       DPH,?V3
   \   00016A   E0           MOVX      A,@DPTR
   \   00016B   6401         XRL       A,#0x1
   \   00016D   700E         JNZ       ??zcl_SendWriteRsp_3
   \   00016F   85..82       MOV       DPL,?V2
   \   000172   85..83       MOV       DPH,?V3
   \   000175   A3           INC       DPTR
   \   000176   E0           MOVX      A,@DPTR
   \   000177   7004         JNZ       ??zcl_SendWriteRsp_3
   1463              {
   1464                dataLen = 1;
   \   000179   7E01         MOV       R6,#0x1
   \   00017B   7F00         MOV       R7,#0x0
   1465              }
   1466          
   1467              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1468                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   00017D                ; Setup parameters for call to function zcl_SendCommand
   \   00017D   78..         MOV       R0,#?V6
   \   00017F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000182   8E..         MOV       ?V10,R6
   \   000184   8F..         MOV       ?V11,R7
   \   000186   78..         MOV       R0,#?V10
   \   000188   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00018B   E5..         MOV       A,?V9
   \   00018D   F5..         MOV       ?V10,A
   \   00018F   78..         MOV       R0,#?V10
   \   000191   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000194   E4           CLR       A
   \   000195   F5..         MOV       ?V10,A
   \   000197   F5..         MOV       ?V11,A
   \   000199   78..         MOV       R0,#?V10
   \   00019B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00019E   E5..         MOV       A,?V12
   \   0001A0   F5..         MOV       ?V10,A
   \   0001A2   78..         MOV       R0,#?V10
   \   0001A4   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001A7   E5..         MOV       A,?V13
   \   0001A9   F5..         MOV       ?V10,A
   \   0001AB   78..         MOV       R0,#?V10
   \   0001AD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001B0   75..00       MOV       ?V10,#0x0
   \   0001B3   78..         MOV       R0,#?V10
   \   0001B5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001B8   75..04       MOV       ?V10,#0x4
   \   0001BB   78..         MOV       R0,#?V10
   \   0001BD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C0   AC..         MOV       R4,?V14
   \   0001C2   AD..         MOV       R5,?V15
   \   0001C4   740B         MOV       A,#0xb
   \   0001C6   12....       LCALL     ?XSTACK_DISP0_8
   \   0001C9   E0           MOVX      A,@DPTR
   \   0001CA   FA           MOV       R2,A
   \   0001CB   A3           INC       DPTR
   \   0001CC   E0           MOVX      A,@DPTR
   \   0001CD   FB           MOV       R3,A
   \   0001CE   A9..         MOV       R1,?V8
   \   0001D0   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001D3   740B         MOV       A,#0xb
   \   0001D5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001D8   E9           MOV       A,R1
   \   0001D9   F5..         MOV       ?V5,A
   1469              zcl_mem_free( buf );
   \   0001DB                ; Setup parameters for call to function osal_mem_free
   \   0001DB   AA..         MOV       R2,?V6
   \   0001DD   AB..         MOV       R3,?V7
   \   0001DF   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001E2   8003         SJMP      ??zcl_SendWriteRsp_4
   1470            }
   1471            else
   1472            {
   1473              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0001E4   75..10       MOV       ?V5,#0x10
   1474            }
   1475          
   1476            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   0001E7   A9..         MOV       R1,?V5
   \   0001E9   7402         MOV       A,#0x2
   \   0001EB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001EE   7F10         MOV       R7,#0x10
   \   0001F0   02....       LJMP      ?BANKED_LEAVE_XDATA
   1477          }
   1478          #endif // ZCL_WRITE
   1479          
   1480          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   1481          /*********************************************************************
   1482           * @fn      zcl_SendConfigReportCmd
   1483           *
   1484           * @brief   Send a Configure Reporting command
   1485           *
   1486           * @param   dstAddr - destination address
   1487           * @param   clusterID - cluster ID
   1488           * @param   cfgReportCmd - configure reporting command to be sent
   1489           * @param   direction - direction of the command
   1490           * @param   seqNum - transaction sequence number
   1491           *
   1492           * @return  ZSuccess if OK
   1493           */
   1494          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1495                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1496                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1497          {
   1498            uint8 *buf;
   1499            uint16 dataLen = 0;
   1500            ZStatus_t status;
   1501            uint8 i;
   1502          
   1503            // Find out the data length
   1504            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1505            {
   1506              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1507          
   1508              dataLen += 1 + 2; // Direction + Attribute ID
   1509          
   1510              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1511              {
   1512                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1513          
   1514                // Find out the size of the Reportable Change field (for Analog data types)
   1515                if ( zclAnalogDataType( reportRec->dataType ) )
   1516                {
   1517                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1518                }
   1519              }
   1520              else
   1521              {
   1522                dataLen += 2; // Timeout Period
   1523              }
   1524            }
   1525          
   1526            buf = zcl_mem_alloc( dataLen );
   1527            if ( buf != NULL )
   1528            {
   1529              // Load the buffer - serially
   1530              uint8 *pBuf = buf;
   1531          
   1532              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1533              {
   1534                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1535          
   1536                *pBuf++ = reportRec->direction;
   1537                *pBuf++ = LO_UINT16( reportRec->attrID );
   1538                *pBuf++ = HI_UINT16( reportRec->attrID );
   1539          
   1540                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1541                {
   1542                  *pBuf++ = reportRec->dataType;
   1543                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1544                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1545                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1546                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1547          
   1548                  if ( zclAnalogDataType( reportRec->dataType ) )
   1549                  {
   1550                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1551                  }
   1552                }
   1553                else
   1554                {
   1555                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   1556                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1557                }
   1558              } // for loop
   1559          
   1560              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1561                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1562              zcl_mem_free( buf );
   1563            }
   1564            else
   1565            {
   1566              status = ZMemError;
   1567            }
   1568          
   1569            return ( status );
   1570          }
   1571          #endif
   1572          
   1573          #ifdef ZCL_REPORTING_DEVICE
   1574          /*********************************************************************
   1575           * @fn      zcl_SendConfigReportRspCmd
   1576           *
   1577           * @brief   Send a Configure Reporting Response command
   1578           *
   1579           * @param   dstAddr - destination address
   1580           * @param   clusterID - cluster ID
   1581           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1582           * @param   direction - direction of the command
   1583           * @param   seqNum - transaction sequence number
   1584           *
   1585           * @return  ZSuccess if OK
   1586           */
   1587          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1588                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1589                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1590          {
   1591            uint16 dataLen;
   1592            uint8 *buf;
   1593            ZStatus_t status;
   1594          
   1595            // Atrribute list (Status, Direction and Attribute ID)
   1596            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   1597          
   1598            buf = zcl_mem_alloc( dataLen );
   1599            if ( buf != NULL )
   1600            {
   1601              // Load the buffer - serially
   1602              uint8 *pBuf = buf;
   1603              uint8 i;
   1604          
   1605              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   1606              {
   1607                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   1608                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   1609                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1610                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1611              }
   1612          
   1613              // If there's only a single status record and its status field is set to
   1614              // SUCCESS then omit the attribute ID field.
   1615              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1616              {
   1617                dataLen = 1;
   1618              }
   1619          
   1620              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1621                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1622                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   1623              zcl_mem_free( buf );
   1624            }
   1625            else
   1626            {
   1627              status = ZMemError;
   1628            }
   1629          
   1630            return ( status );
   1631          }
   1632          #endif
   1633          
   1634          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   1635          /*********************************************************************
   1636           * @fn      zcl_SendReadReportCfgCmd
   1637           *
   1638           * @brief   Send a Read Reporting Configuration command
   1639           *
   1640           * @param   dstAddr - destination address
   1641           * @param   clusterID - cluster ID
   1642           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1643           * @param   direction - direction of the command
   1644           * @param   seqNum - transaction sequence number
   1645           *
   1646           * @return  ZSuccess if OK
   1647           */
   1648          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1649                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1650                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1651          {
   1652            uint16 dataLen;
   1653            uint8 *buf;
   1654            ZStatus_t status;
   1655          
   1656            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1657          
   1658            buf = zcl_mem_alloc( dataLen );
   1659            if ( buf != NULL )
   1660            {
   1661              // Load the buffer - serially
   1662              uint8 *pBuf = buf;
   1663              uint8 i;
   1664          
   1665              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1666              {
   1667                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1668                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1669                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1670              }
   1671          
   1672              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1673                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1674              zcl_mem_free( buf );
   1675            }
   1676            else
   1677            {
   1678              status = ZMemError;
   1679            }
   1680          
   1681            return ( status );
   1682          }
   1683          #endif
   1684          
   1685          #ifdef ZCL_REPORTING_DEVICE
   1686          /*********************************************************************
   1687           * @fn      zcl_SendReadReportCfgRspCmd
   1688           *
   1689           * @brief   Send a Read Reporting Configuration Response command
   1690           *
   1691           * @param   dstAddr - destination address
   1692           * @param   clusterID - cluster ID
   1693           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1694           * @param   direction - direction of the command
   1695           * @param   seqNum - transaction sequence number
   1696           *
   1697           * @return  ZSuccess if OK
   1698           */
   1699          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1700                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1701                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1702          {
   1703            uint8 *buf;
   1704            uint16 dataLen = 0;
   1705            ZStatus_t status;
   1706            uint8 i;
   1707          
   1708            // Find out the data length
   1709            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1710            {
   1711              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1712          
   1713              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1714          
   1715              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1716              {
   1717                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1718                {
   1719                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1720          
   1721                  // Find out the size of the Reportable Change field (for Analog data types)
   1722                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1723                  {
   1724                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1725                  }
   1726                }
   1727                else
   1728                {
   1729                  dataLen += 2; // Timeout Period
   1730                }
   1731              }
   1732            }
   1733          
   1734            buf = zcl_mem_alloc( dataLen );
   1735            if ( buf != NULL )
   1736            {
   1737              // Load the buffer - serially
   1738              uint8 *pBuf = buf;
   1739          
   1740              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1741              {
   1742                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1743          
   1744                *pBuf++ = reportRspRec->status;
   1745                *pBuf++ = reportRspRec->direction;
   1746                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1747                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1748          
   1749                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1750                {
   1751                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1752                  {
   1753                    *pBuf++ = reportRspRec->dataType;
   1754                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1755                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1756                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1757                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1758          
   1759                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1760                    {
   1761                      pBuf = zclSerializeData( reportRspRec->dataType,
   1762                                               reportRspRec->reportableChange, pBuf );
   1763                    }
   1764                  }
   1765                  else
   1766                  {
   1767                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1768                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1769                  }
   1770                }
   1771              }
   1772          
   1773              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1774                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1775                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1776              zcl_mem_free( buf );
   1777            }
   1778            else
   1779            {
   1780              status = ZMemError;
   1781            }
   1782          
   1783            return ( status );
   1784          }
   1785          
   1786          /*********************************************************************
   1787           * @fn      zcl_SendReportCmd
   1788           *
   1789           * @brief   Send a Report command
   1790           *
   1791           * @param   dstAddr - destination address
   1792           * @param   clusterID - cluster ID
   1793           * @param   reportCmd - report command to be sent
   1794           * @param   direction - direction of the command
   1795           * @param   seqNum - transaction sequence number
   1796           *
   1797           * @return  ZSuccess if OK
   1798           */
   1799          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1800                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1801                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1802          {
   1803            uint16 dataLen = 0;
   1804            uint8 *buf;
   1805            ZStatus_t status;
   1806            uint8 i;
   1807          
   1808            // calculate the size of the command
   1809            for ( i = 0; i < reportCmd->numAttr; i++ )
   1810            {
   1811              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1812          
   1813              dataLen += 2 + 1; // Attribute ID + data type
   1814          
   1815              // Attribute Data
   1816              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1817            }
   1818          
   1819            buf = zcl_mem_alloc( dataLen );
   1820            if ( buf != NULL )
   1821            {
   1822              // Load the buffer - serially
   1823              uint8 *pBuf = buf;
   1824          
   1825              for ( i = 0; i < reportCmd->numAttr; i++ )
   1826              {
   1827                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1828          
   1829                *pBuf++ = LO_UINT16( reportRec->attrID );
   1830                *pBuf++ = HI_UINT16( reportRec->attrID );
   1831                *pBuf++ = reportRec->dataType;
   1832          
   1833                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1834              }
   1835          
   1836              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1837                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1838              zcl_mem_free( buf );
   1839            }
   1840            else
   1841            {
   1842              status = ZMemError;
   1843            }
   1844          
   1845            return ( status );
   1846          }
   1847          #endif
   1848          
   1849          /*********************************************************************
   1850           * @fn      zcl_SendDefaultRspCmd
   1851           *
   1852           * @brief   Send a Default Response command
   1853           *
   1854           *          Note: The manufacturer code field should be set if this
   1855           *          command is being sent in response to a manufacturer specific
   1856           *          command.
   1857           *
   1858           * @param   dstAddr - destination address
   1859           * @param   clusterID - cluster ID
   1860           * @param   defaultRspCmd - default response command to be sent
   1861           * @param   direction - direction of the command
   1862           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1863           * @param   seqNum - transaction sequence number
   1864           *
   1865           * @return  ZSuccess if OK
   1866           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1867          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1868                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1869                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1870          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V3,R1
   \   00000C   8A..         MOV       ?V10,R2
   \   00000E   8B..         MOV       ?V11,R3
   \   000010   8C..         MOV       ?V6,R4
   \   000012   8D..         MOV       ?V7,R5
   \   000014   7416         MOV       A,#0x16
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V4,A
   \   00001C   A3           INC       DPTR
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   F5..         MOV       ?V5,A
   \   000020   7418         MOV       A,#0x18
   \   000022   12....       LCALL     ?XSTACK_DISP0_8
   \   000025   E0           MOVX      A,@DPTR
   \   000026   F5..         MOV       ?V0,A
   \   000028   7419         MOV       A,#0x19
   \   00002A   12....       LCALL     ?XSTACK_DISP0_8
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   F5..         MOV       ?V1,A
   \   000030   741A         MOV       A,#0x1a
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   E0           MOVX      A,@DPTR
   \   000036   FE           MOV       R6,A
   \   000037   A3           INC       DPTR
   \   000038   E0           MOVX      A,@DPTR
   \   000039   FF           MOV       R7,A
   \   00003A   741C         MOV       A,#0x1c
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F5..         MOV       ?V2,A
   1871            uint8 buf[2]; // Command ID and Status;
   1872          
   1873            // Load the buffer - serially
   1874            buf[0] = defaultRspCmd->commandID;
   \   000042   85..82       MOV       DPL,?V4
   \   000045   85..83       MOV       DPH,?V5
   \   000048   E0           MOVX      A,@DPTR
   \   000049   C0E0         PUSH      A
   \   00004B   85..82       MOV       DPL,?XSP + 0
   \   00004E   85..83       MOV       DPH,?XSP + 1
   \   000051   D0E0         POP       A
   \   000053   F0           MOVX      @DPTR,A
   1875            buf[1] = defaultRspCmd->statusCode;
   \   000054   85..82       MOV       DPL,?V4
   \   000057   85..83       MOV       DPH,?V5
   \   00005A   A3           INC       DPTR
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   C0E0         PUSH      A
   \   00005E   7401         MOV       A,#0x1
   \   000060   12....       LCALL     ?XSTACK_DISP0_8
   \   000063   D0E0         POP       A
   \   000065   F0           MOVX      @DPTR,A
   1876          
   1877            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1878                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000066                ; Setup parameters for call to function zcl_SendCommand
   \   000066   A8..         MOV       R0,?XSP + 0
   \   000068   A9..         MOV       R1,?XSP + 1
   \   00006A   88..         MOV       ?V8,R0
   \   00006C   89..         MOV       ?V9,R1
   \   00006E   78..         MOV       R0,#?V8
   \   000070   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000073   75..02       MOV       ?V8,#0x2
   \   000076   75..00       MOV       ?V9,#0x0
   \   000079   78..         MOV       R0,#?V8
   \   00007B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007E   E5..         MOV       A,?V2
   \   000080   F5..         MOV       ?V8,A
   \   000082   78..         MOV       R0,#?V8
   \   000084   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000087   8E..         MOV       ?V8,R6
   \   000089   8F..         MOV       ?V9,R7
   \   00008B   78..         MOV       R0,#?V8
   \   00008D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000090   E5..         MOV       A,?V1
   \   000092   F5..         MOV       ?V8,A
   \   000094   78..         MOV       R0,#?V8
   \   000096   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000099   E5..         MOV       A,?V0
   \   00009B   F5..         MOV       ?V8,A
   \   00009D   78..         MOV       R0,#?V8
   \   00009F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A2   75..00       MOV       ?V8,#0x0
   \   0000A5   78..         MOV       R0,#?V8
   \   0000A7   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000AA   75..0B       MOV       ?V8,#0xb
   \   0000AD   78..         MOV       R0,#?V8
   \   0000AF   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B2   AC..         MOV       R4,?V6
   \   0000B4   AD..         MOV       R5,?V7
   \   0000B6   AA..         MOV       R2,?V10
   \   0000B8   AB..         MOV       R3,?V11
   \   0000BA   A9..         MOV       R1,?V3
   \   0000BC   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000BF   740B         MOV       A,#0xb
   \   0000C1   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C4   7402         MOV       A,#0x2
   \   0000C6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C9   7F0C         MOV       R7,#0xc
   \   0000CB   02....       LJMP      ?BANKED_LEAVE_XDATA
   1879          }
   1880          
   1881          #ifdef ZCL_DISCOVER
   1882          /*********************************************************************
   1883           * @fn      zcl_SendDiscoverCmdsCmd
   1884           *
   1885           * @brief   Send a Discover Commands command
   1886           *
   1887           * @param   dstAddr - destination address
   1888           * @param   clusterID - cluster ID
   1889           * @param   cmdType - requesting command ID
   1890           * @param   pDiscoverCmd - discover command to be sent
   1891           * @param   direction - direction of the command
   1892           * @param   seqNum - transaction sequence number
   1893           *
   1894           * @return  ZSuccess if OK
   1895           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1896          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDiscoverCmdsCmd:
   1897                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1898                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1899          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FF           MOV       R7,A
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   8C..         MOV       ?V8,R4
   \   000012   8D..         MOV       ?V9,R5
   \   000014   7416         MOV       A,#0x16
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V3,A
   \   00001C   7417         MOV       A,#0x17
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F5..         MOV       ?V10,A
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   F5..         MOV       ?V11,A
   \   000028   7419         MOV       A,#0x19
   \   00002A   12....       LCALL     ?XSTACK_DISP0_8
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   F5..         MOV       ?V2,A
   \   000030   741A         MOV       A,#0x1a
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   E0           MOVX      A,@DPTR
   \   000036   F5..         MOV       ?V1,A
   \   000038   741B         MOV       A,#0x1b
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   F5..         MOV       ?V0,A
   1900            uint8 payload[2]; // size of startCmdID and maxCmdID
   1901            ZStatus_t status;
   1902          
   1903            payload[0] = pDiscoverCmd->startCmdID;
   \   000040   85..82       MOV       DPL,?V10
   \   000043   85..83       MOV       DPH,?V11
   \   000046   E0           MOVX      A,@DPTR
   \   000047   C0E0         PUSH      A
   \   000049   85..82       MOV       DPL,?XSP + 0
   \   00004C   85..83       MOV       DPH,?XSP + 1
   \   00004F   D0E0         POP       A
   \   000051   F0           MOVX      @DPTR,A
   1904            payload[1] = pDiscoverCmd->maxCmdID;
   \   000052   85..82       MOV       DPL,?V10
   \   000055   85..83       MOV       DPH,?V11
   \   000058   A3           INC       DPTR
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   C0E0         PUSH      A
   \   00005C   7401         MOV       A,#0x1
   \   00005E   12....       LCALL     ?XSTACK_DISP0_8
   \   000061   D0E0         POP       A
   \   000063   F0           MOVX      @DPTR,A
   1905          
   1906            // Send message for either commands received or generated
   1907            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   \   000064   7411         MOV       A,#0x11
   \   000066   65..         XRL       A,?V3
   \   000068   7063         JNZ       ??zcl_SendDiscoverCmdsCmd_0
   1908            {
   1909              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1910                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   \   00006A                ; Setup parameters for call to function zcl_SendCommand
   \   00006A   A8..         MOV       R0,?XSP + 0
   \   00006C   A9..         MOV       R1,?XSP + 1
   \   00006E   88..         MOV       ?V6,R0
   \   000070   89..         MOV       ?V7,R1
   \   000072   78..         MOV       R0,#?V6
   \   000074   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000077   75..02       MOV       ?V6,#0x2
   \   00007A   75..00       MOV       ?V7,#0x0
   \   00007D   78..         MOV       R0,#?V6
   \   00007F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000082   E5..         MOV       A,?V0
   \   000084   F5..         MOV       ?V6,A
   \   000086   78..         MOV       R0,#?V6
   \   000088   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008B   E4           CLR       A
   \   00008C   F5..         MOV       ?V6,A
   \   00008E   F5..         MOV       ?V7,A
   \   000090   78..         MOV       R0,#?V6
   \   000092   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000095   E5..         MOV       A,?V1
   \   000097   F5..         MOV       ?V6,A
   \   000099   78..         MOV       R0,#?V6
   \   00009B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00009E   E5..         MOV       A,?V2
   \   0000A0   F5..         MOV       ?V6,A
   \   0000A2   78..         MOV       R0,#?V6
   \   0000A4   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A7   75..00       MOV       ?V6,#0x0
   \   0000AA   78..         MOV       R0,#?V6
   \   0000AC   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000AF   75..11       MOV       ?V6,#0x11
   \   0000B2   78..         MOV       R0,#?V6
   \   0000B4   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B7   AC..         MOV       R4,?V8
   \   0000B9   AD..         MOV       R5,?V9
   \   0000BB   AA..         MOV       R2,?V4
   \   0000BD   AB..         MOV       R3,?V5
   \   0000BF   EF           MOV       A,R7
   \   0000C0   F9           MOV       R1,A
   \   0000C1   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000C4   740B         MOV       A,#0xb
   \   0000C6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C9   E9           MOV       A,R1
   \   0000CA   FE           MOV       R6,A
   \   0000CB   8061         SJMP      ??zcl_SendDiscoverCmdsCmd_1
   1911            }
   1912            else  // generated
   1913            {
   1914              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1915                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   \                     ??zcl_SendDiscoverCmdsCmd_0:
   \   0000CD                ; Setup parameters for call to function zcl_SendCommand
   \   0000CD   A8..         MOV       R0,?XSP + 0
   \   0000CF   A9..         MOV       R1,?XSP + 1
   \   0000D1   88..         MOV       ?V6,R0
   \   0000D3   89..         MOV       ?V7,R1
   \   0000D5   78..         MOV       R0,#?V6
   \   0000D7   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000DA   75..02       MOV       ?V6,#0x2
   \   0000DD   75..00       MOV       ?V7,#0x0
   \   0000E0   78..         MOV       R0,#?V6
   \   0000E2   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000E5   E5..         MOV       A,?V0
   \   0000E7   F5..         MOV       ?V6,A
   \   0000E9   78..         MOV       R0,#?V6
   \   0000EB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000EE   E4           CLR       A
   \   0000EF   F5..         MOV       ?V6,A
   \   0000F1   F5..         MOV       ?V7,A
   \   0000F3   78..         MOV       R0,#?V6
   \   0000F5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000F8   E5..         MOV       A,?V1
   \   0000FA   F5..         MOV       ?V6,A
   \   0000FC   78..         MOV       R0,#?V6
   \   0000FE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000101   E5..         MOV       A,?V2
   \   000103   F5..         MOV       ?V6,A
   \   000105   78..         MOV       R0,#?V6
   \   000107   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00010A   75..00       MOV       ?V6,#0x0
   \   00010D   78..         MOV       R0,#?V6
   \   00010F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000112   75..13       MOV       ?V6,#0x13
   \   000115   78..         MOV       R0,#?V6
   \   000117   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00011A   AC..         MOV       R4,?V8
   \   00011C   AD..         MOV       R5,?V9
   \   00011E   AA..         MOV       R2,?V4
   \   000120   AB..         MOV       R3,?V5
   \   000122   EF           MOV       A,R7
   \   000123   F9           MOV       R1,A
   \   000124   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000127   740B         MOV       A,#0xb
   \   000129   12....       LCALL     ?DEALLOC_XSTACK8
   \   00012C   E9           MOV       A,R1
   \   00012D   FE           MOV       R6,A
   1916            }
   1917          
   1918            return ( status );
   \                     ??zcl_SendDiscoverCmdsCmd_1:
   \   00012E   EE           MOV       A,R6
   \   00012F   F9           MOV       R1,A
   \   000130   7402         MOV       A,#0x2
   \   000132   12....       LCALL     ?DEALLOC_XSTACK8
   \   000135   7F0C         MOV       R7,#0xc
   \   000137   02....       LJMP      ?BANKED_LEAVE_XDATA
   1919          }
   1920          
   1921          /*********************************************************************
   1922           * @fn      zcl_SendDiscoverCmdsRspCmd
   1923           *
   1924           * @brief   Send a Discover Commands Response command
   1925           *
   1926           * @param   dstAddr - destination address
   1927           * @param   clusterID - cluster ID
   1928           * @param   pDiscoverRspCmd - response command to be sent
   1929           * @param   direction - direction of the command
   1930           * @param   seqNum - transaction sequence number
   1931           *
   1932           * @return  ZSuccess if OK
   1933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1934          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverCmdsRspCmd:
   1935                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1936                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1937          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EC           MOV       A,R4
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   ED           MOV       A,R5
   \   000014   F0           MOVX      @DPTR,A
   \   000015   89..         MOV       ?V7,R1
   \   000017   8A..         MOV       ?V14,R2
   \   000019   8B..         MOV       ?V15,R3
   \   00001B   741A         MOV       A,#0x1a
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V2,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F5..         MOV       ?V3,A
   \   000027   741C         MOV       A,#0x1c
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F5..         MOV       ?V12,A
   \   00002F   741D         MOV       A,#0x1d
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F5..         MOV       ?V11,A
   \   000037   741E         MOV       A,#0x1e
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F5..         MOV       ?V10,A
   1938            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   \   00003F   85..82       MOV       DPL,?V2
   \   000042   85..83       MOV       DPH,?V3
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   2401         ADD       A,#0x1
   \   00004A   F5..         MOV       ?V6,A
   1939            uint8 *pCmdBuf;
   1940            uint8 i;
   1941            ZStatus_t status = ZSuccess;
   \   00004C   7E00         MOV       R6,#0x0
   1942          
   1943            // allocate memory
   1944            pCmdBuf = zcl_mem_alloc( payloadSize );
   \   00004E                ; Setup parameters for call to function osal_mem_alloc
   \   00004E   E5..         MOV       A,?V6
   \   000050   FA           MOV       R2,A
   \   000051   7B00         MOV       R3,#0x0
   \   000053   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000056   8A..         MOV       ?V0,R2
   \   000058   8B..         MOV       ?V1,R3
   \   00005A   85....       MOV       ?V4,?V0
   \   00005D   85....       MOV       ?V5,?V1
   1945            if ( pCmdBuf != NULL )
   \   000060   E5..         MOV       A,?V4
   \   000062   45..         ORL       A,?V5
   \   000064   7003         JNZ       $+5
   \   000066   02....       LJMP      ??zcl_SendDiscoverCmdsRspCmd_0 & 0xFFFF
   1946            {
   1947              uint8 *pBuf = pCmdBuf;
   \   000069   85....       MOV       ?V0,?V4
   \   00006C   85....       MOV       ?V1,?V5
   1948          
   1949              // Load the buffer - serially
   1950              *pBuf++ = pDiscoverRspCmd->discComplete;
   \   00006F   85..82       MOV       DPL,?V2
   \   000072   85..83       MOV       DPH,?V3
   \   000075   E0           MOVX      A,@DPTR
   \   000076   C0E0         PUSH      A
   \   000078   85..82       MOV       DPL,?V0
   \   00007B   85..83       MOV       DPH,?V1
   \   00007E   D0E0         POP       A
   \   000080   F0           MOVX      @DPTR,A
   \   000081   85..82       MOV       DPL,?V0
   \   000084   85..83       MOV       DPH,?V1
   \   000087   A3           INC       DPTR
   \   000088   8582..       MOV       ?V0,DPL
   \   00008B   8583..       MOV       ?V1,DPH
   1951              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   \   00008E   7F00         MOV       R7,#0x0
   \                     ??zcl_SendDiscoverCmdsRspCmd_1:
   \   000090   85..82       MOV       DPL,?V2
   \   000093   85..83       MOV       DPH,?V3
   \   000096   A3           INC       DPTR
   \   000097   A3           INC       DPTR
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F8           MOV       R0,A
   \   00009A   EF           MOV       A,R7
   \   00009B   C3           CLR       C
   \   00009C   98           SUBB      A,R0
   \   00009D   5033         JNC       ??zcl_SendDiscoverCmdsRspCmd_2
   1952              {
   1953                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   \   00009F   EF           MOV       A,R7
   \   0000A0   F8           MOV       R0,A
   \   0000A1   7900         MOV       R1,#0x0
   \   0000A3   85..82       MOV       DPL,?V2
   \   0000A6   85..83       MOV       DPH,?V3
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   A3           INC       DPTR
   \   0000AC   E0           MOVX      A,@DPTR
   \   0000AD   28           ADD       A,R0
   \   0000AE   FA           MOV       R2,A
   \   0000AF   A3           INC       DPTR
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   39           ADDC      A,R1
   \   0000B2   8A82         MOV       DPL,R2
   \   0000B4   F583         MOV       DPH,A
   \   0000B6   E0           MOVX      A,@DPTR
   \   0000B7   C0E0         PUSH      A
   \   0000B9   85..82       MOV       DPL,?V0
   \   0000BC   85..83       MOV       DPH,?V1
   \   0000BF   D0E0         POP       A
   \   0000C1   F0           MOVX      @DPTR,A
   \   0000C2   85..82       MOV       DPL,?V0
   \   0000C5   85..83       MOV       DPH,?V1
   \   0000C8   A3           INC       DPTR
   \   0000C9   8582..       MOV       ?V0,DPL
   \   0000CC   8583..       MOV       ?V1,DPH
   1954              }
   \   0000CF   0F           INC       R7
   \   0000D0   80BE         SJMP      ??zcl_SendDiscoverCmdsRspCmd_1
   1955          
   1956              // Send response message for either commands received or generated
   1957              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   \                     ??zcl_SendDiscoverCmdsRspCmd_2:
   \   0000D2   85..82       MOV       DPL,?V2
   \   0000D5   85..83       MOV       DPH,?V3
   \   0000D8   A3           INC       DPTR
   \   0000D9   E0           MOVX      A,@DPTR
   \   0000DA   6411         XRL       A,#0x11
   \   0000DC   7062         JNZ       ??zcl_SendDiscoverCmdsRspCmd_3
   1958              {
   1959                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1960                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   \   0000DE                ; Setup parameters for call to function zcl_SendCommand
   \   0000DE   78..         MOV       R0,#?V4
   \   0000E0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000E3   E5..         MOV       A,?V6
   \   0000E5   F5..         MOV       ?V8,A
   \   0000E7   75..00       MOV       ?V9,#0x0
   \   0000EA   78..         MOV       R0,#?V8
   \   0000EC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000EF   E5..         MOV       A,?V10
   \   0000F1   F5..         MOV       ?V8,A
   \   0000F3   78..         MOV       R0,#?V8
   \   0000F5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000F8   E4           CLR       A
   \   0000F9   F5..         MOV       ?V8,A
   \   0000FB   F5..         MOV       ?V9,A
   \   0000FD   78..         MOV       R0,#?V8
   \   0000FF   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000102   E5..         MOV       A,?V11
   \   000104   F5..         MOV       ?V8,A
   \   000106   78..         MOV       R0,#?V8
   \   000108   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00010B   E5..         MOV       A,?V12
   \   00010D   F5..         MOV       ?V8,A
   \   00010F   78..         MOV       R0,#?V8
   \   000111   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000114   75..00       MOV       ?V8,#0x0
   \   000117   78..         MOV       R0,#?V8
   \   000119   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00011C   75..12       MOV       ?V8,#0x12
   \   00011F   78..         MOV       R0,#?V8
   \   000121   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000124   740B         MOV       A,#0xb
   \   000126   12....       LCALL     ?XSTACK_DISP0_8
   \   000129   E0           MOVX      A,@DPTR
   \   00012A   FC           MOV       R4,A
   \   00012B   A3           INC       DPTR
   \   00012C   E0           MOVX      A,@DPTR
   \   00012D   FD           MOV       R5,A
   \   00012E   AA..         MOV       R2,?V14
   \   000130   AB..         MOV       R3,?V15
   \   000132   A9..         MOV       R1,?V7
   \   000134   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000137   740B         MOV       A,#0xb
   \   000139   12....       LCALL     ?DEALLOC_XSTACK8
   \   00013C   E9           MOV       A,R1
   \   00013D   FE           MOV       R6,A
   \   00013E   806C         SJMP      ??zcl_SendDiscoverCmdsRspCmd_4
   1961              }
   1962              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   \                     ??zcl_SendDiscoverCmdsRspCmd_3:
   \   000140   85..82       MOV       DPL,?V2
   \   000143   85..83       MOV       DPH,?V3
   \   000146   A3           INC       DPTR
   \   000147   E0           MOVX      A,@DPTR
   \   000148   6413         XRL       A,#0x13
   \   00014A   7060         JNZ       ??zcl_SendDiscoverCmdsRspCmd_4
   1963              {
   1964                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1965                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   \   00014C                ; Setup parameters for call to function zcl_SendCommand
   \   00014C   78..         MOV       R0,#?V4
   \   00014E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000151   E5..         MOV       A,?V6
   \   000153   F5..         MOV       ?V8,A
   \   000155   75..00       MOV       ?V9,#0x0
   \   000158   78..         MOV       R0,#?V8
   \   00015A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00015D   E5..         MOV       A,?V10
   \   00015F   F5..         MOV       ?V8,A
   \   000161   78..         MOV       R0,#?V8
   \   000163   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000166   E4           CLR       A
   \   000167   F5..         MOV       ?V8,A
   \   000169   F5..         MOV       ?V9,A
   \   00016B   78..         MOV       R0,#?V8
   \   00016D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000170   E5..         MOV       A,?V11
   \   000172   F5..         MOV       ?V8,A
   \   000174   78..         MOV       R0,#?V8
   \   000176   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000179   E5..         MOV       A,?V12
   \   00017B   F5..         MOV       ?V8,A
   \   00017D   78..         MOV       R0,#?V8
   \   00017F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000182   75..00       MOV       ?V8,#0x0
   \   000185   78..         MOV       R0,#?V8
   \   000187   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00018A   75..14       MOV       ?V8,#0x14
   \   00018D   78..         MOV       R0,#?V8
   \   00018F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000192   740B         MOV       A,#0xb
   \   000194   12....       LCALL     ?XSTACK_DISP0_8
   \   000197   E0           MOVX      A,@DPTR
   \   000198   FC           MOV       R4,A
   \   000199   A3           INC       DPTR
   \   00019A   E0           MOVX      A,@DPTR
   \   00019B   FD           MOV       R5,A
   \   00019C   AA..         MOV       R2,?V14
   \   00019E   AB..         MOV       R3,?V15
   \   0001A0   A9..         MOV       R1,?V7
   \   0001A2   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001A5   740B         MOV       A,#0xb
   \   0001A7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001AA   E9           MOV       A,R1
   \   0001AB   FE           MOV       R6,A
   1966              }
   1967          
   1968              zcl_mem_free( pCmdBuf );
   \                     ??zcl_SendDiscoverCmdsRspCmd_4:
   \   0001AC                ; Setup parameters for call to function osal_mem_free
   \   0001AC   AA..         MOV       R2,?V4
   \   0001AE   AB..         MOV       R3,?V5
   \   0001B0   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001B3   8002         SJMP      ??zcl_SendDiscoverCmdsRspCmd_5
   1969            }
   1970            else
   1971            {
   1972              status = ZMemError;
   \                     ??zcl_SendDiscoverCmdsRspCmd_0:
   \   0001B5   7E10         MOV       R6,#0x10
   1973            }
   1974          
   1975            return ( status );
   \                     ??zcl_SendDiscoverCmdsRspCmd_5:
   \   0001B7   EE           MOV       A,R6
   \   0001B8   F9           MOV       R1,A
   \   0001B9   7402         MOV       A,#0x2
   \   0001BB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001BE   7F10         MOV       R7,#0x10
   \   0001C0   02....       LJMP      ?BANKED_LEAVE_XDATA
   1976          }
   1977          
   1978          /*********************************************************************
   1979           * @fn      zcl_SendDiscoverAttrsCmd
   1980           *
   1981           * @brief   Send a Discover Attributes command
   1982           *
   1983           * @param   dstAddr - destination address
   1984           * @param   clusterID - cluster ID
   1985           * @param   pDiscoverCmd - discover command to be sent
   1986           * @param   direction - direction of the command
   1987           * @param   seqNum - transaction sequence number
   1988           *
   1989           * @return  ZSuccess if OK
   1990           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1991          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverAttrsCmd:
   1992                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1993                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1994          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V6,R1
   \   000007   8A..         MOV       ?V14,R2
   \   000009   8B..         MOV       ?V15,R3
   \   00000B   8C..         MOV       ?V12,R4
   \   00000D   8D..         MOV       ?V13,R5
   \   00000F   7418         MOV       A,#0x18
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F5..         MOV       ?V4,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F5..         MOV       ?V5,A
   \   00001B   741A         MOV       A,#0x1a
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V11,A
   \   000023   741B         MOV       A,#0x1b
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F5..         MOV       ?V10,A
   \   00002B   741C         MOV       A,#0x1c
   \   00002D   12....       LCALL     ?XSTACK_DISP0_8
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F5..         MOV       ?V7,A
   1995            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   \   000033   75..03       MOV       ?V3,#0x3
   1996            uint8 *buf;
   1997            ZStatus_t status;
   1998          
   1999            buf = zcl_mem_alloc( dataLen );
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   E5..         MOV       A,?V3
   \   000038   FA           MOV       R2,A
   \   000039   7B00         MOV       R3,#0x0
   \   00003B   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003E   8A..         MOV       ?V8,R2
   \   000040   8B..         MOV       ?V9,R3
   \   000042   85....       MOV       ?V0,?V8
   \   000045   85....       MOV       ?V1,?V9
   2000            if ( buf != NULL )
   \   000048   E5..         MOV       A,?V0
   \   00004A   45..         ORL       A,?V1
   \   00004C   7003         JNZ       $+5
   \   00004E   02....       LJMP      ??zcl_SendDiscoverAttrsCmd_0 & 0xFFFF
   2001            {
   2002              // Load the buffer - serially
   2003              uint8 *pBuf = buf;
   \   000051   AE..         MOV       R6,?V0
   \   000053   AF..         MOV       R7,?V1
   2004              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   \   000055   85..82       MOV       DPL,?V4
   \   000058   85..83       MOV       DPH,?V5
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   F8           MOV       R0,A
   \   00005D   A3           INC       DPTR
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F9           MOV       R1,A
   \   000060   E8           MOV       A,R0
   \   000061   C0E0         PUSH      A
   \   000063   8E82         MOV       DPL,R6
   \   000065   8F83         MOV       DPH,R7
   \   000067   D0E0         POP       A
   \   000069   F0           MOVX      @DPTR,A
   \   00006A   8E82         MOV       DPL,R6
   \   00006C   8F83         MOV       DPH,R7
   \   00006E   A3           INC       DPTR
   \   00006F   AE82         MOV       R6,DPL
   \   000071   AF83         MOV       R7,DPH
   2005              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   \   000073   85..82       MOV       DPL,?V4
   \   000076   85..83       MOV       DPH,?V5
   \   000079   E0           MOVX      A,@DPTR
   \   00007A   F8           MOV       R0,A
   \   00007B   A3           INC       DPTR
   \   00007C   E0           MOVX      A,@DPTR
   \   00007D   F9           MOV       R1,A
   \   00007E   E4           CLR       A
   \   00007F   C9           XCH       A,R1
   \   000080   F8           MOV       R0,A
   \   000081   E8           MOV       A,R0
   \   000082   C0E0         PUSH      A
   \   000084   8E82         MOV       DPL,R6
   \   000086   8F83         MOV       DPH,R7
   \   000088   D0E0         POP       A
   \   00008A   F0           MOVX      @DPTR,A
   \   00008B   8E82         MOV       DPL,R6
   \   00008D   8F83         MOV       DPH,R7
   \   00008F   A3           INC       DPTR
   \   000090   AE82         MOV       R6,DPL
   \   000092   AF83         MOV       R7,DPH
   2006              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   \   000094   85..82       MOV       DPL,?V4
   \   000097   85..83       MOV       DPH,?V5
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   C0E0         PUSH      A
   \   00009F   8E82         MOV       DPL,R6
   \   0000A1   8F83         MOV       DPH,R7
   \   0000A3   D0E0         POP       A
   \   0000A5   F0           MOVX      @DPTR,A
   \   0000A6   8E82         MOV       DPL,R6
   \   0000A8   8F83         MOV       DPH,R7
   \   0000AA   A3           INC       DPTR
   \   0000AB   AE82         MOV       R6,DPL
   \   0000AD   AF83         MOV       R7,DPH
   2007          
   2008              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   2009                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   0000AF                ; Setup parameters for call to function zcl_SendCommand
   \   0000AF   78..         MOV       R0,#?V0
   \   0000B1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B4   E5..         MOV       A,?V3
   \   0000B6   F5..         MOV       ?V8,A
   \   0000B8   75..00       MOV       ?V9,#0x0
   \   0000BB   78..         MOV       R0,#?V8
   \   0000BD   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C0   E5..         MOV       A,?V7
   \   0000C2   F5..         MOV       ?V8,A
   \   0000C4   78..         MOV       R0,#?V8
   \   0000C6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C9   E4           CLR       A
   \   0000CA   F5..         MOV       ?V8,A
   \   0000CC   F5..         MOV       ?V9,A
   \   0000CE   78..         MOV       R0,#?V8
   \   0000D0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000D3   E5..         MOV       A,?V10
   \   0000D5   F5..         MOV       ?V8,A
   \   0000D7   78..         MOV       R0,#?V8
   \   0000D9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000DC   E5..         MOV       A,?V11
   \   0000DE   F5..         MOV       ?V8,A
   \   0000E0   78..         MOV       R0,#?V8
   \   0000E2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E5   75..00       MOV       ?V8,#0x0
   \   0000E8   78..         MOV       R0,#?V8
   \   0000EA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000ED   75..0C       MOV       ?V8,#0xc
   \   0000F0   78..         MOV       R0,#?V8
   \   0000F2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000F5   AC..         MOV       R4,?V12
   \   0000F7   AD..         MOV       R5,?V13
   \   0000F9   AA..         MOV       R2,?V14
   \   0000FB   AB..         MOV       R3,?V15
   \   0000FD   A9..         MOV       R1,?V6
   \   0000FF   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000102   740B         MOV       A,#0xb
   \   000104   12....       LCALL     ?DEALLOC_XSTACK8
   \   000107   E9           MOV       A,R1
   \   000108   F5..         MOV       ?V2,A
   2010              zcl_mem_free( buf );
   \   00010A                ; Setup parameters for call to function osal_mem_free
   \   00010A   AA..         MOV       R2,?V0
   \   00010C   AB..         MOV       R3,?V1
   \   00010E   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000111   8003         SJMP      ??zcl_SendDiscoverAttrsCmd_1
   2011            }
   2012            else
   2013            {
   2014              status = ZMemError;
   \                     ??zcl_SendDiscoverAttrsCmd_0:
   \   000113   75..10       MOV       ?V2,#0x10
   2015            }
   2016          
   2017            return ( status );
   \                     ??zcl_SendDiscoverAttrsCmd_1:
   \   000116   A9..         MOV       R1,?V2
   \   000118   7F10         MOV       R7,#0x10
   \   00011A   02....       LJMP      ?BANKED_LEAVE_XDATA
   2018          }
   2019          
   2020          /*********************************************************************
   2021           * @fn      zcl_SendDiscoverAttrsRspCmd
   2022           *
   2023           * @brief   Send a Discover Attributes Response command
   2024           *
   2025           * @param   dstAddr - destination address
   2026           * @param   clusterID - cluster ID
   2027           * @param   reportRspCmd - report response command to be sent
   2028           * @param   direction - direction of the command
   2029           * @param   seqNum - transaction sequence number
   2030           *
   2031           * @return  ZSuccess if OK
   2032           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2033          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverAttrsRspCmd:
   2034                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   2035                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2036          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   89..         MOV       ?V8,R1
   \   000017   8C..         MOV       ?V14,R4
   \   000019   8D..         MOV       ?V15,R5
   \   00001B   741A         MOV       A,#0x1a
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V4,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F5..         MOV       ?V5,A
   \   000027   741C         MOV       A,#0x1c
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F5..         MOV       ?V13,A
   \   00002F   741D         MOV       A,#0x1d
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F5..         MOV       ?V12,A
   \   000037   741E         MOV       A,#0x1e
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F5..         MOV       ?V9,A
   2037            uint16 dataLen = 1; // Discovery complete
   \   00003F   75..01       MOV       ?V0,#0x1
   \   000042   75..00       MOV       ?V1,#0x0
   2038            uint8 *buf;
   2039            ZStatus_t status;
   2040          
   2041            // calculate the size of the command
   2042            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   \   000045   85..82       MOV       DPL,?V4
   \   000048   85..83       MOV       DPH,?V5
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   F8           MOV       R0,A
   \   00004E   7900         MOV       R1,#0x0
   \   000050   E8           MOV       A,R0
   \   000051   75F003       MOV       B,#0x3
   \   000054   A4           MUL       AB
   \   000055   C8           XCH       A,R0
   \   000056   AAF0         MOV       R2,B
   \   000058   75F000       MOV       B,#0x0
   \   00005B   A4           MUL       AB
   \   00005C   2A           ADD       A,R2
   \   00005D   FA           MOV       R2,A
   \   00005E   75F003       MOV       B,#0x3
   \   000061   E9           MOV       A,R1
   \   000062   A4           MUL       AB
   \   000063   2A           ADD       A,R2
   \   000064   F9           MOV       R1,A
   \   000065   E5..         MOV       A,?V0
   \   000067   28           ADD       A,R0
   \   000068   F5..         MOV       ?V0,A
   \   00006A   E5..         MOV       A,?V1
   \   00006C   39           ADDC      A,R1
   \   00006D   F5..         MOV       ?V1,A
   2043          
   2044            buf = zcl_mem_alloc( dataLen );
   \   00006F                ; Setup parameters for call to function osal_mem_alloc
   \   00006F   AA..         MOV       R2,?V0
   \   000071   AB..         MOV       R3,?V1
   \   000073   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000076   8A..         MOV       ?V10,R2
   \   000078   8B..         MOV       ?V11,R3
   \   00007A   85....       MOV       ?V6,?V10
   \   00007D   85....       MOV       ?V7,?V11
   2045            if ( buf != NULL )
   \   000080   E5..         MOV       A,?V6
   \   000082   45..         ORL       A,?V7
   \   000084   7003         JNZ       $+5
   \   000086   02....       LJMP      ??zcl_SendDiscoverAttrsRspCmd_0 & 0xFFFF
   2046            {
   2047              // Load the buffer - serially
   2048              uint8 i;
   2049              uint8 *pBuf = buf;
   \   000089   AE..         MOV       R6,?V6
   \   00008B   AF..         MOV       R7,?V7
   2050          
   2051              *pBuf++ = pDiscoverRspCmd->discComplete;
   \   00008D   85..82       MOV       DPL,?V4
   \   000090   85..83       MOV       DPH,?V5
   \   000093   E0           MOVX      A,@DPTR
   \   000094   C0E0         PUSH      A
   \   000096   8E82         MOV       DPL,R6
   \   000098   8F83         MOV       DPH,R7
   \   00009A   D0E0         POP       A
   \   00009C   F0           MOVX      @DPTR,A
   \   00009D   8E82         MOV       DPL,R6
   \   00009F   8F83         MOV       DPH,R7
   \   0000A1   A3           INC       DPTR
   \   0000A2   AE82         MOV       R6,DPL
   \   0000A4   AF83         MOV       R7,DPH
   2052          
   2053              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   \   0000A6   75..00       MOV       ?V2,#0x0
   \                     ??zcl_SendDiscoverAttrsRspCmd_1:
   \   0000A9   85..82       MOV       DPL,?V4
   \   0000AC   85..83       MOV       DPH,?V5
   \   0000AF   A3           INC       DPTR
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   F8           MOV       R0,A
   \   0000B2   E5..         MOV       A,?V2
   \   0000B4   C3           CLR       C
   \   0000B5   98           SUBB      A,R0
   \   0000B6   4003         JC        $+5
   \   0000B8   02....       LJMP      ??zcl_SendDiscoverAttrsRspCmd_2 & 0xFFFF
   2054              {
   2055                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   \   0000BB   E5..         MOV       A,?V2
   \   0000BD   F8           MOV       R0,A
   \   0000BE   7900         MOV       R1,#0x0
   \   0000C0   E8           MOV       A,R0
   \   0000C1   75F003       MOV       B,#0x3
   \   0000C4   A4           MUL       AB
   \   0000C5   C8           XCH       A,R0
   \   0000C6   AAF0         MOV       R2,B
   \   0000C8   75F000       MOV       B,#0x0
   \   0000CB   A4           MUL       AB
   \   0000CC   2A           ADD       A,R2
   \   0000CD   FA           MOV       R2,A
   \   0000CE   75F003       MOV       B,#0x3
   \   0000D1   E9           MOV       A,R1
   \   0000D2   A4           MUL       AB
   \   0000D3   2A           ADD       A,R2
   \   0000D4   F9           MOV       R1,A
   \   0000D5   E5..         MOV       A,?V4
   \   0000D7   28           ADD       A,R0
   \   0000D8   F582         MOV       DPL,A
   \   0000DA   E5..         MOV       A,?V5
   \   0000DC   39           ADDC      A,R1
   \   0000DD   F583         MOV       DPH,A
   \   0000DF   A3           INC       DPTR
   \   0000E0   A3           INC       DPTR
   \   0000E1   E0           MOVX      A,@DPTR
   \   0000E2   F8           MOV       R0,A
   \   0000E3   A3           INC       DPTR
   \   0000E4   E0           MOVX      A,@DPTR
   \   0000E5   F9           MOV       R1,A
   \   0000E6   E8           MOV       A,R0
   \   0000E7   C0E0         PUSH      A
   \   0000E9   8E82         MOV       DPL,R6
   \   0000EB   8F83         MOV       DPH,R7
   \   0000ED   D0E0         POP       A
   \   0000EF   F0           MOVX      @DPTR,A
   \   0000F0   8E82         MOV       DPL,R6
   \   0000F2   8F83         MOV       DPH,R7
   \   0000F4   A3           INC       DPTR
   \   0000F5   AE82         MOV       R6,DPL
   \   0000F7   AF83         MOV       R7,DPH
   2056                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   \   0000F9   E5..         MOV       A,?V2
   \   0000FB   F8           MOV       R0,A
   \   0000FC   7900         MOV       R1,#0x0
   \   0000FE   E8           MOV       A,R0
   \   0000FF   75F003       MOV       B,#0x3
   \   000102   A4           MUL       AB
   \   000103   C8           XCH       A,R0
   \   000104   AAF0         MOV       R2,B
   \   000106   75F000       MOV       B,#0x0
   \   000109   A4           MUL       AB
   \   00010A   2A           ADD       A,R2
   \   00010B   FA           MOV       R2,A
   \   00010C   75F003       MOV       B,#0x3
   \   00010F   E9           MOV       A,R1
   \   000110   A4           MUL       AB
   \   000111   2A           ADD       A,R2
   \   000112   F9           MOV       R1,A
   \   000113   E5..         MOV       A,?V4
   \   000115   28           ADD       A,R0
   \   000116   F582         MOV       DPL,A
   \   000118   E5..         MOV       A,?V5
   \   00011A   39           ADDC      A,R1
   \   00011B   F583         MOV       DPH,A
   \   00011D   A3           INC       DPTR
   \   00011E   A3           INC       DPTR
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   F8           MOV       R0,A
   \   000121   A3           INC       DPTR
   \   000122   E0           MOVX      A,@DPTR
   \   000123   F9           MOV       R1,A
   \   000124   E4           CLR       A
   \   000125   C9           XCH       A,R1
   \   000126   F8           MOV       R0,A
   \   000127   E8           MOV       A,R0
   \   000128   C0E0         PUSH      A
   \   00012A   8E82         MOV       DPL,R6
   \   00012C   8F83         MOV       DPH,R7
   \   00012E   D0E0         POP       A
   \   000130   F0           MOVX      @DPTR,A
   \   000131   8E82         MOV       DPL,R6
   \   000133   8F83         MOV       DPH,R7
   \   000135   A3           INC       DPTR
   \   000136   AE82         MOV       R6,DPL
   \   000138   AF83         MOV       R7,DPH
   2057                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   \   00013A   E5..         MOV       A,?V2
   \   00013C   F8           MOV       R0,A
   \   00013D   7900         MOV       R1,#0x0
   \   00013F   E8           MOV       A,R0
   \   000140   75F003       MOV       B,#0x3
   \   000143   A4           MUL       AB
   \   000144   C8           XCH       A,R0
   \   000145   AAF0         MOV       R2,B
   \   000147   75F000       MOV       B,#0x0
   \   00014A   A4           MUL       AB
   \   00014B   2A           ADD       A,R2
   \   00014C   FA           MOV       R2,A
   \   00014D   75F003       MOV       B,#0x3
   \   000150   E9           MOV       A,R1
   \   000151   A4           MUL       AB
   \   000152   2A           ADD       A,R2
   \   000153   F9           MOV       R1,A
   \   000154   E5..         MOV       A,?V4
   \   000156   28           ADD       A,R0
   \   000157   F582         MOV       DPL,A
   \   000159   E5..         MOV       A,?V5
   \   00015B   39           ADDC      A,R1
   \   00015C   F583         MOV       DPH,A
   \   00015E   A3           INC       DPTR
   \   00015F   A3           INC       DPTR
   \   000160   A3           INC       DPTR
   \   000161   A3           INC       DPTR
   \   000162   E0           MOVX      A,@DPTR
   \   000163   C0E0         PUSH      A
   \   000165   8E82         MOV       DPL,R6
   \   000167   8F83         MOV       DPH,R7
   \   000169   D0E0         POP       A
   \   00016B   F0           MOVX      @DPTR,A
   \   00016C   8E82         MOV       DPL,R6
   \   00016E   8F83         MOV       DPH,R7
   \   000170   A3           INC       DPTR
   \   000171   AE82         MOV       R6,DPL
   \   000173   AF83         MOV       R7,DPH
   2058              }
   \   000175   05..         INC       ?V2
   \   000177   02....       LJMP      ??zcl_SendDiscoverAttrsRspCmd_1 & 0xFFFF
   2059          
   2060              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   2061                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendDiscoverAttrsRspCmd_2:
   \   00017A                ; Setup parameters for call to function zcl_SendCommand
   \   00017A   78..         MOV       R0,#?V6
   \   00017C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00017F   78..         MOV       R0,#?V0
   \   000181   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000184   E5..         MOV       A,?V9
   \   000186   F5..         MOV       ?V10,A
   \   000188   78..         MOV       R0,#?V10
   \   00018A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00018D   E4           CLR       A
   \   00018E   F5..         MOV       ?V10,A
   \   000190   F5..         MOV       ?V11,A
   \   000192   78..         MOV       R0,#?V10
   \   000194   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000197   E5..         MOV       A,?V12
   \   000199   F5..         MOV       ?V10,A
   \   00019B   78..         MOV       R0,#?V10
   \   00019D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001A0   E5..         MOV       A,?V13
   \   0001A2   F5..         MOV       ?V10,A
   \   0001A4   78..         MOV       R0,#?V10
   \   0001A6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001A9   75..00       MOV       ?V10,#0x0
   \   0001AC   78..         MOV       R0,#?V10
   \   0001AE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001B1   75..0D       MOV       ?V10,#0xd
   \   0001B4   78..         MOV       R0,#?V10
   \   0001B6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001B9   AC..         MOV       R4,?V14
   \   0001BB   AD..         MOV       R5,?V15
   \   0001BD   740B         MOV       A,#0xb
   \   0001BF   12....       LCALL     ?XSTACK_DISP0_8
   \   0001C2   E0           MOVX      A,@DPTR
   \   0001C3   FA           MOV       R2,A
   \   0001C4   A3           INC       DPTR
   \   0001C5   E0           MOVX      A,@DPTR
   \   0001C6   FB           MOV       R3,A
   \   0001C7   A9..         MOV       R1,?V8
   \   0001C9   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001CC   740B         MOV       A,#0xb
   \   0001CE   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001D1   E9           MOV       A,R1
   \   0001D2   F5..         MOV       ?V3,A
   2062              zcl_mem_free( buf );
   \   0001D4                ; Setup parameters for call to function osal_mem_free
   \   0001D4   AA..         MOV       R2,?V6
   \   0001D6   AB..         MOV       R3,?V7
   \   0001D8   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001DB   8003         SJMP      ??zcl_SendDiscoverAttrsRspCmd_3
   2063            }
   2064            else
   2065            {
   2066              status = ZMemError;
   \                     ??zcl_SendDiscoverAttrsRspCmd_0:
   \   0001DD   75..10       MOV       ?V3,#0x10
   2067            }
   2068          
   2069            return ( status );
   \                     ??zcl_SendDiscoverAttrsRspCmd_3:
   \   0001E0   A9..         MOV       R1,?V3
   \   0001E2   7402         MOV       A,#0x2
   \   0001E4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001E7   7F10         MOV       R7,#0x10
   \   0001E9   02....       LJMP      ?BANKED_LEAVE_XDATA
   2070          }
   2071          
   2072          /*********************************************************************
   2073           * @fn      zcl_SendDiscoverAttrsExt
   2074           *
   2075           * @brief   Send a Discover Attributes Extended command
   2076           *
   2077           * @param   dstAddr - destination address
   2078           * @param   clusterID - cluster ID
   2079           * @param   pDiscoverAttrsExt:
   2080           *            - startAttrID: the first attribute to be selected
   2081           *            - maxAttrIDs: maximum number of returned attributes
   2082           * @param   direction - direction of the command
   2083           * @param   seqNum - transaction sequence number
   2084           *
   2085           * @return  ZSuccess if OK
   2086           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2087          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverAttrsExt:
   2088                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   2089                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2090          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V1,R1
   \   00000C   8A..         MOV       ?V10,R2
   \   00000E   8B..         MOV       ?V11,R3
   \   000010   8C..         MOV       ?V6,R4
   \   000012   8D..         MOV       ?V7,R5
   \   000014   7417         MOV       A,#0x17
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   FE           MOV       R6,A
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   FF           MOV       R7,A
   \   00001E   7419         MOV       A,#0x19
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F5..         MOV       ?V4,A
   \   000026   741A         MOV       A,#0x1a
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   F5..         MOV       ?V3,A
   \   00002E   741B         MOV       A,#0x1b
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   E0           MOVX      A,@DPTR
   \   000034   F5..         MOV       ?V2,A
   2091            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   2092            ZStatus_t status;
   2093          
   2094            // Load the buffer - serially
   2095            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   \   000036   8E82         MOV       DPL,R6
   \   000038   8F83         MOV       DPH,R7
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   F8           MOV       R0,A
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   F9           MOV       R1,A
   \   00003F   E8           MOV       A,R0
   \   000040   C0E0         PUSH      A
   \   000042   85..82       MOV       DPL,?XSP + 0
   \   000045   85..83       MOV       DPH,?XSP + 1
   \   000048   D0E0         POP       A
   \   00004A   F0           MOVX      @DPTR,A
   2096            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   \   00004B   8E82         MOV       DPL,R6
   \   00004D   8F83         MOV       DPH,R7
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   F8           MOV       R0,A
   \   000051   A3           INC       DPTR
   \   000052   E0           MOVX      A,@DPTR
   \   000053   F9           MOV       R1,A
   \   000054   E4           CLR       A
   \   000055   C9           XCH       A,R1
   \   000056   F8           MOV       R0,A
   \   000057   E8           MOV       A,R0
   \   000058   C0E0         PUSH      A
   \   00005A   7401         MOV       A,#0x1
   \   00005C   12....       LCALL     ?XSTACK_DISP0_8
   \   00005F   D0E0         POP       A
   \   000061   F0           MOVX      @DPTR,A
   2097            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   \   000062   8E82         MOV       DPL,R6
   \   000064   8F83         MOV       DPH,R7
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   E0           MOVX      A,@DPTR
   \   000069   C0E0         PUSH      A
   \   00006B   7402         MOV       A,#0x2
   \   00006D   12....       LCALL     ?XSTACK_DISP0_8
   \   000070   D0E0         POP       A
   \   000072   F0           MOVX      @DPTR,A
   2098          
   2099            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   2100                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   \   000073                ; Setup parameters for call to function zcl_SendCommand
   \   000073   A8..         MOV       R0,?XSP + 0
   \   000075   A9..         MOV       R1,?XSP + 1
   \   000077   88..         MOV       ?V8,R0
   \   000079   89..         MOV       ?V9,R1
   \   00007B   78..         MOV       R0,#?V8
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000080   75..03       MOV       ?V8,#0x3
   \   000083   75..00       MOV       ?V9,#0x0
   \   000086   78..         MOV       R0,#?V8
   \   000088   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008B   E5..         MOV       A,?V2
   \   00008D   F5..         MOV       ?V5,A
   \   00008F   78..         MOV       R0,#?V5
   \   000091   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000094   E4           CLR       A
   \   000095   F5..         MOV       ?V8,A
   \   000097   F5..         MOV       ?V9,A
   \   000099   78..         MOV       R0,#?V8
   \   00009B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009E   E5..         MOV       A,?V3
   \   0000A0   F5..         MOV       ?V5,A
   \   0000A2   78..         MOV       R0,#?V5
   \   0000A4   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A7   E5..         MOV       A,?V4
   \   0000A9   F5..         MOV       ?V5,A
   \   0000AB   78..         MOV       R0,#?V5
   \   0000AD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B0   75..00       MOV       ?V5,#0x0
   \   0000B3   78..         MOV       R0,#?V5
   \   0000B5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B8   75..15       MOV       ?V5,#0x15
   \   0000BB   78..         MOV       R0,#?V5
   \   0000BD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C0   AC..         MOV       R4,?V6
   \   0000C2   AD..         MOV       R5,?V7
   \   0000C4   AA..         MOV       R2,?V10
   \   0000C6   AB..         MOV       R3,?V11
   \   0000C8   A9..         MOV       R1,?V1
   \   0000CA   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000CD   740B         MOV       A,#0xb
   \   0000CF   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000D2   E9           MOV       A,R1
   \   0000D3   F5..         MOV       ?V0,A
   2101          
   2102            return ( status );
   \   0000D5   A9..         MOV       R1,?V0
   \   0000D7   7403         MOV       A,#0x3
   \   0000D9   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000DC   7F0C         MOV       R7,#0xc
   \   0000DE   02....       LJMP      ?BANKED_LEAVE_XDATA
   2103          }
   2104          
   2105          /*********************************************************************
   2106           * @fn      zcl_SendDiscoverAttrsExtRsp
   2107           *
   2108           * @brief   Send a Discover Attributes Extended Response command
   2109           *
   2110           * @param   dstAddr - destination address
   2111           * @param   clusterID - cluster ID
   2112           * @param   pDiscoverRspCmd:
   2113           *            - discComplete: indicates whether all requested attributes returned
   2114           *            - attrID: attribute ID
   2115           *            - attrDataType: data type of the given attribute
   2116           *            - attrAccessControl: access control of the given attribute
   2117           * @param   direction - direction of the command
   2118           * @param   seqNum - transaction sequence number
   2119           *
   2120           * @return  ZSuccess if OK
   2121           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2122          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverAttrsExtRsp:
   2123                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   2124                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2125          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   89..         MOV       ?V8,R1
   \   000017   8C..         MOV       ?V14,R4
   \   000019   8D..         MOV       ?V15,R5
   \   00001B   741A         MOV       A,#0x1a
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V2,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F5..         MOV       ?V3,A
   \   000027   741C         MOV       A,#0x1c
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F5..         MOV       ?V13,A
   \   00002F   741D         MOV       A,#0x1d
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F5..         MOV       ?V12,A
   \   000037   741E         MOV       A,#0x1e
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F5..         MOV       ?V9,A
   2126            uint8 *buf;
   2127            uint8 i;
   2128            uint16 dataLen = 1; // Discovery complete
   \   00003F   75..01       MOV       ?V0,#0x1
   \   000042   75..00       MOV       ?V1,#0x0
   2129            ZStatus_t status;
   2130          
   2131            // calculate the size of the command
   2132            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   \   000045   85..82       MOV       DPL,?V2
   \   000048   85..83       MOV       DPH,?V3
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   F8           MOV       R0,A
   \   00004E   7900         MOV       R1,#0x0
   \   000050   E8           MOV       A,R0
   \   000051   75F004       MOV       B,#0x4
   \   000054   A4           MUL       AB
   \   000055   C8           XCH       A,R0
   \   000056   AAF0         MOV       R2,B
   \   000058   75F000       MOV       B,#0x0
   \   00005B   A4           MUL       AB
   \   00005C   2A           ADD       A,R2
   \   00005D   FA           MOV       R2,A
   \   00005E   75F004       MOV       B,#0x4
   \   000061   E9           MOV       A,R1
   \   000062   A4           MUL       AB
   \   000063   2A           ADD       A,R2
   \   000064   F9           MOV       R1,A
   \   000065   E5..         MOV       A,?V0
   \   000067   28           ADD       A,R0
   \   000068   F5..         MOV       ?V0,A
   \   00006A   E5..         MOV       A,?V1
   \   00006C   39           ADDC      A,R1
   \   00006D   F5..         MOV       ?V1,A
   2133          
   2134            buf = zcl_mem_alloc( dataLen );
   \   00006F                ; Setup parameters for call to function osal_mem_alloc
   \   00006F   AA..         MOV       R2,?V0
   \   000071   AB..         MOV       R3,?V1
   \   000073   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000076   8A..         MOV       ?V10,R2
   \   000078   8B..         MOV       ?V11,R3
   \   00007A   85....       MOV       ?V6,?V10
   \   00007D   85....       MOV       ?V7,?V11
   2135            if ( buf != NULL )
   \   000080   E5..         MOV       A,?V6
   \   000082   45..         ORL       A,?V7
   \   000084   7003         JNZ       $+5
   \   000086   02....       LJMP      ??zcl_SendDiscoverAttrsExtRsp_0 & 0xFFFF
   2136            {
   2137              // Load the buffer - serially
   2138              uint8 *pBuf = buf;
   \   000089   AE..         MOV       R6,?V6
   \   00008B   AF..         MOV       R7,?V7
   2139              *pBuf++ = pDiscoverRspCmd->discComplete;
   \   00008D   85..82       MOV       DPL,?V2
   \   000090   85..83       MOV       DPH,?V3
   \   000093   E0           MOVX      A,@DPTR
   \   000094   C0E0         PUSH      A
   \   000096   8E82         MOV       DPL,R6
   \   000098   8F83         MOV       DPH,R7
   \   00009A   D0E0         POP       A
   \   00009C   F0           MOVX      @DPTR,A
   \   00009D   8E82         MOV       DPL,R6
   \   00009F   8F83         MOV       DPH,R7
   \   0000A1   A3           INC       DPTR
   \   0000A2   AE82         MOV       R6,DPL
   \   0000A4   AF83         MOV       R7,DPH
   2140              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   \   0000A6   75..00       MOV       ?V4,#0x0
   \                     ??zcl_SendDiscoverAttrsExtRsp_1:
   \   0000A9   85..82       MOV       DPL,?V2
   \   0000AC   85..83       MOV       DPH,?V3
   \   0000AF   A3           INC       DPTR
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   F8           MOV       R0,A
   \   0000B2   E5..         MOV       A,?V4
   \   0000B4   C3           CLR       C
   \   0000B5   98           SUBB      A,R0
   \   0000B6   4003         JC        $+5
   \   0000B8   02....       LJMP      ??zcl_SendDiscoverAttrsExtRsp_2 & 0xFFFF
   2141              {
   2142                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   \   0000BB   E5..         MOV       A,?V4
   \   0000BD   F8           MOV       R0,A
   \   0000BE   7900         MOV       R1,#0x0
   \   0000C0   E8           MOV       A,R0
   \   0000C1   75F004       MOV       B,#0x4
   \   0000C4   A4           MUL       AB
   \   0000C5   C8           XCH       A,R0
   \   0000C6   AAF0         MOV       R2,B
   \   0000C8   75F000       MOV       B,#0x0
   \   0000CB   A4           MUL       AB
   \   0000CC   2A           ADD       A,R2
   \   0000CD   FA           MOV       R2,A
   \   0000CE   75F004       MOV       B,#0x4
   \   0000D1   E9           MOV       A,R1
   \   0000D2   A4           MUL       AB
   \   0000D3   2A           ADD       A,R2
   \   0000D4   F9           MOV       R1,A
   \   0000D5   E5..         MOV       A,?V2
   \   0000D7   28           ADD       A,R0
   \   0000D8   F582         MOV       DPL,A
   \   0000DA   E5..         MOV       A,?V3
   \   0000DC   39           ADDC      A,R1
   \   0000DD   F583         MOV       DPH,A
   \   0000DF   A3           INC       DPTR
   \   0000E0   A3           INC       DPTR
   \   0000E1   E0           MOVX      A,@DPTR
   \   0000E2   F8           MOV       R0,A
   \   0000E3   A3           INC       DPTR
   \   0000E4   E0           MOVX      A,@DPTR
   \   0000E5   F9           MOV       R1,A
   \   0000E6   E8           MOV       A,R0
   \   0000E7   C0E0         PUSH      A
   \   0000E9   8E82         MOV       DPL,R6
   \   0000EB   8F83         MOV       DPH,R7
   \   0000ED   D0E0         POP       A
   \   0000EF   F0           MOVX      @DPTR,A
   \   0000F0   8E82         MOV       DPL,R6
   \   0000F2   8F83         MOV       DPH,R7
   \   0000F4   A3           INC       DPTR
   \   0000F5   AE82         MOV       R6,DPL
   \   0000F7   AF83         MOV       R7,DPH
   2143                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   \   0000F9   E5..         MOV       A,?V4
   \   0000FB   F8           MOV       R0,A
   \   0000FC   7900         MOV       R1,#0x0
   \   0000FE   E8           MOV       A,R0
   \   0000FF   75F004       MOV       B,#0x4
   \   000102   A4           MUL       AB
   \   000103   C8           XCH       A,R0
   \   000104   AAF0         MOV       R2,B
   \   000106   75F000       MOV       B,#0x0
   \   000109   A4           MUL       AB
   \   00010A   2A           ADD       A,R2
   \   00010B   FA           MOV       R2,A
   \   00010C   75F004       MOV       B,#0x4
   \   00010F   E9           MOV       A,R1
   \   000110   A4           MUL       AB
   \   000111   2A           ADD       A,R2
   \   000112   F9           MOV       R1,A
   \   000113   E5..         MOV       A,?V2
   \   000115   28           ADD       A,R0
   \   000116   F582         MOV       DPL,A
   \   000118   E5..         MOV       A,?V3
   \   00011A   39           ADDC      A,R1
   \   00011B   F583         MOV       DPH,A
   \   00011D   A3           INC       DPTR
   \   00011E   A3           INC       DPTR
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   F8           MOV       R0,A
   \   000121   A3           INC       DPTR
   \   000122   E0           MOVX      A,@DPTR
   \   000123   F9           MOV       R1,A
   \   000124   E4           CLR       A
   \   000125   C9           XCH       A,R1
   \   000126   F8           MOV       R0,A
   \   000127   E8           MOV       A,R0
   \   000128   C0E0         PUSH      A
   \   00012A   8E82         MOV       DPL,R6
   \   00012C   8F83         MOV       DPH,R7
   \   00012E   D0E0         POP       A
   \   000130   F0           MOVX      @DPTR,A
   \   000131   8E82         MOV       DPL,R6
   \   000133   8F83         MOV       DPH,R7
   \   000135   A3           INC       DPTR
   \   000136   AE82         MOV       R6,DPL
   \   000138   AF83         MOV       R7,DPH
   2144                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   \   00013A   E5..         MOV       A,?V4
   \   00013C   F8           MOV       R0,A
   \   00013D   7900         MOV       R1,#0x0
   \   00013F   E8           MOV       A,R0
   \   000140   75F004       MOV       B,#0x4
   \   000143   A4           MUL       AB
   \   000144   C8           XCH       A,R0
   \   000145   AAF0         MOV       R2,B
   \   000147   75F000       MOV       B,#0x0
   \   00014A   A4           MUL       AB
   \   00014B   2A           ADD       A,R2
   \   00014C   FA           MOV       R2,A
   \   00014D   75F004       MOV       B,#0x4
   \   000150   E9           MOV       A,R1
   \   000151   A4           MUL       AB
   \   000152   2A           ADD       A,R2
   \   000153   F9           MOV       R1,A
   \   000154   E5..         MOV       A,?V2
   \   000156   28           ADD       A,R0
   \   000157   F582         MOV       DPL,A
   \   000159   E5..         MOV       A,?V3
   \   00015B   39           ADDC      A,R1
   \   00015C   F583         MOV       DPH,A
   \   00015E   A3           INC       DPTR
   \   00015F   A3           INC       DPTR
   \   000160   A3           INC       DPTR
   \   000161   A3           INC       DPTR
   \   000162   E0           MOVX      A,@DPTR
   \   000163   C0E0         PUSH      A
   \   000165   8E82         MOV       DPL,R6
   \   000167   8F83         MOV       DPH,R7
   \   000169   D0E0         POP       A
   \   00016B   F0           MOVX      @DPTR,A
   \   00016C   8E82         MOV       DPL,R6
   \   00016E   8F83         MOV       DPH,R7
   \   000170   A3           INC       DPTR
   \   000171   AE82         MOV       R6,DPL
   \   000173   AF83         MOV       R7,DPH
   2145                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   \   000175   E5..         MOV       A,?V4
   \   000177   F8           MOV       R0,A
   \   000178   7900         MOV       R1,#0x0
   \   00017A   E8           MOV       A,R0
   \   00017B   75F004       MOV       B,#0x4
   \   00017E   A4           MUL       AB
   \   00017F   C8           XCH       A,R0
   \   000180   AAF0         MOV       R2,B
   \   000182   75F000       MOV       B,#0x0
   \   000185   A4           MUL       AB
   \   000186   2A           ADD       A,R2
   \   000187   FA           MOV       R2,A
   \   000188   75F004       MOV       B,#0x4
   \   00018B   E9           MOV       A,R1
   \   00018C   A4           MUL       AB
   \   00018D   2A           ADD       A,R2
   \   00018E   F9           MOV       R1,A
   \   00018F   E5..         MOV       A,?V2
   \   000191   28           ADD       A,R0
   \   000192   F582         MOV       DPL,A
   \   000194   E5..         MOV       A,?V3
   \   000196   39           ADDC      A,R1
   \   000197   F583         MOV       DPH,A
   \   000199   A3           INC       DPTR
   \   00019A   A3           INC       DPTR
   \   00019B   A3           INC       DPTR
   \   00019C   A3           INC       DPTR
   \   00019D   A3           INC       DPTR
   \   00019E   E0           MOVX      A,@DPTR
   \   00019F   C0E0         PUSH      A
   \   0001A1   8E82         MOV       DPL,R6
   \   0001A3   8F83         MOV       DPH,R7
   \   0001A5   D0E0         POP       A
   \   0001A7   F0           MOVX      @DPTR,A
   \   0001A8   8E82         MOV       DPL,R6
   \   0001AA   8F83         MOV       DPH,R7
   \   0001AC   A3           INC       DPTR
   \   0001AD   AE82         MOV       R6,DPL
   \   0001AF   AF83         MOV       R7,DPH
   2146              }
   \   0001B1   05..         INC       ?V4
   \   0001B3   02....       LJMP      ??zcl_SendDiscoverAttrsExtRsp_1 & 0xFFFF
   2147          
   2148              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   2149                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendDiscoverAttrsExtRsp_2:
   \   0001B6                ; Setup parameters for call to function zcl_SendCommand
   \   0001B6   78..         MOV       R0,#?V6
   \   0001B8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001BB   78..         MOV       R0,#?V0
   \   0001BD   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001C0   E5..         MOV       A,?V9
   \   0001C2   F5..         MOV       ?V10,A
   \   0001C4   78..         MOV       R0,#?V10
   \   0001C6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C9   E4           CLR       A
   \   0001CA   F5..         MOV       ?V10,A
   \   0001CC   F5..         MOV       ?V11,A
   \   0001CE   78..         MOV       R0,#?V10
   \   0001D0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001D3   E5..         MOV       A,?V12
   \   0001D5   F5..         MOV       ?V10,A
   \   0001D7   78..         MOV       R0,#?V10
   \   0001D9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001DC   E5..         MOV       A,?V13
   \   0001DE   F5..         MOV       ?V10,A
   \   0001E0   78..         MOV       R0,#?V10
   \   0001E2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001E5   75..00       MOV       ?V10,#0x0
   \   0001E8   78..         MOV       R0,#?V10
   \   0001EA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001ED   75..16       MOV       ?V10,#0x16
   \   0001F0   78..         MOV       R0,#?V10
   \   0001F2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001F5   AC..         MOV       R4,?V14
   \   0001F7   AD..         MOV       R5,?V15
   \   0001F9   740B         MOV       A,#0xb
   \   0001FB   12....       LCALL     ?XSTACK_DISP0_8
   \   0001FE   E0           MOVX      A,@DPTR
   \   0001FF   FA           MOV       R2,A
   \   000200   A3           INC       DPTR
   \   000201   E0           MOVX      A,@DPTR
   \   000202   FB           MOV       R3,A
   \   000203   A9..         MOV       R1,?V8
   \   000205   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000208   740B         MOV       A,#0xb
   \   00020A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00020D   E9           MOV       A,R1
   \   00020E   F5..         MOV       ?V5,A
   2150              zcl_mem_free( buf );
   \   000210                ; Setup parameters for call to function osal_mem_free
   \   000210   AA..         MOV       R2,?V6
   \   000212   AB..         MOV       R3,?V7
   \   000214   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000217   8003         SJMP      ??zcl_SendDiscoverAttrsExtRsp_3
   2151            }
   2152            else
   2153            {
   2154              status = ZMemError;
   \                     ??zcl_SendDiscoverAttrsExtRsp_0:
   \   000219   75..10       MOV       ?V5,#0x10
   2155            }
   2156          
   2157            return ( status );
   \                     ??zcl_SendDiscoverAttrsExtRsp_3:
   \   00021C   A9..         MOV       R1,?V5
   \   00021E   7402         MOV       A,#0x2
   \   000220   12....       LCALL     ?DEALLOC_XSTACK8
   \   000223   7F10         MOV       R7,#0x10
   \   000225   02....       LJMP      ?BANKED_LEAVE_XDATA
   2158          }
   2159          #endif // ZCL_DISCOVER
   2160          
   2161          /*********************************************************************
   2162           * @fn      zcl_ProcessMessageMSG
   2163           *
   2164           * @brief   Data message processor callback.  This function processes
   2165           *          any incoming data - probably from other devices.  So, based
   2166           *          on cluster ID, perform the intended action.
   2167           *
   2168           * @param   pkt - incoming message
   2169           *
   2170           * @return  zclProcMsgStatus_t
   2171           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2172          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   2173          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV       A,#-0x13
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV       A,#-0x15
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   2174            endPointDesc_t *epDesc;
   2175            zclIncoming_t inMsg;
   2176            zclLibPlugin_t *pInPlugin;
   2177            zclDefaultRspCmd_t defautlRspCmd;
   2178            uint8 options;
   2179            uint8 securityEnable;
   2180            uint8 interPanMsg;
   2181            ZStatus_t status = ZFailure;
   \   00000E   7E01         MOV       R6,#0x1
   2182            uint8 defaultResponseSent = FALSE;
   \   000010   7F00         MOV       R7,#0x0
   2183          
   2184            if ( pkt->cmd.DataLength < ZCL_VALID_MIN_HEADER_LEN  )
   \   000012   E5..         MOV       A,?V0
   \   000014   2420         ADD       A,#0x20
   \   000016   F582         MOV       DPL,A
   \   000018   E4           CLR       A
   \   000019   35..         ADDC      A,?V1
   \   00001B   F583         MOV       DPH,A
   \   00001D   C3           CLR       C
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   9403         SUBB      A,#0x3
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   9400         SUBB      A,#0x0
   \   000025   5005         JNC       ??zcl_ProcessMessageMSG_0
   2185            {
   2186              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   000027   7901         MOV       R1,#0x1
   \   000029   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2187            }
   2188          
   2189            // Initialize
   2190            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   00002C   90....       MOV       DPTR,#rawAFMsg
   \   00002F   E5..         MOV       A,?V0
   \   000031   F0           MOVX      @DPTR,A
   \   000032   A3           INC       DPTR
   \   000033   E5..         MOV       A,?V1
   \   000035   F0           MOVX      @DPTR,A
   2191            inMsg.msg = pkt;
   \   000036   85..82       MOV       DPL,?XSP + 0
   \   000039   85..83       MOV       DPH,?XSP + 1
   \   00003C   E5..         MOV       A,?V0
   \   00003E   F0           MOVX      @DPTR,A
   \   00003F   A3           INC       DPTR
   \   000040   E5..         MOV       A,?V1
   \   000042   F0           MOVX      @DPTR,A
   2192            inMsg.attrCmd = NULL;
   \   000043   740C         MOV       A,#0xc
   \   000045   12....       LCALL     ?XSTACK_DISP0_8
   \   000048   7400         MOV       A,#0x0
   \   00004A   F0           MOVX      @DPTR,A
   \   00004B   A3           INC       DPTR
   \   00004C   7400         MOV       A,#0x0
   \   00004E   F0           MOVX      @DPTR,A
   2193            inMsg.pData = NULL;
   \   00004F   7408         MOV       A,#0x8
   \   000051   12....       LCALL     ?XSTACK_DISP0_8
   \   000054   7400         MOV       A,#0x0
   \   000056   F0           MOVX      @DPTR,A
   \   000057   A3           INC       DPTR
   \   000058   7400         MOV       A,#0x0
   \   00005A   F0           MOVX      @DPTR,A
   2194            inMsg.pDataLen = 0;
   \   00005B   740A         MOV       A,#0xa
   \   00005D   12....       LCALL     ?XSTACK_DISP0_8
   \   000060   7400         MOV       A,#0x0
   \   000062   F0           MOVX      @DPTR,A
   \   000063   A3           INC       DPTR
   \   000064   7400         MOV       A,#0x0
   \   000066   F0           MOVX      @DPTR,A
   2195          
   2196            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000067                ; Setup parameters for call to function zclParseHdr
   \   000067   E5..         MOV       A,?V0
   \   000069   2422         ADD       A,#0x22
   \   00006B   F582         MOV       DPL,A
   \   00006D   E4           CLR       A
   \   00006E   35..         ADDC      A,?V1
   \   000070   F583         MOV       DPH,A
   \   000072   E0           MOVX      A,@DPTR
   \   000073   FC           MOV       R4,A
   \   000074   A3           INC       DPTR
   \   000075   E0           MOVX      A,@DPTR
   \   000076   FD           MOV       R5,A
   \   000077   7402         MOV       A,#0x2
   \   000079   12....       LCALL     ?XSTACK_DISP0_8
   \   00007C   AA82         MOV       R2,DPL
   \   00007E   AB83         MOV       R3,DPH
   \   000080   12....       LCALL     `??zclParseHdr::?relay`; Banked call to: zclParseHdr
   \   000083   7408         MOV       A,#0x8
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   EA           MOV       A,R2
   \   000089   F0           MOVX      @DPTR,A
   \   00008A   A3           INC       DPTR
   \   00008B   EB           MOV       A,R3
   \   00008C   F0           MOVX      @DPTR,A
   2197            inMsg.pDataLen = pkt->cmd.DataLength;
   \   00008D   E5..         MOV       A,?V0
   \   00008F   2420         ADD       A,#0x20
   \   000091   F582         MOV       DPL,A
   \   000093   E4           CLR       A
   \   000094   35..         ADDC      A,?V1
   \   000096   F583         MOV       DPH,A
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F8           MOV       R0,A
   \   00009A   A3           INC       DPTR
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   F9           MOV       R1,A
   \   00009D   740A         MOV       A,#0xa
   \   00009F   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A2   E8           MOV       A,R0
   \   0000A3   F0           MOVX      @DPTR,A
   \   0000A4   A3           INC       DPTR
   \   0000A5   E9           MOV       A,R1
   \   0000A6   F0           MOVX      @DPTR,A
   2198            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \   0000A7   740A         MOV       A,#0xa
   \   0000A9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AC   C082         PUSH      DPL
   \   0000AE   C083         PUSH      DPH
   \   0000B0   7408         MOV       A,#0x8
   \   0000B2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B5   E0           MOVX      A,@DPTR
   \   0000B6   F8           MOV       R0,A
   \   0000B7   A3           INC       DPTR
   \   0000B8   E0           MOVX      A,@DPTR
   \   0000B9   F9           MOV       R1,A
   \   0000BA   D083         POP       DPH
   \   0000BC   D082         POP       DPL
   \   0000BE   E0           MOVX      A,@DPTR
   \   0000BF   C3           CLR       C
   \   0000C0   98           SUBB      A,R0
   \   0000C1   F8           MOV       R0,A
   \   0000C2   A3           INC       DPTR
   \   0000C3   E0           MOVX      A,@DPTR
   \   0000C4   99           SUBB      A,R1
   \   0000C5   F9           MOV       R1,A
   \   0000C6   E5..         MOV       A,?V0
   \   0000C8   2422         ADD       A,#0x22
   \   0000CA   F582         MOV       DPL,A
   \   0000CC   E4           CLR       A
   \   0000CD   35..         ADDC      A,?V1
   \   0000CF   F583         MOV       DPH,A
   \   0000D1   E0           MOVX      A,@DPTR
   \   0000D2   28           ADD       A,R0
   \   0000D3   F8           MOV       R0,A
   \   0000D4   A3           INC       DPTR
   \   0000D5   E0           MOVX      A,@DPTR
   \   0000D6   39           ADDC      A,R1
   \   0000D7   F9           MOV       R1,A
   \   0000D8   740A         MOV       A,#0xa
   \   0000DA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DD   E8           MOV       A,R0
   \   0000DE   F0           MOVX      @DPTR,A
   \   0000DF   A3           INC       DPTR
   \   0000E0   E9           MOV       A,R1
   \   0000E1   F0           MOVX      @DPTR,A
   2199          
   2200            // Temporary workaround to allow callback functions access to the
   2201            // transaction sequence number.  Callback functions will call
   2202            // zcl_getParsedTransSeqNum() to retrieve this number.
   2203            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \   0000E2   7406         MOV       A,#0x6
   \   0000E4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   90....       MOV       DPTR,#savedZCLTransSeqNum
   \   0000EB   F0           MOVX      @DPTR,A
   2204          
   2205            // Find the wanted endpoint
   2206            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000EC                ; Setup parameters for call to function afFindEndPointDesc
   \   0000EC   E5..         MOV       A,?V0
   \   0000EE   2414         ADD       A,#0x14
   \   0000F0   F582         MOV       DPL,A
   \   0000F2   E4           CLR       A
   \   0000F3   35..         ADDC      A,?V1
   \   0000F5   F583         MOV       DPH,A
   \   0000F7   E0           MOVX      A,@DPTR
   \   0000F8   F9           MOV       R1,A
   \   0000F9   12....       LCALL     `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   0000FC   8A..         MOV       ?V8,R2
   \   0000FE   8B..         MOV       ?V9,R3
   \   000100   85....       MOV       ?V6,?V8
   \   000103   85....       MOV       ?V7,?V9
   2207            if ( epDesc == NULL )
   \   000106   E5..         MOV       A,?V6
   \   000108   45..         ORL       A,?V7
   \   00010A   700F         JNZ       ??zcl_ProcessMessageMSG_2
   2208            {
   2209              rawAFMsg = NULL;
   \   00010C   90....       MOV       DPTR,#rawAFMsg
   \   00010F   7400         MOV       A,#0x0
   \   000111   F0           MOVX      @DPTR,A
   \   000112   A3           INC       DPTR
   \   000113   7400         MOV       A,#0x0
   \   000115   F0           MOVX      @DPTR,A
   2210              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   000116   7902         MOV       R1,#0x2
   \   000118   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2211            }
   2212          
   2213            if ( ( epDesc->simpleDesc == NULL ) ||
   2214                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   2215                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   00011B   85..82       MOV       DPL,?V6
   \   00011E   85..83       MOV       DPH,?V7
   \   000121   A3           INC       DPTR
   \   000122   A3           INC       DPTR
   \   000123   A3           INC       DPTR
   \   000124   A3           INC       DPTR
   \   000125   E0           MOVX      A,@DPTR
   \   000126   F8           MOV       R0,A
   \   000127   A3           INC       DPTR
   \   000128   E0           MOVX      A,@DPTR
   \   000129   F9           MOV       R1,A
   \   00012A   E8           MOV       A,R0
   \   00012B   49           ORL       A,R1
   \   00012C   6052         JZ        ??zcl_ProcessMessageMSG_3
   \   00012E                ; Setup parameters for call to function zcl_DeviceOperational
   \   00012E   85..82       MOV       DPL,?V6
   \   000131   85..83       MOV       DPH,?V7
   \   000134   A3           INC       DPTR
   \   000135   A3           INC       DPTR
   \   000136   A3           INC       DPTR
   \   000137   A3           INC       DPTR
   \   000138   E0           MOVX      A,@DPTR
   \   000139   F8           MOV       R0,A
   \   00013A   A3           INC       DPTR
   \   00013B   E0           MOVX      A,@DPTR
   \   00013C   F583         MOV       DPH,A
   \   00013E   8882         MOV       DPL,R0
   \   000140   A3           INC       DPTR
   \   000141   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000144   7409         MOV       A,#0x9
   \   000146   12....       LCALL     ?XSTACK_DISP0_8
   \   000149   E0           MOVX      A,@DPTR
   \   00014A   FD           MOV       R5,A
   \   00014B   7404         MOV       A,#0x4
   \   00014D   12....       LCALL     ?XSTACK_DISP0_8
   \   000150   E0           MOVX      A,@DPTR
   \   000151   F8           MOV       R0,A
   \   000152   A3           INC       DPTR
   \   000153   E0           MOVX      A,@DPTR
   \   000154   F9           MOV       R1,A
   \   000155   E8           MOV       A,R0
   \   000156   5403         ANL       A,#0x3
   \   000158   FC           MOV       R4,A
   \   000159   85..82       MOV       DPL,?V0
   \   00015C   85..83       MOV       DPH,?V1
   \   00015F   A3           INC       DPTR
   \   000160   A3           INC       DPTR
   \   000161   A3           INC       DPTR
   \   000162   A3           INC       DPTR
   \   000163   E0           MOVX      A,@DPTR
   \   000164   FA           MOV       R2,A
   \   000165   A3           INC       DPTR
   \   000166   E0           MOVX      A,@DPTR
   \   000167   FB           MOV       R3,A
   \   000168   E5..         MOV       A,?V0
   \   00016A   2414         ADD       A,#0x14
   \   00016C   F582         MOV       DPL,A
   \   00016E   E4           CLR       A
   \   00016F   35..         ADDC      A,?V1
   \   000171   F583         MOV       DPH,A
   \   000173   E0           MOVX      A,@DPTR
   \   000174   F9           MOV       R1,A
   \   000175   12....       LCALL     `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   000178   7402         MOV       A,#0x2
   \   00017A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00017D   E9           MOV       A,R1
   \   00017E   700F         JNZ       ??zcl_ProcessMessageMSG_4
   2216            {
   2217              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   000180   90....       MOV       DPTR,#rawAFMsg
   \   000183   7400         MOV       A,#0x0
   \   000185   F0           MOVX      @DPTR,A
   \   000186   A3           INC       DPTR
   \   000187   7400         MOV       A,#0x0
   \   000189   F0           MOVX      @DPTR,A
   2218              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   00018A   7903         MOV       R1,#0x3
   \   00018C   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2219            }
   2220          
   2221          #if defined ( INTER_PAN )
   2222            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   \                     ??zcl_ProcessMessageMSG_4:
   \   00018F                ; Setup parameters for call to function StubAPS_InterPan
   \   00018F   E5..         MOV       A,?V0
   \   000191   240F         ADD       A,#0xf
   \   000193   F582         MOV       DPL,A
   \   000195   E4           CLR       A
   \   000196   35..         ADDC      A,?V1
   \   000198   F583         MOV       DPH,A
   \   00019A   E0           MOVX      A,@DPTR
   \   00019B   F9           MOV       R1,A
   \   00019C   E5..         MOV       A,?V0
   \   00019E   2410         ADD       A,#0x10
   \   0001A0   F582         MOV       DPL,A
   \   0001A2   E4           CLR       A
   \   0001A3   35..         ADDC      A,?V1
   \   0001A5   F583         MOV       DPH,A
   \   0001A7   E0           MOVX      A,@DPTR
   \   0001A8   FA           MOV       R2,A
   \   0001A9   A3           INC       DPTR
   \   0001AA   E0           MOVX      A,@DPTR
   \   0001AB   FB           MOV       R3,A
   \   0001AC   12....       LCALL     `??StubAPS_InterPan::?relay`; Banked call to: StubAPS_InterPan
   \   0001AF   E9           MOV       A,R1
   \   0001B0   6028         JZ        ??zcl_ProcessMessageMSG_5
   2223            {
   2224              // No foundation command is supported thru Inter-PAN communication.
   2225              // But the Light Link cluster uses a different Frame Control format
   2226              // for it's Inter-PAN messages, where the messages could be confused
   2227              // with the foundation commands.
   2228              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \   0001B2   7402         MOV       A,#0x2
   \   0001B4   12....       LCALL     ?XSTACK_DISP0_8
   \   0001B7   E0           MOVX      A,@DPTR
   \   0001B8   5403         ANL       A,#0x3
   \   0001BA   F8           MOV       R0,A
   \   0001BB   A3           INC       DPTR
   \   0001BC   E0           MOVX      A,@DPTR
   \   0001BD   5400         ANL       A,#0x0
   \   0001BF   F9           MOV       R1,A
   \   0001C0   E8           MOV       A,R0
   \   0001C1   700F         JNZ       ??zcl_ProcessMessageMSG_6
   2229              {
   2230                rawAFMsg = NULL;
   \   0001C3   90....       MOV       DPTR,#rawAFMsg
   \   0001C6   7400         MOV       A,#0x0
   \   0001C8   F0           MOVX      @DPTR,A
   \   0001C9   A3           INC       DPTR
   \   0001CA   7400         MOV       A,#0x0
   \   0001CC   F0           MOVX      @DPTR,A
   2231                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   \   0001CD   7904         MOV       R1,#0x4
   \   0001CF   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2232              }
   2233          
   2234              interPanMsg = TRUE;
   \                     ??zcl_ProcessMessageMSG_6:
   \   0001D2   75..01       MOV       ?V2,#0x1
   2235              options = AF_TX_OPTIONS_NONE;
   \   0001D5   75..00       MOV       ?V3,#0x0
   \   0001D8   8025         SJMP      ??zcl_ProcessMessageMSG_7
   2236            }
   2237            else
   2238          #endif
   2239            {
   2240              interPanMsg = FALSE;
   \                     ??zcl_ProcessMessageMSG_5:
   \   0001DA   75..00       MOV       ?V2,#0x0
   2241              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   0001DD                ; Setup parameters for call to function zclGetClusterOption
   \   0001DD   85..82       MOV       DPL,?V0
   \   0001E0   85..83       MOV       DPH,?V1
   \   0001E3   A3           INC       DPTR
   \   0001E4   A3           INC       DPTR
   \   0001E5   A3           INC       DPTR
   \   0001E6   A3           INC       DPTR
   \   0001E7   E0           MOVX      A,@DPTR
   \   0001E8   FA           MOV       R2,A
   \   0001E9   A3           INC       DPTR
   \   0001EA   E0           MOVX      A,@DPTR
   \   0001EB   FB           MOV       R3,A
   \   0001EC   E5..         MOV       A,?V0
   \   0001EE   2414         ADD       A,#0x14
   \   0001F0   F582         MOV       DPL,A
   \   0001F2   E4           CLR       A
   \   0001F3   35..         ADDC      A,?V1
   \   0001F5   F583         MOV       DPH,A
   \   0001F7   E0           MOVX      A,@DPTR
   \   0001F8   F9           MOV       R1,A
   \   0001F9   12....       LCALL     `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   0001FC   E9           MOV       A,R1
   \   0001FD   F5..         MOV       ?V3,A
   2242            }
   2243          
   2244            // Find the appropriate plugin
   2245            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \                     ??zcl_ProcessMessageMSG_7:
   \   0001FF                ; Setup parameters for call to function zclFindPlugin
   \   0001FF   85..82       MOV       DPL,?V6
   \   000202   85..83       MOV       DPH,?V7
   \   000205   A3           INC       DPTR
   \   000206   A3           INC       DPTR
   \   000207   A3           INC       DPTR
   \   000208   A3           INC       DPTR
   \   000209   E0           MOVX      A,@DPTR
   \   00020A   F8           MOV       R0,A
   \   00020B   A3           INC       DPTR
   \   00020C   E0           MOVX      A,@DPTR
   \   00020D   F583         MOV       DPH,A
   \   00020F   8882         MOV       DPL,R0
   \   000211   A3           INC       DPTR
   \   000212   E0           MOVX      A,@DPTR
   \   000213   FC           MOV       R4,A
   \   000214   A3           INC       DPTR
   \   000215   E0           MOVX      A,@DPTR
   \   000216   FD           MOV       R5,A
   \   000217   85..82       MOV       DPL,?V0
   \   00021A   85..83       MOV       DPH,?V1
   \   00021D   A3           INC       DPTR
   \   00021E   A3           INC       DPTR
   \   00021F   A3           INC       DPTR
   \   000220   A3           INC       DPTR
   \   000221   E0           MOVX      A,@DPTR
   \   000222   FA           MOV       R2,A
   \   000223   A3           INC       DPTR
   \   000224   E0           MOVX      A,@DPTR
   \   000225   FB           MOV       R3,A
   \   000226   12....       LCALL     `??zclFindPlugin::?relay`; Banked call to: zclFindPlugin
   \   000229   8A..         MOV       ?V8,R2
   \   00022B   8B..         MOV       ?V9,R3
   \   00022D   85....       MOV       ?V4,?V8
   \   000230   85....       MOV       ?V5,?V9
   2246          
   2247            // Local and remote Security options must match except for Default Response command
   2248            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   \   000233   E5..         MOV       A,?V4
   \   000235   45..         ORL       A,?V5
   \   000237   7003         JNZ       $+5
   \   000239   02....       LJMP      ??zcl_ProcessMessageMSG_8 & 0xFFFF
   \   00023C   7402         MOV       A,#0x2
   \   00023E   12....       LCALL     ?XSTACK_DISP0_8
   \   000241   E0           MOVX      A,@DPTR
   \   000242   5407         ANL       A,#0x7
   \   000244   F8           MOV       R0,A
   \   000245   A3           INC       DPTR
   \   000246   E0           MOVX      A,@DPTR
   \   000247   5400         ANL       A,#0x0
   \   000249   F9           MOV       R1,A
   \   00024A   E8           MOV       A,R0
   \   00024B   49           ORL       A,R1
   \   00024C   700D         JNZ       ??zcl_ProcessMessageMSG_9
   \   00024E   7407         MOV       A,#0x7
   \   000250   12....       LCALL     ?XSTACK_DISP0_8
   \   000253   E0           MOVX      A,@DPTR
   \   000254   640B         XRL       A,#0xb
   \   000256   7003         JNZ       $+5
   \   000258   02....       LJMP      ??zcl_ProcessMessageMSG_8 & 0xFFFF
   2249            {
   2250              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_9:
   \   00025B   E5..         MOV       A,?V3
   \   00025D   A2E6         MOV       C,0xE0 /* A   */.6
   \   00025F   5004         JNC       ??zcl_ProcessMessageMSG_10
   \   000261   D2F0         SETB      B.0
   \   000263   8002         SJMP      ??zcl_ProcessMessageMSG_11
   \                     ??zcl_ProcessMessageMSG_10:
   \   000265   C2F0         CLR       B.0
   \                     ??zcl_ProcessMessageMSG_11:
   \   000267   A2F0         MOV       C,B.0
   \   000269   E4           CLR       A
   \   00026A   33           RLC       A
   \   00026B   F5..         MOV       ?V10,A
   2251          
   2252              // Make sure that Clusters specifically defined to use security are received secure,
   2253              // any other cluster that wants to use APS security will be allowed
   2254              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   \   00026D   7401         MOV       A,#0x1
   \   00026F   65..         XRL       A,?V10
   \   000271   6003         JZ        $+5
   \   000273   02....       LJMP      ??zcl_ProcessMessageMSG_8 & 0xFFFF
   \   000276   E5..         MOV       A,?V0
   \   000278   2419         ADD       A,#0x19
   \   00027A   F582         MOV       DPL,A
   \   00027C   E4           CLR       A
   \   00027D   35..         ADDC      A,?V1
   \   00027F   F583         MOV       DPH,A
   \   000281   E0           MOVX      A,@DPTR
   \   000282   6003         JZ        $+5
   \   000284   02....       LJMP      ??zcl_ProcessMessageMSG_8 & 0xFFFF
   2255              {
   2256                if ( UNICAST_MSG( inMsg.msg ) )
   \   000287   85..82       MOV       DPL,?XSP + 0
   \   00028A   85..83       MOV       DPH,?XSP + 1
   \   00028D   E0           MOVX      A,@DPTR
   \   00028E   F8           MOV       R0,A
   \   00028F   A3           INC       DPTR
   \   000290   E0           MOVX      A,@DPTR
   \   000291   C8           XCH       A,R0
   \   000292   2415         ADD       A,#0x15
   \   000294   F582         MOV       DPL,A
   \   000296   C8           XCH       A,R0
   \   000297   3400         ADDC      A,#0x0
   \   000299   F583         MOV       DPH,A
   \   00029B   E0           MOVX      A,@DPTR
   \   00029C   6003         JZ        $+5
   \   00029E   02....       LJMP      ??zcl_ProcessMessageMSG_12 & 0xFFFF
   \   0002A1   85..82       MOV       DPL,?XSP + 0
   \   0002A4   85..83       MOV       DPH,?XSP + 1
   \   0002A7   E0           MOVX      A,@DPTR
   \   0002A8   F8           MOV       R0,A
   \   0002A9   A3           INC       DPTR
   \   0002AA   E0           MOVX      A,@DPTR
   \   0002AB   F583         MOV       DPH,A
   \   0002AD   8882         MOV       DPL,R0
   \   0002AF   A3           INC       DPTR
   \   0002B0   A3           INC       DPTR
   \   0002B1   E0           MOVX      A,@DPTR
   \   0002B2   F8           MOV       R0,A
   \   0002B3   A3           INC       DPTR
   \   0002B4   E0           MOVX      A,@DPTR
   \   0002B5   F9           MOV       R1,A
   \   0002B6   E8           MOV       A,R0
   \   0002B7   49           ORL       A,R1
   \   0002B8   6003         JZ        $+5
   \   0002BA   02....       LJMP      ??zcl_ProcessMessageMSG_12 & 0xFFFF
   2257                {
   2258                  // Send a Default Response command back with no Application Link Key security
   2259                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   0002BD                ; Setup parameters for call to function zclSetSecurityOption
   \   0002BD   7C00         MOV       R4,#0x0
   \   0002BF   85..82       MOV       DPL,?V0
   \   0002C2   85..83       MOV       DPH,?V1
   \   0002C5   A3           INC       DPTR
   \   0002C6   A3           INC       DPTR
   \   0002C7   A3           INC       DPTR
   \   0002C8   A3           INC       DPTR
   \   0002C9   E0           MOVX      A,@DPTR
   \   0002CA   FA           MOV       R2,A
   \   0002CB   A3           INC       DPTR
   \   0002CC   E0           MOVX      A,@DPTR
   \   0002CD   FB           MOV       R3,A
   \   0002CE   E5..         MOV       A,?V0
   \   0002D0   2414         ADD       A,#0x14
   \   0002D2   F582         MOV       DPL,A
   \   0002D4   E4           CLR       A
   \   0002D5   35..         ADDC      A,?V1
   \   0002D7   F583         MOV       DPH,A
   \   0002D9   E0           MOVX      A,@DPTR
   \   0002DA   F9           MOV       R1,A
   \   0002DB   12....       LCALL     `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2260          
   2261                  defautlRspCmd.statusCode = status;
   \   0002DE   EE           MOV       A,R6
   \   0002DF   C0E0         PUSH      A
   \   0002E1   740F         MOV       A,#0xf
   \   0002E3   12....       LCALL     ?XSTACK_DISP0_8
   \   0002E6   D0E0         POP       A
   \   0002E8   F0           MOVX      @DPTR,A
   2262                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0002E9   7407         MOV       A,#0x7
   \   0002EB   12....       LCALL     ?XSTACK_DISP0_8
   \   0002EE   E0           MOVX      A,@DPTR
   \   0002EF   C0E0         PUSH      A
   \   0002F1   740E         MOV       A,#0xe
   \   0002F3   12....       LCALL     ?XSTACK_DISP0_8
   \   0002F6   D0E0         POP       A
   \   0002F8   F0           MOVX      @DPTR,A
   2263                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2264                                         inMsg.msg->clusterId, &defautlRspCmd,
   2265                                         !inMsg.hdr.fc.direction, true,
   2266                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   0002F9                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   0002F9   7406         MOV       A,#0x6
   \   0002FB   12....       LCALL     ?XSTACK_DISP0_8
   \   0002FE   E0           MOVX      A,@DPTR
   \   0002FF   F5..         MOV       ?V8,A
   \   000301   78..         MOV       R0,#?V8
   \   000303   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000306   7405         MOV       A,#0x5
   \   000308   12....       LCALL     ?XSTACK_DISP0_8
   \   00030B   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00030E   75..01       MOV       ?V8,#0x1
   \   000311   78..         MOV       R0,#?V8
   \   000313   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000316   7406         MOV       A,#0x6
   \   000318   12....       LCALL     ?XSTACK_DISP0_8
   \   00031B   E0           MOVX      A,@DPTR
   \   00031C   F8           MOV       R0,A
   \   00031D   A3           INC       DPTR
   \   00031E   E0           MOVX      A,@DPTR
   \   00031F   F9           MOV       R1,A
   \   000320   E8           MOV       A,R0
   \   000321   13           RRC       A
   \   000322   13           RRC       A
   \   000323   13           RRC       A
   \   000324   541F         ANL       A,#0x1f
   \   000326   6401         XRL       A,#0x1
   \   000328   5401         ANL       A,#0x1
   \   00032A   F5..         MOV       ?V8,A
   \   00032C   78..         MOV       R0,#?V8
   \   00032E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000331   7413         MOV       A,#0x13
   \   000333   12....       LCALL     ?XSTACK_DISP100_8
   \   000336   88..         MOV       ?V8,R0
   \   000338   89..         MOV       ?V9,R1
   \   00033A   78..         MOV       R0,#?V8
   \   00033C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00033F   7407         MOV       A,#0x7
   \   000341   12....       LCALL     ?XSTACK_DISP0_8
   \   000344   E0           MOVX      A,@DPTR
   \   000345   F8           MOV       R0,A
   \   000346   A3           INC       DPTR
   \   000347   E0           MOVX      A,@DPTR
   \   000348   F583         MOV       DPH,A
   \   00034A   8882         MOV       DPL,R0
   \   00034C   A3           INC       DPTR
   \   00034D   A3           INC       DPTR
   \   00034E   A3           INC       DPTR
   \   00034F   A3           INC       DPTR
   \   000350   E0           MOVX      A,@DPTR
   \   000351   FC           MOV       R4,A
   \   000352   A3           INC       DPTR
   \   000353   E0           MOVX      A,@DPTR
   \   000354   FD           MOV       R5,A
   \   000355   7407         MOV       A,#0x7
   \   000357   12....       LCALL     ?XSTACK_DISP0_8
   \   00035A   E0           MOVX      A,@DPTR
   \   00035B   2406         ADD       A,#0x6
   \   00035D   FA           MOV       R2,A
   \   00035E   A3           INC       DPTR
   \   00035F   E0           MOVX      A,@DPTR
   \   000360   3400         ADDC      A,#0x0
   \   000362   FB           MOV       R3,A
   \   000363   7407         MOV       A,#0x7
   \   000365   12....       LCALL     ?XSTACK_DISP0_8
   \   000368   E0           MOVX      A,@DPTR
   \   000369   F8           MOV       R0,A
   \   00036A   A3           INC       DPTR
   \   00036B   E0           MOVX      A,@DPTR
   \   00036C   C8           XCH       A,R0
   \   00036D   2414         ADD       A,#0x14
   \   00036F   F582         MOV       DPL,A
   \   000371   C8           XCH       A,R0
   \   000372   3400         ADDC      A,#0x0
   \   000374   F583         MOV       DPH,A
   \   000376   E0           MOVX      A,@DPTR
   \   000377   F9           MOV       R1,A
   \   000378   12....       LCALL     `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   00037B   7407         MOV       A,#0x7
   \   00037D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000380   E9           MOV       A,R1
   2267          
   2268                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   000381                ; Setup parameters for call to function zclSetSecurityOption
   \   000381   7C01         MOV       R4,#0x1
   \   000383   85..82       MOV       DPL,?V0
   \   000386   85..83       MOV       DPH,?V1
   \   000389   A3           INC       DPTR
   \   00038A   A3           INC       DPTR
   \   00038B   A3           INC       DPTR
   \   00038C   A3           INC       DPTR
   \   00038D   E0           MOVX      A,@DPTR
   \   00038E   FA           MOV       R2,A
   \   00038F   A3           INC       DPTR
   \   000390   E0           MOVX      A,@DPTR
   \   000391   FB           MOV       R3,A
   \   000392   E5..         MOV       A,?V0
   \   000394   2414         ADD       A,#0x14
   \   000396   F582         MOV       DPL,A
   \   000398   E4           CLR       A
   \   000399   35..         ADDC      A,?V1
   \   00039B   F583         MOV       DPH,A
   \   00039D   E0           MOVX      A,@DPTR
   \   00039E   F9           MOV       R1,A
   \   00039F   12....       LCALL     `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2269                }
   2270          
   2271                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_12:
   \   0003A2   90....       MOV       DPTR,#rawAFMsg
   \   0003A5   7400         MOV       A,#0x0
   \   0003A7   F0           MOVX      @DPTR,A
   \   0003A8   A3           INC       DPTR
   \   0003A9   7400         MOV       A,#0x0
   \   0003AB   F0           MOVX      @DPTR,A
   2272                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   0003AC   7905         MOV       R1,#0x5
   \   0003AE   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2273              }
   2274            }
   2275          
   2276            // Is this a foundation type message
   2277            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_8:
   \   0003B1   E5..         MOV       A,?V2
   \   0003B3   6003         JZ        $+5
   \   0003B5   02....       LJMP      ??zcl_ProcessMessageMSG_13 & 0xFFFF
   \   0003B8   7402         MOV       A,#0x2
   \   0003BA   12....       LCALL     ?XSTACK_DISP0_8
   \   0003BD   E0           MOVX      A,@DPTR
   \   0003BE   5403         ANL       A,#0x3
   \   0003C0   F8           MOV       R0,A
   \   0003C1   A3           INC       DPTR
   \   0003C2   E0           MOVX      A,@DPTR
   \   0003C3   5400         ANL       A,#0x0
   \   0003C5   F9           MOV       R1,A
   \   0003C6   E8           MOV       A,R0
   \   0003C7   6003         JZ        $+5
   \   0003C9   02....       LJMP      ??zcl_ProcessMessageMSG_13 & 0xFFFF
   2278            {
   2279              if ( inMsg.hdr.fc.manuSpecific )
   \   0003CC   7402         MOV       A,#0x2
   \   0003CE   12....       LCALL     ?XSTACK_DISP0_8
   \   0003D1   E0           MOVX      A,@DPTR
   \   0003D2   F8           MOV       R0,A
   \   0003D3   A3           INC       DPTR
   \   0003D4   E0           MOVX      A,@DPTR
   \   0003D5   F9           MOV       R1,A
   \   0003D6   E8           MOV       A,R0
   \   0003D7   13           RRC       A
   \   0003D8   13           RRC       A
   \   0003D9   543F         ANL       A,#0x3f
   \   0003DB   5401         ANL       A,#0x1
   \   0003DD   A2E0         MOV       C,0xE0 /* A   */.0
   \   0003DF   5005         JNC       ??zcl_ProcessMessageMSG_14
   2280              {
   2281                // We don't support any manufacturer specific command
   2282                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   0003E1   7E84         MOV       R6,#-0x7c
   \   0003E3   02....       LJMP      ??zcl_ProcessMessageMSG_15 & 0xFFFF
   2283              }
   2284              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2285                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_14:
   \   0003E6   7407         MOV       A,#0x7
   \   0003E8   12....       LCALL     ?XSTACK_DISP0_8
   \   0003EB   E0           MOVX      A,@DPTR
   \   0003EC   C3           CLR       C
   \   0003ED   9417         SUBB      A,#0x17
   \   0003EF   4003         JC        $+5
   \   0003F1   02....       LJMP      ??zcl_ProcessMessageMSG_16 & 0xFFFF
   \   0003F4   7407         MOV       A,#0x7
   \   0003F6   12....       LCALL     ?XSTACK_DISP0_8
   \   0003F9   E0           MOVX      A,@DPTR
   \   0003FA   F8           MOV       R0,A
   \   0003FB   7900         MOV       R1,#0x0
   \   0003FD   E8           MOV       A,R0
   \   0003FE   75F004       MOV       B,#0x4
   \   000401   A4           MUL       AB
   \   000402   C8           XCH       A,R0
   \   000403   AAF0         MOV       R2,B
   \   000405   75F000       MOV       B,#0x0
   \   000408   A4           MUL       AB
   \   000409   2A           ADD       A,R2
   \   00040A   FA           MOV       R2,A
   \   00040B   75F004       MOV       B,#0x4
   \   00040E   E9           MOV       A,R1
   \   00040F   A4           MUL       AB
   \   000410   2A           ADD       A,R2
   \   000411   F9           MOV       R1,A
   \   000412   74..         MOV       A,#zclCmdTable & 0xff
   \   000414   28           ADD       A,R0
   \   000415   F582         MOV       DPL,A
   \   000417   74..         MOV       A,#(zclCmdTable >> 8) & 0xff
   \   000419   39           ADDC      A,R1
   \   00041A   F583         MOV       DPH,A
   \   00041C   E4           CLR       A
   \   00041D   93           MOVC      A,@A+DPTR
   \   00041E   F8           MOV       R0,A
   \   00041F   7401         MOV       A,#0x1
   \   000421   93           MOVC      A,@A+DPTR
   \   000422   F9           MOV       R1,A
   \   000423   E8           MOV       A,R0
   \   000424   49           ORL       A,R1
   \   000425   7003         JNZ       $+5
   \   000427   02....       LJMP      ??zcl_ProcessMessageMSG_16 & 0xFFFF
   2286              {
   2287                zclParseCmd_t parseCmd;
   2288          
   2289                parseCmd.endpoint = pkt->endPoint;
   \   00042A   E5..         MOV       A,?V0
   \   00042C   2414         ADD       A,#0x14
   \   00042E   F582         MOV       DPL,A
   \   000430   E4           CLR       A
   \   000431   35..         ADDC      A,?V1
   \   000433   F583         MOV       DPH,A
   \   000435   E0           MOVX      A,@DPTR
   \   000436   C0E0         PUSH      A
   \   000438   7410         MOV       A,#0x10
   \   00043A   12....       LCALL     ?XSTACK_DISP0_8
   \   00043D   D0E0         POP       A
   \   00043F   F0           MOVX      @DPTR,A
   2290                parseCmd.dataLen = inMsg.pDataLen;
   \   000440   740A         MOV       A,#0xa
   \   000442   12....       LCALL     ?XSTACK_DISP0_8
   \   000445   E0           MOVX      A,@DPTR
   \   000446   F8           MOV       R0,A
   \   000447   A3           INC       DPTR
   \   000448   E0           MOVX      A,@DPTR
   \   000449   F9           MOV       R1,A
   \   00044A   7411         MOV       A,#0x11
   \   00044C   12....       LCALL     ?XSTACK_DISP0_8
   \   00044F   E8           MOV       A,R0
   \   000450   F0           MOVX      @DPTR,A
   \   000451   A3           INC       DPTR
   \   000452   E9           MOV       A,R1
   \   000453   F0           MOVX      @DPTR,A
   2291                parseCmd.pData = inMsg.pData;
   \   000454   7408         MOV       A,#0x8
   \   000456   12....       LCALL     ?XSTACK_DISP0_8
   \   000459   E0           MOVX      A,@DPTR
   \   00045A   F8           MOV       R0,A
   \   00045B   A3           INC       DPTR
   \   00045C   E0           MOVX      A,@DPTR
   \   00045D   F9           MOV       R1,A
   \   00045E   7413         MOV       A,#0x13
   \   000460   12....       LCALL     ?XSTACK_DISP0_8
   \   000463   E8           MOV       A,R0
   \   000464   F0           MOVX      @DPTR,A
   \   000465   A3           INC       DPTR
   \   000466   E9           MOV       A,R1
   \   000467   F0           MOVX      @DPTR,A
   2292          
   2293                // Parse the command, remember that the return value is a pointer to allocated memory
   2294                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \   000468                ; Setup parameters for indirect call
   \   000468   7410         MOV       A,#0x10
   \   00046A   12....       LCALL     ?XSTACK_DISP101_8
   \   00046D   7407         MOV       A,#0x7
   \   00046F   12....       LCALL     ?XSTACK_DISP0_8
   \   000472   E0           MOVX      A,@DPTR
   \   000473   F8           MOV       R0,A
   \   000474   7900         MOV       R1,#0x0
   \   000476   E8           MOV       A,R0
   \   000477   75F004       MOV       B,#0x4
   \   00047A   A4           MUL       AB
   \   00047B   C8           XCH       A,R0
   \   00047C   ACF0         MOV       R4,B
   \   00047E   75F000       MOV       B,#0x0
   \   000481   A4           MUL       AB
   \   000482   2C           ADD       A,R4
   \   000483   FC           MOV       R4,A
   \   000484   75F004       MOV       B,#0x4
   \   000487   E9           MOV       A,R1
   \   000488   A4           MUL       AB
   \   000489   2C           ADD       A,R4
   \   00048A   F9           MOV       R1,A
   \   00048B   74..         MOV       A,#zclCmdTable & 0xff
   \   00048D   28           ADD       A,R0
   \   00048E   F582         MOV       DPL,A
   \   000490   74..         MOV       A,#(zclCmdTable >> 8) & 0xff
   \   000492   39           ADDC      A,R1
   \   000493   F583         MOV       DPH,A
   \   000495   E4           CLR       A
   \   000496   93           MOVC      A,@A+DPTR
   \   000497   C0E0         PUSH      A
   \   000499   7401         MOV       A,#0x1
   \   00049B   93           MOVC      A,@A+DPTR
   \   00049C   F583         MOV       DPH,A
   \   00049E   D082         POP       DPL
   \   0004A0   12....       LCALL     ?CALL_IND
   \   0004A3   740C         MOV       A,#0xc
   \   0004A5   12....       LCALL     ?XSTACK_DISP0_8
   \   0004A8   EA           MOV       A,R2
   \   0004A9   F0           MOVX      @DPTR,A
   \   0004AA   A3           INC       DPTR
   \   0004AB   EB           MOV       A,R3
   \   0004AC   F0           MOVX      @DPTR,A
   2295                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \   0004AD   740C         MOV       A,#0xc
   \   0004AF   12....       LCALL     ?XSTACK_DISP0_8
   \   0004B2   E0           MOVX      A,@DPTR
   \   0004B3   F8           MOV       R0,A
   \   0004B4   A3           INC       DPTR
   \   0004B5   E0           MOVX      A,@DPTR
   \   0004B6   F9           MOV       R1,A
   \   0004B7   E8           MOV       A,R0
   \   0004B8   49           ORL       A,R1
   \   0004B9   606E         JZ        ??zcl_ProcessMessageMSG_17
   \   0004BB   7407         MOV       A,#0x7
   \   0004BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0004C0   E0           MOVX      A,@DPTR
   \   0004C1   F8           MOV       R0,A
   \   0004C2   7900         MOV       R1,#0x0
   \   0004C4   E8           MOV       A,R0
   \   0004C5   75F004       MOV       B,#0x4
   \   0004C8   A4           MUL       AB
   \   0004C9   C8           XCH       A,R0
   \   0004CA   AAF0         MOV       R2,B
   \   0004CC   75F000       MOV       B,#0x0
   \   0004CF   A4           MUL       AB
   \   0004D0   2A           ADD       A,R2
   \   0004D1   FA           MOV       R2,A
   \   0004D2   75F004       MOV       B,#0x4
   \   0004D5   E9           MOV       A,R1
   \   0004D6   A4           MUL       AB
   \   0004D7   2A           ADD       A,R2
   \   0004D8   F9           MOV       R1,A
   \   0004D9   74..         MOV       A,#(zclCmdTable + 2) & 0xff
   \   0004DB   28           ADD       A,R0
   \   0004DC   F582         MOV       DPL,A
   \   0004DE   74..         MOV       A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0004E0   39           ADDC      A,R1
   \   0004E1   F583         MOV       DPH,A
   \   0004E3   E4           CLR       A
   \   0004E4   93           MOVC      A,@A+DPTR
   \   0004E5   F8           MOV       R0,A
   \   0004E6   7401         MOV       A,#0x1
   \   0004E8   93           MOVC      A,@A+DPTR
   \   0004E9   F9           MOV       R1,A
   \   0004EA   E8           MOV       A,R0
   \   0004EB   49           ORL       A,R1
   \   0004EC   603B         JZ        ??zcl_ProcessMessageMSG_17
   2296                {
   2297                  // Process the command
   2298                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0004EE                ; Setup parameters for indirect call
   \   0004EE   AA..         MOV       R2,?XSP + 0
   \   0004F0   AB..         MOV       R3,?XSP + 1
   \   0004F2   7407         MOV       A,#0x7
   \   0004F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0004F7   E0           MOVX      A,@DPTR
   \   0004F8   F8           MOV       R0,A
   \   0004F9   7900         MOV       R1,#0x0
   \   0004FB   E8           MOV       A,R0
   \   0004FC   75F004       MOV       B,#0x4
   \   0004FF   A4           MUL       AB
   \   000500   C8           XCH       A,R0
   \   000501   ACF0         MOV       R4,B
   \   000503   75F000       MOV       B,#0x0
   \   000506   A4           MUL       AB
   \   000507   2C           ADD       A,R4
   \   000508   FC           MOV       R4,A
   \   000509   75F004       MOV       B,#0x4
   \   00050C   E9           MOV       A,R1
   \   00050D   A4           MUL       AB
   \   00050E   2C           ADD       A,R4
   \   00050F   F9           MOV       R1,A
   \   000510   74..         MOV       A,#(zclCmdTable + 2) & 0xff
   \   000512   28           ADD       A,R0
   \   000513   F582         MOV       DPL,A
   \   000515   74..         MOV       A,#((zclCmdTable + 2) >> 8) & 0xff
   \   000517   39           ADDC      A,R1
   \   000518   F583         MOV       DPH,A
   \   00051A   E4           CLR       A
   \   00051B   93           MOVC      A,@A+DPTR
   \   00051C   C0E0         PUSH      A
   \   00051E   7401         MOV       A,#0x1
   \   000520   93           MOVC      A,@A+DPTR
   \   000521   F583         MOV       DPH,A
   \   000523   D082         POP       DPL
   \   000525   12....       LCALL     ?CALL_IND
   \   000528   E9           MOV       A,R1
   2299                  {
   2300                    // Couldn't find attribute in the table.
   2301                  }
   2302                }
   2303          
   2304                // Free the buffer
   2305                if ( inMsg.attrCmd )
   \                     ??zcl_ProcessMessageMSG_17:
   \   000529   740C         MOV       A,#0xc
   \   00052B   12....       LCALL     ?XSTACK_DISP0_8
   \   00052E   E0           MOVX      A,@DPTR
   \   00052F   F8           MOV       R0,A
   \   000530   A3           INC       DPTR
   \   000531   E0           MOVX      A,@DPTR
   \   000532   F9           MOV       R1,A
   \   000533   E8           MOV       A,R0
   \   000534   49           ORL       A,R1
   \   000535   600D         JZ        ??zcl_ProcessMessageMSG_18
   2306                {
   2307                  zcl_mem_free( inMsg.attrCmd );
   \   000537                ; Setup parameters for call to function osal_mem_free
   \   000537   740C         MOV       A,#0xc
   \   000539   12....       LCALL     ?XSTACK_DISP0_8
   \   00053C   E0           MOVX      A,@DPTR
   \   00053D   FA           MOV       R2,A
   \   00053E   A3           INC       DPTR
   \   00053F   E0           MOVX      A,@DPTR
   \   000540   FB           MOV       R3,A
   \   000541   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2308                }
   2309          
   2310                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_18:
   \   000544   7407         MOV       A,#0x7
   \   000546   12....       LCALL     ?XSTACK_DISP0_8
   \   000549   E0           MOVX      A,@DPTR
   \   00054A   6064         JZ        ??zcl_ProcessMessageMSG_19
   \   00054C   7407         MOV       A,#0x7
   \   00054E   12....       LCALL     ?XSTACK_DISP0_8
   \   000551   E0           MOVX      A,@DPTR
   \   000552   6402         XRL       A,#0x2
   \   000554   605A         JZ        ??zcl_ProcessMessageMSG_19
   \   000556   7407         MOV       A,#0x7
   \   000558   12....       LCALL     ?XSTACK_DISP0_8
   \   00055B   E0           MOVX      A,@DPTR
   \   00055C   6403         XRL       A,#0x3
   \   00055E   6050         JZ        ??zcl_ProcessMessageMSG_19
   \   000560   7407         MOV       A,#0x7
   \   000562   12....       LCALL     ?XSTACK_DISP0_8
   \   000565   E0           MOVX      A,@DPTR
   \   000566   6405         XRL       A,#0x5
   \   000568   6046         JZ        ??zcl_ProcessMessageMSG_19
   \   00056A   7407         MOV       A,#0x7
   \   00056C   12....       LCALL     ?XSTACK_DISP0_8
   \   00056F   E0           MOVX      A,@DPTR
   \   000570   6406         XRL       A,#0x6
   \   000572   603C         JZ        ??zcl_ProcessMessageMSG_19
   \   000574   7407         MOV       A,#0x7
   \   000576   12....       LCALL     ?XSTACK_DISP0_8
   \   000579   E0           MOVX      A,@DPTR
   \   00057A   6408         XRL       A,#0x8
   \   00057C   6032         JZ        ??zcl_ProcessMessageMSG_19
   \   00057E   7407         MOV       A,#0x7
   \   000580   12....       LCALL     ?XSTACK_DISP0_8
   \   000583   E0           MOVX      A,@DPTR
   \   000584   640C         XRL       A,#0xc
   \   000586   6028         JZ        ??zcl_ProcessMessageMSG_19
   \   000588   7407         MOV       A,#0x7
   \   00058A   12....       LCALL     ?XSTACK_DISP0_8
   \   00058D   E0           MOVX      A,@DPTR
   \   00058E   6411         XRL       A,#0x11
   \   000590   601E         JZ        ??zcl_ProcessMessageMSG_19
   \   000592   7407         MOV       A,#0x7
   \   000594   12....       LCALL     ?XSTACK_DISP0_8
   \   000597   E0           MOVX      A,@DPTR
   \   000598   6413         XRL       A,#0x13
   \   00059A   6014         JZ        ??zcl_ProcessMessageMSG_19
   \   00059C   7407         MOV       A,#0x7
   \   00059E   12....       LCALL     ?XSTACK_DISP0_8
   \   0005A1   E0           MOVX      A,@DPTR
   \   0005A2   6415         XRL       A,#0x15
   \   0005A4   600A         JZ        ??zcl_ProcessMessageMSG_19
   \   0005A6   7407         MOV       A,#0x7
   \   0005A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0005AB   E0           MOVX      A,@DPTR
   \   0005AC   640B         XRL       A,#0xb
   \   0005AE   700F         JNZ       ??zcl_ProcessMessageMSG_20
   2311                {
   2312                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_19:
   \   0005B0   90....       MOV       DPTR,#rawAFMsg
   \   0005B3   7400         MOV       A,#0x0
   \   0005B5   F0           MOVX      @DPTR,A
   \   0005B6   A3           INC       DPTR
   \   0005B7   7400         MOV       A,#0x0
   \   0005B9   F0           MOVX      @DPTR,A
   2313                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   0005BA   7900         MOV       R1,#0x0
   \   0005BC   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2314                }
   2315          
   2316                status = ZSuccess;
   \                     ??zcl_ProcessMessageMSG_20:
   \   0005BF   7E00         MOV       R6,#0x0
   \   0005C1   8077         SJMP      ??zcl_ProcessMessageMSG_15
   2317              }
   2318              else
   2319              {
   2320                // Unsupported message
   2321                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_16:
   \   0005C3   7E82         MOV       R6,#-0x7e
   \   0005C5   8073         SJMP      ??zcl_ProcessMessageMSG_15
   2322              }
   2323            }
   2324            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2325            {
   2326              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_13:
   \   0005C7   E5..         MOV       A,?V4
   \   0005C9   45..         ORL       A,?V5
   \   0005CB   604D         JZ        ??zcl_ProcessMessageMSG_21
   \   0005CD   85..82       MOV       DPL,?V4
   \   0005D0   85..83       MOV       DPH,?V5
   \   0005D3   A3           INC       DPTR
   \   0005D4   A3           INC       DPTR
   \   0005D5   A3           INC       DPTR
   \   0005D6   A3           INC       DPTR
   \   0005D7   A3           INC       DPTR
   \   0005D8   A3           INC       DPTR
   \   0005D9   E0           MOVX      A,@DPTR
   \   0005DA   F8           MOV       R0,A
   \   0005DB   A3           INC       DPTR
   \   0005DC   E0           MOVX      A,@DPTR
   \   0005DD   F9           MOV       R1,A
   \   0005DE   E8           MOV       A,R0
   \   0005DF   49           ORL       A,R1
   \   0005E0   6038         JZ        ??zcl_ProcessMessageMSG_21
   2327              {
   2328                // The return value of the plugin function will be
   2329                //  ZSuccess - Supported and need default response
   2330                //  ZFailure - Unsupported
   2331                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2332                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2333                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2334                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2335                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   0005E2                ; Setup parameters for indirect call
   \   0005E2   AA..         MOV       R2,?XSP + 0
   \   0005E4   AB..         MOV       R3,?XSP + 1
   \   0005E6   85..82       MOV       DPL,?V4
   \   0005E9   85..83       MOV       DPH,?V5
   \   0005EC   A3           INC       DPTR
   \   0005ED   A3           INC       DPTR
   \   0005EE   A3           INC       DPTR
   \   0005EF   A3           INC       DPTR
   \   0005F0   A3           INC       DPTR
   \   0005F1   A3           INC       DPTR
   \   0005F2   E0           MOVX      A,@DPTR
   \   0005F3   F8           MOV       R0,A
   \   0005F4   A3           INC       DPTR
   \   0005F5   E0           MOVX      A,@DPTR
   \   0005F6   F583         MOV       DPH,A
   \   0005F8   8882         MOV       DPL,R0
   \   0005FA   12....       LCALL     ?CALL_IND
   \   0005FD   E9           MOV       A,R1
   \   0005FE   FE           MOV       R6,A
   2336                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   0005FF   74FF         MOV       A,#-0x1
   \   000601   6E           XRL       A,R6
   \   000602   6007         JZ        ??zcl_ProcessMessageMSG_22
   \   000604   E5..         MOV       A,?V2
   \   000606   6012         JZ        ??zcl_ProcessMessageMSG_21
   \   000608   EE           MOV       A,R6
   \   000609   700F         JNZ       ??zcl_ProcessMessageMSG_21
   2337                {
   2338                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_22:
   \   00060B   90....       MOV       DPTR,#rawAFMsg
   \   00060E   7400         MOV       A,#0x0
   \   000610   F0           MOVX      @DPTR,A
   \   000611   A3           INC       DPTR
   \   000612   7400         MOV       A,#0x0
   \   000614   F0           MOVX      @DPTR,A
   2339                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   000615   7900         MOV       R1,#0x0
   \   000617   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2340                }
   2341              }
   2342          
   2343              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_21:
   \   00061A   7401         MOV       A,#0x1
   \   00061C   6E           XRL       A,R6
   \   00061D   701B         JNZ       ??zcl_ProcessMessageMSG_15
   2344              {
   2345                // Unsupported message
   2346                if ( inMsg.hdr.fc.manuSpecific )
   \   00061F   7402         MOV       A,#0x2
   \   000621   12....       LCALL     ?XSTACK_DISP0_8
   \   000624   E0           MOVX      A,@DPTR
   \   000625   F8           MOV       R0,A
   \   000626   A3           INC       DPTR
   \   000627   E0           MOVX      A,@DPTR
   \   000628   F9           MOV       R1,A
   \   000629   E8           MOV       A,R0
   \   00062A   13           RRC       A
   \   00062B   13           RRC       A
   \   00062C   543F         ANL       A,#0x3f
   \   00062E   5401         ANL       A,#0x1
   \   000630   A2E0         MOV       C,0xE0 /* A   */.0
   \   000632   5004         JNC       ??zcl_ProcessMessageMSG_23
   2347                {
   2348                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000634   7E83         MOV       R6,#-0x7d
   \   000636   8002         SJMP      ??zcl_ProcessMessageMSG_15
   2349                }
   2350                else
   2351                {
   2352                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_23:
   \   000638   7E81         MOV       R6,#-0x7f
   2353                }
   2354              }
   2355            }
   2356          
   2357            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_15:
   \   00063A   85..82       MOV       DPL,?XSP + 0
   \   00063D   85..83       MOV       DPH,?XSP + 1
   \   000640   E0           MOVX      A,@DPTR
   \   000641   F8           MOV       R0,A
   \   000642   A3           INC       DPTR
   \   000643   E0           MOVX      A,@DPTR
   \   000644   C8           XCH       A,R0
   \   000645   2415         ADD       A,#0x15
   \   000647   F582         MOV       DPL,A
   \   000649   C8           XCH       A,R0
   \   00064A   3400         ADDC      A,#0x0
   \   00064C   F583         MOV       DPH,A
   \   00064E   E0           MOVX      A,@DPTR
   \   00064F   6003         JZ        $+5
   \   000651   02....       LJMP      ??zcl_ProcessMessageMSG_24 & 0xFFFF
   \   000654   85..82       MOV       DPL,?XSP + 0
   \   000657   85..83       MOV       DPH,?XSP + 1
   \   00065A   E0           MOVX      A,@DPTR
   \   00065B   F8           MOV       R0,A
   \   00065C   A3           INC       DPTR
   \   00065D   E0           MOVX      A,@DPTR
   \   00065E   F583         MOV       DPH,A
   \   000660   8882         MOV       DPL,R0
   \   000662   A3           INC       DPTR
   \   000663   A3           INC       DPTR
   \   000664   E0           MOVX      A,@DPTR
   \   000665   F8           MOV       R0,A
   \   000666   A3           INC       DPTR
   \   000667   E0           MOVX      A,@DPTR
   \   000668   F9           MOV       R1,A
   \   000669   E8           MOV       A,R0
   \   00066A   49           ORL       A,R1
   \   00066B   6003         JZ        $+5
   \   00066D   02....       LJMP      ??zcl_ProcessMessageMSG_24 & 0xFFFF
   \   000670   7402         MOV       A,#0x2
   \   000672   12....       LCALL     ?XSTACK_DISP0_8
   \   000675   E0           MOVX      A,@DPTR
   \   000676   F8           MOV       R0,A
   \   000677   A3           INC       DPTR
   \   000678   E0           MOVX      A,@DPTR
   \   000679   F9           MOV       R1,A
   \   00067A   E8           MOV       A,R0
   \   00067B   C4           SWAP      A
   \   00067C   540F         ANL       A,#0xf
   \   00067E   5401         ANL       A,#0x1
   \   000680   A2E0         MOV       C,0xE0 /* A   */.0
   \   000682   5003         JNC       $+5
   \   000684   02....       LJMP      ??zcl_ProcessMessageMSG_24 & 0xFFFF
   2358            {
   2359              // Send a Default Response command back
   2360              defautlRspCmd.statusCode = status;
   \   000687   EE           MOV       A,R6
   \   000688   C0E0         PUSH      A
   \   00068A   740F         MOV       A,#0xf
   \   00068C   12....       LCALL     ?XSTACK_DISP0_8
   \   00068F   D0E0         POP       A
   \   000691   F0           MOVX      @DPTR,A
   2361              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   000692   7407         MOV       A,#0x7
   \   000694   12....       LCALL     ?XSTACK_DISP0_8
   \   000697   E0           MOVX      A,@DPTR
   \   000698   C0E0         PUSH      A
   \   00069A   740E         MOV       A,#0xe
   \   00069C   12....       LCALL     ?XSTACK_DISP0_8
   \   00069F   D0E0         POP       A
   \   0006A1   F0           MOVX      @DPTR,A
   2362              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2363                                     inMsg.msg->clusterId, &defautlRspCmd,
   2364                                     !inMsg.hdr.fc.direction, true,
   2365                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   0006A2                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   0006A2   7406         MOV       A,#0x6
   \   0006A4   12....       LCALL     ?XSTACK_DISP0_8
   \   0006A7   E0           MOVX      A,@DPTR
   \   0006A8   F5..         MOV       ?V8,A
   \   0006AA   78..         MOV       R0,#?V8
   \   0006AC   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0006AF   7405         MOV       A,#0x5
   \   0006B1   12....       LCALL     ?XSTACK_DISP0_8
   \   0006B4   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0006B7   75..01       MOV       ?V8,#0x1
   \   0006BA   78..         MOV       R0,#?V8
   \   0006BC   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0006BF   7406         MOV       A,#0x6
   \   0006C1   12....       LCALL     ?XSTACK_DISP0_8
   \   0006C4   E0           MOVX      A,@DPTR
   \   0006C5   F8           MOV       R0,A
   \   0006C6   A3           INC       DPTR
   \   0006C7   E0           MOVX      A,@DPTR
   \   0006C8   F9           MOV       R1,A
   \   0006C9   E8           MOV       A,R0
   \   0006CA   13           RRC       A
   \   0006CB   13           RRC       A
   \   0006CC   13           RRC       A
   \   0006CD   541F         ANL       A,#0x1f
   \   0006CF   6401         XRL       A,#0x1
   \   0006D1   5401         ANL       A,#0x1
   \   0006D3   F5..         MOV       ?V8,A
   \   0006D5   78..         MOV       R0,#?V8
   \   0006D7   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0006DA   7413         MOV       A,#0x13
   \   0006DC   12....       LCALL     ?XSTACK_DISP100_8
   \   0006DF   88..         MOV       ?V8,R0
   \   0006E1   89..         MOV       ?V9,R1
   \   0006E3   78..         MOV       R0,#?V8
   \   0006E5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0006E8   7407         MOV       A,#0x7
   \   0006EA   12....       LCALL     ?XSTACK_DISP0_8
   \   0006ED   E0           MOVX      A,@DPTR
   \   0006EE   F8           MOV       R0,A
   \   0006EF   A3           INC       DPTR
   \   0006F0   E0           MOVX      A,@DPTR
   \   0006F1   F583         MOV       DPH,A
   \   0006F3   8882         MOV       DPL,R0
   \   0006F5   A3           INC       DPTR
   \   0006F6   A3           INC       DPTR
   \   0006F7   A3           INC       DPTR
   \   0006F8   A3           INC       DPTR
   \   0006F9   E0           MOVX      A,@DPTR
   \   0006FA   FC           MOV       R4,A
   \   0006FB   A3           INC       DPTR
   \   0006FC   E0           MOVX      A,@DPTR
   \   0006FD   FD           MOV       R5,A
   \   0006FE   7407         MOV       A,#0x7
   \   000700   12....       LCALL     ?XSTACK_DISP0_8
   \   000703   E0           MOVX      A,@DPTR
   \   000704   2406         ADD       A,#0x6
   \   000706   FA           MOV       R2,A
   \   000707   A3           INC       DPTR
   \   000708   E0           MOVX      A,@DPTR
   \   000709   3400         ADDC      A,#0x0
   \   00070B   FB           MOV       R3,A
   \   00070C   7407         MOV       A,#0x7
   \   00070E   12....       LCALL     ?XSTACK_DISP0_8
   \   000711   E0           MOVX      A,@DPTR
   \   000712   F8           MOV       R0,A
   \   000713   A3           INC       DPTR
   \   000714   E0           MOVX      A,@DPTR
   \   000715   C8           XCH       A,R0
   \   000716   2414         ADD       A,#0x14
   \   000718   F582         MOV       DPL,A
   \   00071A   C8           XCH       A,R0
   \   00071B   3400         ADDC      A,#0x0
   \   00071D   F583         MOV       DPH,A
   \   00071F   E0           MOVX      A,@DPTR
   \   000720   F9           MOV       R1,A
   \   000721   12....       LCALL     `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   000724   7407         MOV       A,#0x7
   \   000726   12....       LCALL     ?DEALLOC_XSTACK8
   \   000729   E9           MOV       A,R1
   2366              defaultResponseSent = TRUE;
   \   00072A   7F01         MOV       R7,#0x1
   2367            }
   2368          
   2369            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_24:
   \   00072C   90....       MOV       DPTR,#rawAFMsg
   \   00072F   7400         MOV       A,#0x0
   \   000731   F0           MOVX      @DPTR,A
   \   000732   A3           INC       DPTR
   \   000733   7400         MOV       A,#0x0
   \   000735   F0           MOVX      @DPTR,A
   2370            if ( status == ZSuccess )
   \   000736   EE           MOV       A,R6
   \   000737   7004         JNZ       ??zcl_ProcessMessageMSG_25
   2371            {
   2372              return ( ZCL_PROC_SUCCESS );
   \   000739   7900         MOV       R1,#0x0
   \   00073B   8019         SJMP      ??zcl_ProcessMessageMSG_1
   2373            }
   2374            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_25:
   \   00073D   7484         MOV       A,#-0x7c
   \   00073F   6E           XRL       A,R6
   \   000740   700B         JNZ       ??zcl_ProcessMessageMSG_26
   2375            {
   2376              if ( defaultResponseSent )
   \   000742   EF           MOV       A,R7
   \   000743   6004         JZ        ??zcl_ProcessMessageMSG_27
   2377              {
   2378                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   000745   7907         MOV       R1,#0x7
   \   000747   800D         SJMP      ??zcl_ProcessMessageMSG_1
   2379              }
   2380              else
   2381              {
   2382                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_27:
   \   000749   7906         MOV       R1,#0x6
   \   00074B   8009         SJMP      ??zcl_ProcessMessageMSG_1
   2383              }
   2384            }
   2385            else
   2386            {
   2387              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_26:
   \   00074D   EF           MOV       A,R7
   \   00074E   6004         JZ        ??zcl_ProcessMessageMSG_28
   2388              {
   2389                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000750   7909         MOV       R1,#0x9
   \   000752   8002         SJMP      ??zcl_ProcessMessageMSG_1
   2390              }
   2391              else
   2392              {
   2393                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_28:
   \   000754   7908         MOV       R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   000756   7415         MOV       A,#0x15
   \   000758   12....       LCALL     ?DEALLOC_XSTACK8
   \   00075B   7F0B         MOV       R7,#0xb
   \   00075D   02....       LJMP      ?BANKED_LEAVE_XDATA
   2394              }
   2395            }
   2396          }
   2397          
   2398          /*********************************************************************
   2399           * PRIVATE FUNCTIONS
   2400           *********************************************************************/
   2401          
   2402          /*********************************************************************
   2403           * @fn      zclParseHdr
   2404           *
   2405           * @brief   Parse header of the ZCL format
   2406           *
   2407           * @param   hdr - place to put the frame control information
   2408           * @param   pData - incoming buffer to parse
   2409           *
   2410           * @return  pointer past the header
   2411           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2412          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2413          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   2414            // Clear the header
   2415            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV       R4,#0x6
   \   00000F   7D00         MOV       R5,#0x0
   \   000011   7900         MOV       R1,#0x0
   \   000013   AA..         MOV       R2,?V0
   \   000015   AB..         MOV       R3,?V1
   \   000017   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2416          
   2417            // Parse the Frame Control
   2418            hdr->fc.type = zcl_FCType( *pData );
   \   00001A   8E82         MOV       DPL,R6
   \   00001C   8F83         MOV       DPH,R7
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F8           MOV       R0,A
   \   000020   7900         MOV       R1,#0x0
   \   000022   E8           MOV       A,R0
   \   000023   5403         ANL       A,#0x3
   \   000025   F8           MOV       R0,A
   \   000026   E9           MOV       A,R1
   \   000027   5400         ANL       A,#0x0
   \   000029   F9           MOV       R1,A
   \   00002A   85..82       MOV       DPL,?V0
   \   00002D   85..83       MOV       DPH,?V1
   \   000030   E0           MOVX      A,@DPTR
   \   000031   54FC         ANL       A,#0xfc
   \   000033   F0           MOVX      @DPTR,A
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   54FF         ANL       A,#0xff
   \   000038   F0           MOVX      @DPTR,A
   \   000039   E8           MOV       A,R0
   \   00003A   5403         ANL       A,#0x3
   \   00003C   F8           MOV       R0,A
   \   00003D   E9           MOV       A,R1
   \   00003E   5400         ANL       A,#0x0
   \   000040   F9           MOV       R1,A
   \   000041   85..82       MOV       DPL,?V0
   \   000044   85..83       MOV       DPH,?V1
   \   000047   E0           MOVX      A,@DPTR
   \   000048   48           ORL       A,R0
   \   000049   F0           MOVX      @DPTR,A
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   49           ORL       A,R1
   \   00004D   F0           MOVX      @DPTR,A
   2419            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \   00004E   8E82         MOV       DPL,R6
   \   000050   8F83         MOV       DPH,R7
   \   000052   E0           MOVX      A,@DPTR
   \   000053   A2E2         MOV       C,0xE0 /* A   */.2
   \   000055   5004         JNC       ??zclParseHdr_0
   \   000057   D2F0         SETB      B.0
   \   000059   8002         SJMP      ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   00005B   C2F0         CLR       B.0
   \                     ??zclParseHdr_1:
   \   00005D   85..82       MOV       DPL,?V0
   \   000060   85..83       MOV       DPH,?V1
   \   000063   E0           MOVX      A,@DPTR
   \   000064   54FB         ANL       A,#0xfb
   \   000066   F0           MOVX      @DPTR,A
   \   000067   A3           INC       DPTR
   \   000068   E0           MOVX      A,@DPTR
   \   000069   54FF         ANL       A,#0xff
   \   00006B   F0           MOVX      @DPTR,A
   \   00006C   A2F0         MOV       C,B.0
   \   00006E   E4           CLR       A
   \   00006F   33           RLC       A
   \   000070   F5..         MOV       ?V2,A
   \   000072   75..00       MOV       ?V3,#0x0
   \   000075   7402         MOV       A,#0x2
   \   000077   78..         MOV       R0,#?V2
   \   000079   12....       LCALL     ?S_SHL
   \   00007C   85..82       MOV       DPL,?V0
   \   00007F   85..83       MOV       DPH,?V1
   \   000082   E0           MOVX      A,@DPTR
   \   000083   45..         ORL       A,?V2
   \   000085   F0           MOVX      @DPTR,A
   \   000086   A3           INC       DPTR
   \   000087   E0           MOVX      A,@DPTR
   \   000088   45..         ORL       A,?V3
   \   00008A   F0           MOVX      @DPTR,A
   2420            if ( zcl_FCDirection( *pData ) )
   \   00008B   8E82         MOV       DPL,R6
   \   00008D   8F83         MOV       DPH,R7
   \   00008F   E0           MOVX      A,@DPTR
   \   000090   A2E3         MOV       C,0xE0 /* A   */.3
   \   000092   5011         JNC       ??zclParseHdr_2
   2421            {
   2422              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000094   85..82       MOV       DPL,?V0
   \   000097   85..83       MOV       DPH,?V1
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   4408         ORL       A,#0x8
   \   00009D   F0           MOVX      @DPTR,A
   \   00009E   A3           INC       DPTR
   \   00009F   E0           MOVX      A,@DPTR
   \   0000A0   4400         ORL       A,#0x0
   \   0000A2   F0           MOVX      @DPTR,A
   \   0000A3   800F         SJMP      ??zclParseHdr_3
   2423            }
   2424            else
   2425            {
   2426              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   0000A5   85..82       MOV       DPL,?V0
   \   0000A8   85..83       MOV       DPH,?V1
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   54F7         ANL       A,#0xf7
   \   0000AE   F0           MOVX      @DPTR,A
   \   0000AF   A3           INC       DPTR
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   54FF         ANL       A,#0xff
   \   0000B3   F0           MOVX      @DPTR,A
   2427            }
   2428          
   2429            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??zclParseHdr_3:
   \   0000B4   8E82         MOV       DPL,R6
   \   0000B6   8F83         MOV       DPH,R7
   \   0000B8   E0           MOVX      A,@DPTR
   \   0000B9   A2E4         MOV       C,0xE0 /* A   */.4
   \   0000BB   5004         JNC       ??zclParseHdr_4
   \   0000BD   D2F0         SETB      B.0
   \   0000BF   8002         SJMP      ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   0000C1   C2F0         CLR       B.0
   \                     ??zclParseHdr_5:
   \   0000C3   85..82       MOV       DPL,?V0
   \   0000C6   85..83       MOV       DPH,?V1
   \   0000C9   E0           MOVX      A,@DPTR
   \   0000CA   54EF         ANL       A,#0xef
   \   0000CC   F0           MOVX      @DPTR,A
   \   0000CD   A3           INC       DPTR
   \   0000CE   E0           MOVX      A,@DPTR
   \   0000CF   54FF         ANL       A,#0xff
   \   0000D1   F0           MOVX      @DPTR,A
   \   0000D2   A2F0         MOV       C,B.0
   \   0000D4   E4           CLR       A
   \   0000D5   33           RLC       A
   \   0000D6   F5..         MOV       ?V2,A
   \   0000D8   75..00       MOV       ?V3,#0x0
   \   0000DB   7404         MOV       A,#0x4
   \   0000DD   78..         MOV       R0,#?V2
   \   0000DF   12....       LCALL     ?S_SHL
   \   0000E2   85..82       MOV       DPL,?V0
   \   0000E5   85..83       MOV       DPH,?V1
   \   0000E8   E0           MOVX      A,@DPTR
   \   0000E9   45..         ORL       A,?V2
   \   0000EB   F0           MOVX      @DPTR,A
   \   0000EC   A3           INC       DPTR
   \   0000ED   E0           MOVX      A,@DPTR
   \   0000EE   45..         ORL       A,?V3
   \   0000F0   F0           MOVX      @DPTR,A
   2430            pData++;  // move past the frame control field
   \   0000F1   8E82         MOV       DPL,R6
   \   0000F3   8F83         MOV       DPH,R7
   \   0000F5   A3           INC       DPTR
   \   0000F6   AE82         MOV       R6,DPL
   \   0000F8   AF83         MOV       R7,DPH
   2431          
   2432            // parse the manfacturer code
   2433            if ( hdr->fc.manuSpecific )
   \   0000FA   85..82       MOV       DPL,?V0
   \   0000FD   85..83       MOV       DPH,?V1
   \   000100   E0           MOVX      A,@DPTR
   \   000101   F8           MOV       R0,A
   \   000102   A3           INC       DPTR
   \   000103   E0           MOVX      A,@DPTR
   \   000104   F9           MOV       R1,A
   \   000105   E8           MOV       A,R0
   \   000106   13           RRC       A
   \   000107   13           RRC       A
   \   000108   543F         ANL       A,#0x3f
   \   00010A   5401         ANL       A,#0x1
   \   00010C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00010E   502E         JNC       ??zclParseHdr_6
   2434            {
   2435              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   000110   8E82         MOV       DPL,R6
   \   000112   8F83         MOV       DPH,R7
   \   000114   E0           MOVX      A,@DPTR
   \   000115   FA           MOV       R2,A
   \   000116   7B00         MOV       R3,#0x0
   \   000118   8E82         MOV       DPL,R6
   \   00011A   8F83         MOV       DPH,R7
   \   00011C   A3           INC       DPTR
   \   00011D   E0           MOVX      A,@DPTR
   \   00011E   F8           MOV       R0,A
   \   00011F   7900         MOV       R1,#0x0
   \   000121   E4           CLR       A
   \   000122   C8           XCH       A,R0
   \   000123   F9           MOV       R1,A
   \   000124   EA           MOV       A,R2
   \   000125   28           ADD       A,R0
   \   000126   F8           MOV       R0,A
   \   000127   EB           MOV       A,R3
   \   000128   39           ADDC      A,R1
   \   000129   F9           MOV       R1,A
   \   00012A   85..82       MOV       DPL,?V0
   \   00012D   85..83       MOV       DPH,?V1
   \   000130   A3           INC       DPTR
   \   000131   A3           INC       DPTR
   \   000132   E8           MOV       A,R0
   \   000133   F0           MOVX      @DPTR,A
   \   000134   A3           INC       DPTR
   \   000135   E9           MOV       A,R1
   \   000136   F0           MOVX      @DPTR,A
   2436              pData += 2;
   \   000137   EE           MOV       A,R6
   \   000138   2402         ADD       A,#0x2
   \   00013A   FE           MOV       R6,A
   \   00013B   5001         JNC       ??zclParseHdr_6
   \   00013D   0F           INC       R7
   2437            }
   2438          
   2439            // parse the Transaction Sequence Number
   2440            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   00013E   8E82         MOV       DPL,R6
   \   000140   8F83         MOV       DPH,R7
   \   000142   E0           MOVX      A,@DPTR
   \   000143   C0E0         PUSH      A
   \   000145   85..82       MOV       DPL,?V0
   \   000148   85..83       MOV       DPH,?V1
   \   00014B   A3           INC       DPTR
   \   00014C   A3           INC       DPTR
   \   00014D   A3           INC       DPTR
   \   00014E   A3           INC       DPTR
   \   00014F   D0E0         POP       A
   \   000151   F0           MOVX      @DPTR,A
   \   000152   8E82         MOV       DPL,R6
   \   000154   8F83         MOV       DPH,R7
   \   000156   A3           INC       DPTR
   \   000157   AE82         MOV       R6,DPL
   \   000159   AF83         MOV       R7,DPH
   2441          
   2442            // parse the Cluster's command ID
   2443            hdr->commandID = *pData++;
   \   00015B   8E82         MOV       DPL,R6
   \   00015D   8F83         MOV       DPH,R7
   \   00015F   E0           MOVX      A,@DPTR
   \   000160   C0E0         PUSH      A
   \   000162   85..82       MOV       DPL,?V0
   \   000165   85..83       MOV       DPH,?V1
   \   000168   A3           INC       DPTR
   \   000169   A3           INC       DPTR
   \   00016A   A3           INC       DPTR
   \   00016B   A3           INC       DPTR
   \   00016C   A3           INC       DPTR
   \   00016D   D0E0         POP       A
   \   00016F   F0           MOVX      @DPTR,A
   \   000170   8E82         MOV       DPL,R6
   \   000172   8F83         MOV       DPH,R7
   \   000174   A3           INC       DPTR
   \   000175   AE82         MOV       R6,DPL
   \   000177   AF83         MOV       R7,DPH
   2444          
   2445            // Should point to the frame payload
   2446            return ( pData );
   \   000179   EE           MOV       A,R6
   \   00017A   FA           MOV       R2,A
   \   00017B   EF           MOV       A,R7
   \   00017C   FB           MOV       R3,A
   \   00017D   7F04         MOV       R7,#0x4
   \   00017F   02....       LJMP      ?BANKED_LEAVE_XDATA
   2447          }
   2448          
   2449          /*********************************************************************
   2450           * @fn      zclBuildHdr
   2451           *
   2452           * @brief   Build header of the ZCL format
   2453           *
   2454           * @param   hdr - outgoing header information
   2455           * @param   pData - outgoing header space
   2456           *
   2457           * @return  pointer past the header
   2458           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2459          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2460          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   EA           MOV       A,R2
   \   000005   F8           MOV       R0,A
   \   000006   EB           MOV       A,R3
   \   000007   F9           MOV       R1,A
   \   000008   EC           MOV       A,R4
   \   000009   FA           MOV       R2,A
   \   00000A   ED           MOV       A,R5
   \   00000B   FB           MOV       R3,A
   2461            // Build the Frame Control byte
   2462            *pData = hdr->fc.type;
   \   00000C   8882         MOV       DPL,R0
   \   00000E   8983         MOV       DPH,R1
   \   000010   E0           MOVX      A,@DPTR
   \   000011   FC           MOV       R4,A
   \   000012   A3           INC       DPTR
   \   000013   E0           MOVX      A,@DPTR
   \   000014   FD           MOV       R5,A
   \   000015   EC           MOV       A,R4
   \   000016   5403         ANL       A,#0x3
   \   000018   C0E0         PUSH      A
   \   00001A   8A82         MOV       DPL,R2
   \   00001C   8B83         MOV       DPH,R3
   \   00001E   D0E0         POP       A
   \   000020   F0           MOVX      @DPTR,A
   2463            *pData |= hdr->fc.manuSpecific << 2;
   \   000021   8882         MOV       DPL,R0
   \   000023   8983         MOV       DPH,R1
   \   000025   E0           MOVX      A,@DPTR
   \   000026   FC           MOV       R4,A
   \   000027   A3           INC       DPTR
   \   000028   E0           MOVX      A,@DPTR
   \   000029   FD           MOV       R5,A
   \   00002A   EC           MOV       A,R4
   \   00002B   13           RRC       A
   \   00002C   13           RRC       A
   \   00002D   543F         ANL       A,#0x3f
   \   00002F   5401         ANL       A,#0x1
   \   000031   33           RLC       A
   \   000032   33           RLC       A
   \   000033   54FC         ANL       A,#0xfc
   \   000035   FC           MOV       R4,A
   \   000036   8A82         MOV       DPL,R2
   \   000038   8B83         MOV       DPH,R3
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   4C           ORL       A,R4
   \   00003C   F0           MOVX      @DPTR,A
   2464            *pData |= hdr->fc.direction << 3;
   \   00003D   8882         MOV       DPL,R0
   \   00003F   8983         MOV       DPH,R1
   \   000041   E0           MOVX      A,@DPTR
   \   000042   FC           MOV       R4,A
   \   000043   A3           INC       DPTR
   \   000044   E0           MOVX      A,@DPTR
   \   000045   FD           MOV       R5,A
   \   000046   EC           MOV       A,R4
   \   000047   13           RRC       A
   \   000048   13           RRC       A
   \   000049   13           RRC       A
   \   00004A   541F         ANL       A,#0x1f
   \   00004C   5401         ANL       A,#0x1
   \   00004E   33           RLC       A
   \   00004F   33           RLC       A
   \   000050   33           RLC       A
   \   000051   54F8         ANL       A,#0xf8
   \   000053   FC           MOV       R4,A
   \   000054   8A82         MOV       DPL,R2
   \   000056   8B83         MOV       DPH,R3
   \   000058   E0           MOVX      A,@DPTR
   \   000059   4C           ORL       A,R4
   \   00005A   F0           MOVX      @DPTR,A
   2465            *pData |= hdr->fc.disableDefaultRsp << 4;
   \   00005B   8882         MOV       DPL,R0
   \   00005D   8983         MOV       DPH,R1
   \   00005F   E0           MOVX      A,@DPTR
   \   000060   FC           MOV       R4,A
   \   000061   A3           INC       DPTR
   \   000062   E0           MOVX      A,@DPTR
   \   000063   FD           MOV       R5,A
   \   000064   EC           MOV       A,R4
   \   000065   C4           SWAP      A
   \   000066   540F         ANL       A,#0xf
   \   000068   5401         ANL       A,#0x1
   \   00006A   C4           SWAP      A
   \   00006B   54F0         ANL       A,#0xf0
   \   00006D   FC           MOV       R4,A
   \   00006E   8A82         MOV       DPL,R2
   \   000070   8B83         MOV       DPH,R3
   \   000072   E0           MOVX      A,@DPTR
   \   000073   4C           ORL       A,R4
   \   000074   F0           MOVX      @DPTR,A
   2466            pData++;  // move past the frame control field
   \   000075   8A82         MOV       DPL,R2
   \   000077   8B83         MOV       DPH,R3
   \   000079   A3           INC       DPTR
   \   00007A   AA82         MOV       R2,DPL
   \   00007C   AB83         MOV       R3,DPH
   2467          
   2468            // Add the manfacturer code
   2469            if ( hdr->fc.manuSpecific )
   \   00007E   8882         MOV       DPL,R0
   \   000080   8983         MOV       DPH,R1
   \   000082   E0           MOVX      A,@DPTR
   \   000083   FC           MOV       R4,A
   \   000084   A3           INC       DPTR
   \   000085   E0           MOVX      A,@DPTR
   \   000086   FD           MOV       R5,A
   \   000087   EC           MOV       A,R4
   \   000088   13           RRC       A
   \   000089   13           RRC       A
   \   00008A   543F         ANL       A,#0x3f
   \   00008C   5401         ANL       A,#0x1
   \   00008E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000090   503F         JNC       ??zclBuildHdr_0
   2470            {
   2471              *pData++ = LO_UINT16( hdr->manuCode );
   \   000092   8882         MOV       DPL,R0
   \   000094   8983         MOV       DPH,R1
   \   000096   A3           INC       DPTR
   \   000097   A3           INC       DPTR
   \   000098   E0           MOVX      A,@DPTR
   \   000099   FC           MOV       R4,A
   \   00009A   A3           INC       DPTR
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   FD           MOV       R5,A
   \   00009D   EC           MOV       A,R4
   \   00009E   C0E0         PUSH      A
   \   0000A0   8A82         MOV       DPL,R2
   \   0000A2   8B83         MOV       DPH,R3
   \   0000A4   D0E0         POP       A
   \   0000A6   F0           MOVX      @DPTR,A
   \   0000A7   8A82         MOV       DPL,R2
   \   0000A9   8B83         MOV       DPH,R3
   \   0000AB   A3           INC       DPTR
   \   0000AC   AA82         MOV       R2,DPL
   \   0000AE   AB83         MOV       R3,DPH
   2472              *pData++ = HI_UINT16( hdr->manuCode );
   \   0000B0   8882         MOV       DPL,R0
   \   0000B2   8983         MOV       DPH,R1
   \   0000B4   A3           INC       DPTR
   \   0000B5   A3           INC       DPTR
   \   0000B6   E0           MOVX      A,@DPTR
   \   0000B7   FC           MOV       R4,A
   \   0000B8   A3           INC       DPTR
   \   0000B9   E0           MOVX      A,@DPTR
   \   0000BA   FD           MOV       R5,A
   \   0000BB   E4           CLR       A
   \   0000BC   CD           XCH       A,R5
   \   0000BD   FC           MOV       R4,A
   \   0000BE   EC           MOV       A,R4
   \   0000BF   C0E0         PUSH      A
   \   0000C1   8A82         MOV       DPL,R2
   \   0000C3   8B83         MOV       DPH,R3
   \   0000C5   D0E0         POP       A
   \   0000C7   F0           MOVX      @DPTR,A
   \   0000C8   8A82         MOV       DPL,R2
   \   0000CA   8B83         MOV       DPH,R3
   \   0000CC   A3           INC       DPTR
   \   0000CD   AA82         MOV       R2,DPL
   \   0000CF   AB83         MOV       R3,DPH
   2473            }
   2474          
   2475            // Add the Transaction Sequence Number
   2476            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   0000D1   8882         MOV       DPL,R0
   \   0000D3   8983         MOV       DPH,R1
   \   0000D5   A3           INC       DPTR
   \   0000D6   A3           INC       DPTR
   \   0000D7   A3           INC       DPTR
   \   0000D8   A3           INC       DPTR
   \   0000D9   E0           MOVX      A,@DPTR
   \   0000DA   C0E0         PUSH      A
   \   0000DC   8A82         MOV       DPL,R2
   \   0000DE   8B83         MOV       DPH,R3
   \   0000E0   D0E0         POP       A
   \   0000E2   F0           MOVX      @DPTR,A
   \   0000E3   8A82         MOV       DPL,R2
   \   0000E5   8B83         MOV       DPH,R3
   \   0000E7   A3           INC       DPTR
   \   0000E8   AA82         MOV       R2,DPL
   \   0000EA   AB83         MOV       R3,DPH
   2477          
   2478            // Add the Cluster's command ID
   2479            *pData++ = hdr->commandID;
   \   0000EC   8882         MOV       DPL,R0
   \   0000EE   8983         MOV       DPH,R1
   \   0000F0   A3           INC       DPTR
   \   0000F1   A3           INC       DPTR
   \   0000F2   A3           INC       DPTR
   \   0000F3   A3           INC       DPTR
   \   0000F4   A3           INC       DPTR
   \   0000F5   E0           MOVX      A,@DPTR
   \   0000F6   C0E0         PUSH      A
   \   0000F8   8A82         MOV       DPL,R2
   \   0000FA   8B83         MOV       DPH,R3
   \   0000FC   D0E0         POP       A
   \   0000FE   F0           MOVX      @DPTR,A
   \   0000FF   8A82         MOV       DPL,R2
   \   000101   8B83         MOV       DPH,R3
   \   000103   A3           INC       DPTR
   \   000104   AA82         MOV       R2,DPL
   \   000106   AB83         MOV       R3,DPH
   2480          
   2481            // Should point to the frame payload
   2482            return ( pData );
   \   000108   D083         POP       DPH
   \   00010A   D082         POP       DPL
   \   00010C   02....       LJMP      ?BRET
   2483          }
   2484          
   2485          /*********************************************************************
   2486           * @fn      zclCalcHdrSize
   2487           *
   2488           * @brief   Calculate the number of bytes needed for an outgoing
   2489           *          ZCL header.
   2490           *
   2491           * @param   hdr - outgoing header information
   2492           *
   2493           * @return  returns the number of bytes needed
   2494           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2495          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   \                     zclCalcHdrSize:
   2496          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2497            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   \   000004   7903         MOV       R1,#0x3
   2498          
   2499            // Add the manfacturer code
   2500            if ( hdr->fc.manuSpecific )
   \   000006   8A82         MOV       DPL,R2
   \   000008   8B83         MOV       DPH,R3
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   FC           MOV       R4,A
   \   00000C   A3           INC       DPTR
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   FD           MOV       R5,A
   \   00000F   EC           MOV       A,R4
   \   000010   13           RRC       A
   \   000011   13           RRC       A
   \   000012   543F         ANL       A,#0x3f
   \   000014   5401         ANL       A,#0x1
   \   000016   A2E0         MOV       C,0xE0 /* A   */.0
   \   000018   5004         JNC       ??zclCalcHdrSize_0
   2501            {
   2502              needed += 2;
   \   00001A   7402         MOV       A,#0x2
   \   00001C   29           ADD       A,R1
   \   00001D   F9           MOV       R1,A
   2503            }
   2504          
   2505            return ( needed );
   \                     ??zclCalcHdrSize_0:
   \   00001E   D083         POP       DPH
   \   000020   D082         POP       DPL
   \   000022   02....       LJMP      ?BRET
   2506          }
   2507          
   2508          /*********************************************************************
   2509           * @fn      zclFindPlugin
   2510           *
   2511           * @brief   Find the right plugin for a cluster ID
   2512           *
   2513           * @param   clusterID - cluster ID to look for
   2514           * @param   profileID - profile ID
   2515           *
   2516           * @return  pointer to plugin, NULL if not found
   2517           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2518          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   \                     zclFindPlugin:
   2519          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2520            zclLibPlugin_t *pLoop = plugins;
   \   000009   90....       MOV       DPTR,#plugins
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F8           MOV       R0,A
   \   00000E   A3           INC       DPTR
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   F9           MOV       R1,A
   2521          
   2522            (void)profileID;  // Intentionally unreferenced parameter
   2523          
   2524            while ( pLoop != NULL )
   \                     ??zclFindPlugin_0:
   \   000011   E8           MOV       A,R0
   \   000012   49           ORL       A,R1
   \   000013   6033         JZ        ??zclFindPlugin_1
   2525            {
   2526              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   \   000015   8882         MOV       DPL,R0
   \   000017   8983         MOV       DPH,R1
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   FA           MOV       R2,A
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   FB           MOV       R3,A
   \   000020   C3           CLR       C
   \   000021   EE           MOV       A,R6
   \   000022   9A           SUBB      A,R2
   \   000023   EF           MOV       A,R7
   \   000024   9B           SUBB      A,R3
   \   000025   4016         JC        ??zclFindPlugin_2
   \   000027   8882         MOV       DPL,R0
   \   000029   8983         MOV       DPH,R1
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   C3           CLR       C
   \   000030   E0           MOVX      A,@DPTR
   \   000031   9E           SUBB      A,R6
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   9F           SUBB      A,R7
   \   000035   4006         JC        ??zclFindPlugin_2
   2527              {
   2528                return ( pLoop );
   \   000037   E8           MOV       A,R0
   \   000038   FA           MOV       R2,A
   \   000039   E9           MOV       A,R1
   \   00003A   FB           MOV       R3,A
   \   00003B   800F         SJMP      ??zclFindPlugin_3
   2529              }
   2530          
   2531              pLoop = pLoop->next;
   \                     ??zclFindPlugin_2:
   \   00003D   8882         MOV       DPL,R0
   \   00003F   8983         MOV       DPH,R1
   \   000041   E0           MOVX      A,@DPTR
   \   000042   F8           MOV       R0,A
   \   000043   A3           INC       DPTR
   \   000044   E0           MOVX      A,@DPTR
   \   000045   F9           MOV       R1,A
   \   000046   80C9         SJMP      ??zclFindPlugin_0
   2532            }
   2533          
   2534            return ( (zclLibPlugin_t *)NULL );
   \                     ??zclFindPlugin_1:
   \   000048   7A00         MOV       R2,#0x0
   \   00004A   7B00         MOV       R3,#0x0
   \                     ??zclFindPlugin_3:
   \   00004C   7F01         MOV       R7,#0x1
   \   00004E   02....       LJMP      ?BANKED_LEAVE_XDATA
   2535          }
   2536          
   2537          #ifdef ZCL_DISCOVER
   2538          /*********************************************************************
   2539           * @fn      zclFindCmdRecsList
   2540           *
   2541           * @brief   Find the right command record list for an endpoint
   2542           *
   2543           * @param   endpoint - endpoint to look for
   2544           *
   2545           * @return  pointer to record list, NULL if not found
   2546           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2547          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   \                     zclFindCmdRecsList:
   2548          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2549            zclCmdRecsList_t *pLoop = gpCmdList;
   \   000004   90....       MOV       DPTR,#gpCmdList
   \   000007   E0           MOVX      A,@DPTR
   \   000008   FC           MOV       R4,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   FD           MOV       R5,A
   2550          
   2551            while ( pLoop != NULL )
   \                     ??zclFindCmdRecsList_0:
   \   00000C   EC           MOV       A,R4
   \   00000D   4D           ORL       A,R5
   \   00000E   601B         JZ        ??zclFindCmdRecsList_1
   2552            {
   2553              if ( pLoop->endpoint == endpoint )
   \   000010   8C82         MOV       DPL,R4
   \   000012   8D83         MOV       DPH,R5
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   69           XRL       A,R1
   \   000018   7006         JNZ       ??zclFindCmdRecsList_2
   2554              {
   2555                return ( pLoop );
   \   00001A   EC           MOV       A,R4
   \   00001B   FA           MOV       R2,A
   \   00001C   ED           MOV       A,R5
   \   00001D   FB           MOV       R3,A
   \   00001E   800F         SJMP      ??zclFindCmdRecsList_3
   2556              }
   2557          
   2558              pLoop = pLoop->pNext;
   \                     ??zclFindCmdRecsList_2:
   \   000020   8C82         MOV       DPL,R4
   \   000022   8D83         MOV       DPH,R5
   \   000024   E0           MOVX      A,@DPTR
   \   000025   FC           MOV       R4,A
   \   000026   A3           INC       DPTR
   \   000027   E0           MOVX      A,@DPTR
   \   000028   FD           MOV       R5,A
   \   000029   80E1         SJMP      ??zclFindCmdRecsList_0
   2559            }
   2560          
   2561            return ( NULL );
   \                     ??zclFindCmdRecsList_1:
   \   00002B   7A00         MOV       R2,#0x0
   \   00002D   7B00         MOV       R3,#0x0
   \                     ??zclFindCmdRecsList_3:
   \   00002F   D083         POP       DPH
   \   000031   D082         POP       DPL
   \   000033   02....       LJMP      ?BRET
   2562          }
   2563          
   2564          /*********************************************************************
   2565           * @fn      zclFindCmdRec
   2566           *
   2567           * @brief   Find the command record that matchs the parameters
   2568           *
   2569           * @param   endpoint - Application's endpoint
   2570           * @param   clusterID - cluster ID
   2571           * @param   attrId - attribute looking for
   2572           * @param   pAttr - attribute record to be returned
   2573           *
   2574           * @return  TRUE if record found. FALSE, otherwise.
   2575           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2576          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   \                     zclFindCmdRec:
   2577          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   8C..         MOV       ?V3,R4
   \   00000D   7410         MOV       A,#0x10
   \   00000F   12....       LCALL     ?XSTACK_DISP0_8
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FE           MOV       R6,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FF           MOV       R7,A
   2578            uint8 i;
   2579            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   \   000017                ; Setup parameters for call to function zclFindCmdRecsList
   \   000017   A9..         MOV       R1,?V2
   \   000019   12....       LCALL     `??zclFindCmdRecsList::?relay`; Banked call to: zclFindCmdRecsList
   \   00001C   8A..         MOV       ?V6,R2
   \   00001E   8B..         MOV       ?V7,R3
   \   000020   AA..         MOV       R2,?V6
   \   000022   AB..         MOV       R3,?V7
   2580          
   2581            if ( pRec != NULL )
   \   000024   EA           MOV       A,R2
   \   000025   4B           ORL       A,R3
   \   000026   7003         JNZ       $+5
   \   000028   02....       LJMP      ??zclFindCmdRec_0 & 0xFFFF
   2582            {
   2583              for ( i = 0; i < pRec->numCommands; i++ )
   \   00002B   75..00       MOV       ?V4,#0x0
   \                     ??zclFindCmdRec_1:
   \   00002E   8A82         MOV       DPL,R2
   \   000030   8B83         MOV       DPH,R3
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   F8           MOV       R0,A
   \   000037   E5..         MOV       A,?V4
   \   000039   C3           CLR       C
   \   00003A   98           SUBB      A,R0
   \   00003B   4003         JC        $+5
   \   00003D   02....       LJMP      ??zclFindCmdRec_0 & 0xFFFF
   2584              {
   2585                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   \   000040   E5..         MOV       A,?V4
   \   000042   F8           MOV       R0,A
   \   000043   7900         MOV       R1,#0x0
   \   000045   E8           MOV       A,R0
   \   000046   75F004       MOV       B,#0x4
   \   000049   A4           MUL       AB
   \   00004A   C8           XCH       A,R0
   \   00004B   ACF0         MOV       R4,B
   \   00004D   75F000       MOV       B,#0x0
   \   000050   A4           MUL       AB
   \   000051   2C           ADD       A,R4
   \   000052   FC           MOV       R4,A
   \   000053   75F004       MOV       B,#0x4
   \   000056   E9           MOV       A,R1
   \   000057   A4           MUL       AB
   \   000058   2C           ADD       A,R4
   \   000059   F9           MOV       R1,A
   \   00005A   8A82         MOV       DPL,R2
   \   00005C   8B83         MOV       DPH,R3
   \   00005E   A3           INC       DPTR
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   A3           INC       DPTR
   \   000062   E0           MOVX      A,@DPTR
   \   000063   28           ADD       A,R0
   \   000064   FC           MOV       R4,A
   \   000065   A3           INC       DPTR
   \   000066   E0           MOVX      A,@DPTR
   \   000067   39           ADDC      A,R1
   \   000068   8C82         MOV       DPL,R4
   \   00006A   F583         MOV       DPH,A
   \   00006C   E4           CLR       A
   \   00006D   93           MOVC      A,@A+DPTR
   \   00006E   F8           MOV       R0,A
   \   00006F   7401         MOV       A,#0x1
   \   000071   93           MOVC      A,@A+DPTR
   \   000072   F9           MOV       R1,A
   \   000073   E5..         MOV       A,?V0
   \   000075   68           XRL       A,R0
   \   000076   7003         JNZ       ??zclFindCmdRec_2
   \   000078   E5..         MOV       A,?V1
   \   00007A   69           XRL       A,R1
   \                     ??zclFindCmdRec_2:
   \   00007B   706D         JNZ       ??zclFindCmdRec_3
   \   00007D   E5..         MOV       A,?V4
   \   00007F   F8           MOV       R0,A
   \   000080   7900         MOV       R1,#0x0
   \   000082   E8           MOV       A,R0
   \   000083   75F004       MOV       B,#0x4
   \   000086   A4           MUL       AB
   \   000087   C8           XCH       A,R0
   \   000088   ACF0         MOV       R4,B
   \   00008A   75F000       MOV       B,#0x0
   \   00008D   A4           MUL       AB
   \   00008E   2C           ADD       A,R4
   \   00008F   FC           MOV       R4,A
   \   000090   75F004       MOV       B,#0x4
   \   000093   E9           MOV       A,R1
   \   000094   A4           MUL       AB
   \   000095   2C           ADD       A,R4
   \   000096   F9           MOV       R1,A
   \   000097   8A82         MOV       DPL,R2
   \   000099   8B83         MOV       DPH,R3
   \   00009B   A3           INC       DPTR
   \   00009C   A3           INC       DPTR
   \   00009D   A3           INC       DPTR
   \   00009E   A3           INC       DPTR
   \   00009F   E0           MOVX      A,@DPTR
   \   0000A0   28           ADD       A,R0
   \   0000A1   FC           MOV       R4,A
   \   0000A2   A3           INC       DPTR
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   39           ADDC      A,R1
   \   0000A5   8C82         MOV       DPL,R4
   \   0000A7   F583         MOV       DPH,A
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   E4           CLR       A
   \   0000AC   93           MOVC      A,@A+DPTR
   \   0000AD   65..         XRL       A,?V3
   \   0000AF   7039         JNZ       ??zclFindCmdRec_3
   2586                {
   2587                  *pCmd = pRec->pCmdRecs[i];
   \   0000B1   E5..         MOV       A,?V4
   \   0000B3   F8           MOV       R0,A
   \   0000B4   7900         MOV       R1,#0x0
   \   0000B6   E8           MOV       A,R0
   \   0000B7   75F004       MOV       B,#0x4
   \   0000BA   A4           MUL       AB
   \   0000BB   C8           XCH       A,R0
   \   0000BC   ACF0         MOV       R4,B
   \   0000BE   75F000       MOV       B,#0x0
   \   0000C1   A4           MUL       AB
   \   0000C2   2C           ADD       A,R4
   \   0000C3   FC           MOV       R4,A
   \   0000C4   75F004       MOV       B,#0x4
   \   0000C7   E9           MOV       A,R1
   \   0000C8   A4           MUL       AB
   \   0000C9   2C           ADD       A,R4
   \   0000CA   F9           MOV       R1,A
   \   0000CB   8A82         MOV       DPL,R2
   \   0000CD   8B83         MOV       DPH,R3
   \   0000CF   A3           INC       DPTR
   \   0000D0   A3           INC       DPTR
   \   0000D1   A3           INC       DPTR
   \   0000D2   A3           INC       DPTR
   \   0000D3   E0           MOVX      A,@DPTR
   \   0000D4   28           ADD       A,R0
   \   0000D5   FC           MOV       R4,A
   \   0000D6   A3           INC       DPTR
   \   0000D7   E0           MOVX      A,@DPTR
   \   0000D8   39           ADDC      A,R1
   \   0000D9   8C82         MOV       DPL,R4
   \   0000DB   F583         MOV       DPH,A
   \   0000DD   EE           MOV       A,R6
   \   0000DE   FC           MOV       R4,A
   \   0000DF   EF           MOV       A,R7
   \   0000E0   FD           MOV       R5,A
   \   0000E1   7404         MOV       A,#0x4
   \   0000E3   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2588          
   2589                  return ( TRUE ); // EMBEDDED RETURN
   \   0000E6   7901         MOV       R1,#0x1
   \   0000E8   8007         SJMP      ??zclFindCmdRec_4
   2590                }
   2591              }
   \                     ??zclFindCmdRec_3:
   \   0000EA   05..         INC       ?V4
   \   0000EC   02....       LJMP      ??zclFindCmdRec_1 & 0xFFFF
   2592            }
   2593          
   2594            return ( FALSE );
   \                     ??zclFindCmdRec_0:
   \   0000EF   7900         MOV       R1,#0x0
   \                     ??zclFindCmdRec_4:
   \   0000F1   7F08         MOV       R7,#0x8
   \   0000F3   02....       LJMP      ?BANKED_LEAVE_XDATA
   2595          }
   2596          #endif // ZCL_DISCOVER
   2597          
   2598          /*********************************************************************
   2599           * @fn      zclFindAttrRecsList
   2600           *
   2601           * @brief   Find the right attribute record list for an endpoint
   2602           *
   2603           * @param   clusterID - endpointto look for
   2604           *
   2605           * @return  pointer to record list, NULL if not found
   2606           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2607          zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2608          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2609            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV       DPTR,#attrList
   \   000007   E0           MOVX      A,@DPTR
   \   000008   FC           MOV       R4,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   FD           MOV       R5,A
   2610          
   2611            while ( pLoop != NULL )
   \                     ??zclFindAttrRecsList_0:
   \   00000C   EC           MOV       A,R4
   \   00000D   4D           ORL       A,R5
   \   00000E   601B         JZ        ??zclFindAttrRecsList_1
   2612            {
   2613              if ( pLoop->endpoint == endpoint )
   \   000010   8C82         MOV       DPL,R4
   \   000012   8D83         MOV       DPH,R5
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   69           XRL       A,R1
   \   000018   7006         JNZ       ??zclFindAttrRecsList_2
   2614              {
   2615                return ( pLoop );
   \   00001A   EC           MOV       A,R4
   \   00001B   FA           MOV       R2,A
   \   00001C   ED           MOV       A,R5
   \   00001D   FB           MOV       R3,A
   \   00001E   800F         SJMP      ??zclFindAttrRecsList_3
   2616              }
   2617          
   2618              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_2:
   \   000020   8C82         MOV       DPL,R4
   \   000022   8D83         MOV       DPH,R5
   \   000024   E0           MOVX      A,@DPTR
   \   000025   FC           MOV       R4,A
   \   000026   A3           INC       DPTR
   \   000027   E0           MOVX      A,@DPTR
   \   000028   FD           MOV       R5,A
   \   000029   80E1         SJMP      ??zclFindAttrRecsList_0
   2619            }
   2620          
   2621            return ( NULL );
   \                     ??zclFindAttrRecsList_1:
   \   00002B   7A00         MOV       R2,#0x0
   \   00002D   7B00         MOV       R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   00002F   D083         POP       DPH
   \   000031   D082         POP       DPL
   \   000033   02....       LJMP      ?BRET
   2622          }
   2623          
   2624          /*********************************************************************
   2625           * @fn      zclFindAttrRec
   2626           *
   2627           * @brief   Find the attribute record that matchs the parameters
   2628           *
   2629           * @param   endpoint - Application's endpoint
   2630           * @param   clusterID - cluster ID
   2631           * @param   attrId - attribute looking for
   2632           * @param   pAttr - attribute record to be returned
   2633           *
   2634           * @return  TRUE if record found. FALSE, otherwise.
   2635           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2636          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2637          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   8C..         MOV       ?V2,R4
   \   00000D   8D..         MOV       ?V3,R5
   \   00000F   7410         MOV       A,#0x10
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   E0           MOVX      A,@DPTR
   \   000015   FE           MOV       R6,A
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   FF           MOV       R7,A
   2638            uint8 x;
   2639            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000019                ; Setup parameters for call to function zclFindAttrRecsList
   \   000019   A9..         MOV       R1,?V4
   \   00001B   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   00001E   8A..         MOV       ?V6,R2
   \   000020   8B..         MOV       ?V7,R3
   \   000022   AA..         MOV       R2,?V6
   \   000024   AB..         MOV       R3,?V7
   2640          
   2641            if ( pRec != NULL )
   \   000026   EA           MOV       A,R2
   \   000027   4B           ORL       A,R3
   \   000028   7003         JNZ       $+5
   \   00002A   02....       LJMP      ??zclFindAttrRec_0 & 0xFFFF
   2642            {
   2643              for ( x = 0; x < pRec->numAttributes; x++ )
   \   00002D   75..00       MOV       ?V5,#0x0
   \                     ??zclFindAttrRec_1:
   \   000030   8A82         MOV       DPL,R2
   \   000032   8B83         MOV       DPH,R3
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   F8           MOV       R0,A
   \   00003D   E5..         MOV       A,?V5
   \   00003F   C3           CLR       C
   \   000040   98           SUBB      A,R0
   \   000041   4003         JC        $+5
   \   000043   02....       LJMP      ??zclFindAttrRec_0 & 0xFFFF
   2644              {
   2645                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000046   E5..         MOV       A,?V5
   \   000048   F8           MOV       R0,A
   \   000049   7900         MOV       R1,#0x0
   \   00004B   E8           MOV       A,R0
   \   00004C   75F008       MOV       B,#0x8
   \   00004F   A4           MUL       AB
   \   000050   C8           XCH       A,R0
   \   000051   ACF0         MOV       R4,B
   \   000053   75F000       MOV       B,#0x0
   \   000056   A4           MUL       AB
   \   000057   2C           ADD       A,R4
   \   000058   FC           MOV       R4,A
   \   000059   75F008       MOV       B,#0x8
   \   00005C   E9           MOV       A,R1
   \   00005D   A4           MUL       AB
   \   00005E   2C           ADD       A,R4
   \   00005F   F9           MOV       R1,A
   \   000060   8A82         MOV       DPL,R2
   \   000062   8B83         MOV       DPH,R3
   \   000064   A3           INC       DPTR
   \   000065   A3           INC       DPTR
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   28           ADD       A,R0
   \   00006E   FC           MOV       R4,A
   \   00006F   A3           INC       DPTR
   \   000070   E0           MOVX      A,@DPTR
   \   000071   39           ADDC      A,R1
   \   000072   8C82         MOV       DPL,R4
   \   000074   F583         MOV       DPH,A
   \   000076   E4           CLR       A
   \   000077   93           MOVC      A,@A+DPTR
   \   000078   F8           MOV       R0,A
   \   000079   7401         MOV       A,#0x1
   \   00007B   93           MOVC      A,@A+DPTR
   \   00007C   F9           MOV       R1,A
   \   00007D   E5..         MOV       A,?V0
   \   00007F   68           XRL       A,R0
   \   000080   7003         JNZ       ??zclFindAttrRec_2
   \   000082   E5..         MOV       A,?V1
   \   000084   69           XRL       A,R1
   \                     ??zclFindAttrRec_2:
   \   000085   6003         JZ        $+5
   \   000087   02....       LJMP      ??zclFindAttrRec_3 & 0xFFFF
   \   00008A   E5..         MOV       A,?V5
   \   00008C   F8           MOV       R0,A
   \   00008D   7900         MOV       R1,#0x0
   \   00008F   E8           MOV       A,R0
   \   000090   75F008       MOV       B,#0x8
   \   000093   A4           MUL       AB
   \   000094   C8           XCH       A,R0
   \   000095   ACF0         MOV       R4,B
   \   000097   75F000       MOV       B,#0x0
   \   00009A   A4           MUL       AB
   \   00009B   2C           ADD       A,R4
   \   00009C   FC           MOV       R4,A
   \   00009D   75F008       MOV       B,#0x8
   \   0000A0   E9           MOV       A,R1
   \   0000A1   A4           MUL       AB
   \   0000A2   2C           ADD       A,R4
   \   0000A3   F9           MOV       R1,A
   \   0000A4   8A82         MOV       DPL,R2
   \   0000A6   8B83         MOV       DPH,R3
   \   0000A8   A3           INC       DPTR
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   A3           INC       DPTR
   \   0000AC   A3           INC       DPTR
   \   0000AD   A3           INC       DPTR
   \   0000AE   A3           INC       DPTR
   \   0000AF   A3           INC       DPTR
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   28           ADD       A,R0
   \   0000B2   FC           MOV       R4,A
   \   0000B3   A3           INC       DPTR
   \   0000B4   E0           MOVX      A,@DPTR
   \   0000B5   39           ADDC      A,R1
   \   0000B6   8C82         MOV       DPL,R4
   \   0000B8   F583         MOV       DPH,A
   \   0000BA   A3           INC       DPTR
   \   0000BB   A3           INC       DPTR
   \   0000BC   E4           CLR       A
   \   0000BD   93           MOVC      A,@A+DPTR
   \   0000BE   F8           MOV       R0,A
   \   0000BF   7401         MOV       A,#0x1
   \   0000C1   93           MOVC      A,@A+DPTR
   \   0000C2   F9           MOV       R1,A
   \   0000C3   E5..         MOV       A,?V2
   \   0000C5   68           XRL       A,R0
   \   0000C6   7003         JNZ       ??zclFindAttrRec_4
   \   0000C8   E5..         MOV       A,?V3
   \   0000CA   69           XRL       A,R1
   \                     ??zclFindAttrRec_4:
   \   0000CB   703D         JNZ       ??zclFindAttrRec_3
   2646                {
   2647                  *pAttr = pRec->attrs[x];
   \   0000CD   E5..         MOV       A,?V5
   \   0000CF   F8           MOV       R0,A
   \   0000D0   7900         MOV       R1,#0x0
   \   0000D2   E8           MOV       A,R0
   \   0000D3   75F008       MOV       B,#0x8
   \   0000D6   A4           MUL       AB
   \   0000D7   C8           XCH       A,R0
   \   0000D8   ACF0         MOV       R4,B
   \   0000DA   75F000       MOV       B,#0x0
   \   0000DD   A4           MUL       AB
   \   0000DE   2C           ADD       A,R4
   \   0000DF   FC           MOV       R4,A
   \   0000E0   75F008       MOV       B,#0x8
   \   0000E3   E9           MOV       A,R1
   \   0000E4   A4           MUL       AB
   \   0000E5   2C           ADD       A,R4
   \   0000E6   F9           MOV       R1,A
   \   0000E7   8A82         MOV       DPL,R2
   \   0000E9   8B83         MOV       DPH,R3
   \   0000EB   A3           INC       DPTR
   \   0000EC   A3           INC       DPTR
   \   0000ED   A3           INC       DPTR
   \   0000EE   A3           INC       DPTR
   \   0000EF   A3           INC       DPTR
   \   0000F0   A3           INC       DPTR
   \   0000F1   A3           INC       DPTR
   \   0000F2   A3           INC       DPTR
   \   0000F3   E0           MOVX      A,@DPTR
   \   0000F4   28           ADD       A,R0
   \   0000F5   FC           MOV       R4,A
   \   0000F6   A3           INC       DPTR
   \   0000F7   E0           MOVX      A,@DPTR
   \   0000F8   39           ADDC      A,R1
   \   0000F9   8C82         MOV       DPL,R4
   \   0000FB   F583         MOV       DPH,A
   \   0000FD   EE           MOV       A,R6
   \   0000FE   FC           MOV       R4,A
   \   0000FF   EF           MOV       A,R7
   \   000100   FD           MOV       R5,A
   \   000101   7408         MOV       A,#0x8
   \   000103   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2648          
   2649                  return ( TRUE ); // EMBEDDED RETURN
   \   000106   7901         MOV       R1,#0x1
   \   000108   8007         SJMP      ??zclFindAttrRec_5
   2650                }
   2651              }
   \                     ??zclFindAttrRec_3:
   \   00010A   05..         INC       ?V5
   \   00010C   02....       LJMP      ??zclFindAttrRec_1 & 0xFFFF
   2652            }
   2653          
   2654            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   00010F   7900         MOV       R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   000111   7F08         MOV       R7,#0x8
   \   000113   02....       LJMP      ?BANKED_LEAVE_XDATA
   2655          }
   2656          
   2657          #if defined ( ZCL_STANDALONE )
   2658          /*********************************************************************
   2659           * @fn      zclSetAttrRecList
   2660           *
   2661           * @brief   Set attribute record list for end point
   2662           *
   2663           * @param   endpoint - endpoint the attribute list belongs to
   2664           * @param   numAttr - number of attributes in list
   2665           * @param   attrList - array of attribute records.
   2666           *                     NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE
   2667           *                     IN ASCENDING ORDER. OTHERWISE, THE DISCOVERY
   2668           *                     RESPONSE COMMAND WILL NOT HAVE THE RIGHT
   2669           *                     ATTRIBUTE INFO
   2670           *
   2671           * @return  TRUE if successful, FALSE otherwise.
   2672           */
   2673          uint8 zclSetAttrRecList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t attrList[] )
   2674          {
   2675            zclAttrRecsList *pRecsList = zclFindAttrRecsList( endpoint );
   2676          
   2677            if ( pRecsList != NULL )
   2678            {
   2679              pRecsList->numAttributes = numAttr;
   2680              pRecsList->attrs = attrList;
   2681              return ( TRUE );
   2682            }
   2683          
   2684            return ( FALSE );
   2685          }
   2686          
   2687          #endif // ZCL_STANDALONE
   2688          
   2689          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2690          /*********************************************************************
   2691           * @fn      zclGetReadWriteCB
   2692           *
   2693           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2694           *
   2695           * @param   endpoint - Application's endpoint
   2696           *
   2697           * @return  Read/Write CB, NULL if not found
   2698           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2699          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2700          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   2701            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000007                ; Setup parameters for call to function zclFindAttrRecsList
   \   000007   EE           MOV       A,R6
   \   000008   F9           MOV       R1,A
   \   000009   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   85..82       MOV       DPL,?V0
   \   000013   85..83       MOV       DPH,?V1
   2702          
   2703            if ( pRec != NULL )
   \   000016   E582         MOV       A,DPL
   \   000018   4583         ORL       A,DPH
   \   00001A   600A         JZ        ??zclGetReadWriteCB_0
   2704            {
   2705              return ( pRec->pfnReadWriteCB );
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   FA           MOV       R2,A
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   FB           MOV       R3,A
   \   000024   8004         SJMP      ??zclGetReadWriteCB_1
   2706            }
   2707          
   2708            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000026   7A00         MOV       R2,#0x0
   \   000028   7B00         MOV       R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   00002A   7F02         MOV       R7,#0x2
   \   00002C   02....       LJMP      ?BANKED_LEAVE_XDATA
   2709          }
   2710          
   2711          /*********************************************************************
   2712           * @fn      zclGetAuthorizeCB
   2713           *
   2714           * @brief   Get the Read/Write Authorization callback function pointer
   2715           *          for a given endpoint.
   2716           *
   2717           * @param   endpoint - Application's endpoint
   2718           *
   2719           * @return  Authorization CB, NULL if not found
   2720           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2721          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2722          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   2723            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000007                ; Setup parameters for call to function zclFindAttrRecsList
   \   000007   EE           MOV       A,R6
   \   000008   F9           MOV       R1,A
   \   000009   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   85..82       MOV       DPL,?V0
   \   000013   85..83       MOV       DPH,?V1
   2724          
   2725            if ( pRec != NULL )
   \   000016   E582         MOV       A,DPL
   \   000018   4583         ORL       A,DPH
   \   00001A   600C         JZ        ??zclGetAuthorizeCB_0
   2726            {
   2727              return ( pRec->pfnAuthorizeCB );
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   FA           MOV       R2,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   FB           MOV       R3,A
   \   000026   8004         SJMP      ??zclGetAuthorizeCB_1
   2728            }
   2729          
   2730            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000028   7A00         MOV       R2,#0x0
   \   00002A   7B00         MOV       R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00002C   7F02         MOV       R7,#0x2
   \   00002E   02....       LJMP      ?BANKED_LEAVE_XDATA
   2731          }
   2732          #endif // ZCL_READ || ZCL_WRITE
   2733          
   2734          /*********************************************************************
   2735           * @fn      zclFindClusterOption
   2736           *
   2737           * @brief   Find the option record that matchs the cluster id
   2738           *
   2739           * @param   endpoint - Application's endpoint
   2740           * @param   clusterID - cluster ID looking for
   2741           *
   2742           * @return  pointer to clutser option, NULL if not found
   2743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2744          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2745          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FD           MOV       R5,A
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
   2746            zclClusterOptionList *pLoop;
   2747          
   2748            pLoop = clusterOptionList;
   \   00000B   90....       MOV       DPTR,#clusterOptionList
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   FA           MOV       R2,A
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   FB           MOV       R3,A
   \   000013   EA           MOV       A,R2
   \   000014   F8           MOV       R0,A
   \   000015   EB           MOV       A,R3
   \   000016   F9           MOV       R1,A
   2749            while ( pLoop != NULL )
   \                     ??zclFindClusterOption_0:
   \   000017   E8           MOV       A,R0
   \   000018   49           ORL       A,R1
   \   000019   7003         JNZ       $+5
   \   00001B   02....       LJMP      ??zclFindClusterOption_1 & 0xFFFF
   2750            {
   2751              if ( pLoop->endpoint == endpoint )
   \   00001E   8882         MOV       DPL,R0
   \   000020   8983         MOV       DPH,R1
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   6D           XRL       A,R5
   \   000026   7077         JNZ       ??zclFindClusterOption_2
   2752              {
   2753                uint8 x;
   2754                for ( x = 0; x < pLoop->numOptions; x++ )
   \   000028   7C00         MOV       R4,#0x0
   \                     ??zclFindClusterOption_3:
   \   00002A   8882         MOV       DPL,R0
   \   00002C   8983         MOV       DPH,R1
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   E0           MOVX      A,@DPTR
   \   000032   FA           MOV       R2,A
   \   000033   EC           MOV       A,R4
   \   000034   C3           CLR       C
   \   000035   9A           SUBB      A,R2
   \   000036   5067         JNC       ??zclFindClusterOption_2
   2755                {
   2756                  if ( pLoop->options[x].clusterID == clusterID )
   \   000038   EC           MOV       A,R4
   \   000039   FA           MOV       R2,A
   \   00003A   7B00         MOV       R3,#0x0
   \   00003C   EA           MOV       A,R2
   \   00003D   75F003       MOV       B,#0x3
   \   000040   A4           MUL       AB
   \   000041   CA           XCH       A,R2
   \   000042   85F0..       MOV       ?V0,B
   \   000045   75F000       MOV       B,#0x0
   \   000048   A4           MUL       AB
   \   000049   25..         ADD       A,?V0
   \   00004B   F5..         MOV       ?V0,A
   \   00004D   75F003       MOV       B,#0x3
   \   000050   EB           MOV       A,R3
   \   000051   A4           MUL       AB
   \   000052   25..         ADD       A,?V0
   \   000054   FB           MOV       R3,A
   \   000055   8882         MOV       DPL,R0
   \   000057   8983         MOV       DPH,R1
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   2A           ADD       A,R2
   \   00005F   F5..         MOV       ?V0,A
   \   000061   A3           INC       DPTR
   \   000062   E0           MOVX      A,@DPTR
   \   000063   3B           ADDC      A,R3
   \   000064   85..82       MOV       DPL,?V0
   \   000067   F583         MOV       DPH,A
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   6E           XRL       A,R6
   \   00006B   7003         JNZ       ??zclFindClusterOption_4
   \   00006D   A3           INC       DPTR
   \   00006E   E0           MOVX      A,@DPTR
   \   00006F   6F           XRL       A,R7
   \                     ??zclFindClusterOption_4:
   \   000070   702A         JNZ       ??zclFindClusterOption_5
   2757                  {
   2758                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   \   000072   EC           MOV       A,R4
   \   000073   FA           MOV       R2,A
   \   000074   7B00         MOV       R3,#0x0
   \   000076   EA           MOV       A,R2
   \   000077   75F003       MOV       B,#0x3
   \   00007A   A4           MUL       AB
   \   00007B   CA           XCH       A,R2
   \   00007C   ACF0         MOV       R4,B
   \   00007E   75F000       MOV       B,#0x0
   \   000081   A4           MUL       AB
   \   000082   2C           ADD       A,R4
   \   000083   FC           MOV       R4,A
   \   000084   75F003       MOV       B,#0x3
   \   000087   EB           MOV       A,R3
   \   000088   A4           MUL       AB
   \   000089   2C           ADD       A,R4
   \   00008A   FB           MOV       R3,A
   \   00008B   8882         MOV       DPL,R0
   \   00008D   8983         MOV       DPH,R1
   \   00008F   A3           INC       DPTR
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   E0           MOVX      A,@DPTR
   \   000094   2A           ADD       A,R2
   \   000095   FA           MOV       R2,A
   \   000096   A3           INC       DPTR
   \   000097   E0           MOVX      A,@DPTR
   \   000098   3B           ADDC      A,R3
   \   000099   FB           MOV       R3,A
   \   00009A   8013         SJMP      ??zclFindClusterOption_6
   2759                  }
   2760                }
   \                     ??zclFindClusterOption_5:
   \   00009C   0C           INC       R4
   \   00009D   808B         SJMP      ??zclFindClusterOption_3
   2761              }
   2762          
   2763              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_2:
   \   00009F   8882         MOV       DPL,R0
   \   0000A1   8983         MOV       DPH,R1
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   F8           MOV       R0,A
   \   0000A5   A3           INC       DPTR
   \   0000A6   E0           MOVX      A,@DPTR
   \   0000A7   F9           MOV       R1,A
   \   0000A8   02....       LJMP      ??zclFindClusterOption_0 & 0xFFFF
   2764            }
   2765          
   2766            return ( NULL );
   \                     ??zclFindClusterOption_1:
   \   0000AB   7A00         MOV       R2,#0x0
   \   0000AD   7B00         MOV       R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   0000AF   7F01         MOV       R7,#0x1
   \   0000B1   02....       LJMP      ?BANKED_LEAVE_XDATA
   2767          }
   2768          
   2769          /*********************************************************************
   2770           * @fn      zclGetClusterOption
   2771           *
   2772           * @brief   Get the option record that matchs the cluster id
   2773           *
   2774           * @param   endpoint - Application's endpoint
   2775           * @param   clusterID - cluster ID looking for
   2776           *
   2777           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2778           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2779          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2780          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V1,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
   2781            uint8 option;
   2782            zclOptionRec_t *pOption;
   2783          
   2784            pOption = zclFindClusterOption( endpoint, clusterID );
   \   00000B                ; Setup parameters for call to function zclFindClusterOption
   \   00000B   EE           MOV       A,R6
   \   00000C   FA           MOV       R2,A
   \   00000D   EF           MOV       A,R7
   \   00000E   FB           MOV       R3,A
   \   00000F   A9..         MOV       R1,?V1
   \   000011   12....       LCALL     `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   000014   8A..         MOV       ?V4,R2
   \   000016   8B..         MOV       ?V5,R3
   \   000018   85....       MOV       ?V2,?V4
   \   00001B   85....       MOV       ?V3,?V5
   2785            if ( pOption != NULL )
   \   00001E   E5..         MOV       A,?V2
   \   000020   45..         ORL       A,?V3
   \   000022   600F         JZ        ??zclGetClusterOption_0
   2786            {
   2787              option = pOption->option;
   \   000024   85..82       MOV       DPL,?V2
   \   000027   85..83       MOV       DPH,?V3
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F5..         MOV       ?V0,A
   2788              if ( !ZG_SECURE_ENABLED )
   2789              {
   2790                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2791              }
   2792          
   2793              return ( option ); // EMBEDDED RETURN
   \   00002F   A9..         MOV       R1,?V0
   \   000031   8002         SJMP      ??zclGetClusterOption_1
   2794            }
   2795          
   2796            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000033   7900         MOV       R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   000035   7F06         MOV       R7,#0x6
   \   000037   02....       LJMP      ?BANKED_LEAVE_XDATA
   2797          }
   2798          
   2799          /*********************************************************************
   2800           * @fn      zclSetSecurityOption
   2801           *
   2802           * @brief   Set the security option for the cluster id
   2803           *
   2804           * @param   endpoint - Application's endpoint
   2805           * @param   clusterID - cluster ID looking for
   2806           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2807           *
   2808           * @return  none
   2809           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2810          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2811          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
   \   00000B   8C..         MOV       ?V3,R4
   2812            zclOptionRec_t *pOption;
   2813          
   2814            pOption = zclFindClusterOption( endpoint, clusterID );
   \   00000D                ; Setup parameters for call to function zclFindClusterOption
   \   00000D   EE           MOV       A,R6
   \   00000E   FA           MOV       R2,A
   \   00000F   EF           MOV       A,R7
   \   000010   FB           MOV       R3,A
   \   000011   A9..         MOV       R1,?V2
   \   000013   12....       LCALL     `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   000016   8A..         MOV       ?V4,R2
   \   000018   8B..         MOV       ?V5,R3
   \   00001A   85....       MOV       ?V0,?V4
   \   00001D   85....       MOV       ?V1,?V5
   2815            if ( pOption != NULL )
   \   000020   E5..         MOV       A,?V0
   \   000022   45..         ORL       A,?V1
   \   000024   601E         JZ        ??zclSetSecurityOption_0
   2816            {
   2817              if ( enable )
   \   000026   E5..         MOV       A,?V3
   \   000028   600E         JZ        ??zclSetSecurityOption_1
   2818              {
   2819                pOption->option |= AF_EN_SECURITY;
   \   00002A   85..82       MOV       DPL,?V0
   \   00002D   85..83       MOV       DPH,?V1
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   D2E6         SETB      0xE0 /* A   */.6
   \   000035   F0           MOVX      @DPTR,A
   \   000036   800C         SJMP      ??zclSetSecurityOption_0
   2820              }
   2821              else
   2822              {
   2823                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000038   85..82       MOV       DPL,?V0
   \   00003B   85..83       MOV       DPH,?V1
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   C2E6         CLR       0xE0 /* A   */.6
   \   000043   F0           MOVX      @DPTR,A
   2824              }
   2825            }
   2826          }
   \                     ??zclSetSecurityOption_0:
   \   000044   7F06         MOV       R7,#0x6
   \   000046   02....       LJMP      ?BANKED_LEAVE_XDATA
   2827          
   2828          #ifdef ZCL_DISCOVER
   2829          /*********************************************************************
   2830           * @fn      zclFindNextCmdRec
   2831           *
   2832           * @brief   Find the command (or next) record that matchs the parameters
   2833           *
   2834           * @param   endpoint - Application's endpoint
   2835           * @param   clusterID - cluster ID
   2836           * @param   commandID - command ID from requesting command
   2837           * @param   direction- direction of received command
   2838           * @param   pCmdID - command looking for
   2839           * @param   pCmd - command information within command record list
   2840           *
   2841           * @return  pointer to command record, NULL no more records of this cluster
   2842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2843          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   \                     zclFindNextCmdRec:
   2844                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2845          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   8C..         MOV       ?V5,R4
   \   00000D   8D..         MOV       ?V6,R5
   \   00000F   7412         MOV       A,#0x12
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F5..         MOV       ?V2,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F5..         MOV       ?V3,A
   \   00001B   7414         MOV       A,#0x14
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   FE           MOV       R6,A
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   FF           MOV       R7,A
   2846            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   \   000025                ; Setup parameters for call to function zclFindCmdRecsList
   \   000025   A9..         MOV       R1,?V4
   \   000027   12....       LCALL     `??zclFindCmdRecsList::?relay`; Banked call to: zclFindCmdRecsList
   \   00002A   8A..         MOV       ?V8,R2
   \   00002C   8B..         MOV       ?V9,R3
   \   00002E   AA..         MOV       R2,?V8
   \   000030   AB..         MOV       R3,?V9
   2847            uint8 i;
   2848          
   2849            if ( pRec != NULL )
   \   000032   EA           MOV       A,R2
   \   000033   4B           ORL       A,R3
   \   000034   7003         JNZ       $+5
   \   000036   02....       LJMP      ??zclFindNextCmdRec_0 & 0xFFFF
   2850            {
   2851              for ( i = 0; i < pRec->numCommands; i++ )
   \   000039   75..00       MOV       ?V7,#0x0
   \                     ??zclFindNextCmdRec_1:
   \   00003C   8A82         MOV       DPL,R2
   \   00003E   8B83         MOV       DPH,R3
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   E0           MOVX      A,@DPTR
   \   000044   F8           MOV       R0,A
   \   000045   E5..         MOV       A,?V7
   \   000047   C3           CLR       C
   \   000048   98           SUBB      A,R0
   \   000049   4003         JC        $+5
   \   00004B   02....       LJMP      ??zclFindNextCmdRec_0 & 0xFFFF
   2852              {
   2853                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2854                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   \   00004E   E5..         MOV       A,?V7
   \   000050   F8           MOV       R0,A
   \   000051   7900         MOV       R1,#0x0
   \   000053   E8           MOV       A,R0
   \   000054   75F004       MOV       B,#0x4
   \   000057   A4           MUL       AB
   \   000058   C8           XCH       A,R0
   \   000059   ACF0         MOV       R4,B
   \   00005B   75F000       MOV       B,#0x0
   \   00005E   A4           MUL       AB
   \   00005F   2C           ADD       A,R4
   \   000060   FC           MOV       R4,A
   \   000061   75F004       MOV       B,#0x4
   \   000064   E9           MOV       A,R1
   \   000065   A4           MUL       AB
   \   000066   2C           ADD       A,R4
   \   000067   F9           MOV       R1,A
   \   000068   8A82         MOV       DPL,R2
   \   00006A   8B83         MOV       DPH,R3
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   E0           MOVX      A,@DPTR
   \   000071   28           ADD       A,R0
   \   000072   FC           MOV       R4,A
   \   000073   A3           INC       DPTR
   \   000074   E0           MOVX      A,@DPTR
   \   000075   39           ADDC      A,R1
   \   000076   8C82         MOV       DPL,R4
   \   000078   F583         MOV       DPH,A
   \   00007A   E4           CLR       A
   \   00007B   93           MOVC      A,@A+DPTR
   \   00007C   F8           MOV       R0,A
   \   00007D   7401         MOV       A,#0x1
   \   00007F   93           MOVC      A,@A+DPTR
   \   000080   F9           MOV       R1,A
   \   000081   E5..         MOV       A,?V0
   \   000083   68           XRL       A,R0
   \   000084   7003         JNZ       ??zclFindNextCmdRec_2
   \   000086   E5..         MOV       A,?V1
   \   000088   69           XRL       A,R1
   \                     ??zclFindNextCmdRec_2:
   \   000089   6003         JZ        $+5
   \   00008B   02....       LJMP      ??zclFindNextCmdRec_3 & 0xFFFF
   \   00008E   85..82       MOV       DPL,?V2
   \   000091   85..83       MOV       DPH,?V3
   \   000094   E0           MOVX      A,@DPTR
   \   000095   FD           MOV       R5,A
   \   000096   E5..         MOV       A,?V7
   \   000098   F8           MOV       R0,A
   \   000099   7900         MOV       R1,#0x0
   \   00009B   E8           MOV       A,R0
   \   00009C   75F004       MOV       B,#0x4
   \   00009F   A4           MUL       AB
   \   0000A0   C8           XCH       A,R0
   \   0000A1   ACF0         MOV       R4,B
   \   0000A3   75F000       MOV       B,#0x0
   \   0000A6   A4           MUL       AB
   \   0000A7   2C           ADD       A,R4
   \   0000A8   FC           MOV       R4,A
   \   0000A9   75F004       MOV       B,#0x4
   \   0000AC   E9           MOV       A,R1
   \   0000AD   A4           MUL       AB
   \   0000AE   2C           ADD       A,R4
   \   0000AF   F9           MOV       R1,A
   \   0000B0   8A82         MOV       DPL,R2
   \   0000B2   8B83         MOV       DPH,R3
   \   0000B4   A3           INC       DPTR
   \   0000B5   A3           INC       DPTR
   \   0000B6   A3           INC       DPTR
   \   0000B7   A3           INC       DPTR
   \   0000B8   E0           MOVX      A,@DPTR
   \   0000B9   28           ADD       A,R0
   \   0000BA   FC           MOV       R4,A
   \   0000BB   A3           INC       DPTR
   \   0000BC   E0           MOVX      A,@DPTR
   \   0000BD   39           ADDC      A,R1
   \   0000BE   8C82         MOV       DPL,R4
   \   0000C0   F583         MOV       DPH,A
   \   0000C2   A3           INC       DPTR
   \   0000C3   A3           INC       DPTR
   \   0000C4   E4           CLR       A
   \   0000C5   93           MOVC      A,@A+DPTR
   \   0000C6   C3           CLR       C
   \   0000C7   9D           SUBB      A,R5
   \   0000C8   5003         JNC       $+5
   \   0000CA   02....       LJMP      ??zclFindNextCmdRec_3 & 0xFFFF
   2855                {
   2856                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   \   0000CD   7411         MOV       A,#0x11
   \   0000CF   65..         XRL       A,?V5
   \   0000D1   6003         JZ        $+5
   \   0000D3   02....       LJMP      ??zclFindNextCmdRec_4 & 0xFFFF
   2857                  {
   2858                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   \   0000D6   7401         MOV       A,#0x1
   \   0000D8   65..         XRL       A,?V6
   \   0000DA   6003         JZ        $+5
   \   0000DC   02....       LJMP      ??zclFindNextCmdRec_5 & 0xFFFF
   \   0000DF   E5..         MOV       A,?V7
   \   0000E1   F8           MOV       R0,A
   \   0000E2   7900         MOV       R1,#0x0
   \   0000E4   E8           MOV       A,R0
   \   0000E5   75F004       MOV       B,#0x4
   \   0000E8   A4           MUL       AB
   \   0000E9   C8           XCH       A,R0
   \   0000EA   ACF0         MOV       R4,B
   \   0000EC   75F000       MOV       B,#0x0
   \   0000EF   A4           MUL       AB
   \   0000F0   2C           ADD       A,R4
   \   0000F1   FC           MOV       R4,A
   \   0000F2   75F004       MOV       B,#0x4
   \   0000F5   E9           MOV       A,R1
   \   0000F6   A4           MUL       AB
   \   0000F7   2C           ADD       A,R4
   \   0000F8   F9           MOV       R1,A
   \   0000F9   8A82         MOV       DPL,R2
   \   0000FB   8B83         MOV       DPH,R3
   \   0000FD   A3           INC       DPTR
   \   0000FE   A3           INC       DPTR
   \   0000FF   A3           INC       DPTR
   \   000100   A3           INC       DPTR
   \   000101   E0           MOVX      A,@DPTR
   \   000102   28           ADD       A,R0
   \   000103   FC           MOV       R4,A
   \   000104   A3           INC       DPTR
   \   000105   E0           MOVX      A,@DPTR
   \   000106   39           ADDC      A,R1
   \   000107   8C82         MOV       DPL,R4
   \   000109   F583         MOV       DPH,A
   \   00010B   A3           INC       DPTR
   \   00010C   A3           INC       DPTR
   \   00010D   A3           INC       DPTR
   \   00010E   E4           CLR       A
   \   00010F   93           MOVC      A,@A+DPTR
   \   000110   A2E3         MOV       C,0xE0 /* A   */.3
   \   000112   504C         JNC       ??zclFindNextCmdRec_5
   2859                    {
   2860                      *pCmd = pRec->pCmdRecs[i];
   \   000114   E5..         MOV       A,?V7
   \   000116   F8           MOV       R0,A
   \   000117   7900         MOV       R1,#0x0
   \   000119   E8           MOV       A,R0
   \   00011A   75F004       MOV       B,#0x4
   \   00011D   A4           MUL       AB
   \   00011E   C8           XCH       A,R0
   \   00011F   ACF0         MOV       R4,B
   \   000121   75F000       MOV       B,#0x0
   \   000124   A4           MUL       AB
   \   000125   2C           ADD       A,R4
   \   000126   FC           MOV       R4,A
   \   000127   75F004       MOV       B,#0x4
   \   00012A   E9           MOV       A,R1
   \   00012B   A4           MUL       AB
   \   00012C   2C           ADD       A,R4
   \   00012D   F9           MOV       R1,A
   \   00012E   8A82         MOV       DPL,R2
   \   000130   8B83         MOV       DPH,R3
   \   000132   A3           INC       DPTR
   \   000133   A3           INC       DPTR
   \   000134   A3           INC       DPTR
   \   000135   A3           INC       DPTR
   \   000136   E0           MOVX      A,@DPTR
   \   000137   28           ADD       A,R0
   \   000138   FC           MOV       R4,A
   \   000139   A3           INC       DPTR
   \   00013A   E0           MOVX      A,@DPTR
   \   00013B   39           ADDC      A,R1
   \   00013C   8C82         MOV       DPL,R4
   \   00013E   F583         MOV       DPH,A
   \   000140   EE           MOV       A,R6
   \   000141   FC           MOV       R4,A
   \   000142   EF           MOV       A,R7
   \   000143   FD           MOV       R5,A
   \   000144   7404         MOV       A,#0x4
   \   000146   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2861          
   2862                      // Update command ID
   2863                      *pCmdID = pCmd->cmdID;
   \   000149   8E82         MOV       DPL,R6
   \   00014B   8F83         MOV       DPH,R7
   \   00014D   A3           INC       DPTR
   \   00014E   A3           INC       DPTR
   \   00014F   E0           MOVX      A,@DPTR
   \   000150   C0E0         PUSH      A
   \   000152   85..82       MOV       DPL,?V2
   \   000155   85..83       MOV       DPH,?V3
   \   000158   D0E0         POP       A
   \   00015A   F0           MOVX      @DPTR,A
   2864          
   2865                      return ( TRUE ); // EMBEDDED RETURN
   \   00015B   7901         MOV       R1,#0x1
   \   00015D   02....       LJMP      ??zclFindNextCmdRec_6 & 0xFFFF
   2866                    }
   2867                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   \                     ??zclFindNextCmdRec_5:
   \   000160   E5..         MOV       A,?V6
   \   000162   6003         JZ        $+5
   \   000164   02....       LJMP      ??zclFindNextCmdRec_3 & 0xFFFF
   \   000167   E5..         MOV       A,?V7
   \   000169   F8           MOV       R0,A
   \   00016A   7900         MOV       R1,#0x0
   \   00016C   E8           MOV       A,R0
   \   00016D   75F004       MOV       B,#0x4
   \   000170   A4           MUL       AB
   \   000171   C8           XCH       A,R0
   \   000172   ACF0         MOV       R4,B
   \   000174   75F000       MOV       B,#0x0
   \   000177   A4           MUL       AB
   \   000178   2C           ADD       A,R4
   \   000179   FC           MOV       R4,A
   \   00017A   75F004       MOV       B,#0x4
   \   00017D   E9           MOV       A,R1
   \   00017E   A4           MUL       AB
   \   00017F   2C           ADD       A,R4
   \   000180   F9           MOV       R1,A
   \   000181   8A82         MOV       DPL,R2
   \   000183   8B83         MOV       DPH,R3
   \   000185   A3           INC       DPTR
   \   000186   A3           INC       DPTR
   \   000187   A3           INC       DPTR
   \   000188   A3           INC       DPTR
   \   000189   E0           MOVX      A,@DPTR
   \   00018A   28           ADD       A,R0
   \   00018B   FC           MOV       R4,A
   \   00018C   A3           INC       DPTR
   \   00018D   E0           MOVX      A,@DPTR
   \   00018E   39           ADDC      A,R1
   \   00018F   8C82         MOV       DPL,R4
   \   000191   F583         MOV       DPH,A
   \   000193   A3           INC       DPTR
   \   000194   A3           INC       DPTR
   \   000195   A3           INC       DPTR
   \   000196   E4           CLR       A
   \   000197   93           MOVC      A,@A+DPTR
   \   000198   A2E2         MOV       C,0xE0 /* A   */.2
   \   00019A   4003         JC        $+5
   \   00019C   02....       LJMP      ??zclFindNextCmdRec_3 & 0xFFFF
   2868                    {
   2869                      *pCmd = pRec->pCmdRecs[i];
   \   00019F   E5..         MOV       A,?V7
   \   0001A1   F8           MOV       R0,A
   \   0001A2   7900         MOV       R1,#0x0
   \   0001A4   E8           MOV       A,R0
   \   0001A5   75F004       MOV       B,#0x4
   \   0001A8   A4           MUL       AB
   \   0001A9   C8           XCH       A,R0
   \   0001AA   ACF0         MOV       R4,B
   \   0001AC   75F000       MOV       B,#0x0
   \   0001AF   A4           MUL       AB
   \   0001B0   2C           ADD       A,R4
   \   0001B1   FC           MOV       R4,A
   \   0001B2   75F004       MOV       B,#0x4
   \   0001B5   E9           MOV       A,R1
   \   0001B6   A4           MUL       AB
   \   0001B7   2C           ADD       A,R4
   \   0001B8   F9           MOV       R1,A
   \   0001B9   8A82         MOV       DPL,R2
   \   0001BB   8B83         MOV       DPH,R3
   \   0001BD   A3           INC       DPTR
   \   0001BE   A3           INC       DPTR
   \   0001BF   A3           INC       DPTR
   \   0001C0   A3           INC       DPTR
   \   0001C1   E0           MOVX      A,@DPTR
   \   0001C2   28           ADD       A,R0
   \   0001C3   FC           MOV       R4,A
   \   0001C4   A3           INC       DPTR
   \   0001C5   E0           MOVX      A,@DPTR
   \   0001C6   39           ADDC      A,R1
   \   0001C7   8C82         MOV       DPL,R4
   \   0001C9   F583         MOV       DPH,A
   \   0001CB   EE           MOV       A,R6
   \   0001CC   FC           MOV       R4,A
   \   0001CD   EF           MOV       A,R7
   \   0001CE   FD           MOV       R5,A
   \   0001CF   7404         MOV       A,#0x4
   \   0001D1   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2870          
   2871                      // Update command ID
   2872                      *pCmdID = pCmd->cmdID;
   \   0001D4   8E82         MOV       DPL,R6
   \   0001D6   8F83         MOV       DPH,R7
   \   0001D8   A3           INC       DPTR
   \   0001D9   A3           INC       DPTR
   \   0001DA   E0           MOVX      A,@DPTR
   \   0001DB   C0E0         PUSH      A
   \   0001DD   85..82       MOV       DPL,?V2
   \   0001E0   85..83       MOV       DPH,?V3
   \   0001E3   D0E0         POP       A
   \   0001E5   F0           MOVX      @DPTR,A
   2873          
   2874                      return ( TRUE ); // EMBEDDED RETURN
   \   0001E6   7901         MOV       R1,#0x1
   \   0001E8   02....       LJMP      ??zclFindNextCmdRec_6 & 0xFFFF
   2875                    }
   2876                  }
   2877                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   \                     ??zclFindNextCmdRec_4:
   \   0001EB   7413         MOV       A,#0x13
   \   0001ED   65..         XRL       A,?V5
   \   0001EF   6003         JZ        $+5
   \   0001F1   02....       LJMP      ??zclFindNextCmdRec_7 & 0xFFFF
   2878                  {
   2879                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   \   0001F4   E5..         MOV       A,?V6
   \   0001F6   6003         JZ        $+5
   \   0001F8   02....       LJMP      ??zclFindNextCmdRec_8 & 0xFFFF
   \   0001FB   E5..         MOV       A,?V7
   \   0001FD   F8           MOV       R0,A
   \   0001FE   7900         MOV       R1,#0x0
   \   000200   E8           MOV       A,R0
   \   000201   75F004       MOV       B,#0x4
   \   000204   A4           MUL       AB
   \   000205   C8           XCH       A,R0
   \   000206   ACF0         MOV       R4,B
   \   000208   75F000       MOV       B,#0x0
   \   00020B   A4           MUL       AB
   \   00020C   2C           ADD       A,R4
   \   00020D   FC           MOV       R4,A
   \   00020E   75F004       MOV       B,#0x4
   \   000211   E9           MOV       A,R1
   \   000212   A4           MUL       AB
   \   000213   2C           ADD       A,R4
   \   000214   F9           MOV       R1,A
   \   000215   8A82         MOV       DPL,R2
   \   000217   8B83         MOV       DPH,R3
   \   000219   A3           INC       DPTR
   \   00021A   A3           INC       DPTR
   \   00021B   A3           INC       DPTR
   \   00021C   A3           INC       DPTR
   \   00021D   E0           MOVX      A,@DPTR
   \   00021E   28           ADD       A,R0
   \   00021F   FC           MOV       R4,A
   \   000220   A3           INC       DPTR
   \   000221   E0           MOVX      A,@DPTR
   \   000222   39           ADDC      A,R1
   \   000223   8C82         MOV       DPL,R4
   \   000225   F583         MOV       DPH,A
   \   000227   A3           INC       DPTR
   \   000228   A3           INC       DPTR
   \   000229   A3           INC       DPTR
   \   00022A   E4           CLR       A
   \   00022B   93           MOVC      A,@A+DPTR
   \   00022C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00022E   504C         JNC       ??zclFindNextCmdRec_8
   2880                    {
   2881                      *pCmd = pRec->pCmdRecs[i];
   \   000230   E5..         MOV       A,?V7
   \   000232   F8           MOV       R0,A
   \   000233   7900         MOV       R1,#0x0
   \   000235   E8           MOV       A,R0
   \   000236   75F004       MOV       B,#0x4
   \   000239   A4           MUL       AB
   \   00023A   C8           XCH       A,R0
   \   00023B   ACF0         MOV       R4,B
   \   00023D   75F000       MOV       B,#0x0
   \   000240   A4           MUL       AB
   \   000241   2C           ADD       A,R4
   \   000242   FC           MOV       R4,A
   \   000243   75F004       MOV       B,#0x4
   \   000246   E9           MOV       A,R1
   \   000247   A4           MUL       AB
   \   000248   2C           ADD       A,R4
   \   000249   F9           MOV       R1,A
   \   00024A   8A82         MOV       DPL,R2
   \   00024C   8B83         MOV       DPH,R3
   \   00024E   A3           INC       DPTR
   \   00024F   A3           INC       DPTR
   \   000250   A3           INC       DPTR
   \   000251   A3           INC       DPTR
   \   000252   E0           MOVX      A,@DPTR
   \   000253   28           ADD       A,R0
   \   000254   FC           MOV       R4,A
   \   000255   A3           INC       DPTR
   \   000256   E0           MOVX      A,@DPTR
   \   000257   39           ADDC      A,R1
   \   000258   8C82         MOV       DPL,R4
   \   00025A   F583         MOV       DPH,A
   \   00025C   EE           MOV       A,R6
   \   00025D   FC           MOV       R4,A
   \   00025E   EF           MOV       A,R7
   \   00025F   FD           MOV       R5,A
   \   000260   7404         MOV       A,#0x4
   \   000262   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2882          
   2883                      // Update command ID
   2884                      *pCmdID = pCmd->cmdID;
   \   000265   8E82         MOV       DPL,R6
   \   000267   8F83         MOV       DPH,R7
   \   000269   A3           INC       DPTR
   \   00026A   A3           INC       DPTR
   \   00026B   E0           MOVX      A,@DPTR
   \   00026C   C0E0         PUSH      A
   \   00026E   85..82       MOV       DPL,?V2
   \   000271   85..83       MOV       DPH,?V3
   \   000274   D0E0         POP       A
   \   000276   F0           MOVX      @DPTR,A
   2885          
   2886                      return ( TRUE ); // EMBEDDED RETURN
   \   000277   7901         MOV       R1,#0x1
   \   000279   02....       LJMP      ??zclFindNextCmdRec_6 & 0xFFFF
   2887                    }
   2888                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   \                     ??zclFindNextCmdRec_8:
   \   00027C   7401         MOV       A,#0x1
   \   00027E   65..         XRL       A,?V6
   \   000280   6003         JZ        $+5
   \   000282   02....       LJMP      ??zclFindNextCmdRec_3 & 0xFFFF
   \   000285   E5..         MOV       A,?V7
   \   000287   F8           MOV       R0,A
   \   000288   7900         MOV       R1,#0x0
   \   00028A   E8           MOV       A,R0
   \   00028B   75F004       MOV       B,#0x4
   \   00028E   A4           MUL       AB
   \   00028F   C8           XCH       A,R0
   \   000290   ACF0         MOV       R4,B
   \   000292   75F000       MOV       B,#0x0
   \   000295   A4           MUL       AB
   \   000296   2C           ADD       A,R4
   \   000297   FC           MOV       R4,A
   \   000298   75F004       MOV       B,#0x4
   \   00029B   E9           MOV       A,R1
   \   00029C   A4           MUL       AB
   \   00029D   2C           ADD       A,R4
   \   00029E   F9           MOV       R1,A
   \   00029F   8A82         MOV       DPL,R2
   \   0002A1   8B83         MOV       DPH,R3
   \   0002A3   A3           INC       DPTR
   \   0002A4   A3           INC       DPTR
   \   0002A5   A3           INC       DPTR
   \   0002A6   A3           INC       DPTR
   \   0002A7   E0           MOVX      A,@DPTR
   \   0002A8   28           ADD       A,R0
   \   0002A9   FC           MOV       R4,A
   \   0002AA   A3           INC       DPTR
   \   0002AB   E0           MOVX      A,@DPTR
   \   0002AC   39           ADDC      A,R1
   \   0002AD   8C82         MOV       DPL,R4
   \   0002AF   F583         MOV       DPH,A
   \   0002B1   A3           INC       DPTR
   \   0002B2   A3           INC       DPTR
   \   0002B3   A3           INC       DPTR
   \   0002B4   E4           CLR       A
   \   0002B5   93           MOVC      A,@A+DPTR
   \   0002B6   A2E1         MOV       C,0xE0 /* A   */.1
   \   0002B8   504F         JNC       ??zclFindNextCmdRec_3
   2889                    {
   2890                      *pCmd = pRec->pCmdRecs[i];
   \   0002BA   E5..         MOV       A,?V7
   \   0002BC   F8           MOV       R0,A
   \   0002BD   7900         MOV       R1,#0x0
   \   0002BF   E8           MOV       A,R0
   \   0002C0   75F004       MOV       B,#0x4
   \   0002C3   A4           MUL       AB
   \   0002C4   C8           XCH       A,R0
   \   0002C5   ACF0         MOV       R4,B
   \   0002C7   75F000       MOV       B,#0x0
   \   0002CA   A4           MUL       AB
   \   0002CB   2C           ADD       A,R4
   \   0002CC   FC           MOV       R4,A
   \   0002CD   75F004       MOV       B,#0x4
   \   0002D0   E9           MOV       A,R1
   \   0002D1   A4           MUL       AB
   \   0002D2   2C           ADD       A,R4
   \   0002D3   F9           MOV       R1,A
   \   0002D4   8A82         MOV       DPL,R2
   \   0002D6   8B83         MOV       DPH,R3
   \   0002D8   A3           INC       DPTR
   \   0002D9   A3           INC       DPTR
   \   0002DA   A3           INC       DPTR
   \   0002DB   A3           INC       DPTR
   \   0002DC   E0           MOVX      A,@DPTR
   \   0002DD   28           ADD       A,R0
   \   0002DE   FC           MOV       R4,A
   \   0002DF   A3           INC       DPTR
   \   0002E0   E0           MOVX      A,@DPTR
   \   0002E1   39           ADDC      A,R1
   \   0002E2   8C82         MOV       DPL,R4
   \   0002E4   F583         MOV       DPH,A
   \   0002E6   EE           MOV       A,R6
   \   0002E7   FC           MOV       R4,A
   \   0002E8   EF           MOV       A,R7
   \   0002E9   FD           MOV       R5,A
   \   0002EA   7404         MOV       A,#0x4
   \   0002EC   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2891          
   2892                      // Update command ID
   2893                      *pCmdID = pCmd->cmdID;
   \   0002EF   8E82         MOV       DPL,R6
   \   0002F1   8F83         MOV       DPH,R7
   \   0002F3   A3           INC       DPTR
   \   0002F4   A3           INC       DPTR
   \   0002F5   E0           MOVX      A,@DPTR
   \   0002F6   C0E0         PUSH      A
   \   0002F8   85..82       MOV       DPL,?V2
   \   0002FB   85..83       MOV       DPH,?V3
   \   0002FE   D0E0         POP       A
   \   000300   F0           MOVX      @DPTR,A
   2894          
   2895                      return ( TRUE ); // EMBEDDED RETURN
   \   000301   7901         MOV       R1,#0x1
   \   000303   800B         SJMP      ??zclFindNextCmdRec_6
   2896                    }
   2897                  }
   2898                  else
   2899                  {
   2900                    return ( FALSE ); // Incorrect Command ID
   \                     ??zclFindNextCmdRec_7:
   \   000305   7900         MOV       R1,#0x0
   \   000307   8007         SJMP      ??zclFindNextCmdRec_6
   2901                  }
   2902                }
   2903              }
   \                     ??zclFindNextCmdRec_3:
   \   000309   05..         INC       ?V7
   \   00030B   02....       LJMP      ??zclFindNextCmdRec_1 & 0xFFFF
   2904            }
   2905          
   2906            return ( FALSE );
   \                     ??zclFindNextCmdRec_0:
   \   00030E   7900         MOV       R1,#0x0
   \                     ??zclFindNextCmdRec_6:
   \   000310   7F0A         MOV       R7,#0xa
   \   000312   02....       LJMP      ?BANKED_LEAVE_XDATA
   2907          }
   2908          
   2909          /*********************************************************************
   2910           * @fn      zclFindNextAttrRec
   2911           *
   2912           * @brief   Find the attribute (or next) record that matchs the parameters
   2913           *
   2914           * @param   endpoint - Application's endpoint
   2915           * @param   clusterID - cluster ID
   2916           * @param   attr - attribute looking for
   2917           *
   2918           * @return  pointer to attribute record, NULL if not found
   2919           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2920          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   \                     zclFindNextAttrRec:
   2921                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2922          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   8C..         MOV       ?V5,R4
   \   00000D   7412         MOV       A,#0x12
   \   00000F   12....       LCALL     ?XSTACK_DISP0_8
   \   000012   E0           MOVX      A,@DPTR
   \   000013   F5..         MOV       ?V2,A
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F5..         MOV       ?V3,A
   \   000019   7414         MOV       A,#0x14
   \   00001B   12....       LCALL     ?XSTACK_DISP0_8
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   FE           MOV       R6,A
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   FF           MOV       R7,A
   2923            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000023                ; Setup parameters for call to function zclFindAttrRecsList
   \   000023   A9..         MOV       R1,?V4
   \   000025   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000028   8A..         MOV       ?V8,R2
   \   00002A   8B..         MOV       ?V9,R3
   \   00002C   85....       MOV       ?V6,?V8
   \   00002F   85....       MOV       ?V7,?V9
   2924            uint8 attrDir;
   2925          
   2926            if ( pRec != NULL )
   \   000032   E5..         MOV       A,?V6
   \   000034   45..         ORL       A,?V7
   \   000036   7003         JNZ       $+5
   \   000038   02....       LJMP      ??zclFindNextAttrRec_0 & 0xFFFF
   2927            {
   2928              uint16 x;
   2929          
   2930              for ( x = 0; x < pRec->numAttributes; x++ )
   \   00003B   7A00         MOV       R2,#0x0
   \   00003D   7B00         MOV       R3,#0x0
   \                     ??zclFindNextAttrRec_1:
   \   00003F   85..82       MOV       DPL,?V6
   \   000042   85..83       MOV       DPH,?V7
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   A3           INC       DPTR
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   F8           MOV       R0,A
   \   00004E   7900         MOV       R1,#0x0
   \   000050   C3           CLR       C
   \   000051   EA           MOV       A,R2
   \   000052   98           SUBB      A,R0
   \   000053   EB           MOV       A,R3
   \   000054   99           SUBB      A,R1
   \   000055   4003         JC        $+5
   \   000057   02....       LJMP      ??zclFindNextAttrRec_0 & 0xFFFF
   2931              {
   2932                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2933                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   \   00005A   EA           MOV       A,R2
   \   00005B   F8           MOV       R0,A
   \   00005C   EB           MOV       A,R3
   \   00005D   F9           MOV       R1,A
   \   00005E   E8           MOV       A,R0
   \   00005F   75F008       MOV       B,#0x8
   \   000062   A4           MUL       AB
   \   000063   C8           XCH       A,R0
   \   000064   ACF0         MOV       R4,B
   \   000066   75F000       MOV       B,#0x0
   \   000069   A4           MUL       AB
   \   00006A   2C           ADD       A,R4
   \   00006B   FC           MOV       R4,A
   \   00006C   75F008       MOV       B,#0x8
   \   00006F   E9           MOV       A,R1
   \   000070   A4           MUL       AB
   \   000071   2C           ADD       A,R4
   \   000072   F9           MOV       R1,A
   \   000073   85..82       MOV       DPL,?V6
   \   000076   85..83       MOV       DPH,?V7
   \   000079   A3           INC       DPTR
   \   00007A   A3           INC       DPTR
   \   00007B   A3           INC       DPTR
   \   00007C   A3           INC       DPTR
   \   00007D   A3           INC       DPTR
   \   00007E   A3           INC       DPTR
   \   00007F   A3           INC       DPTR
   \   000080   A3           INC       DPTR
   \   000081   E0           MOVX      A,@DPTR
   \   000082   28           ADD       A,R0
   \   000083   FC           MOV       R4,A
   \   000084   A3           INC       DPTR
   \   000085   E0           MOVX      A,@DPTR
   \   000086   39           ADDC      A,R1
   \   000087   8C82         MOV       DPL,R4
   \   000089   F583         MOV       DPH,A
   \   00008B   E4           CLR       A
   \   00008C   93           MOVC      A,@A+DPTR
   \   00008D   F8           MOV       R0,A
   \   00008E   7401         MOV       A,#0x1
   \   000090   93           MOVC      A,@A+DPTR
   \   000091   F9           MOV       R1,A
   \   000092   E5..         MOV       A,?V0
   \   000094   68           XRL       A,R0
   \   000095   7003         JNZ       ??zclFindNextAttrRec_2
   \   000097   E5..         MOV       A,?V1
   \   000099   69           XRL       A,R1
   \                     ??zclFindNextAttrRec_2:
   \   00009A   6003         JZ        $+5
   \   00009C   02....       LJMP      ??zclFindNextAttrRec_3 & 0xFFFF
   \   00009F   EA           MOV       A,R2
   \   0000A0   F8           MOV       R0,A
   \   0000A1   EB           MOV       A,R3
   \   0000A2   F9           MOV       R1,A
   \   0000A3   E8           MOV       A,R0
   \   0000A4   75F008       MOV       B,#0x8
   \   0000A7   A4           MUL       AB
   \   0000A8   C8           XCH       A,R0
   \   0000A9   ACF0         MOV       R4,B
   \   0000AB   75F000       MOV       B,#0x0
   \   0000AE   A4           MUL       AB
   \   0000AF   2C           ADD       A,R4
   \   0000B0   FC           MOV       R4,A
   \   0000B1   75F008       MOV       B,#0x8
   \   0000B4   E9           MOV       A,R1
   \   0000B5   A4           MUL       AB
   \   0000B6   2C           ADD       A,R4
   \   0000B7   F9           MOV       R1,A
   \   0000B8   85..82       MOV       DPL,?V6
   \   0000BB   85..83       MOV       DPH,?V7
   \   0000BE   A3           INC       DPTR
   \   0000BF   A3           INC       DPTR
   \   0000C0   A3           INC       DPTR
   \   0000C1   A3           INC       DPTR
   \   0000C2   A3           INC       DPTR
   \   0000C3   A3           INC       DPTR
   \   0000C4   A3           INC       DPTR
   \   0000C5   A3           INC       DPTR
   \   0000C6   E0           MOVX      A,@DPTR
   \   0000C7   28           ADD       A,R0
   \   0000C8   FC           MOV       R4,A
   \   0000C9   A3           INC       DPTR
   \   0000CA   E0           MOVX      A,@DPTR
   \   0000CB   39           ADDC      A,R1
   \   0000CC   8C82         MOV       DPL,R4
   \   0000CE   F583         MOV       DPH,A
   \   0000D0   A3           INC       DPTR
   \   0000D1   A3           INC       DPTR
   \   0000D2   E4           CLR       A
   \   0000D3   93           MOVC      A,@A+DPTR
   \   0000D4   FC           MOV       R4,A
   \   0000D5   7401         MOV       A,#0x1
   \   0000D7   93           MOVC      A,@A+DPTR
   \   0000D8   FD           MOV       R5,A
   \   0000D9   85..82       MOV       DPL,?V2
   \   0000DC   85..83       MOV       DPH,?V3
   \   0000DF   E0           MOVX      A,@DPTR
   \   0000E0   F8           MOV       R0,A
   \   0000E1   A3           INC       DPTR
   \   0000E2   E0           MOVX      A,@DPTR
   \   0000E3   F9           MOV       R1,A
   \   0000E4   C3           CLR       C
   \   0000E5   EC           MOV       A,R4
   \   0000E6   98           SUBB      A,R0
   \   0000E7   ED           MOV       A,R5
   \   0000E8   99           SUBB      A,R1
   \   0000E9   5003         JNC       $+5
   \   0000EB   02....       LJMP      ??zclFindNextAttrRec_3 & 0xFFFF
   2934                {
   2935                  // also make sure direction is right
   2936                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   \   0000EE   EA           MOV       A,R2
   \   0000EF   F8           MOV       R0,A
   \   0000F0   EB           MOV       A,R3
   \   0000F1   F9           MOV       R1,A
   \   0000F2   E8           MOV       A,R0
   \   0000F3   75F008       MOV       B,#0x8
   \   0000F6   A4           MUL       AB
   \   0000F7   C8           XCH       A,R0
   \   0000F8   ACF0         MOV       R4,B
   \   0000FA   75F000       MOV       B,#0x0
   \   0000FD   A4           MUL       AB
   \   0000FE   2C           ADD       A,R4
   \   0000FF   FC           MOV       R4,A
   \   000100   75F008       MOV       B,#0x8
   \   000103   E9           MOV       A,R1
   \   000104   A4           MUL       AB
   \   000105   2C           ADD       A,R4
   \   000106   F9           MOV       R1,A
   \   000107   85..82       MOV       DPL,?V6
   \   00010A   85..83       MOV       DPH,?V7
   \   00010D   A3           INC       DPTR
   \   00010E   A3           INC       DPTR
   \   00010F   A3           INC       DPTR
   \   000110   A3           INC       DPTR
   \   000111   A3           INC       DPTR
   \   000112   A3           INC       DPTR
   \   000113   A3           INC       DPTR
   \   000114   A3           INC       DPTR
   \   000115   E0           MOVX      A,@DPTR
   \   000116   28           ADD       A,R0
   \   000117   FC           MOV       R4,A
   \   000118   A3           INC       DPTR
   \   000119   E0           MOVX      A,@DPTR
   \   00011A   39           ADDC      A,R1
   \   00011B   8C82         MOV       DPL,R4
   \   00011D   F583         MOV       DPH,A
   \   00011F   A3           INC       DPTR
   \   000120   A3           INC       DPTR
   \   000121   A3           INC       DPTR
   \   000122   A3           INC       DPTR
   \   000123   A3           INC       DPTR
   \   000124   E4           CLR       A
   \   000125   93           MOVC      A,@A+DPTR
   \   000126   A2E7         MOV       C,0xE0 /* A   */.7
   \   000128   E4           CLR       A
   \   000129   33           RLC       A
   \   00012A   F5..         MOV       ?V8,A
   2937                  if ( (attrDir == direction) || (pRec->attrs[x].attr.accessControl & ACCESS_GLOBAL))
   \   00012C   E5..         MOV       A,?V5
   \   00012E   65..         XRL       A,?V8
   \   000130   603C         JZ        ??zclFindNextAttrRec_4
   \   000132   EA           MOV       A,R2
   \   000133   F8           MOV       R0,A
   \   000134   EB           MOV       A,R3
   \   000135   F9           MOV       R1,A
   \   000136   E8           MOV       A,R0
   \   000137   75F008       MOV       B,#0x8
   \   00013A   A4           MUL       AB
   \   00013B   C8           XCH       A,R0
   \   00013C   ACF0         MOV       R4,B
   \   00013E   75F000       MOV       B,#0x0
   \   000141   A4           MUL       AB
   \   000142   2C           ADD       A,R4
   \   000143   FC           MOV       R4,A
   \   000144   75F008       MOV       B,#0x8
   \   000147   E9           MOV       A,R1
   \   000148   A4           MUL       AB
   \   000149   2C           ADD       A,R4
   \   00014A   F9           MOV       R1,A
   \   00014B   85..82       MOV       DPL,?V6
   \   00014E   85..83       MOV       DPH,?V7
   \   000151   A3           INC       DPTR
   \   000152   A3           INC       DPTR
   \   000153   A3           INC       DPTR
   \   000154   A3           INC       DPTR
   \   000155   A3           INC       DPTR
   \   000156   A3           INC       DPTR
   \   000157   A3           INC       DPTR
   \   000158   A3           INC       DPTR
   \   000159   E0           MOVX      A,@DPTR
   \   00015A   28           ADD       A,R0
   \   00015B   FC           MOV       R4,A
   \   00015C   A3           INC       DPTR
   \   00015D   E0           MOVX      A,@DPTR
   \   00015E   39           ADDC      A,R1
   \   00015F   8C82         MOV       DPL,R4
   \   000161   F583         MOV       DPH,A
   \   000163   A3           INC       DPTR
   \   000164   A3           INC       DPTR
   \   000165   A3           INC       DPTR
   \   000166   A3           INC       DPTR
   \   000167   A3           INC       DPTR
   \   000168   E4           CLR       A
   \   000169   93           MOVC      A,@A+DPTR
   \   00016A   A2E6         MOV       C,0xE0 /* A   */.6
   \   00016C   5054         JNC       ??zclFindNextAttrRec_3
   2938                  {
   2939                    // return attribute and found attribute ID
   2940                    *pAttr = pRec->attrs[x];
   \                     ??zclFindNextAttrRec_4:
   \   00016E   EA           MOV       A,R2
   \   00016F   F8           MOV       R0,A
   \   000170   EB           MOV       A,R3
   \   000171   F9           MOV       R1,A
   \   000172   E8           MOV       A,R0
   \   000173   75F008       MOV       B,#0x8
   \   000176   A4           MUL       AB
   \   000177   C8           XCH       A,R0
   \   000178   ACF0         MOV       R4,B
   \   00017A   75F000       MOV       B,#0x0
   \   00017D   A4           MUL       AB
   \   00017E   2C           ADD       A,R4
   \   00017F   FC           MOV       R4,A
   \   000180   75F008       MOV       B,#0x8
   \   000183   E9           MOV       A,R1
   \   000184   A4           MUL       AB
   \   000185   2C           ADD       A,R4
   \   000186   F9           MOV       R1,A
   \   000187   85..82       MOV       DPL,?V6
   \   00018A   85..83       MOV       DPH,?V7
   \   00018D   A3           INC       DPTR
   \   00018E   A3           INC       DPTR
   \   00018F   A3           INC       DPTR
   \   000190   A3           INC       DPTR
   \   000191   A3           INC       DPTR
   \   000192   A3           INC       DPTR
   \   000193   A3           INC       DPTR
   \   000194   A3           INC       DPTR
   \   000195   E0           MOVX      A,@DPTR
   \   000196   28           ADD       A,R0
   \   000197   FC           MOV       R4,A
   \   000198   A3           INC       DPTR
   \   000199   E0           MOVX      A,@DPTR
   \   00019A   39           ADDC      A,R1
   \   00019B   8C82         MOV       DPL,R4
   \   00019D   F583         MOV       DPH,A
   \   00019F   EE           MOV       A,R6
   \   0001A0   FC           MOV       R4,A
   \   0001A1   EF           MOV       A,R7
   \   0001A2   FD           MOV       R5,A
   \   0001A3   7408         MOV       A,#0x8
   \   0001A5   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2941                    *attrId = pAttr->attr.attrId;
   \   0001A8   8E82         MOV       DPL,R6
   \   0001AA   8F83         MOV       DPH,R7
   \   0001AC   A3           INC       DPTR
   \   0001AD   A3           INC       DPTR
   \   0001AE   E0           MOVX      A,@DPTR
   \   0001AF   F8           MOV       R0,A
   \   0001B0   A3           INC       DPTR
   \   0001B1   E0           MOVX      A,@DPTR
   \   0001B2   F9           MOV       R1,A
   \   0001B3   85..82       MOV       DPL,?V2
   \   0001B6   85..83       MOV       DPH,?V3
   \   0001B9   E8           MOV       A,R0
   \   0001BA   F0           MOVX      @DPTR,A
   \   0001BB   A3           INC       DPTR
   \   0001BC   E9           MOV       A,R1
   \   0001BD   F0           MOVX      @DPTR,A
   2942          
   2943                    return ( TRUE ); // EMBEDDED RETURN
   \   0001BE   7901         MOV       R1,#0x1
   \   0001C0   800A         SJMP      ??zclFindNextAttrRec_5
   2944                  }
   2945                }
   2946              }
   \                     ??zclFindNextAttrRec_3:
   \   0001C2   0A           INC       R2
   \   0001C3   EA           MOV       A,R2
   \   0001C4   7001         JNZ       ??zclFindNextAttrRec_6
   \   0001C6   0B           INC       R3
   \                     ??zclFindNextAttrRec_6:
   \   0001C7   02....       LJMP      ??zclFindNextAttrRec_1 & 0xFFFF
   2947            }
   2948          
   2949            return ( FALSE );
   \                     ??zclFindNextAttrRec_0:
   \   0001CA   7900         MOV       R1,#0x0
   \                     ??zclFindNextAttrRec_5:
   \   0001CC   7F0A         MOV       R7,#0xa
   \   0001CE   02....       LJMP      ?BANKED_LEAVE_XDATA
   2950          }
   2951          #endif // ZCL_DISCOVER
   2952          
   2953          /*********************************************************************
   2954           * @fn      zclSerializeData
   2955           *
   2956           * @brief   Builds a buffer from the attribute data to sent out over
   2957           *          the air.
   2958           *          NOTE - Not compatible with application's attributes callbacks.
   2959           *
   2960           * @param   dataType - data types defined in zcl.h
   2961           * @param   attrData - pointer to the attribute data
   2962           * @param   buf - where to put the serialized data
   2963           *
   2964           * @return  pointer to end of destination buffer
   2965           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2966          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2967          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV       A,#-0x13
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V10,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   2968            uint8 *pStr;
   2969            uint16 len;
   2970          
   2971            if ( attrData == NULL )
   \   00000F   E5..         MOV       A,?V0
   \   000011   45..         ORL       A,?V1
   \   000013   7007         JNZ       ??zclSerializeData_0
   2972            {
   2973              return ( buf );
   \   000015   EE           MOV       A,R6
   \   000016   FA           MOV       R2,A
   \   000017   EF           MOV       A,R7
   \   000018   FB           MOV       R3,A
   \   000019   02....       LJMP      ??zclSerializeData_1 & 0xFFFF
   2974            }
   2975          
   2976            switch ( dataType )
   \                     ??zclSerializeData_0:
   \   00001C   E5..         MOV       A,?V10
   \   00001E   12....       LCALL     ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000021   04           DB        4
   \   000022   41           DB        65
   \   000023   42           DB        66
   \   000024   ....         DW        ??zclSerializeData_2
   \   000026   43           DB        67
   \   000027   44           DB        68
   \   000028   ....         DW        ??zclSerializeData_3
   \   00002A   E0           DB        224
   \   00002B   E2           DB        226
   \   00002C   ....         DW        ??zclSerializeData_4
   \   00002E   E8           DB        232
   \   00002F   E9           DB        233
   \   000030   ....         DW        ??zclSerializeData_5
   \   000032   25           DB        37
   \   000033   08           DB        8
   \   000034   ....         DW        ??zclSerializeData_6
   \   000036   09           DB        9
   \   000037   ....         DW        ??zclSerializeData_5
   \   000039   0A           DB        10
   \   00003A   ....         DW        ??zclSerializeData_7
   \   00003C   0B           DB        11
   \   00003D   ....         DW        ??zclSerializeData_4
   \   00003F   10           DB        16
   \   000040   ....         DW        ??zclSerializeData_6
   \   000042   18           DB        24
   \   000043   ....         DW        ??zclSerializeData_6
   \   000045   19           DB        25
   \   000046   ....         DW        ??zclSerializeData_5
   \   000048   1A           DB        26
   \   000049   ....         DW        ??zclSerializeData_7
   \   00004B   1B           DB        27
   \   00004C   ....         DW        ??zclSerializeData_4
   \   00004E   1C           DB        28
   \   00004F   ....         DW        ??zclSerializeData_8
   \   000051   1D           DB        29
   \   000052   ....         DW        ??zclSerializeData_9
   \   000054   1E           DB        30
   \   000055   ....         DW        ??zclSerializeData_10
   \   000057   1F           DB        31
   \   000058   ....         DW        ??zclSerializeData_11
   \   00005A   20           DB        32
   \   00005B   ....         DW        ??zclSerializeData_6
   \   00005D   21           DB        33
   \   00005E   ....         DW        ??zclSerializeData_5
   \   000060   22           DB        34
   \   000061   ....         DW        ??zclSerializeData_7
   \   000063   23           DB        35
   \   000064   ....         DW        ??zclSerializeData_4
   \   000066   24           DB        36
   \   000067   ....         DW        ??zclSerializeData_8
   \   000069   25           DB        37
   \   00006A   ....         DW        ??zclSerializeData_9
   \   00006C   26           DB        38
   \   00006D   ....         DW        ??zclSerializeData_10
   \   00006F   27           DB        39
   \   000070   ....         DW        ??zclSerializeData_11
   \   000072   28           DB        40
   \   000073   ....         DW        ??zclSerializeData_6
   \   000075   29           DB        41
   \   000076   ....         DW        ??zclSerializeData_5
   \   000078   2A           DB        42
   \   000079   ....         DW        ??zclSerializeData_7
   \   00007B   2B           DB        43
   \   00007C   ....         DW        ??zclSerializeData_4
   \   00007E   2C           DB        44
   \   00007F   ....         DW        ??zclSerializeData_8
   \   000081   2D           DB        45
   \   000082   ....         DW        ??zclSerializeData_9
   \   000084   2E           DB        46
   \   000085   ....         DW        ??zclSerializeData_10
   \   000087   2F           DB        47
   \   000088   ....         DW        ??zclSerializeData_11
   \   00008A   30           DB        48
   \   00008B   ....         DW        ??zclSerializeData_6
   \   00008D   31           DB        49
   \   00008E   ....         DW        ??zclSerializeData_5
   \   000090   38           DB        56
   \   000091   ....         DW        ??zclSerializeData_5
   \   000093   39           DB        57
   \   000094   ....         DW        ??zclSerializeData_4
   \   000096   3A           DB        58
   \   000097   ....         DW        ??zclSerializeData_11
   \   000099   EA           DB        234
   \   00009A   ....         DW        ??zclSerializeData_4
   \   00009C   F0           DB        240
   \   00009D   ....         DW        ??zclSerializeData_11
   \   00009F   F1           DB        241
   \   0000A0   ....         DW        ??zclSerializeData_12
   \   0000A2   ....         DW        ??zclSerializeData_13
   2977            {
   2978              case ZCL_DATATYPE_DATA8:
   2979              case ZCL_DATATYPE_BOOLEAN:
   2980              case ZCL_DATATYPE_BITMAP8:
   2981              case ZCL_DATATYPE_INT8:
   2982              case ZCL_DATATYPE_UINT8:
   2983              case ZCL_DATATYPE_ENUM8:
   2984                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_6:
   \   0000A4   85..82       MOV       DPL,?V0
   \   0000A7   85..83       MOV       DPH,?V1
   \   0000AA   E0           MOVX      A,@DPTR
   \   0000AB   C0E0         PUSH      A
   \   0000AD   8E82         MOV       DPL,R6
   \   0000AF   8F83         MOV       DPH,R7
   \   0000B1   D0E0         POP       A
   \   0000B3   F0           MOVX      @DPTR,A
   \   0000B4   8E82         MOV       DPL,R6
   \   0000B6   8F83         MOV       DPH,R7
   \   0000B8   A3           INC       DPTR
   \   0000B9   AE82         MOV       R6,DPL
   \   0000BB   AF83         MOV       R7,DPH
   2985                 break;
   \   0000BD   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   2986          
   2987              case ZCL_DATATYPE_DATA16:
   2988              case ZCL_DATATYPE_BITMAP16:
   2989              case ZCL_DATATYPE_UINT16:
   2990              case ZCL_DATATYPE_INT16:
   2991              case ZCL_DATATYPE_ENUM16:
   2992              case ZCL_DATATYPE_SEMI_PREC:
   2993              case ZCL_DATATYPE_CLUSTER_ID:
   2994              case ZCL_DATATYPE_ATTR_ID:
   2995                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_5:
   \   0000C0   85..82       MOV       DPL,?V0
   \   0000C3   85..83       MOV       DPH,?V1
   \   0000C6   E0           MOVX      A,@DPTR
   \   0000C7   F8           MOV       R0,A
   \   0000C8   A3           INC       DPTR
   \   0000C9   E0           MOVX      A,@DPTR
   \   0000CA   F9           MOV       R1,A
   \   0000CB   E8           MOV       A,R0
   \   0000CC   C0E0         PUSH      A
   \   0000CE   8E82         MOV       DPL,R6
   \   0000D0   8F83         MOV       DPH,R7
   \   0000D2   D0E0         POP       A
   \   0000D4   F0           MOVX      @DPTR,A
   \   0000D5   8E82         MOV       DPL,R6
   \   0000D7   8F83         MOV       DPH,R7
   \   0000D9   A3           INC       DPTR
   \   0000DA   AE82         MOV       R6,DPL
   \   0000DC   AF83         MOV       R7,DPH
   2996                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \   0000DE   85..82       MOV       DPL,?V0
   \   0000E1   85..83       MOV       DPH,?V1
   \   0000E4   E0           MOVX      A,@DPTR
   \   0000E5   F8           MOV       R0,A
   \   0000E6   A3           INC       DPTR
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   F9           MOV       R1,A
   \   0000E9   E4           CLR       A
   \   0000EA   C9           XCH       A,R1
   \   0000EB   F8           MOV       R0,A
   \   0000EC   E8           MOV       A,R0
   \   0000ED   C0E0         PUSH      A
   \   0000EF   8E82         MOV       DPL,R6
   \   0000F1   8F83         MOV       DPH,R7
   \   0000F3   D0E0         POP       A
   \   0000F5   F0           MOVX      @DPTR,A
   \   0000F6   8E82         MOV       DPL,R6
   \   0000F8   8F83         MOV       DPH,R7
   \   0000FA   A3           INC       DPTR
   \   0000FB   AE82         MOV       R6,DPL
   \   0000FD   AF83         MOV       R7,DPH
   2997                break;
   \   0000FF   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   2998          
   2999              case ZCL_DATATYPE_DATA24:
   3000              case ZCL_DATATYPE_BITMAP24:
   3001              case ZCL_DATATYPE_UINT24:
   3002              case ZCL_DATATYPE_INT24:
   3003                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_7:
   \   000102   85..82       MOV       DPL,?V0
   \   000105   85..83       MOV       DPH,?V1
   \   000108   78..         MOV       R0,#?V4
   \   00010A   12....       LCALL     ?L_MOV_X
   \   00010D   E5..         MOV       A,?V4
   \   00010F   C0E0         PUSH      A
   \   000111   8E82         MOV       DPL,R6
   \   000113   8F83         MOV       DPH,R7
   \   000115   D0E0         POP       A
   \   000117   F0           MOVX      @DPTR,A
   \   000118   8E82         MOV       DPL,R6
   \   00011A   8F83         MOV       DPH,R7
   \   00011C   A3           INC       DPTR
   \   00011D   AE82         MOV       R6,DPL
   \   00011F   AF83         MOV       R7,DPH
   3004                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \   000121   85..82       MOV       DPL,?V0
   \   000124   85..83       MOV       DPH,?V1
   \   000127   78..         MOV       R0,#?V4
   \   000129   12....       LCALL     ?L_MOV_X
   \   00012C   E4           CLR       A
   \   00012D   C5..         XCH       A,?V5
   \   00012F   F5..         MOV       ?V4,A
   \   000131   E5..         MOV       A,?V4
   \   000133   C0E0         PUSH      A
   \   000135   8E82         MOV       DPL,R6
   \   000137   8F83         MOV       DPH,R7
   \   000139   D0E0         POP       A
   \   00013B   F0           MOVX      @DPTR,A
   \   00013C   8E82         MOV       DPL,R6
   \   00013E   8F83         MOV       DPH,R7
   \   000140   A3           INC       DPTR
   \   000141   AE82         MOV       R6,DPL
   \   000143   AF83         MOV       R7,DPH
   3005                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \   000145   85..82       MOV       DPL,?V0
   \   000148   85..83       MOV       DPH,?V1
   \   00014B   78..         MOV       R0,#?V4
   \   00014D   12....       LCALL     ?L_MOV_X
   \   000150   7410         MOV       A,#0x10
   \   000152   78..         MOV       R0,#?V4
   \   000154   12....       LCALL     ?UL_SHR
   \   000157   E5..         MOV       A,?V4
   \   000159   C0E0         PUSH      A
   \   00015B   8E82         MOV       DPL,R6
   \   00015D   8F83         MOV       DPH,R7
   \   00015F   D0E0         POP       A
   \   000161   F0           MOVX      @DPTR,A
   \   000162   8E82         MOV       DPL,R6
   \   000164   8F83         MOV       DPH,R7
   \   000166   A3           INC       DPTR
   \   000167   AE82         MOV       R6,DPL
   \   000169   AF83         MOV       R7,DPH
   3006                break;
   \   00016B   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   3007          
   3008              case ZCL_DATATYPE_DATA32:
   3009              case ZCL_DATATYPE_BITMAP32:
   3010              case ZCL_DATATYPE_UINT32:
   3011              case ZCL_DATATYPE_INT32:
   3012              case ZCL_DATATYPE_SINGLE_PREC:
   3013              case ZCL_DATATYPE_TOD:
   3014              case ZCL_DATATYPE_DATE:
   3015              case ZCL_DATATYPE_UTC:
   3016              case ZCL_DATATYPE_BAC_OID:
   3017                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_4:
   \   00016E                ; Setup parameters for call to function osal_buffer_uint32
   \   00016E   85..82       MOV       DPL,?V0
   \   000171   85..83       MOV       DPH,?V1
   \   000174   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000177   EE           MOV       A,R6
   \   000178   FA           MOV       R2,A
   \   000179   EF           MOV       A,R7
   \   00017A   FB           MOV       R3,A
   \   00017B   12....       LCALL     `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   00017E   7404         MOV       A,#0x4
   \   000180   12....       LCALL     ?DEALLOC_XSTACK8
   \   000183   8A..         MOV       ?V4,R2
   \   000185   8B..         MOV       ?V5,R3
   \   000187   AE..         MOV       R6,?V4
   \   000189   AF..         MOV       R7,?V5
   3018                break;
   \   00018B   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   3019          
   3020              case ZCL_DATATYPE_BITMAP40:
   3021              case ZCL_DATATYPE_UINT40:
   3022              case ZCL_DATATYPE_INT40:
   3023                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_8:
   \   00018E   85....       MOV       ?V2,?V0
   \   000191   85....       MOV       ?V3,?V1
   3024                buf = zcl_memcpy( buf, pStr, 5 );
   \   000194                ; Setup parameters for call to function osal_memcpy
   \   000194   85....       MOV       ?V4,?V2
   \   000197   85....       MOV       ?V5,?V3
   \   00019A   75..00       MOV       ?V6,#0x0
   \   00019D   78..         MOV       R0,#?V4
   \   00019F   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0001A2   7C05         MOV       R4,#0x5
   \   0001A4   7D00         MOV       R5,#0x0
   \   0001A6   EE           MOV       A,R6
   \   0001A7   FA           MOV       R2,A
   \   0001A8   EF           MOV       A,R7
   \   0001A9   FB           MOV       R3,A
   \   0001AA   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0001AD   7403         MOV       A,#0x3
   \   0001AF   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001B2   8A..         MOV       ?V4,R2
   \   0001B4   8B..         MOV       ?V5,R3
   \   0001B6   AE..         MOV       R6,?V4
   \   0001B8   AF..         MOV       R7,?V5
   3025                break;
   \   0001BA   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   3026          
   3027              case ZCL_DATATYPE_BITMAP48:
   3028              case ZCL_DATATYPE_UINT48:
   3029              case ZCL_DATATYPE_INT48:
   3030                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_9:
   \   0001BD   85....       MOV       ?V2,?V0
   \   0001C0   85....       MOV       ?V3,?V1
   3031                buf = zcl_memcpy( buf, pStr, 6 );
   \   0001C3                ; Setup parameters for call to function osal_memcpy
   \   0001C3   85....       MOV       ?V4,?V2
   \   0001C6   85....       MOV       ?V5,?V3
   \   0001C9   75..00       MOV       ?V6,#0x0
   \   0001CC   78..         MOV       R0,#?V4
   \   0001CE   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0001D1   7C06         MOV       R4,#0x6
   \   0001D3   7D00         MOV       R5,#0x0
   \   0001D5   EE           MOV       A,R6
   \   0001D6   FA           MOV       R2,A
   \   0001D7   EF           MOV       A,R7
   \   0001D8   FB           MOV       R3,A
   \   0001D9   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0001DC   7403         MOV       A,#0x3
   \   0001DE   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001E1   8A..         MOV       ?V4,R2
   \   0001E3   8B..         MOV       ?V5,R3
   \   0001E5   AE..         MOV       R6,?V4
   \   0001E7   AF..         MOV       R7,?V5
   3032                break;
   \   0001E9   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   3033          
   3034              case ZCL_DATATYPE_BITMAP56:
   3035              case ZCL_DATATYPE_UINT56:
   3036              case ZCL_DATATYPE_INT56:
   3037                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_10:
   \   0001EC   85....       MOV       ?V2,?V0
   \   0001EF   85....       MOV       ?V3,?V1
   3038                buf = zcl_memcpy( buf, pStr, 7 );
   \   0001F2                ; Setup parameters for call to function osal_memcpy
   \   0001F2   85....       MOV       ?V4,?V2
   \   0001F5   85....       MOV       ?V5,?V3
   \   0001F8   75..00       MOV       ?V6,#0x0
   \   0001FB   78..         MOV       R0,#?V4
   \   0001FD   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000200   7C07         MOV       R4,#0x7
   \   000202   7D00         MOV       R5,#0x0
   \   000204   EE           MOV       A,R6
   \   000205   FA           MOV       R2,A
   \   000206   EF           MOV       A,R7
   \   000207   FB           MOV       R3,A
   \   000208   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00020B   7403         MOV       A,#0x3
   \   00020D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000210   8A..         MOV       ?V4,R2
   \   000212   8B..         MOV       ?V5,R3
   \   000214   AE..         MOV       R6,?V4
   \   000216   AF..         MOV       R7,?V5
   3039                break;
   \   000218   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   3040          
   3041              case ZCL_DATATYPE_BITMAP64:
   3042              case ZCL_DATATYPE_DOUBLE_PREC:
   3043              case ZCL_DATATYPE_IEEE_ADDR:
   3044              case ZCL_DATATYPE_UINT64:
   3045              case ZCL_DATATYPE_INT64:
   3046                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_11:
   \   00021B   85....       MOV       ?V2,?V0
   \   00021E   85....       MOV       ?V3,?V1
   3047                buf = zcl_memcpy( buf, pStr, 8 );
   \   000221                ; Setup parameters for call to function osal_memcpy
   \   000221   85....       MOV       ?V4,?V2
   \   000224   85....       MOV       ?V5,?V3
   \   000227   75..00       MOV       ?V6,#0x0
   \   00022A   78..         MOV       R0,#?V4
   \   00022C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00022F   7C08         MOV       R4,#0x8
   \   000231   7D00         MOV       R5,#0x0
   \   000233   EE           MOV       A,R6
   \   000234   FA           MOV       R2,A
   \   000235   EF           MOV       A,R7
   \   000236   FB           MOV       R3,A
   \   000237   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00023A   7403         MOV       A,#0x3
   \   00023C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00023F   8A..         MOV       ?V4,R2
   \   000241   8B..         MOV       ?V5,R3
   \   000243   AE..         MOV       R6,?V4
   \   000245   AF..         MOV       R7,?V5
   3048                break;
   \   000247   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   3049          
   3050              case ZCL_DATATYPE_CHAR_STR:
   3051              case ZCL_DATATYPE_OCTET_STR:
   3052                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_2:
   \   00024A   85....       MOV       ?V2,?V0
   \   00024D   85....       MOV       ?V3,?V1
   3053                len = *pStr;
   \   000250   85..82       MOV       DPL,?V2
   \   000253   85..83       MOV       DPH,?V3
   \   000256   E0           MOVX      A,@DPTR
   \   000257   F8           MOV       R0,A
   \   000258   7900         MOV       R1,#0x0
   \   00025A   88..         MOV       ?V8,R0
   \   00025C   89..         MOV       ?V9,R1
   3054                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \   00025E                ; Setup parameters for call to function osal_memcpy
   \   00025E   85....       MOV       ?V4,?V2
   \   000261   85....       MOV       ?V5,?V3
   \   000264   75..00       MOV       ?V6,#0x0
   \   000267   78..         MOV       R0,#?V4
   \   000269   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00026C   E5..         MOV       A,?V8
   \   00026E   2401         ADD       A,#0x1
   \   000270   FC           MOV       R4,A
   \   000271   E4           CLR       A
   \   000272   35..         ADDC      A,?V9
   \   000274   FD           MOV       R5,A
   \   000275   EE           MOV       A,R6
   \   000276   FA           MOV       R2,A
   \   000277   EF           MOV       A,R7
   \   000278   FB           MOV       R3,A
   \   000279   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00027C   7403         MOV       A,#0x3
   \   00027E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000281   8A..         MOV       ?V4,R2
   \   000283   8B..         MOV       ?V5,R3
   \   000285   AE..         MOV       R6,?V4
   \   000287   AF..         MOV       R7,?V5
   3055                break;
   \   000289   02....       LJMP      ??zclSerializeData_13 & 0xFFFF
   3056          
   3057              case ZCL_DATATYPE_LONG_CHAR_STR:
   3058              case ZCL_DATATYPE_LONG_OCTET_STR:
   3059                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_3:
   \   00028C   85....       MOV       ?V2,?V0
   \   00028F   85....       MOV       ?V3,?V1
   3060                len = BUILD_UINT16( pStr[0], pStr[1] );
   \   000292   85..82       MOV       DPL,?V2
   \   000295   85..83       MOV       DPH,?V3
   \   000298   E0           MOVX      A,@DPTR
   \   000299   FA           MOV       R2,A
   \   00029A   7B00         MOV       R3,#0x0
   \   00029C   85..82       MOV       DPL,?V2
   \   00029F   85..83       MOV       DPH,?V3
   \   0002A2   A3           INC       DPTR
   \   0002A3   E0           MOVX      A,@DPTR
   \   0002A4   F8           MOV       R0,A
   \   0002A5   7900         MOV       R1,#0x0
   \   0002A7   E4           CLR       A
   \   0002A8   C8           XCH       A,R0
   \   0002A9   F9           MOV       R1,A
   \   0002AA   EA           MOV       A,R2
   \   0002AB   28           ADD       A,R0
   \   0002AC   F8           MOV       R0,A
   \   0002AD   EB           MOV       A,R3
   \   0002AE   39           ADDC      A,R1
   \   0002AF   F9           MOV       R1,A
   \   0002B0   88..         MOV       ?V8,R0
   \   0002B2   89..         MOV       ?V9,R1
   3061                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \   0002B4                ; Setup parameters for call to function osal_memcpy
   \   0002B4   85....       MOV       ?V4,?V2
   \   0002B7   85....       MOV       ?V5,?V3
   \   0002BA   75..00       MOV       ?V6,#0x0
   \   0002BD   78..         MOV       R0,#?V4
   \   0002BF   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0002C2   E5..         MOV       A,?V8
   \   0002C4   2402         ADD       A,#0x2
   \   0002C6   FC           MOV       R4,A
   \   0002C7   E4           CLR       A
   \   0002C8   35..         ADDC      A,?V9
   \   0002CA   FD           MOV       R5,A
   \   0002CB   EE           MOV       A,R6
   \   0002CC   FA           MOV       R2,A
   \   0002CD   EF           MOV       A,R7
   \   0002CE   FB           MOV       R3,A
   \   0002CF   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0002D2   7403         MOV       A,#0x3
   \   0002D4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002D7   8A..         MOV       ?V4,R2
   \   0002D9   8B..         MOV       ?V5,R3
   \   0002DB   AE..         MOV       R6,?V4
   \   0002DD   AF..         MOV       R7,?V5
   3062                break;
   \   0002DF   802C         SJMP      ??zclSerializeData_13
   3063          
   3064              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3065                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_12:
   \   0002E1   85....       MOV       ?V2,?V0
   \   0002E4   85....       MOV       ?V3,?V1
   3066                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \   0002E7                ; Setup parameters for call to function osal_memcpy
   \   0002E7   85....       MOV       ?V4,?V2
   \   0002EA   85....       MOV       ?V5,?V3
   \   0002ED   75..00       MOV       ?V6,#0x0
   \   0002F0   78..         MOV       R0,#?V4
   \   0002F2   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0002F5   7C10         MOV       R4,#0x10
   \   0002F7   7D00         MOV       R5,#0x0
   \   0002F9   EE           MOV       A,R6
   \   0002FA   FA           MOV       R2,A
   \   0002FB   EF           MOV       A,R7
   \   0002FC   FB           MOV       R3,A
   \   0002FD   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000300   7403         MOV       A,#0x3
   \   000302   12....       LCALL     ?DEALLOC_XSTACK8
   \   000305   8A..         MOV       ?V4,R2
   \   000307   8B..         MOV       ?V5,R3
   \   000309   AE..         MOV       R6,?V4
   \   00030B   AF..         MOV       R7,?V5
   3067                break;
   3068          
   3069              case ZCL_DATATYPE_NO_DATA:
   3070              case ZCL_DATATYPE_UNKNOWN:
   3071                // Fall through
   3072          
   3073              default:
   3074                break;
   3075            }
   3076          
   3077            return ( buf );
   \                     ??zclSerializeData_13:
   \   00030D   EE           MOV       A,R6
   \   00030E   FA           MOV       R2,A
   \   00030F   EF           MOV       A,R7
   \   000310   FB           MOV       R3,A
   \                     ??zclSerializeData_1:
   \   000311   7F0B         MOV       R7,#0xb
   \   000313   02....       LJMP      ?BANKED_LEAVE_XDATA
   3078          }
   3079          
   3080          #if defined ZCL_REPORTING_DEVICE || defined ZCL_REPORT_CONFIGURING_DEVICE
   3081          /*********************************************************************
   3082           * @fn      zclAnalogDataType
   3083           *
   3084           * @brief   Checks to see if Data Type is Analog
   3085           *
   3086           * @param   dataType - data type
   3087           *
   3088           * @return  TRUE if data type is analog
   3089           */
   3090          uint8 zclAnalogDataType( uint8 dataType )
   3091          {
   3092            uint8 analog;
   3093          
   3094            switch ( dataType )
   3095            {
   3096              case ZCL_DATATYPE_UINT8:
   3097              case ZCL_DATATYPE_UINT16:
   3098              case ZCL_DATATYPE_UINT24:
   3099              case ZCL_DATATYPE_UINT32:
   3100              case ZCL_DATATYPE_UINT40:
   3101              case ZCL_DATATYPE_UINT48:
   3102              case ZCL_DATATYPE_UINT56:
   3103              case ZCL_DATATYPE_UINT64:
   3104              case ZCL_DATATYPE_INT8:
   3105              case ZCL_DATATYPE_INT16:
   3106              case ZCL_DATATYPE_INT24:
   3107              case ZCL_DATATYPE_INT32:
   3108              case ZCL_DATATYPE_INT40:
   3109              case ZCL_DATATYPE_INT48:
   3110              case ZCL_DATATYPE_INT56:
   3111              case ZCL_DATATYPE_INT64:
   3112              case ZCL_DATATYPE_SEMI_PREC:
   3113              case ZCL_DATATYPE_SINGLE_PREC:
   3114              case ZCL_DATATYPE_DOUBLE_PREC:
   3115              case ZCL_DATATYPE_TOD:
   3116              case ZCL_DATATYPE_DATE:
   3117              case ZCL_DATATYPE_UTC:
   3118                analog = TRUE;
   3119                break;
   3120          
   3121              default:
   3122                analog = FALSE;
   3123                break;
   3124            }
   3125          
   3126            return ( analog );
   3127          }
   3128          
   3129          /*********************************************************************
   3130           * @fn      zclIsLittleEndianMachine
   3131           *
   3132           * @brief   Verifies endianness in system.
   3133           *
   3134           * @param   none
   3135           *
   3136           * @return  MSB-00 or LSB-01 depending on endianness in the system
   3137           */
   3138          static int zclIsLittleEndianMachine(void)
   3139          {
   3140            uint16 test = 0x0001;
   3141          
   3142            return (*((uint8 *)(&test)));
   3143          }
   3144          
   3145          /*********************************************************************
   3146           * @fn      zcl_BuildAnalogData
   3147           *
   3148           * @brief   Build an analog arribute out of sequential bytes.
   3149           *
   3150           * @param   dataType - type of data
   3151           * @param   pData - pointer to data
   3152           * @param   pBuf - where to put the data
   3153           *
   3154           * @return  none
   3155           */
   3156          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   3157          {
   3158            int current_byte_index;
   3159            int remaining_bytes;
   3160            int step;
   3161          
   3162            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   3163          
   3164            // decide if move forward or backwards to copy data
   3165            if ( zclIsLittleEndianMachine() )
   3166            {
   3167              step = 1;
   3168              current_byte_index = 0;
   3169            }
   3170            else
   3171            {
   3172              step = -1;
   3173              current_byte_index = remaining_bytes - 1;
   3174            }
   3175          
   3176            while ( remaining_bytes-- )
   3177            {
   3178              pData[current_byte_index] = *(pBuf++);
   3179              current_byte_index += step;
   3180            }
   3181          }
   3182          #endif
   3183          
   3184          /*********************************************************************
   3185           * @fn      zclGetDataTypeLength
   3186           *
   3187           * @brief   Return the length of the datatype in octet.
   3188           *
   3189           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   3190           *                ZCL_DATATYPE_CHAR_STR data types.
   3191           *
   3192           * @param   dataType - data type
   3193           *
   3194           * @return  length of data
   3195           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3196          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   3197          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV       A,R1
   \   000001   F8           MOV       R0,A
   3198            uint8 len;
   3199          
   3200            switch ( dataType )
   \   000002   E8           MOV       A,R0
   \   000003   24F8         ADD       A,#-0x8
   \   000005   6078         JZ        ??zclGetDataTypeLength_0
   \   000007   14           DEC       A
   \   000008   6079         JZ        ??zclGetDataTypeLength_1
   \   00000A   14           DEC       A
   \   00000B   607A         JZ        ??zclGetDataTypeLength_2
   \   00000D   14           DEC       A
   \   00000E   607B         JZ        ??zclGetDataTypeLength_3
   \   000010   24FB         ADD       A,#-0x5
   \   000012   606B         JZ        ??zclGetDataTypeLength_0
   \   000014   24F8         ADD       A,#-0x8
   \   000016   6067         JZ        ??zclGetDataTypeLength_0
   \   000018   14           DEC       A
   \   000019   6068         JZ        ??zclGetDataTypeLength_1
   \   00001B   14           DEC       A
   \   00001C   6069         JZ        ??zclGetDataTypeLength_2
   \   00001E   14           DEC       A
   \   00001F   606A         JZ        ??zclGetDataTypeLength_3
   \   000021   24FB         ADD       A,#-0x5
   \   000023   605A         JZ        ??zclGetDataTypeLength_0
   \   000025   14           DEC       A
   \   000026   605B         JZ        ??zclGetDataTypeLength_1
   \   000028   14           DEC       A
   \   000029   605C         JZ        ??zclGetDataTypeLength_2
   \   00002B   14           DEC       A
   \   00002C   605D         JZ        ??zclGetDataTypeLength_3
   \   00002E   14           DEC       A
   \   00002F   605E         JZ        ??zclGetDataTypeLength_4
   \   000031   14           DEC       A
   \   000032   605F         JZ        ??zclGetDataTypeLength_5
   \   000034   14           DEC       A
   \   000035   6060         JZ        ??zclGetDataTypeLength_6
   \   000037   14           DEC       A
   \   000038   6061         JZ        ??zclGetDataTypeLength_7
   \   00003A   14           DEC       A
   \   00003B   6042         JZ        ??zclGetDataTypeLength_0
   \   00003D   14           DEC       A
   \   00003E   6043         JZ        ??zclGetDataTypeLength_1
   \   000040   14           DEC       A
   \   000041   6044         JZ        ??zclGetDataTypeLength_2
   \   000043   14           DEC       A
   \   000044   6045         JZ        ??zclGetDataTypeLength_3
   \   000046   14           DEC       A
   \   000047   6046         JZ        ??zclGetDataTypeLength_4
   \   000049   14           DEC       A
   \   00004A   6047         JZ        ??zclGetDataTypeLength_5
   \   00004C   14           DEC       A
   \   00004D   6048         JZ        ??zclGetDataTypeLength_6
   \   00004F   14           DEC       A
   \   000050   6049         JZ        ??zclGetDataTypeLength_7
   \   000052   14           DEC       A
   \   000053   602A         JZ        ??zclGetDataTypeLength_0
   \   000055   14           DEC       A
   \   000056   602B         JZ        ??zclGetDataTypeLength_1
   \   000058   24F9         ADD       A,#-0x7
   \   00005A   6027         JZ        ??zclGetDataTypeLength_1
   \   00005C   14           DEC       A
   \   00005D   602C         JZ        ??zclGetDataTypeLength_3
   \   00005F   14           DEC       A
   \   000060   6039         JZ        ??zclGetDataTypeLength_7
   \   000062   245A         ADD       A,#0x5a
   \   000064   6025         JZ        ??zclGetDataTypeLength_3
   \   000066   14           DEC       A
   \   000067   6022         JZ        ??zclGetDataTypeLength_3
   \   000069   14           DEC       A
   \   00006A   601F         JZ        ??zclGetDataTypeLength_3
   \   00006C   24FA         ADD       A,#-0x6
   \   00006E   6013         JZ        ??zclGetDataTypeLength_1
   \   000070   14           DEC       A
   \   000071   6010         JZ        ??zclGetDataTypeLength_1
   \   000073   14           DEC       A
   \   000074   6015         JZ        ??zclGetDataTypeLength_3
   \   000076   24FA         ADD       A,#-0x6
   \   000078   6021         JZ        ??zclGetDataTypeLength_7
   \   00007A   14           DEC       A
   \   00007B   6022         JZ        ??zclGetDataTypeLength_8
   \   00007D   8024         SJMP      ??zclGetDataTypeLength_9
   3201            {
   3202              case ZCL_DATATYPE_DATA8:
   3203              case ZCL_DATATYPE_BOOLEAN:
   3204              case ZCL_DATATYPE_BITMAP8:
   3205              case ZCL_DATATYPE_INT8:
   3206              case ZCL_DATATYPE_UINT8:
   3207              case ZCL_DATATYPE_ENUM8:
   3208                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007F   7901         MOV       R1,#0x1
   3209                break;
   \   000081   8022         SJMP      ??zclGetDataTypeLength_10
   3210          
   3211              case ZCL_DATATYPE_DATA16:
   3212              case ZCL_DATATYPE_BITMAP16:
   3213              case ZCL_DATATYPE_UINT16:
   3214              case ZCL_DATATYPE_INT16:
   3215              case ZCL_DATATYPE_ENUM16:
   3216              case ZCL_DATATYPE_SEMI_PREC:
   3217              case ZCL_DATATYPE_CLUSTER_ID:
   3218              case ZCL_DATATYPE_ATTR_ID:
   3219                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000083   7902         MOV       R1,#0x2
   3220                break;
   \   000085   801E         SJMP      ??zclGetDataTypeLength_10
   3221          
   3222              case ZCL_DATATYPE_DATA24:
   3223              case ZCL_DATATYPE_BITMAP24:
   3224              case ZCL_DATATYPE_UINT24:
   3225              case ZCL_DATATYPE_INT24:
   3226                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000087   7903         MOV       R1,#0x3
   3227                break;
   \   000089   801A         SJMP      ??zclGetDataTypeLength_10
   3228          
   3229              case ZCL_DATATYPE_DATA32:
   3230              case ZCL_DATATYPE_BITMAP32:
   3231              case ZCL_DATATYPE_UINT32:
   3232              case ZCL_DATATYPE_INT32:
   3233              case ZCL_DATATYPE_SINGLE_PREC:
   3234              case ZCL_DATATYPE_TOD:
   3235              case ZCL_DATATYPE_DATE:
   3236              case ZCL_DATATYPE_UTC:
   3237              case ZCL_DATATYPE_BAC_OID:
   3238                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   00008B   7904         MOV       R1,#0x4
   3239                break;
   \   00008D   8016         SJMP      ??zclGetDataTypeLength_10
   3240          
   3241             case ZCL_DATATYPE_UINT40:
   3242             case ZCL_DATATYPE_INT40:
   3243                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008F   7905         MOV       R1,#0x5
   3244                 break;
   \   000091   8012         SJMP      ??zclGetDataTypeLength_10
   3245          
   3246             case ZCL_DATATYPE_UINT48:
   3247             case ZCL_DATATYPE_INT48:
   3248                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000093   7906         MOV       R1,#0x6
   3249                 break;
   \   000095   800E         SJMP      ??zclGetDataTypeLength_10
   3250          
   3251             case ZCL_DATATYPE_UINT56:
   3252             case ZCL_DATATYPE_INT56:
   3253                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000097   7907         MOV       R1,#0x7
   3254                 break;
   \   000099   800A         SJMP      ??zclGetDataTypeLength_10
   3255          
   3256             case ZCL_DATATYPE_DOUBLE_PREC:
   3257             case ZCL_DATATYPE_IEEE_ADDR:
   3258             case ZCL_DATATYPE_UINT64:
   3259             case ZCL_DATATYPE_INT64:
   3260               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   00009B   7908         MOV       R1,#0x8
   3261               break;
   \   00009D   8006         SJMP      ??zclGetDataTypeLength_10
   3262          
   3263              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3264               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009F   7910         MOV       R1,#0x10
   3265               break;
   \   0000A1   8002         SJMP      ??zclGetDataTypeLength_10
   3266          
   3267              case ZCL_DATATYPE_NO_DATA:
   3268              case ZCL_DATATYPE_UNKNOWN:
   3269                // Fall through
   3270          
   3271              default:
   3272                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A3   7900         MOV       R1,#0x0
   3273                break;
   3274            }
   3275          
   3276            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A5   02....       LJMP      ?BRET
   3277          }
   3278          
   3279          /*********************************************************************
   3280           * @fn      zclGetAttrDataLength
   3281           *
   3282           * @brief   Return the length of the attribute.
   3283           *
   3284           * @param   dataType - data type
   3285           * @param   pData - pointer to data
   3286           *
   3287           * @return  returns atrribute length
   3288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3289          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   3290          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
   3291            uint16 dataLen = 0;
   \   00000B   75..00       MOV       ?V0,#0x0
   \   00000E   75..00       MOV       ?V1,#0x0
   3292          
   3293            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000011   7444         MOV       A,#0x44
   \   000013   65..         XRL       A,?V2
   \   000015   6006         JZ        ??zclGetAttrDataLength_0
   \   000017   7443         MOV       A,#0x43
   \   000019   65..         XRL       A,?V2
   \   00001B   7027         JNZ       ??zclGetAttrDataLength_1
   3294            {
   3295              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00001D   8E82         MOV       DPL,R6
   \   00001F   8F83         MOV       DPH,R7
   \   000021   E0           MOVX      A,@DPTR
   \   000022   FA           MOV       R2,A
   \   000023   7B00         MOV       R3,#0x0
   \   000025   8E82         MOV       DPL,R6
   \   000027   8F83         MOV       DPH,R7
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F8           MOV       R0,A
   \   00002C   7900         MOV       R1,#0x0
   \   00002E   E4           CLR       A
   \   00002F   C8           XCH       A,R0
   \   000030   F9           MOV       R1,A
   \   000031   EA           MOV       A,R2
   \   000032   28           ADD       A,R0
   \   000033   F8           MOV       R0,A
   \   000034   EB           MOV       A,R3
   \   000035   39           ADDC      A,R1
   \   000036   F9           MOV       R1,A
   \   000037   E8           MOV       A,R0
   \   000038   2402         ADD       A,#0x2
   \   00003A   F8           MOV       R0,A
   \   00003B   5001         JNC       ??zclGetAttrDataLength_2
   \   00003D   09           INC       R1
   \                     ??zclGetAttrDataLength_2:
   \   00003E   88..         MOV       ?V0,R0
   \   000040   89..         MOV       ?V1,R1
   \   000042   802E         SJMP      ??zclGetAttrDataLength_3
   3296            }
   3297            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   000044   7442         MOV       A,#0x42
   \   000046   65..         XRL       A,?V2
   \   000048   6006         JZ        ??zclGetAttrDataLength_4
   \   00004A   7441         MOV       A,#0x41
   \   00004C   65..         XRL       A,?V2
   \   00004E   7015         JNZ       ??zclGetAttrDataLength_5
   3298            {
   3299              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_4:
   \   000050   8E82         MOV       DPL,R6
   \   000052   8F83         MOV       DPH,R7
   \   000054   E0           MOVX      A,@DPTR
   \   000055   F8           MOV       R0,A
   \   000056   7900         MOV       R1,#0x0
   \   000058   E8           MOV       A,R0
   \   000059   2401         ADD       A,#0x1
   \   00005B   F8           MOV       R0,A
   \   00005C   5001         JNC       ??zclGetAttrDataLength_6
   \   00005E   09           INC       R1
   \                     ??zclGetAttrDataLength_6:
   \   00005F   88..         MOV       ?V0,R0
   \   000061   89..         MOV       ?V1,R1
   \   000063   800D         SJMP      ??zclGetAttrDataLength_3
   3300            }
   3301            else
   3302            {
   3303              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_5:
   \   000065                ; Setup parameters for call to function zclGetDataTypeLength
   \   000065   A9..         MOV       R1,?V2
   \   000067   12....       LCALL     `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00006A   E9           MOV       A,R1
   \   00006B   F8           MOV       R0,A
   \   00006C   7900         MOV       R1,#0x0
   \   00006E   88..         MOV       ?V0,R0
   \   000070   89..         MOV       ?V1,R1
   3304            }
   3305          
   3306            return ( dataLen );
   \                     ??zclGetAttrDataLength_3:
   \   000072   AA..         MOV       R2,?V0
   \   000074   AB..         MOV       R3,?V1
   \   000076   7F03         MOV       R7,#0x3
   \   000078   02....       LJMP      ?BANKED_LEAVE_XDATA
   3307          }
   3308          
   3309          #ifdef ZCL_READ
   3310          /*********************************************************************
   3311           * @fn      zclReadAttrData
   3312           *
   3313           * @brief   Read the attribute's current value into pAttrData.
   3314           *          NOTE - Not compatible with application's attributes callbacks.
   3315           *
   3316           * @param   pAttrData - where to put attribute data
   3317           * @param   pAttr - pointer to attribute
   3318           * @param   pDataLen - where to put attribute data length
   3319           *
   3320           * @return Success
   3321           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3322          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   3323          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V8,R2
   \   000007   8B..         MOV       ?V9,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   \   00000D   7412         MOV       A,#0x12
   \   00000F   12....       LCALL     ?XSTACK_DISP0_8
   \   000012   E0           MOVX      A,@DPTR
   \   000013   F5..         MOV       ?V0,A
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F5..         MOV       ?V1,A
   3324            uint16 dataLen;
   3325          
   3326            if ( pAttr->attr.dataPtr == NULL )
   \   000019   8E82         MOV       DPL,R6
   \   00001B   8F83         MOV       DPH,R7
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F8           MOV       R0,A
   \   000025   A3           INC       DPTR
   \   000026   E0           MOVX      A,@DPTR
   \   000027   F9           MOV       R1,A
   \   000028   E8           MOV       A,R0
   \   000029   49           ORL       A,R1
   \   00002A   7004         JNZ       ??zclReadAttrData_0
   3327            {
   3328              return ( ZCL_STATUS_FAILURE );
   \   00002C   7901         MOV       R1,#0x1
   \   00002E   8064         SJMP      ??zclReadAttrData_1
   3329            }
   3330          
   3331            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000030                ; Setup parameters for call to function zclGetAttrDataLength
   \   000030   8E82         MOV       DPL,R6
   \   000032   8F83         MOV       DPH,R7
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   FA           MOV       R2,A
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   FB           MOV       R3,A
   \   00003F   8E82         MOV       DPL,R6
   \   000041   8F83         MOV       DPH,R7
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   F9           MOV       R1,A
   \   000049   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00004C   8A..         MOV       ?V4,R2
   \   00004E   8B..         MOV       ?V5,R3
   \   000050   85....       MOV       ?V2,?V4
   \   000053   85....       MOV       ?V3,?V5
   3332            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000056                ; Setup parameters for call to function osal_memcpy
   \   000056   8E82         MOV       DPL,R6
   \   000058   8F83         MOV       DPH,R7
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   A3           INC       DPTR
   \   00005E   A3           INC       DPTR
   \   00005F   A3           INC       DPTR
   \   000060   E0           MOVX      A,@DPTR
   \   000061   F5..         MOV       ?V4,A
   \   000063   A3           INC       DPTR
   \   000064   E0           MOVX      A,@DPTR
   \   000065   F5..         MOV       ?V5,A
   \   000067   75..00       MOV       ?V6,#0x0
   \   00006A   78..         MOV       R0,#?V4
   \   00006C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00006F   AC..         MOV       R4,?V2
   \   000071   AD..         MOV       R5,?V3
   \   000073   AA..         MOV       R2,?V8
   \   000075   AB..         MOV       R3,?V9
   \   000077   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00007A   7403         MOV       A,#0x3
   \   00007C   12....       LCALL     ?DEALLOC_XSTACK8
   3333          
   3334            if ( pDataLen != NULL )
   \   00007F   E5..         MOV       A,?V0
   \   000081   45..         ORL       A,?V1
   \   000083   600D         JZ        ??zclReadAttrData_2
   3335            {
   3336              *pDataLen = dataLen;
   \   000085   85..82       MOV       DPL,?V0
   \   000088   85..83       MOV       DPH,?V1
   \   00008B   E5..         MOV       A,?V2
   \   00008D   F0           MOVX      @DPTR,A
   \   00008E   A3           INC       DPTR
   \   00008F   E5..         MOV       A,?V3
   \   000091   F0           MOVX      @DPTR,A
   3337            }
   3338          
   3339            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   000092   7900         MOV       R1,#0x0
   \                     ??zclReadAttrData_1:
   \   000094   7F0A         MOV       R7,#0xa
   \   000096   02....       LJMP      ?BANKED_LEAVE_XDATA
   3340          }
   3341          
   3342          /*********************************************************************
   3343           * @fn      zcl_ReadAttrData
   3344           *
   3345           * @brief   Read the attribute's current value into pAttrData.
   3346           *          Use application's callback function if assigned to this attribute.
   3347           *
   3348           * @param   endpoint - application's endpoint
   3349           * @param   clusterId - cluster that attribute belongs to
   3350           * @param   attrId - attribute id
   3351           * @param   pAttrData - where to put attribute data
   3352           * @param   pDataLen - where to put attribute data length
   3353           *
   3354           * @return  Successful if data was read
   3355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3356          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   3357                                                   uint8 *pAttrData, uint16 *pDataLen )
   3358          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
   \   00000C   EA           MOV       A,R2
   \   00000D   FE           MOV       R6,A
   \   00000E   EB           MOV       A,R3
   \   00000F   FF           MOV       R7,A
   \   000010   8C..         MOV       ?V2,R4
   \   000012   8D..         MOV       ?V3,R5
   \   000014   741A         MOV       A,#0x1a
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V6,A
   \   00001C   A3           INC       DPTR
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   F5..         MOV       ?V7,A
   \   000020   741C         MOV       A,#0x1c
   \   000022   12....       LCALL     ?XSTACK_DISP0_8
   \   000025   E0           MOVX      A,@DPTR
   \   000026   F5..         MOV       ?V4,A
   \   000028   A3           INC       DPTR
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   F5..         MOV       ?V5,A
   3359            zclAttrRec_t attrRec;
   3360          
   3361            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   00002C                ; Setup parameters for call to function zclFindAttrRec
   \   00002C   A8..         MOV       R0,?XSP + 0
   \   00002E   A9..         MOV       R1,?XSP + 1
   \   000030   88..         MOV       ?V8,R0
   \   000032   89..         MOV       ?V9,R1
   \   000034   78..         MOV       R0,#?V8
   \   000036   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000039   AC..         MOV       R4,?V2
   \   00003B   AD..         MOV       R5,?V3
   \   00003D   EE           MOV       A,R6
   \   00003E   FA           MOV       R2,A
   \   00003F   EF           MOV       A,R7
   \   000040   FB           MOV       R3,A
   \   000041   A9..         MOV       R1,?V0
   \   000043   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000046   7402         MOV       A,#0x2
   \   000048   12....       LCALL     ?DEALLOC_XSTACK8
   \   00004B   E9           MOV       A,R1
   \   00004C   7004         JNZ       ??zcl_ReadAttrData_0
   3362            {
   3363              return ( ZCL_STATUS_FAILURE );
   \   00004E   7901         MOV       R1,#0x1
   \   000050   8042         SJMP      ??zcl_ReadAttrData_1
   3364            }
   3365          
   3366            if ( attrRec.attr.dataPtr != NULL )
   \                     ??zcl_ReadAttrData_0:
   \   000052   7406         MOV       A,#0x6
   \   000054   12....       LCALL     ?XSTACK_DISP0_8
   \   000057   E0           MOVX      A,@DPTR
   \   000058   F8           MOV       R0,A
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   F9           MOV       R1,A
   \   00005C   E8           MOV       A,R0
   \   00005D   49           ORL       A,R1
   \   00005E   6018         JZ        ??zcl_ReadAttrData_2
   3367            {
   3368              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   000060                ; Setup parameters for call to function zclReadAttrData
   \   000060   78..         MOV       R0,#?V4
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000065   7402         MOV       A,#0x2
   \   000067   12....       LCALL     ?XSTACK_DISP102_8
   \   00006A   AA..         MOV       R2,?V6
   \   00006C   AB..         MOV       R3,?V7
   \   00006E   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   000071   7402         MOV       A,#0x2
   \   000073   12....       LCALL     ?DEALLOC_XSTACK8
   \   000076   801C         SJMP      ??zcl_ReadAttrData_1
   3369            }
   3370            else
   3371            {
   3372              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000078                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000078   78..         MOV       R0,#?V4
   \   00007A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007D   78..         MOV       R0,#?V6
   \   00007F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000082   AC..         MOV       R4,?V2
   \   000084   AD..         MOV       R5,?V3
   \   000086   EE           MOV       A,R6
   \   000087   FA           MOV       R2,A
   \   000088   EF           MOV       A,R7
   \   000089   FB           MOV       R3,A
   \   00008A   A9..         MOV       R1,?V0
   \   00008C   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   00008F   7404         MOV       A,#0x4
   \   000091   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   000094   7408         MOV       A,#0x8
   \   000096   12....       LCALL     ?DEALLOC_XSTACK8
   \   000099   7F0A         MOV       R7,#0xa
   \   00009B   02....       LJMP      ?BANKED_LEAVE_XDATA
   3373            }
   3374          }
   3375          
   3376          /*********************************************************************
   3377           * @fn      zclGetAttrDataLengthUsingCB
   3378           *
   3379           * @brief   Use application's callback to get the length of the attribute's
   3380           *          current value stored in the database.
   3381           *
   3382           * @param   endpoint - application's endpoint
   3383           * @param   clusterId - cluster that attribute belongs to
   3384           * @param   attrId - attribute id
   3385           *
   3386           * @return  returns attribute length
   3387           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3388          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3389          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V2,R1
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   8C..         MOV       ?V0,R4
   \   000012   8D..         MOV       ?V1,R5
   3390            uint16 dataLen = 0;
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   7400         MOV       A,#0x0
   \   00001C   F0           MOVX      @DPTR,A
   \   00001D   A3           INC       DPTR
   \   00001E   7400         MOV       A,#0x0
   \   000020   F0           MOVX      @DPTR,A
   3391            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000021                ; Setup parameters for call to function zclGetReadWriteCB
   \   000021   A9..         MOV       R1,?V2
   \   000023   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000026   8A..         MOV       ?V6,R2
   \   000028   8B..         MOV       ?V7,R3
   \   00002A   AE..         MOV       R6,?V6
   \   00002C   AF..         MOV       R7,?V7
   3392          
   3393            if ( pfnReadWriteCB != NULL )
   \   00002E   EE           MOV       A,R6
   \   00002F   4F           ORL       A,R7
   \   000030   602E         JZ        ??zclGetAttrDataLengthUsingCB_0
   3394            {
   3395              // Only get the attribute length
   3396              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000032                ; Setup parameters for indirect call
   \   000032   A8..         MOV       R0,?XSP + 0
   \   000034   A9..         MOV       R1,?XSP + 1
   \   000036   88..         MOV       ?V6,R0
   \   000038   89..         MOV       ?V7,R1
   \   00003A   78..         MOV       R0,#?V6
   \   00003C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003F   E4           CLR       A
   \   000040   F5..         MOV       ?V6,A
   \   000042   F5..         MOV       ?V7,A
   \   000044   78..         MOV       R0,#?V6
   \   000046   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000049   7900         MOV       R1,#0x0
   \   00004B   AC..         MOV       R4,?V0
   \   00004D   AD..         MOV       R5,?V1
   \   00004F   AA..         MOV       R2,?V4
   \   000051   AB..         MOV       R3,?V5
   \   000053   8E82         MOV       DPL,R6
   \   000055   8F83         MOV       DPH,R7
   \   000057   12....       LCALL     ?CALL_IND
   \   00005A   7404         MOV       A,#0x4
   \   00005C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005F   E9           MOV       A,R1
   3397            }
   3398          
   3399            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000060   85..82       MOV       DPL,?XSP + 0
   \   000063   85..83       MOV       DPH,?XSP + 1
   \   000066   E0           MOVX      A,@DPTR
   \   000067   FA           MOV       R2,A
   \   000068   A3           INC       DPTR
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   FB           MOV       R3,A
   \   00006B   7402         MOV       A,#0x2
   \   00006D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000070   7F08         MOV       R7,#0x8
   \   000072   02....       LJMP      ?BANKED_LEAVE_XDATA
   3400          }
   3401          
   3402          /*********************************************************************
   3403           * @fn      zclReadAttrDataUsingCB
   3404           *
   3405           * @brief   Use application's callback to read the attribute's current
   3406           *          value stored in the database.
   3407           *
   3408           * @param   endpoint - application's endpoint
   3409           * @param   clusterId - cluster that attribute belongs to
   3410           * @param   attrId - attribute id
   3411           * @param   pAttrData - where to put attribute data
   3412           * @param   pDataLen - where to put attribute data length
   3413           *
   3414           * @return  Successful if data was read
   3415           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3416          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3417                                                   uint8 *pAttrData, uint16 *pDataLen )
   3418          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V2,R2
   \   000009   8B..         MOV       ?V3,R3
   \   00000B   8C..         MOV       ?V0,R4
   \   00000D   8D..         MOV       ?V1,R5
   \   00000F   7414         MOV       A,#0x14
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F5..         MOV       ?V8,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F5..         MOV       ?V9,A
   \   00001B   7416         MOV       A,#0x16
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V6,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F5..         MOV       ?V7,A
   3419            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000027                ; Setup parameters for call to function zclGetReadWriteCB
   \   000027   A9..         MOV       R1,?V4
   \   000029   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   00002C   8A..         MOV       ?V10,R2
   \   00002E   8B..         MOV       ?V11,R3
   \   000030   AE..         MOV       R6,?V10
   \   000032   AF..         MOV       R7,?V11
   3420          
   3421            if ( pDataLen != NULL )
   \   000034   E5..         MOV       A,?V6
   \   000036   45..         ORL       A,?V7
   \   000038   600D         JZ        ??zclReadAttrDataUsingCB_0
   3422            {
   3423              *pDataLen = 0; // Always initialize it to 0
   \   00003A   85..82       MOV       DPL,?V6
   \   00003D   85..83       MOV       DPH,?V7
   \   000040   7400         MOV       A,#0x0
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   7400         MOV       A,#0x0
   \   000046   F0           MOVX      @DPTR,A
   3424            }
   3425          
   3426            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   000047   EE           MOV       A,R6
   \   000048   4F           ORL       A,R7
   \   000049   6022         JZ        ??zclReadAttrDataUsingCB_1
   3427            {
   3428              // Read the attribute value and its length
   3429              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   00004B                ; Setup parameters for indirect call
   \   00004B   78..         MOV       R0,#?V6
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000050   78..         MOV       R0,#?V8
   \   000052   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000055   7901         MOV       R1,#0x1
   \   000057   AC..         MOV       R4,?V0
   \   000059   AD..         MOV       R5,?V1
   \   00005B   AA..         MOV       R2,?V2
   \   00005D   AB..         MOV       R3,?V3
   \   00005F   8E82         MOV       DPL,R6
   \   000061   8F83         MOV       DPH,R7
   \   000063   12....       LCALL     ?CALL_IND
   \   000066   7404         MOV       A,#0x4
   \   000068   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006B   8002         SJMP      ??zclReadAttrDataUsingCB_2
   3430            }
   3431          
   3432            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   00006D   79C1         MOV       R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00006F   7F0C         MOV       R7,#0xc
   \   000071   02....       LJMP      ?BANKED_LEAVE_XDATA
   3433          }
   3434          
   3435          /*********************************************************************
   3436           * @fn      zclAuthorizeRead
   3437           *
   3438           * @brief   Use application's callback to authorize a Read operation
   3439           *          on a given attribute.
   3440           *
   3441           * @param   endpoint - application's endpoint
   3442           * @param   srcAddr - source Address
   3443           * @param   pAttr - pointer to attribute
   3444           *
   3445           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3446           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3447           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3448          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeRead:
   3449          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V2,R2
   \   000009   8B..         MOV       ?V3,R3
   \   00000B   8C..         MOV       ?V0,R4
   \   00000D   8D..         MOV       ?V1,R5
   3450            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   \   00000F   85..82       MOV       DPL,?V0
   \   000012   85..83       MOV       DPH,?V1
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   A2E4         MOV       C,0xE0 /* A   */.4
   \   00001D   5024         JNC       ??zclAuthorizeRead_0
   3451            {
   3452              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001F                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001F   A9..         MOV       R1,?V4
   \   000021   12....       LCALL     `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   000024   8A..         MOV       ?V6,R2
   \   000026   8B..         MOV       ?V7,R3
   \   000028   AE..         MOV       R6,?V6
   \   00002A   AF..         MOV       R7,?V7
   3453          
   3454              if ( pfnAuthorizeCB != NULL )
   \   00002C   EE           MOV       A,R6
   \   00002D   4F           ORL       A,R7
   \   00002E   6013         JZ        ??zclAuthorizeRead_0
   3455              {
   3456                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   \   000030                ; Setup parameters for indirect call
   \   000030   7901         MOV       R1,#0x1
   \   000032   AC..         MOV       R4,?V0
   \   000034   AD..         MOV       R5,?V1
   \   000036   AA..         MOV       R2,?V2
   \   000038   AB..         MOV       R3,?V3
   \   00003A   8E82         MOV       DPL,R6
   \   00003C   8F83         MOV       DPH,R7
   \   00003E   12....       LCALL     ?CALL_IND
   \   000041   8002         SJMP      ??zclAuthorizeRead_1
   3457              }
   3458            }
   3459          
   3460            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeRead_0:
   \   000043   7900         MOV       R1,#0x0
   \                     ??zclAuthorizeRead_1:
   \   000045   7F08         MOV       R7,#0x8
   \   000047   02....       LJMP      ?BANKED_LEAVE_XDATA
   3461          }
   3462          #endif // ZCL_READ
   3463          
   3464          #ifdef ZCL_WRITE
   3465          /*********************************************************************
   3466           * @fn      zclWriteAttrData
   3467           *
   3468           * @brief   Write the received data.
   3469           *
   3470           * @param   endpoint - application's endpoint
   3471           * @param   pAttr - where to write data to
   3472           * @param   pWriteRec - data to be written
   3473           *
   3474           * @return  Successful if data was written
   3475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3476          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3477                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3478          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V3,R1
   \   000007   8A..         MOV       ?V10,R2
   \   000009   8B..         MOV       ?V11,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7414         MOV       A,#0x14
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F5..         MOV       ?V0,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F5..         MOV       ?V1,A
   3479            uint8 status;
   3480          
   3481            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00001B   8E82         MOV       DPL,R6
   \   00001D   8F83         MOV       DPH,R7
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   A2E1         MOV       C,0xE0 /* A   */.1
   \   000027   4003         JC        $+5
   \   000029   02....       LJMP      ??zclWriteAttrData_0 & 0xFFFF
   3482            {
   3483              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   00002C                ; Setup parameters for call to function zclAuthorizeWrite
   \   00002C   EE           MOV       A,R6
   \   00002D   FC           MOV       R4,A
   \   00002E   EF           MOV       A,R7
   \   00002F   FD           MOV       R5,A
   \   000030   AA..         MOV       R2,?V10
   \   000032   AB..         MOV       R3,?V11
   \   000034   A9..         MOV       R1,?V3
   \   000036   12....       LCALL     `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   000039   E9           MOV       A,R1
   \   00003A   F5..         MOV       ?V2,A
   3484              if ( status == ZCL_STATUS_SUCCESS )
   \   00003C   E5..         MOV       A,?V2
   \   00003E   6003         JZ        $+5
   \   000040   02....       LJMP      ??zclWriteAttrData_1 & 0xFFFF
   3485              {
   3486                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   000043   90....       MOV       DPTR,#zcl_ValidateAttrDataCB
   \   000046   E0           MOVX      A,@DPTR
   \   000047   F8           MOV       R0,A
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   F9           MOV       R1,A
   \   00004B   E8           MOV       A,R0
   \   00004C   49           ORL       A,R1
   \   00004D   6019         JZ        ??zclWriteAttrData_2
   \   00004F                ; Setup parameters for indirect call
   \   00004F   AC..         MOV       R4,?V0
   \   000051   AD..         MOV       R5,?V1
   \   000053   EE           MOV       A,R6
   \   000054   FA           MOV       R2,A
   \   000055   EF           MOV       A,R7
   \   000056   FB           MOV       R3,A
   \   000057   90....       MOV       DPTR,#zcl_ValidateAttrDataCB
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   F8           MOV       R0,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   F583         MOV       DPH,A
   \   000060   8882         MOV       DPL,R0
   \   000062   12....       LCALL     ?CALL_IND
   \   000065   E9           MOV       A,R1
   \   000066   605D         JZ        ??zclWriteAttrData_3
   3487                {
   3488                  // Write the attribute value
   3489                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000068                ; Setup parameters for call to function zclGetAttrDataLength
   \   000068   85..82       MOV       DPL,?V0
   \   00006B   85..83       MOV       DPH,?V1
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A3           INC       DPTR
   \   000071   E0           MOVX      A,@DPTR
   \   000072   FA           MOV       R2,A
   \   000073   A3           INC       DPTR
   \   000074   E0           MOVX      A,@DPTR
   \   000075   FB           MOV       R3,A
   \   000076   8E82         MOV       DPL,R6
   \   000078   8F83         MOV       DPH,R7
   \   00007A   A3           INC       DPTR
   \   00007B   A3           INC       DPTR
   \   00007C   A3           INC       DPTR
   \   00007D   A3           INC       DPTR
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   F9           MOV       R1,A
   \   000080   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000083   8A..         MOV       ?V4,R2
   \   000085   8B..         MOV       ?V5,R3
   \   000087   85....       MOV       ?V8,?V4
   \   00008A   85....       MOV       ?V9,?V5
   3490                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00008D                ; Setup parameters for call to function osal_memcpy
   \   00008D   85..82       MOV       DPL,?V0
   \   000090   85..83       MOV       DPH,?V1
   \   000093   A3           INC       DPTR
   \   000094   A3           INC       DPTR
   \   000095   A3           INC       DPTR
   \   000096   E0           MOVX      A,@DPTR
   \   000097   F5..         MOV       ?V4,A
   \   000099   A3           INC       DPTR
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   F5..         MOV       ?V5,A
   \   00009D   75..00       MOV       ?V6,#0x0
   \   0000A0   78..         MOV       R0,#?V4
   \   0000A2   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000A5   AC..         MOV       R4,?V8
   \   0000A7   AD..         MOV       R5,?V9
   \   0000A9   8E82         MOV       DPL,R6
   \   0000AB   8F83         MOV       DPH,R7
   \   0000AD   A3           INC       DPTR
   \   0000AE   A3           INC       DPTR
   \   0000AF   A3           INC       DPTR
   \   0000B0   A3           INC       DPTR
   \   0000B1   A3           INC       DPTR
   \   0000B2   A3           INC       DPTR
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   FA           MOV       R2,A
   \   0000B5   A3           INC       DPTR
   \   0000B6   E0           MOVX      A,@DPTR
   \   0000B7   FB           MOV       R3,A
   \   0000B8   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000BB   7403         MOV       A,#0x3
   \   0000BD   12....       LCALL     ?DEALLOC_XSTACK8
   3491          
   3492                  status = ZCL_STATUS_SUCCESS;
   \   0000C0   75..00       MOV       ?V2,#0x0
   \   0000C3   8008         SJMP      ??zclWriteAttrData_1
   3493                }
   3494                else
   3495                {
   3496                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   0000C5   75..87       MOV       ?V2,#-0x79
   \   0000C8   8003         SJMP      ??zclWriteAttrData_1
   3497                }
   3498              }
   3499            }
   3500            else
   3501            {
   3502              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   0000CA   75..88       MOV       ?V2,#-0x78
   3503            }
   3504          
   3505            return ( status );
   \                     ??zclWriteAttrData_1:
   \   0000CD   A9..         MOV       R1,?V2
   \   0000CF   7F0C         MOV       R7,#0xc
   \   0000D1   02....       LJMP      ?BANKED_LEAVE_XDATA
   3506          }
   3507          
   3508          /*********************************************************************
   3509           * @fn      zclWriteAttrDataUsingCB
   3510           *
   3511           * @brief   Use application's callback to write the attribute's current
   3512           *          value stored in the database.
   3513           *
   3514           * @param   endpoint - application's endpoint
   3515           * @param   pAttr - where to write data to
   3516           * @param   pAttrData - data to be written
   3517           *
   3518           * @return  Successful if data was written
   3519           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3520          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3521                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3522          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V1,R1
   \   000007   8A..         MOV       ?V4,R2
   \   000009   8B..         MOV       ?V5,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7412         MOV       A,#0x12
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F5..         MOV       ?V6,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F5..         MOV       ?V7,A
   3523            uint8 status;
   3524          
   3525            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00001B   8E82         MOV       DPL,R6
   \   00001D   8F83         MOV       DPH,R7
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   A2E1         MOV       C,0xE0 /* A   */.1
   \   000027   5066         JNC       ??zclWriteAttrDataUsingCB_0
   3526            {
   3527              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000029                ; Setup parameters for call to function zclAuthorizeWrite
   \   000029   EE           MOV       A,R6
   \   00002A   FC           MOV       R4,A
   \   00002B   EF           MOV       A,R7
   \   00002C   FD           MOV       R5,A
   \   00002D   AA..         MOV       R2,?V4
   \   00002F   AB..         MOV       R3,?V5
   \   000031   A9..         MOV       R1,?V1
   \   000033   12....       LCALL     `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   000036   E9           MOV       A,R1
   \   000037   F5..         MOV       ?V0,A
   3528              if ( status == ZCL_STATUS_SUCCESS )
   \   000039   E5..         MOV       A,?V0
   \   00003B   7055         JNZ       ??zclWriteAttrDataUsingCB_1
   3529              {
   3530                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00003D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00003D   A9..         MOV       R1,?V1
   \   00003F   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000042   8A..         MOV       ?V8,R2
   \   000044   8B..         MOV       ?V9,R3
   \   000046   85....       MOV       ?V2,?V8
   \   000049   85....       MOV       ?V3,?V9
   3531                if ( pfnReadWriteCB != NULL )
   \   00004C   E5..         MOV       A,?V2
   \   00004E   45..         ORL       A,?V3
   \   000050   6038         JZ        ??zclWriteAttrDataUsingCB_2
   3532                {
   3533                  // Write the attribute value
   3534                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3535                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   000052                ; Setup parameters for indirect call
   \   000052   E4           CLR       A
   \   000053   F5..         MOV       ?V8,A
   \   000055   F5..         MOV       ?V9,A
   \   000057   78..         MOV       R0,#?V8
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005C   78..         MOV       R0,#?V6
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000061   7902         MOV       R1,#0x2
   \   000063   8E82         MOV       DPL,R6
   \   000065   8F83         MOV       DPH,R7
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   FC           MOV       R4,A
   \   00006B   A3           INC       DPTR
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   FD           MOV       R5,A
   \   00006E   8E82         MOV       DPL,R6
   \   000070   8F83         MOV       DPH,R7
   \   000072   E0           MOVX      A,@DPTR
   \   000073   FA           MOV       R2,A
   \   000074   A3           INC       DPTR
   \   000075   E0           MOVX      A,@DPTR
   \   000076   FB           MOV       R3,A
   \   000077   85..82       MOV       DPL,?V2
   \   00007A   85..83       MOV       DPH,?V3
   \   00007D   12....       LCALL     ?CALL_IND
   \   000080   7404         MOV       A,#0x4
   \   000082   12....       LCALL     ?DEALLOC_XSTACK8
   \   000085   E9           MOV       A,R1
   \   000086   F5..         MOV       ?V0,A
   \   000088   8008         SJMP      ??zclWriteAttrDataUsingCB_1
   3536                }
   3537                else
   3538                {
   3539                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   00008A   75..C1       MOV       ?V0,#-0x3f
   \   00008D   8003         SJMP      ??zclWriteAttrDataUsingCB_1
   3540                }
   3541              }
   3542            }
   3543            else
   3544            {
   3545              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   00008F   75..88       MOV       ?V0,#-0x78
   3546            }
   3547          
   3548            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000092   A9..         MOV       R1,?V0
   \   000094   7F0A         MOV       R7,#0xa
   \   000096   02....       LJMP      ?BANKED_LEAVE_XDATA
   3549          }
   3550          
   3551          /*********************************************************************
   3552           * @fn      zclAuthorizeWrite
   3553           *
   3554           * @brief   Use application's callback to authorize a Write operation
   3555           *          on a given attribute.
   3556           *
   3557           * @param   endpoint - application's endpoint
   3558           * @param   srcAddr - source Address
   3559           * @param   pAttr - pointer to attribute
   3560           *
   3561           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3562           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3563           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3564          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3565          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V2,R2
   \   000009   8B..         MOV       ?V3,R3
   \   00000B   8C..         MOV       ?V0,R4
   \   00000D   8D..         MOV       ?V1,R5
   3566            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000F   85..82       MOV       DPL,?V0
   \   000012   85..83       MOV       DPH,?V1
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   A2E5         MOV       C,0xE0 /* A   */.5
   \   00001D   5024         JNC       ??zclAuthorizeWrite_0
   3567            {
   3568              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001F                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001F   A9..         MOV       R1,?V4
   \   000021   12....       LCALL     `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   000024   8A..         MOV       ?V6,R2
   \   000026   8B..         MOV       ?V7,R3
   \   000028   AE..         MOV       R6,?V6
   \   00002A   AF..         MOV       R7,?V7
   3569          
   3570              if ( pfnAuthorizeCB != NULL )
   \   00002C   EE           MOV       A,R6
   \   00002D   4F           ORL       A,R7
   \   00002E   6013         JZ        ??zclAuthorizeWrite_0
   3571              {
   3572                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000030                ; Setup parameters for indirect call
   \   000030   7902         MOV       R1,#0x2
   \   000032   AC..         MOV       R4,?V0
   \   000034   AD..         MOV       R5,?V1
   \   000036   AA..         MOV       R2,?V2
   \   000038   AB..         MOV       R3,?V3
   \   00003A   8E82         MOV       DPL,R6
   \   00003C   8F83         MOV       DPH,R7
   \   00003E   12....       LCALL     ?CALL_IND
   \   000041   8002         SJMP      ??zclAuthorizeWrite_1
   3573              }
   3574            }
   3575          
   3576            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000043   7900         MOV       R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000045   7F08         MOV       R7,#0x8
   \   000047   02....       LJMP      ?BANKED_LEAVE_XDATA
   3577          }
   3578          #endif // ZCL_WRITE
   3579          
   3580          #ifdef ZCL_READ
   3581          /*********************************************************************
   3582           * @fn      zclParseInReadCmd
   3583           *
   3584           * @brief   Parse the "Profile" Read Commands
   3585           *
   3586           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3587           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3588           *
   3589           * @param   pCmd - pointer to incoming data to parse
   3590           *
   3591           * @return  pointer to the parsed command structure
   3592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3593          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3594          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   3595            zclReadCmd_t *readCmd;
   3596            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV       DPL,?V2
   \   00000C   85..83       MOV       DPH,?V3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   F8           MOV       R0,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   F9           MOV       R1,A
   \   000017   88..         MOV       ?V0,R0
   \   000019   89..         MOV       ?V1,R1
   3597          
   3598            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   00001B                ; Setup parameters for call to function osal_mem_alloc
   \   00001B   85..82       MOV       DPL,?V2
   \   00001E   85..83       MOV       DPH,?V3
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   2401         ADD       A,#0x1
   \   000025   FA           MOV       R2,A
   \   000026   A3           INC       DPTR
   \   000027   E0           MOVX      A,@DPTR
   \   000028   3400         ADDC      A,#0x0
   \   00002A   FB           MOV       R3,A
   \   00002B   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002E   8A..         MOV       ?V4,R2
   \   000030   8B..         MOV       ?V5,R3
   \   000032   AE..         MOV       R6,?V4
   \   000034   AF..         MOV       R7,?V5
   3599            if ( readCmd != NULL )
   \   000036   EE           MOV       A,R6
   \   000037   4F           ORL       A,R7
   \   000038   607C         JZ        ??zclParseInReadCmd_0
   3600            {
   3601              uint8 i;
   3602              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00003A   85..82       MOV       DPL,?V2
   \   00003D   85..83       MOV       DPH,?V3
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   F8           MOV       R0,A
   \   000043   A3           INC       DPTR
   \   000044   E0           MOVX      A,@DPTR
   \   000045   F9           MOV       R1,A
   \   000046   E9           MOV       A,R1
   \   000047   C3           CLR       C
   \   000048   13           RRC       A
   \   000049   F9           MOV       R1,A
   \   00004A   E8           MOV       A,R0
   \   00004B   13           RRC       A
   \   00004C   F8           MOV       R0,A
   \   00004D   E8           MOV       A,R0
   \   00004E   C0E0         PUSH      A
   \   000050   8E82         MOV       DPL,R6
   \   000052   8F83         MOV       DPH,R7
   \   000054   D0E0         POP       A
   \   000056   F0           MOVX      @DPTR,A
   3603              for ( i = 0; i < readCmd->numAttr; i++ )
   \   000057   7A00         MOV       R2,#0x0
   \                     ??zclParseInReadCmd_1:
   \   000059   8E82         MOV       DPL,R6
   \   00005B   8F83         MOV       DPH,R7
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   F8           MOV       R0,A
   \   00005F   EA           MOV       A,R2
   \   000060   C3           CLR       C
   \   000061   98           SUBB      A,R0
   \   000062   5052         JNC       ??zclParseInReadCmd_0
   3604              {
   3605                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   000064   85..82       MOV       DPL,?V0
   \   000067   85..83       MOV       DPH,?V1
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   FC           MOV       R4,A
   \   00006C   7D00         MOV       R5,#0x0
   \   00006E   85..82       MOV       DPL,?V0
   \   000071   85..83       MOV       DPH,?V1
   \   000074   A3           INC       DPTR
   \   000075   E0           MOVX      A,@DPTR
   \   000076   F8           MOV       R0,A
   \   000077   7900         MOV       R1,#0x0
   \   000079   E4           CLR       A
   \   00007A   C8           XCH       A,R0
   \   00007B   F9           MOV       R1,A
   \   00007C   EC           MOV       A,R4
   \   00007D   28           ADD       A,R0
   \   00007E   FC           MOV       R4,A
   \   00007F   ED           MOV       A,R5
   \   000080   39           ADDC      A,R1
   \   000081   FD           MOV       R5,A
   \   000082   EA           MOV       A,R2
   \   000083   F8           MOV       R0,A
   \   000084   7900         MOV       R1,#0x0
   \   000086   E8           MOV       A,R0
   \   000087   75F002       MOV       B,#0x2
   \   00008A   A4           MUL       AB
   \   00008B   C8           XCH       A,R0
   \   00008C   ABF0         MOV       R3,B
   \   00008E   75F000       MOV       B,#0x0
   \   000091   A4           MUL       AB
   \   000092   2B           ADD       A,R3
   \   000093   FB           MOV       R3,A
   \   000094   75F002       MOV       B,#0x2
   \   000097   E9           MOV       A,R1
   \   000098   A4           MUL       AB
   \   000099   2B           ADD       A,R3
   \   00009A   F9           MOV       R1,A
   \   00009B   EE           MOV       A,R6
   \   00009C   28           ADD       A,R0
   \   00009D   F582         MOV       DPL,A
   \   00009F   EF           MOV       A,R7
   \   0000A0   39           ADDC      A,R1
   \   0000A1   F583         MOV       DPH,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   EC           MOV       A,R4
   \   0000A5   F0           MOVX      @DPTR,A
   \   0000A6   A3           INC       DPTR
   \   0000A7   ED           MOV       A,R5
   \   0000A8   F0           MOVX      @DPTR,A
   3606                pBuf += 2;
   \   0000A9   E5..         MOV       A,?V0
   \   0000AB   2402         ADD       A,#0x2
   \   0000AD   F5..         MOV       ?V0,A
   \   0000AF   5002         JNC       ??zclParseInReadCmd_2
   \   0000B1   05..         INC       ?V1
   3607              }
   \                     ??zclParseInReadCmd_2:
   \   0000B3   0A           INC       R2
   \   0000B4   80A3         SJMP      ??zclParseInReadCmd_1
   3608            }
   3609          
   3610            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   0000B6   EE           MOV       A,R6
   \   0000B7   FA           MOV       R2,A
   \   0000B8   EF           MOV       A,R7
   \   0000B9   FB           MOV       R3,A
   \   0000BA   7F06         MOV       R7,#0x6
   \   0000BC   02....       LJMP      ?BANKED_LEAVE_XDATA
   3611          }
   3612          
   3613          /*********************************************************************
   3614           * @fn      zclParseInReadRspCmd
   3615           *
   3616           * @brief   Parse the "Profile" Read Response Commands
   3617           *
   3618           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3619           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3620           *
   3621           * @param   pCmd - pointer to incoming data to parse
   3622           *
   3623           * @return  pointer to the parsed command structure
   3624           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3625          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3626          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V14,R2
   \   00000C   8B..         MOV       ?V15,R3
   3627            zclReadRspCmd_t *readRspCmd;
   3628            uint8 *pBuf = pCmd->pData;
   \   00000E   85..82       MOV       DPL,?V14
   \   000011   85..83       MOV       DPH,?V15
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   FE           MOV       R6,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   FF           MOV       R7,A
   3629            uint8 *dataPtr;
   3630            uint8 numAttr = 0;
   \   00001C   75..00       MOV       ?V7,#0x0
   3631            uint8 hdrLen;
   3632            uint16 dataLen = 0;
   \   00001F   85..82       MOV       DPL,?XSP + 0
   \   000022   85..83       MOV       DPH,?XSP + 1
   \   000025   7400         MOV       A,#0x0
   \   000027   F0           MOVX      @DPTR,A
   \   000028   A3           INC       DPTR
   \   000029   7400         MOV       A,#0x0
   \   00002B   F0           MOVX      @DPTR,A
   3633            uint16 attrDataLen;
   3634          
   3635            // find out the number of attributes and the length of attribute data
   3636            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInReadRspCmd_0:
   \   00002C   85..82       MOV       DPL,?V14
   \   00002F   85..83       MOV       DPH,?V15
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   F8           MOV       R0,A
   \   000035   A3           INC       DPTR
   \   000036   E0           MOVX      A,@DPTR
   \   000037   F9           MOV       R1,A
   \   000038   85..82       MOV       DPL,?V14
   \   00003B   85..83       MOV       DPH,?V15
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   28           ADD       A,R0
   \   000043   F8           MOV       R0,A
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   39           ADDC      A,R1
   \   000047   F9           MOV       R1,A
   \   000048   C3           CLR       C
   \   000049   EE           MOV       A,R6
   \   00004A   98           SUBB      A,R0
   \   00004B   EF           MOV       A,R7
   \   00004C   99           SUBB      A,R1
   \   00004D   5068         JNC       ??zclParseInReadRspCmd_1
   3637            {
   3638              uint8 status;
   3639          
   3640              numAttr++;
   \   00004F   05..         INC       ?V7
   3641              pBuf += 2; // move pass attribute id
   \   000051   EE           MOV       A,R6
   \   000052   2402         ADD       A,#0x2
   \   000054   FE           MOV       R6,A
   \   000055   5001         JNC       ??zclParseInReadRspCmd_2
   \   000057   0F           INC       R7
   3642          
   3643              status = *pBuf++;
   \                     ??zclParseInReadRspCmd_2:
   \   000058   8E82         MOV       DPL,R6
   \   00005A   8F83         MOV       DPH,R7
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F5..         MOV       ?V4,A
   \   00005F   8E82         MOV       DPL,R6
   \   000061   8F83         MOV       DPH,R7
   \   000063   A3           INC       DPTR
   \   000064   AE82         MOV       R6,DPL
   \   000066   AF83         MOV       R7,DPH
   3644              if ( status == ZCL_STATUS_SUCCESS )
   \   000068   E5..         MOV       A,?V4
   \   00006A   70C0         JNZ       ??zclParseInReadRspCmd_0
   3645              {
   3646                uint8 dataType = *pBuf++;
   \   00006C   8E82         MOV       DPL,R6
   \   00006E   8F83         MOV       DPH,R7
   \   000070   E0           MOVX      A,@DPTR
   \   000071   F5..         MOV       ?V5,A
   \   000073   8E82         MOV       DPL,R6
   \   000075   8F83         MOV       DPH,R7
   \   000077   A3           INC       DPTR
   \   000078   AE82         MOV       R6,DPL
   \   00007A   AF83         MOV       R7,DPH
   3647          
   3648                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   00007C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00007C   EE           MOV       A,R6
   \   00007D   FA           MOV       R2,A
   \   00007E   EF           MOV       A,R7
   \   00007F   FB           MOV       R3,A
   \   000080   A9..         MOV       R1,?V5
   \   000082   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000085   8A..         MOV       ?V0,R2
   \   000087   8B..         MOV       ?V1,R3
   \   000089   85....       MOV       ?V2,?V0
   \   00008C   85....       MOV       ?V3,?V1
   3649                pBuf += attrDataLen; // move pass attribute data
   \   00008F   EE           MOV       A,R6
   \   000090   25..         ADD       A,?V2
   \   000092   FE           MOV       R6,A
   \   000093   EF           MOV       A,R7
   \   000094   35..         ADDC      A,?V3
   \   000096   FF           MOV       R7,A
   3650          
   3651                // add padding if needed
   3652                if ( PADDING_NEEDED( attrDataLen ) )
   \   000097   E5..         MOV       A,?V2
   \   000099   A2E0         MOV       C,0xE0 /* A   */.0
   \   00009B   5008         JNC       ??zclParseInReadRspCmd_3
   3653                {
   3654                  attrDataLen++;
   \   00009D   05..         INC       ?V2
   \   00009F   E5..         MOV       A,?V2
   \   0000A1   7002         JNZ       ??zclParseInReadRspCmd_3
   \   0000A3   05..         INC       ?V3
   3655                }
   3656          
   3657                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   0000A5   85..82       MOV       DPL,?XSP + 0
   \   0000A8   85..83       MOV       DPH,?XSP + 1
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   25..         ADD       A,?V2
   \   0000AE   F0           MOVX      @DPTR,A
   \   0000AF   A3           INC       DPTR
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   35..         ADDC      A,?V3
   \   0000B3   F0           MOVX      @DPTR,A
   \   0000B4   02....       LJMP      ??zclParseInReadRspCmd_0 & 0xFFFF
   3658              }
   3659            }
   3660          
   3661            // calculate the length of the response header
   3662            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \                     ??zclParseInReadRspCmd_1:
   \   0000B7   75F006       MOV       B,#0x6
   \   0000BA   E5..         MOV       A,?V7
   \   0000BC   A4           MUL       AB
   \   0000BD   2401         ADD       A,#0x1
   \   0000BF   F5..         MOV       ?V11,A
   3663          
   3664            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   0000C1                ; Setup parameters for call to function osal_mem_alloc
   \   0000C1   E5..         MOV       A,?V11
   \   0000C3   F8           MOV       R0,A
   \   0000C4   7900         MOV       R1,#0x0
   \   0000C6   85..82       MOV       DPL,?XSP + 0
   \   0000C9   85..83       MOV       DPH,?XSP + 1
   \   0000CC   E0           MOVX      A,@DPTR
   \   0000CD   28           ADD       A,R0
   \   0000CE   FA           MOV       R2,A
   \   0000CF   A3           INC       DPTR
   \   0000D0   E0           MOVX      A,@DPTR
   \   0000D1   39           ADDC      A,R1
   \   0000D2   FB           MOV       R3,A
   \   0000D3   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000D6   8A..         MOV       ?V0,R2
   \   0000D8   8B..         MOV       ?V1,R3
   \   0000DA   85....       MOV       ?V12,?V0
   \   0000DD   85....       MOV       ?V13,?V1
   3665            if ( readRspCmd != NULL )
   \   0000E0   E5..         MOV       A,?V12
   \   0000E2   45..         ORL       A,?V13
   \   0000E4   7003         JNZ       $+5
   \   0000E6   02....       LJMP      ??zclParseInReadRspCmd_4 & 0xFFFF
   3666            {
   3667              uint8 i;
   3668              pBuf = pCmd->pData;
   \   0000E9   85..82       MOV       DPL,?V14
   \   0000EC   85..83       MOV       DPH,?V15
   \   0000EF   A3           INC       DPTR
   \   0000F0   A3           INC       DPTR
   \   0000F1   A3           INC       DPTR
   \   0000F2   E0           MOVX      A,@DPTR
   \   0000F3   F8           MOV       R0,A
   \   0000F4   A3           INC       DPTR
   \   0000F5   E0           MOVX      A,@DPTR
   \   0000F6   F9           MOV       R1,A
   \   0000F7   E8           MOV       A,R0
   \   0000F8   FE           MOV       R6,A
   \   0000F9   E9           MOV       A,R1
   \   0000FA   FF           MOV       R7,A
   3669              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \   0000FB   E5..         MOV       A,?V11
   \   0000FD   F8           MOV       R0,A
   \   0000FE   7900         MOV       R1,#0x0
   \   000100   E5..         MOV       A,?V12
   \   000102   28           ADD       A,R0
   \   000103   F8           MOV       R0,A
   \   000104   E5..         MOV       A,?V13
   \   000106   39           ADDC      A,R1
   \   000107   F9           MOV       R1,A
   \   000108   88..         MOV       ?V8,R0
   \   00010A   89..         MOV       ?V9,R1
   3670          
   3671              readRspCmd->numAttr = numAttr;
   \   00010C   E5..         MOV       A,?V7
   \   00010E   C0E0         PUSH      A
   \   000110   85..82       MOV       DPL,?V12
   \   000113   85..83       MOV       DPH,?V13
   \   000116   D0E0         POP       A
   \   000118   F0           MOVX      @DPTR,A
   3672              for ( i = 0; i < numAttr; i++ )
   \   000119   75..00       MOV       ?V10,#0x0
   \                     ??zclParseInReadRspCmd_5:
   \   00011C   E5..         MOV       A,?V10
   \   00011E   C3           CLR       C
   \   00011F   95..         SUBB      A,?V7
   \   000121   4003         JC        $+5
   \   000123   02....       LJMP      ??zclParseInReadRspCmd_4 & 0xFFFF
   3673              {
   3674                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \   000126   E5..         MOV       A,?V10
   \   000128   F8           MOV       R0,A
   \   000129   7900         MOV       R1,#0x0
   \   00012B   E8           MOV       A,R0
   \   00012C   75F006       MOV       B,#0x6
   \   00012F   A4           MUL       AB
   \   000130   C8           XCH       A,R0
   \   000131   AAF0         MOV       R2,B
   \   000133   75F000       MOV       B,#0x0
   \   000136   A4           MUL       AB
   \   000137   2A           ADD       A,R2
   \   000138   FA           MOV       R2,A
   \   000139   75F006       MOV       B,#0x6
   \   00013C   E9           MOV       A,R1
   \   00013D   A4           MUL       AB
   \   00013E   2A           ADD       A,R2
   \   00013F   F9           MOV       R1,A
   \   000140   E5..         MOV       A,?V12
   \   000142   28           ADD       A,R0
   \   000143   F582         MOV       DPL,A
   \   000145   E5..         MOV       A,?V13
   \   000147   39           ADDC      A,R1
   \   000148   F583         MOV       DPH,A
   \   00014A   A3           INC       DPTR
   \   00014B   8582..       MOV       ?V0,DPL
   \   00014E   8583..       MOV       ?V1,DPH
   3675          
   3676                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   000151   8E82         MOV       DPL,R6
   \   000153   8F83         MOV       DPH,R7
   \   000155   E0           MOVX      A,@DPTR
   \   000156   FA           MOV       R2,A
   \   000157   7B00         MOV       R3,#0x0
   \   000159   8E82         MOV       DPL,R6
   \   00015B   8F83         MOV       DPH,R7
   \   00015D   A3           INC       DPTR
   \   00015E   E0           MOVX      A,@DPTR
   \   00015F   F8           MOV       R0,A
   \   000160   7900         MOV       R1,#0x0
   \   000162   E4           CLR       A
   \   000163   C8           XCH       A,R0
   \   000164   F9           MOV       R1,A
   \   000165   EA           MOV       A,R2
   \   000166   28           ADD       A,R0
   \   000167   F8           MOV       R0,A
   \   000168   EB           MOV       A,R3
   \   000169   39           ADDC      A,R1
   \   00016A   F9           MOV       R1,A
   \   00016B   85..82       MOV       DPL,?V0
   \   00016E   85..83       MOV       DPH,?V1
   \   000171   E8           MOV       A,R0
   \   000172   F0           MOVX      @DPTR,A
   \   000173   A3           INC       DPTR
   \   000174   E9           MOV       A,R1
   \   000175   F0           MOVX      @DPTR,A
   3677                pBuf += 2;
   \   000176   EE           MOV       A,R6
   \   000177   2402         ADD       A,#0x2
   \   000179   FE           MOV       R6,A
   \   00017A   5001         JNC       ??zclParseInReadRspCmd_6
   \   00017C   0F           INC       R7
   3678          
   3679                statusRec->status = *pBuf++;
   \                     ??zclParseInReadRspCmd_6:
   \   00017D   8E82         MOV       DPL,R6
   \   00017F   8F83         MOV       DPH,R7
   \   000181   E0           MOVX      A,@DPTR
   \   000182   C0E0         PUSH      A
   \   000184   85..82       MOV       DPL,?V0
   \   000187   85..83       MOV       DPH,?V1
   \   00018A   A3           INC       DPTR
   \   00018B   A3           INC       DPTR
   \   00018C   D0E0         POP       A
   \   00018E   F0           MOVX      @DPTR,A
   \   00018F   8E82         MOV       DPL,R6
   \   000191   8F83         MOV       DPH,R7
   \   000193   A3           INC       DPTR
   \   000194   AE82         MOV       R6,DPL
   \   000196   AF83         MOV       R7,DPH
   3680                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   000198   85..82       MOV       DPL,?V0
   \   00019B   85..83       MOV       DPH,?V1
   \   00019E   A3           INC       DPTR
   \   00019F   A3           INC       DPTR
   \   0001A0   E0           MOVX      A,@DPTR
   \   0001A1   6003         JZ        $+5
   \   0001A3   02....       LJMP      ??zclParseInReadRspCmd_7 & 0xFFFF
   3681                {
   3682                  statusRec->dataType = *pBuf++;
   \   0001A6   8E82         MOV       DPL,R6
   \   0001A8   8F83         MOV       DPH,R7
   \   0001AA   E0           MOVX      A,@DPTR
   \   0001AB   C0E0         PUSH      A
   \   0001AD   85..82       MOV       DPL,?V0
   \   0001B0   85..83       MOV       DPH,?V1
   \   0001B3   A3           INC       DPTR
   \   0001B4   A3           INC       DPTR
   \   0001B5   A3           INC       DPTR
   \   0001B6   D0E0         POP       A
   \   0001B8   F0           MOVX      @DPTR,A
   \   0001B9   8E82         MOV       DPL,R6
   \   0001BB   8F83         MOV       DPH,R7
   \   0001BD   A3           INC       DPTR
   \   0001BE   AE82         MOV       R6,DPL
   \   0001C0   AF83         MOV       R7,DPH
   3683          
   3684                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   0001C2                ; Setup parameters for call to function zclGetAttrDataLength
   \   0001C2   EE           MOV       A,R6
   \   0001C3   FA           MOV       R2,A
   \   0001C4   EF           MOV       A,R7
   \   0001C5   FB           MOV       R3,A
   \   0001C6   85..82       MOV       DPL,?V0
   \   0001C9   85..83       MOV       DPH,?V1
   \   0001CC   A3           INC       DPTR
   \   0001CD   A3           INC       DPTR
   \   0001CE   A3           INC       DPTR
   \   0001CF   E0           MOVX      A,@DPTR
   \   0001D0   F9           MOV       R1,A
   \   0001D1   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0001D4   8A..         MOV       ?V4,R2
   \   0001D6   8B..         MOV       ?V5,R3
   \   0001D8   85....       MOV       ?V2,?V4
   \   0001DB   85....       MOV       ?V3,?V5
   3685                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0001DE                ; Setup parameters for call to function osal_memcpy
   \   0001DE   8E..         MOV       ?V4,R6
   \   0001E0   8F..         MOV       ?V5,R7
   \   0001E2   75..00       MOV       ?V6,#0x0
   \   0001E5   78..         MOV       R0,#?V4
   \   0001E7   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0001EA   AC..         MOV       R4,?V2
   \   0001EC   AD..         MOV       R5,?V3
   \   0001EE   AA..         MOV       R2,?V8
   \   0001F0   AB..         MOV       R3,?V9
   \   0001F2   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0001F5   7403         MOV       A,#0x3
   \   0001F7   12....       LCALL     ?DEALLOC_XSTACK8
   3686                  statusRec->data = dataPtr;
   \   0001FA   85..82       MOV       DPL,?V0
   \   0001FD   85..83       MOV       DPH,?V1
   \   000200   A3           INC       DPTR
   \   000201   A3           INC       DPTR
   \   000202   A3           INC       DPTR
   \   000203   A3           INC       DPTR
   \   000204   E5..         MOV       A,?V8
   \   000206   F0           MOVX      @DPTR,A
   \   000207   A3           INC       DPTR
   \   000208   E5..         MOV       A,?V9
   \   00020A   F0           MOVX      @DPTR,A
   3687          
   3688                  pBuf += attrDataLen; // move pass attribute data
   \   00020B   EE           MOV       A,R6
   \   00020C   25..         ADD       A,?V2
   \   00020E   FE           MOV       R6,A
   \   00020F   EF           MOV       A,R7
   \   000210   35..         ADDC      A,?V3
   \   000212   FF           MOV       R7,A
   3689          
   3690                  // advance attribute data pointer
   3691                  if ( PADDING_NEEDED( attrDataLen ) )
   \   000213   E5..         MOV       A,?V2
   \   000215   A2E0         MOV       C,0xE0 /* A   */.0
   \   000217   5008         JNC       ??zclParseInReadRspCmd_8
   3692                  {
   3693                    attrDataLen++;
   \   000219   05..         INC       ?V2
   \   00021B   E5..         MOV       A,?V2
   \   00021D   7002         JNZ       ??zclParseInReadRspCmd_8
   \   00021F   05..         INC       ?V3
   3694                  }
   3695          
   3696                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_8:
   \   000221   E5..         MOV       A,?V8
   \   000223   25..         ADD       A,?V2
   \   000225   F5..         MOV       ?V8,A
   \   000227   E5..         MOV       A,?V9
   \   000229   35..         ADDC      A,?V3
   \   00022B   F5..         MOV       ?V9,A
   3697                }
   3698              }
   \                     ??zclParseInReadRspCmd_7:
   \   00022D   05..         INC       ?V10
   \   00022F   02....       LJMP      ??zclParseInReadRspCmd_5 & 0xFFFF
   3699            }
   3700          
   3701            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   000232   AA..         MOV       R2,?V12
   \   000234   AB..         MOV       R3,?V13
   \   000236   7402         MOV       A,#0x2
   \   000238   12....       LCALL     ?DEALLOC_XSTACK8
   \   00023B   7F10         MOV       R7,#0x10
   \   00023D   02....       LJMP      ?BANKED_LEAVE_XDATA
   3702          }
   3703          #endif // ZCL_READ
   3704          
   3705          #ifdef ZCL_WRITE
   3706          /*********************************************************************
   3707           * @fn      zclParseInWriteCmd
   3708           *
   3709           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3710           *          Response Commands
   3711           *
   3712           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3713           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3714           *
   3715           * @param   pCmd - pointer to incoming data to parse
   3716           *
   3717           * @return  pointer to the parsed command structure
   3718           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3719          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3720          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V14,R2
   \   00000C   8B..         MOV       ?V15,R3
   3721            zclWriteCmd_t *writeCmd;
   3722            uint8 *pBuf = pCmd->pData;
   \   00000E   85..82       MOV       DPL,?V14
   \   000011   85..83       MOV       DPH,?V15
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   FE           MOV       R6,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   FF           MOV       R7,A
   3723            uint16 attrDataLen;
   3724            uint8 *dataPtr;
   3725            uint8 numAttr = 0;
   \   00001C   75..00       MOV       ?V8,#0x0
   3726            uint8 hdrLen;
   3727            uint16 dataLen = 0;
   \   00001F   85..82       MOV       DPL,?XSP + 0
   \   000022   85..83       MOV       DPH,?XSP + 1
   \   000025   7400         MOV       A,#0x0
   \   000027   F0           MOVX      @DPTR,A
   \   000028   A3           INC       DPTR
   \   000029   7400         MOV       A,#0x0
   \   00002B   F0           MOVX      @DPTR,A
   3728          
   3729            // find out the number of attributes and the length of attribute data
   3730            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInWriteCmd_0:
   \   00002C   85..82       MOV       DPL,?V14
   \   00002F   85..83       MOV       DPH,?V15
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   F8           MOV       R0,A
   \   000035   A3           INC       DPTR
   \   000036   E0           MOVX      A,@DPTR
   \   000037   F9           MOV       R1,A
   \   000038   85..82       MOV       DPL,?V14
   \   00003B   85..83       MOV       DPH,?V15
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   28           ADD       A,R0
   \   000043   F8           MOV       R0,A
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   39           ADDC      A,R1
   \   000047   F9           MOV       R1,A
   \   000048   C3           CLR       C
   \   000049   EE           MOV       A,R6
   \   00004A   98           SUBB      A,R0
   \   00004B   EF           MOV       A,R7
   \   00004C   99           SUBB      A,R1
   \   00004D   5053         JNC       ??zclParseInWriteCmd_1
   3731            {
   3732              uint8 dataType;
   3733          
   3734              numAttr++;
   \   00004F   05..         INC       ?V8
   3735              pBuf += 2; // move pass attribute id
   \   000051   EE           MOV       A,R6
   \   000052   2402         ADD       A,#0x2
   \   000054   FE           MOV       R6,A
   \   000055   5001         JNC       ??zclParseInWriteCmd_2
   \   000057   0F           INC       R7
   3736          
   3737              dataType = *pBuf++;
   \                     ??zclParseInWriteCmd_2:
   \   000058   8E82         MOV       DPL,R6
   \   00005A   8F83         MOV       DPH,R7
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F5..         MOV       ?V6,A
   \   00005F   8E82         MOV       DPL,R6
   \   000061   8F83         MOV       DPH,R7
   \   000063   A3           INC       DPTR
   \   000064   AE82         MOV       R6,DPL
   \   000066   AF83         MOV       R7,DPH
   3738          
   3739              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000068                ; Setup parameters for call to function zclGetAttrDataLength
   \   000068   EE           MOV       A,R6
   \   000069   FA           MOV       R2,A
   \   00006A   EF           MOV       A,R7
   \   00006B   FB           MOV       R3,A
   \   00006C   A9..         MOV       R1,?V6
   \   00006E   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000071   8A..         MOV       ?V4,R2
   \   000073   8B..         MOV       ?V5,R3
   \   000075   85....       MOV       ?V0,?V4
   \   000078   85....       MOV       ?V1,?V5
   3740              pBuf += attrDataLen; // move pass attribute data
   \   00007B   EE           MOV       A,R6
   \   00007C   25..         ADD       A,?V0
   \   00007E   FE           MOV       R6,A
   \   00007F   EF           MOV       A,R7
   \   000080   35..         ADDC      A,?V1
   \   000082   FF           MOV       R7,A
   3741          
   3742              // add padding if needed
   3743              if ( PADDING_NEEDED( attrDataLen ) )
   \   000083   E5..         MOV       A,?V0
   \   000085   A2E0         MOV       C,0xE0 /* A   */.0
   \   000087   5008         JNC       ??zclParseInWriteCmd_3
   3744              {
   3745                attrDataLen++;
   \   000089   05..         INC       ?V0
   \   00008B   E5..         MOV       A,?V0
   \   00008D   7002         JNZ       ??zclParseInWriteCmd_3
   \   00008F   05..         INC       ?V1
   3746              }
   3747          
   3748              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_3:
   \   000091   85..82       MOV       DPL,?XSP + 0
   \   000094   85..83       MOV       DPH,?XSP + 1
   \   000097   E0           MOVX      A,@DPTR
   \   000098   25..         ADD       A,?V0
   \   00009A   F0           MOVX      @DPTR,A
   \   00009B   A3           INC       DPTR
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   35..         ADDC      A,?V1
   \   00009F   F0           MOVX      @DPTR,A
   \   0000A0   808A         SJMP      ??zclParseInWriteCmd_0
   3749            }
   3750          
   3751            // calculate the length of the response header
   3752            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \                     ??zclParseInWriteCmd_1:
   \   0000A2   75F005       MOV       B,#0x5
   \   0000A5   E5..         MOV       A,?V8
   \   0000A7   A4           MUL       AB
   \   0000A8   2401         ADD       A,#0x1
   \   0000AA   F5..         MOV       ?V9,A
   3753          
   3754            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   0000AC                ; Setup parameters for call to function osal_mem_alloc
   \   0000AC   E5..         MOV       A,?V9
   \   0000AE   F8           MOV       R0,A
   \   0000AF   7900         MOV       R1,#0x0
   \   0000B1   85..82       MOV       DPL,?XSP + 0
   \   0000B4   85..83       MOV       DPH,?XSP + 1
   \   0000B7   E0           MOVX      A,@DPTR
   \   0000B8   28           ADD       A,R0
   \   0000B9   FA           MOV       R2,A
   \   0000BA   A3           INC       DPTR
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   39           ADDC      A,R1
   \   0000BD   FB           MOV       R3,A
   \   0000BE   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000C1   8A..         MOV       ?V4,R2
   \   0000C3   8B..         MOV       ?V5,R3
   \   0000C5   85....       MOV       ?V10,?V4
   \   0000C8   85....       MOV       ?V11,?V5
   3755            if ( writeCmd != NULL )
   \   0000CB   E5..         MOV       A,?V10
   \   0000CD   45..         ORL       A,?V11
   \   0000CF   7003         JNZ       $+5
   \   0000D1   02....       LJMP      ??zclParseInWriteCmd_4 & 0xFFFF
   3756            {
   3757              uint8 i;
   3758              pBuf = pCmd->pData;
   \   0000D4   85..82       MOV       DPL,?V14
   \   0000D7   85..83       MOV       DPH,?V15
   \   0000DA   A3           INC       DPTR
   \   0000DB   A3           INC       DPTR
   \   0000DC   A3           INC       DPTR
   \   0000DD   E0           MOVX      A,@DPTR
   \   0000DE   F8           MOV       R0,A
   \   0000DF   A3           INC       DPTR
   \   0000E0   E0           MOVX      A,@DPTR
   \   0000E1   F9           MOV       R1,A
   \   0000E2   E8           MOV       A,R0
   \   0000E3   FE           MOV       R6,A
   \   0000E4   E9           MOV       A,R1
   \   0000E5   FF           MOV       R7,A
   3759              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   \   0000E6   E5..         MOV       A,?V9
   \   0000E8   F8           MOV       R0,A
   \   0000E9   7900         MOV       R1,#0x0
   \   0000EB   E5..         MOV       A,?V10
   \   0000ED   28           ADD       A,R0
   \   0000EE   F8           MOV       R0,A
   \   0000EF   E5..         MOV       A,?V11
   \   0000F1   39           ADDC      A,R1
   \   0000F2   F9           MOV       R1,A
   \   0000F3   88..         MOV       ?V2,R0
   \   0000F5   89..         MOV       ?V3,R1
   3760          
   3761              writeCmd->numAttr = numAttr;
   \   0000F7   E5..         MOV       A,?V8
   \   0000F9   C0E0         PUSH      A
   \   0000FB   85..82       MOV       DPL,?V10
   \   0000FE   85..83       MOV       DPH,?V11
   \   000101   D0E0         POP       A
   \   000103   F0           MOVX      @DPTR,A
   3762              for ( i = 0; i < numAttr; i++ )
   \   000104   75..00       MOV       ?V7,#0x0
   \                     ??zclParseInWriteCmd_5:
   \   000107   E5..         MOV       A,?V7
   \   000109   C3           CLR       C
   \   00010A   95..         SUBB      A,?V8
   \   00010C   4003         JC        $+5
   \   00010E   02....       LJMP      ??zclParseInWriteCmd_4 & 0xFFFF
   3763              {
   3764                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   000111   E5..         MOV       A,?V7
   \   000113   F8           MOV       R0,A
   \   000114   7900         MOV       R1,#0x0
   \   000116   E8           MOV       A,R0
   \   000117   75F005       MOV       B,#0x5
   \   00011A   A4           MUL       AB
   \   00011B   C8           XCH       A,R0
   \   00011C   AAF0         MOV       R2,B
   \   00011E   75F000       MOV       B,#0x0
   \   000121   A4           MUL       AB
   \   000122   2A           ADD       A,R2
   \   000123   FA           MOV       R2,A
   \   000124   75F005       MOV       B,#0x5
   \   000127   E9           MOV       A,R1
   \   000128   A4           MUL       AB
   \   000129   2A           ADD       A,R2
   \   00012A   F9           MOV       R1,A
   \   00012B   E5..         MOV       A,?V10
   \   00012D   28           ADD       A,R0
   \   00012E   F582         MOV       DPL,A
   \   000130   E5..         MOV       A,?V11
   \   000132   39           ADDC      A,R1
   \   000133   F583         MOV       DPH,A
   \   000135   A3           INC       DPTR
   \   000136   8582..       MOV       ?V12,DPL
   \   000139   8583..       MOV       ?V13,DPH
   3765          
   3766                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00013C   8E82         MOV       DPL,R6
   \   00013E   8F83         MOV       DPH,R7
   \   000140   E0           MOVX      A,@DPTR
   \   000141   FA           MOV       R2,A
   \   000142   7B00         MOV       R3,#0x0
   \   000144   8E82         MOV       DPL,R6
   \   000146   8F83         MOV       DPH,R7
   \   000148   A3           INC       DPTR
   \   000149   E0           MOVX      A,@DPTR
   \   00014A   F8           MOV       R0,A
   \   00014B   7900         MOV       R1,#0x0
   \   00014D   E4           CLR       A
   \   00014E   C8           XCH       A,R0
   \   00014F   F9           MOV       R1,A
   \   000150   EA           MOV       A,R2
   \   000151   28           ADD       A,R0
   \   000152   F8           MOV       R0,A
   \   000153   EB           MOV       A,R3
   \   000154   39           ADDC      A,R1
   \   000155   F9           MOV       R1,A
   \   000156   85..82       MOV       DPL,?V12
   \   000159   85..83       MOV       DPH,?V13
   \   00015C   E8           MOV       A,R0
   \   00015D   F0           MOVX      @DPTR,A
   \   00015E   A3           INC       DPTR
   \   00015F   E9           MOV       A,R1
   \   000160   F0           MOVX      @DPTR,A
   3767                pBuf += 2;
   \   000161   EE           MOV       A,R6
   \   000162   2402         ADD       A,#0x2
   \   000164   FE           MOV       R6,A
   \   000165   5001         JNC       ??zclParseInWriteCmd_6
   \   000167   0F           INC       R7
   3768                statusRec->dataType = *pBuf++;
   \                     ??zclParseInWriteCmd_6:
   \   000168   8E82         MOV       DPL,R6
   \   00016A   8F83         MOV       DPH,R7
   \   00016C   E0           MOVX      A,@DPTR
   \   00016D   C0E0         PUSH      A
   \   00016F   85..82       MOV       DPL,?V12
   \   000172   85..83       MOV       DPH,?V13
   \   000175   A3           INC       DPTR
   \   000176   A3           INC       DPTR
   \   000177   D0E0         POP       A
   \   000179   F0           MOVX      @DPTR,A
   \   00017A   8E82         MOV       DPL,R6
   \   00017C   8F83         MOV       DPH,R7
   \   00017E   A3           INC       DPTR
   \   00017F   AE82         MOV       R6,DPL
   \   000181   AF83         MOV       R7,DPH
   3769          
   3770                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   000183                ; Setup parameters for call to function zclGetAttrDataLength
   \   000183   EE           MOV       A,R6
   \   000184   FA           MOV       R2,A
   \   000185   EF           MOV       A,R7
   \   000186   FB           MOV       R3,A
   \   000187   85..82       MOV       DPL,?V12
   \   00018A   85..83       MOV       DPH,?V13
   \   00018D   A3           INC       DPTR
   \   00018E   A3           INC       DPTR
   \   00018F   E0           MOVX      A,@DPTR
   \   000190   F9           MOV       R1,A
   \   000191   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000194   8A..         MOV       ?V4,R2
   \   000196   8B..         MOV       ?V5,R3
   \   000198   85....       MOV       ?V0,?V4
   \   00019B   85....       MOV       ?V1,?V5
   3771                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   00019E                ; Setup parameters for call to function osal_memcpy
   \   00019E   8E..         MOV       ?V4,R6
   \   0001A0   8F..         MOV       ?V5,R7
   \   0001A2   75..00       MOV       ?V6,#0x0
   \   0001A5   78..         MOV       R0,#?V4
   \   0001A7   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0001AA   AC..         MOV       R4,?V0
   \   0001AC   AD..         MOV       R5,?V1
   \   0001AE   AA..         MOV       R2,?V2
   \   0001B0   AB..         MOV       R3,?V3
   \   0001B2   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0001B5   7403         MOV       A,#0x3
   \   0001B7   12....       LCALL     ?DEALLOC_XSTACK8
   3772                statusRec->attrData = dataPtr;
   \   0001BA   85..82       MOV       DPL,?V12
   \   0001BD   85..83       MOV       DPH,?V13
   \   0001C0   A3           INC       DPTR
   \   0001C1   A3           INC       DPTR
   \   0001C2   A3           INC       DPTR
   \   0001C3   E5..         MOV       A,?V2
   \   0001C5   F0           MOVX      @DPTR,A
   \   0001C6   A3           INC       DPTR
   \   0001C7   E5..         MOV       A,?V3
   \   0001C9   F0           MOVX      @DPTR,A
   3773          
   3774                pBuf += attrDataLen; // move pass attribute data
   \   0001CA   EE           MOV       A,R6
   \   0001CB   25..         ADD       A,?V0
   \   0001CD   FE           MOV       R6,A
   \   0001CE   EF           MOV       A,R7
   \   0001CF   35..         ADDC      A,?V1
   \   0001D1   FF           MOV       R7,A
   3775          
   3776                // advance attribute data pointer
   3777                if ( PADDING_NEEDED( attrDataLen ) )
   \   0001D2   E5..         MOV       A,?V0
   \   0001D4   A2E0         MOV       C,0xE0 /* A   */.0
   \   0001D6   5008         JNC       ??zclParseInWriteCmd_7
   3778                {
   3779                  attrDataLen++;
   \   0001D8   05..         INC       ?V0
   \   0001DA   E5..         MOV       A,?V0
   \   0001DC   7002         JNZ       ??zclParseInWriteCmd_7
   \   0001DE   05..         INC       ?V1
   3780                }
   3781          
   3782                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_7:
   \   0001E0   E5..         MOV       A,?V2
   \   0001E2   25..         ADD       A,?V0
   \   0001E4   F5..         MOV       ?V2,A
   \   0001E6   E5..         MOV       A,?V3
   \   0001E8   35..         ADDC      A,?V1
   \   0001EA   F5..         MOV       ?V3,A
   3783              }
   \   0001EC   05..         INC       ?V7
   \   0001EE   02....       LJMP      ??zclParseInWriteCmd_5 & 0xFFFF
   3784            }
   3785          
   3786            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_4:
   \   0001F1   AA..         MOV       R2,?V10
   \   0001F3   AB..         MOV       R3,?V11
   \   0001F5   7402         MOV       A,#0x2
   \   0001F7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001FA   7F10         MOV       R7,#0x10
   \   0001FC   02....       LJMP      ?BANKED_LEAVE_XDATA
   3787          }
   3788          
   3789          /*********************************************************************
   3790           * @fn      zclParseInWriteRspCmd
   3791           *
   3792           * @brief   Parse the "Profile" Write Response Commands
   3793           *
   3794           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3795           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3796           *
   3797           * @param   pCmd - pointer to incoming data to parse
   3798           *
   3799           * @return  pointer to the parsed command structure
   3800           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3801          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3802          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   3803            zclWriteRspCmd_t *writeRspCmd;
   3804            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV       DPL,?V2
   \   00000C   85..83       MOV       DPH,?V3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   F5..         MOV       ?V0,A
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F5..         MOV       ?V1,A
   3805            uint8 i = 0;
   \   000019   75..00       MOV       ?V4,#0x0
   3806          
   3807            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   00001C                ; Setup parameters for call to function osal_mem_alloc
   \   00001C   85..82       MOV       DPL,?V2
   \   00001F   85..83       MOV       DPH,?V3
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   2401         ADD       A,#0x1
   \   000026   FA           MOV       R2,A
   \   000027   A3           INC       DPTR
   \   000028   E0           MOVX      A,@DPTR
   \   000029   3400         ADDC      A,#0x0
   \   00002B   FB           MOV       R3,A
   \   00002C   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002F   8A..         MOV       ?V6,R2
   \   000031   8B..         MOV       ?V7,R3
   \   000033   AE..         MOV       R6,?V6
   \   000035   AF..         MOV       R7,?V7
   3808            if ( writeRspCmd != NULL )
   \   000037   EE           MOV       A,R6
   \   000038   4F           ORL       A,R7
   \   000039   7003         JNZ       $+5
   \   00003B   02....       LJMP      ??zclParseInWriteRspCmd_0 & 0xFFFF
   3809            {
   3810              if ( pCmd->dataLen == 1 )
   \   00003E   85..82       MOV       DPL,?V2
   \   000041   85..83       MOV       DPH,?V3
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   6401         XRL       A,#0x1
   \   000048   7004         JNZ       ??zclParseInWriteRspCmd_1
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   6400         XRL       A,#0x0
   \                     ??zclParseInWriteRspCmd_1:
   \   00004E   7034         JNZ       ??zclParseInWriteRspCmd_2
   3811              {
   3812                // special case when all writes were successfull
   3813                writeRspCmd->attrList[i++].status = *pBuf;
   \   000050   85..82       MOV       DPL,?V0
   \   000053   85..83       MOV       DPH,?V1
   \   000056   E0           MOVX      A,@DPTR
   \   000057   C0E0         PUSH      A
   \   000059   E5..         MOV       A,?V4
   \   00005B   F8           MOV       R0,A
   \   00005C   7900         MOV       R1,#0x0
   \   00005E   E8           MOV       A,R0
   \   00005F   75F003       MOV       B,#0x3
   \   000062   A4           MUL       AB
   \   000063   C8           XCH       A,R0
   \   000064   AAF0         MOV       R2,B
   \   000066   75F000       MOV       B,#0x0
   \   000069   A4           MUL       AB
   \   00006A   2A           ADD       A,R2
   \   00006B   FA           MOV       R2,A
   \   00006C   75F003       MOV       B,#0x3
   \   00006F   E9           MOV       A,R1
   \   000070   A4           MUL       AB
   \   000071   2A           ADD       A,R2
   \   000072   F9           MOV       R1,A
   \   000073   EE           MOV       A,R6
   \   000074   28           ADD       A,R0
   \   000075   F582         MOV       DPL,A
   \   000077   EF           MOV       A,R7
   \   000078   39           ADDC      A,R1
   \   000079   F583         MOV       DPH,A
   \   00007B   A3           INC       DPTR
   \   00007C   D0E0         POP       A
   \   00007E   F0           MOVX      @DPTR,A
   \   00007F   05..         INC       ?V4
   \   000081   02....       LJMP      ??zclParseInWriteRspCmd_3 & 0xFFFF
   3814              }
   3815              else
   3816              {
   3817                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInWriteRspCmd_2:
   \   000084   85..82       MOV       DPL,?V2
   \   000087   85..83       MOV       DPH,?V3
   \   00008A   A3           INC       DPTR
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   F8           MOV       R0,A
   \   00008D   A3           INC       DPTR
   \   00008E   E0           MOVX      A,@DPTR
   \   00008F   F9           MOV       R1,A
   \   000090   85..82       MOV       DPL,?V2
   \   000093   85..83       MOV       DPH,?V3
   \   000096   A3           INC       DPTR
   \   000097   A3           INC       DPTR
   \   000098   A3           INC       DPTR
   \   000099   E0           MOVX      A,@DPTR
   \   00009A   28           ADD       A,R0
   \   00009B   F8           MOV       R0,A
   \   00009C   A3           INC       DPTR
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   39           ADDC      A,R1
   \   00009F   F9           MOV       R1,A
   \   0000A0   C3           CLR       C
   \   0000A1   E5..         MOV       A,?V0
   \   0000A3   98           SUBB      A,R0
   \   0000A4   E5..         MOV       A,?V1
   \   0000A6   99           SUBB      A,R1
   \   0000A7   4003         JC        $+5
   \   0000A9   02....       LJMP      ??zclParseInWriteRspCmd_3 & 0xFFFF
   3818                {
   3819                  writeRspCmd->attrList[i].status = *pBuf++;
   \   0000AC   85..82       MOV       DPL,?V0
   \   0000AF   85..83       MOV       DPH,?V1
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   C0E0         PUSH      A
   \   0000B5   E5..         MOV       A,?V4
   \   0000B7   F8           MOV       R0,A
   \   0000B8   7900         MOV       R1,#0x0
   \   0000BA   E8           MOV       A,R0
   \   0000BB   75F003       MOV       B,#0x3
   \   0000BE   A4           MUL       AB
   \   0000BF   C8           XCH       A,R0
   \   0000C0   AAF0         MOV       R2,B
   \   0000C2   75F000       MOV       B,#0x0
   \   0000C5   A4           MUL       AB
   \   0000C6   2A           ADD       A,R2
   \   0000C7   FA           MOV       R2,A
   \   0000C8   75F003       MOV       B,#0x3
   \   0000CB   E9           MOV       A,R1
   \   0000CC   A4           MUL       AB
   \   0000CD   2A           ADD       A,R2
   \   0000CE   F9           MOV       R1,A
   \   0000CF   EE           MOV       A,R6
   \   0000D0   28           ADD       A,R0
   \   0000D1   F582         MOV       DPL,A
   \   0000D3   EF           MOV       A,R7
   \   0000D4   39           ADDC      A,R1
   \   0000D5   F583         MOV       DPH,A
   \   0000D7   A3           INC       DPTR
   \   0000D8   D0E0         POP       A
   \   0000DA   F0           MOVX      @DPTR,A
   \   0000DB   85..82       MOV       DPL,?V0
   \   0000DE   85..83       MOV       DPH,?V1
   \   0000E1   A3           INC       DPTR
   \   0000E2   8582..       MOV       ?V0,DPL
   \   0000E5   8583..       MOV       ?V1,DPH
   3820                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   0000E8   85..82       MOV       DPL,?V0
   \   0000EB   85..83       MOV       DPH,?V1
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   FA           MOV       R2,A
   \   0000F0   7B00         MOV       R3,#0x0
   \   0000F2   85..82       MOV       DPL,?V0
   \   0000F5   85..83       MOV       DPH,?V1
   \   0000F8   A3           INC       DPTR
   \   0000F9   E0           MOVX      A,@DPTR
   \   0000FA   F8           MOV       R0,A
   \   0000FB   7900         MOV       R1,#0x0
   \   0000FD   E4           CLR       A
   \   0000FE   C8           XCH       A,R0
   \   0000FF   F9           MOV       R1,A
   \   000100   EA           MOV       A,R2
   \   000101   28           ADD       A,R0
   \   000102   FA           MOV       R2,A
   \   000103   EB           MOV       A,R3
   \   000104   39           ADDC      A,R1
   \   000105   FB           MOV       R3,A
   \   000106   E5..         MOV       A,?V4
   \   000108   F8           MOV       R0,A
   \   000109   7900         MOV       R1,#0x0
   \   00010B   E8           MOV       A,R0
   \   00010C   75F003       MOV       B,#0x3
   \   00010F   A4           MUL       AB
   \   000110   C8           XCH       A,R0
   \   000111   ACF0         MOV       R4,B
   \   000113   75F000       MOV       B,#0x0
   \   000116   A4           MUL       AB
   \   000117   2C           ADD       A,R4
   \   000118   FC           MOV       R4,A
   \   000119   75F003       MOV       B,#0x3
   \   00011C   E9           MOV       A,R1
   \   00011D   A4           MUL       AB
   \   00011E   2C           ADD       A,R4
   \   00011F   F9           MOV       R1,A
   \   000120   EE           MOV       A,R6
   \   000121   28           ADD       A,R0
   \   000122   F582         MOV       DPL,A
   \   000124   EF           MOV       A,R7
   \   000125   39           ADDC      A,R1
   \   000126   F583         MOV       DPH,A
   \   000128   A3           INC       DPTR
   \   000129   A3           INC       DPTR
   \   00012A   EA           MOV       A,R2
   \   00012B   F0           MOVX      @DPTR,A
   \   00012C   A3           INC       DPTR
   \   00012D   EB           MOV       A,R3
   \   00012E   F0           MOVX      @DPTR,A
   \   00012F   05..         INC       ?V4
   3821                  pBuf += 2;
   \   000131   E5..         MOV       A,?V0
   \   000133   2402         ADD       A,#0x2
   \   000135   F5..         MOV       ?V0,A
   \   000137   5002         JNC       ??zclParseInWriteRspCmd_4
   \   000139   05..         INC       ?V1
   \                     ??zclParseInWriteRspCmd_4:
   \   00013B   02....       LJMP      ??zclParseInWriteRspCmd_2 & 0xFFFF
   3822                }
   3823              }
   3824          
   3825              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   00013E   E5..         MOV       A,?V4
   \   000140   C0E0         PUSH      A
   \   000142   8E82         MOV       DPL,R6
   \   000144   8F83         MOV       DPH,R7
   \   000146   D0E0         POP       A
   \   000148   F0           MOVX      @DPTR,A
   3826            }
   3827          
   3828            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   000149   EE           MOV       A,R6
   \   00014A   FA           MOV       R2,A
   \   00014B   EF           MOV       A,R7
   \   00014C   FB           MOV       R3,A
   \   00014D   7F08         MOV       R7,#0x8
   \   00014F   02....       LJMP      ?BANKED_LEAVE_XDATA
   3829          }
   3830          #endif // ZCL_WRITE
   3831          
   3832          #ifdef ZCL_REPORTING_DEVICE
   3833          /*********************************************************************
   3834           * @fn      zclParseInConfigReportCmd
   3835           *
   3836           * @brief   Parse the "Profile" Configure Reporting Command
   3837           *
   3838           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3839           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3840           *
   3841           * @param   pCmd - pointer to incoming data to parse
   3842           *
   3843           * @return  pointer to the parsed command structure
   3844           */
   3845          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   3846          {
   3847            zclCfgReportCmd_t *cfgReportCmd;
   3848            uint8 *pBuf = pCmd->pData;
   3849            uint8 *dataPtr;
   3850            uint8 numAttr = 0;
   3851            uint8 dataType;
   3852            uint8 hdrLen;
   3853            uint16 dataLen = 0;
   3854            uint8 reportChangeLen; // length of Reportable Change field
   3855          
   3856            // Calculate the length of the Request command
   3857            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3858            {
   3859              uint8 direction;
   3860          
   3861              numAttr++;
   3862              direction = *pBuf++;
   3863              pBuf += 2; // move pass the attribute ID
   3864          
   3865              // Is there a Reportable Change field?
   3866              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3867              {
   3868                dataType = *pBuf++;
   3869                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3870          
   3871                // For attributes of 'discrete' data types this field is omitted
   3872                if ( zclAnalogDataType( dataType ) )
   3873                {
   3874                  reportChangeLen = zclGetDataTypeLength( dataType );
   3875                  pBuf += reportChangeLen;
   3876          
   3877                  // add padding if needed
   3878                  if ( PADDING_NEEDED( reportChangeLen ) )
   3879                  {
   3880                    reportChangeLen++;
   3881                  }
   3882          
   3883                  dataLen += reportChangeLen;
   3884                }
   3885                else
   3886                {
   3887                  pBuf++; // move past reportable change field
   3888                }
   3889              }
   3890              else
   3891              {
   3892                pBuf += 2; // move pass the Timeout Period
   3893              }
   3894            } // while loop
   3895          
   3896            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   3897          
   3898            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3899            if ( cfgReportCmd != NULL )
   3900            {
   3901              uint8 i;
   3902              pBuf = pCmd->pData;
   3903              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   3904          
   3905              cfgReportCmd->numAttr = numAttr;
   3906              for ( i = 0; i < numAttr; i++ )
   3907              {
   3908                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3909          
   3910                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3911          
   3912                reportRec->direction = *pBuf++;
   3913                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3914                pBuf += 2;
   3915                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3916                {
   3917                  // Attribute to be reported
   3918                  reportRec->dataType = *pBuf++;
   3919                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3920                  pBuf += 2;
   3921                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3922                  pBuf += 2;
   3923          
   3924                  // For attributes of 'discrete' data types this field is omitted
   3925                  if ( zclAnalogDataType( reportRec->dataType ) )
   3926                  {
   3927                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3928                    reportRec->reportableChange = dataPtr;
   3929          
   3930                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3931                    pBuf += reportChangeLen;
   3932          
   3933                    // advance attribute data pointer
   3934                    if ( PADDING_NEEDED( reportChangeLen ) )
   3935                    {
   3936                      reportChangeLen++;
   3937                    }
   3938          
   3939                    dataPtr += reportChangeLen;
   3940                  }
   3941                }
   3942                else
   3943                {
   3944                  // Attribute reports to be received
   3945                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3946                  pBuf += 2;
   3947                }
   3948              } // while loop
   3949            }
   3950          
   3951            return ( (void *)cfgReportCmd );
   3952          }
   3953          #endif
   3954          
   3955          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   3956          /*********************************************************************
   3957           * @fn      zclParseInConfigReportRspCmd
   3958           *
   3959           * @brief   Parse the "Profile" Configure Reporting Response Command
   3960           *
   3961           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3962           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3963           *
   3964           * @param   pCmd - pointer to incoming data to parse
   3965           *
   3966           * @return  pointer to the parsed command structure
   3967           */
   3968          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   3969          {
   3970            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3971            uint8 *pBuf = pCmd->pData;
   3972            uint8 numAttr;
   3973          
   3974            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   3975          
   3976            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3977                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   3978            if ( cfgReportRspCmd != NULL )
   3979            {
   3980              uint8 i;
   3981              cfgReportRspCmd->numAttr = numAttr;
   3982              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   3983              {
   3984                cfgReportRspCmd->attrList[i].status = *pBuf++;
   3985                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3986                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3987                pBuf += 2;
   3988              }
   3989            }
   3990          
   3991            return ( (void *)cfgReportRspCmd );
   3992          }
   3993          #endif
   3994          
   3995          #ifdef ZCL_REPORTING_DEVICE
   3996          /*********************************************************************
   3997           * @fn      zclParseInReadReportCfgCmd
   3998           *
   3999           * @brief   Parse the "Profile" Read Reporting Configuration Command
   4000           *
   4001           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4002           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4003           *
   4004           * @param   pCmd - pointer to incoming data to parse
   4005           *
   4006           * @return  pointer to the parsed command structure
   4007           */
   4008          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   4009          {
   4010            zclReadReportCfgCmd_t *readReportCfgCmd;
   4011            uint8 *pBuf = pCmd->pData;
   4012            uint8 numAttr;
   4013          
   4014            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   4015          
   4016            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   4017                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   4018            if ( readReportCfgCmd != NULL )
   4019            {
   4020              uint8 i;
   4021              readReportCfgCmd->numAttr = numAttr;
   4022              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   4023              {
   4024                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   4025                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4026                pBuf += 2;
   4027              }
   4028            }
   4029          
   4030            return ( (void *)readReportCfgCmd );
   4031          }
   4032          #endif
   4033          
   4034          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   4035          /*********************************************************************
   4036           * @fn      zclParseInReadReportCfgRspCmd
   4037           *
   4038           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   4039           *
   4040           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4041           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4042           *
   4043           * @param   pCmd - pointer to incoming data to parse
   4044           *
   4045           * @return  pointer to the parsed command structure
   4046           */
   4047          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   4048          {
   4049            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   4050            uint8 reportChangeLen;
   4051            uint8 *pBuf = pCmd->pData;
   4052            uint8 *dataPtr;
   4053            uint8 numAttr = 0;
   4054            uint8 hdrLen;
   4055            uint16 dataLen = 0;
   4056          
   4057            // Calculate the length of the response command
   4058            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4059            {
   4060              uint8 status;
   4061              uint8 direction;
   4062          
   4063              numAttr++;
   4064              status = *pBuf++;
   4065              direction = *pBuf++;
   4066              pBuf += 2; // move pass the attribute ID
   4067          
   4068              if ( status == ZCL_STATUS_SUCCESS )
   4069              {
   4070                if ( direction == ZCL_SEND_ATTR_REPORTS )
   4071                {
   4072                  uint8 dataType = *pBuf++;
   4073                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   4074          
   4075                  // For attributes of 'discrete' data types this field is omitted
   4076                  if ( zclAnalogDataType( dataType ) )
   4077                  {
   4078                    reportChangeLen = zclGetDataTypeLength( dataType );
   4079                    pBuf += reportChangeLen;
   4080          
   4081                    // add padding if needed
   4082                    if ( PADDING_NEEDED( reportChangeLen ) )
   4083                    {
   4084                      reportChangeLen++;
   4085                    }
   4086          
   4087                    dataLen += reportChangeLen;
   4088                  }
   4089                }
   4090                else
   4091                {
   4092                  pBuf += 2; // move pass the Timeout field
   4093                }
   4094              }
   4095            } // while loop
   4096          
   4097            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   4098          
   4099            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   4100            if ( readReportCfgRspCmd != NULL )
   4101            {
   4102              uint8 i;
   4103              pBuf = pCmd->pData;
   4104              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   4105          
   4106              readReportCfgRspCmd->numAttr = numAttr;
   4107              for ( i = 0; i < numAttr; i++ )
   4108              {
   4109                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   4110          
   4111                reportRspRec->status = *pBuf++;
   4112                reportRspRec->direction = *pBuf++;
   4113                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4114                pBuf += 2;
   4115          
   4116                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   4117                {
   4118                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   4119                  {
   4120                    reportRspRec->dataType = *pBuf++;
   4121                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   4122                    pBuf += 2;
   4123                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   4124                    pBuf += 2;
   4125          
   4126                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   4127                    {
   4128                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   4129                      reportRspRec->reportableChange = dataPtr;
   4130          
   4131                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   4132                      pBuf += reportChangeLen;
   4133          
   4134                      // advance attribute data pointer
   4135                      if ( PADDING_NEEDED( reportChangeLen ) )
   4136                      {
   4137                        reportChangeLen++;
   4138                      }
   4139          
   4140                      dataPtr += reportChangeLen;
   4141                    }
   4142                  }
   4143                  else
   4144                  {
   4145                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   4146                    pBuf += 2;
   4147                  }
   4148                }
   4149              }
   4150            }
   4151          
   4152            return ( (void *)readReportCfgRspCmd );
   4153          }
   4154          #endif
   4155          
   4156          #ifdef ZCL_REPORT_DESTINATION_DEVICE
   4157          /*********************************************************************
   4158           * @fn      zclParseInReportCmd
   4159           *
   4160           * @brief   Parse the "Profile" Report Command
   4161           *
   4162           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4163           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4164           *
   4165           * @param   pCmd - pointer to incoming data to parse
   4166           *
   4167           * @return  pointer to the parsed command structure
   4168           */
   4169          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   4170          {
   4171            zclReportCmd_t *reportCmd;
   4172            uint8 *pBuf = pCmd->pData;
   4173            uint16 attrDataLen;
   4174            uint8 *dataPtr;
   4175            uint8 numAttr = 0;
   4176            uint8 hdrLen;
   4177            uint16 dataLen = 0;
   4178          
   4179            // find out the number of attributes and the length of attribute data
   4180            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4181            {
   4182              uint8 dataType;
   4183          
   4184              numAttr++;
   4185              pBuf += 2; // move pass attribute id
   4186          
   4187              dataType = *pBuf++;
   4188          
   4189              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   4190              pBuf += attrDataLen; // move pass attribute data
   4191          
   4192              // add padding if needed
   4193              if ( PADDING_NEEDED( attrDataLen ) )
   4194              {
   4195                attrDataLen++;
   4196              }
   4197          
   4198              dataLen += attrDataLen;
   4199            }
   4200          
   4201            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   4202          
   4203            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   4204            if (reportCmd != NULL )
   4205            {
   4206              uint8 i;
   4207              pBuf = pCmd->pData;
   4208              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   4209          
   4210              reportCmd->numAttr = numAttr;
   4211              for ( i = 0; i < numAttr; i++ )
   4212              {
   4213                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   4214          
   4215                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4216                pBuf += 2;
   4217                reportRec->dataType = *pBuf++;
   4218          
   4219                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   4220                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   4221                reportRec->attrData = dataPtr;
   4222          
   4223                pBuf += attrDataLen; // move pass attribute data
   4224          
   4225                // advance attribute data pointer
   4226                if ( PADDING_NEEDED( attrDataLen ) )
   4227                {
   4228                  attrDataLen++;
   4229                }
   4230          
   4231                dataPtr += attrDataLen;
   4232              }
   4233            }
   4234          
   4235            return ( (void *)reportCmd );
   4236          }
   4237          #endif
   4238          
   4239          /*********************************************************************
   4240           * @fn      zclParseInDefaultRspCmd
   4241           *
   4242           * @brief   Parse the "Profile" Default Response Command
   4243           *
   4244           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4245           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4246           *
   4247           * @param   pCmd - pointer to incoming data to parse
   4248           *
   4249           * @return  pointer to the parsed command structure
   4250           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4251          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   4252          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   4253            zclDefaultRspCmd_t *defaultRspCmd;
   4254            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV       DPL,?V2
   \   00000C   85..83       MOV       DPH,?V3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FE           MOV       R6,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FF           MOV       R7,A
   4255          
   4256            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \   000017                ; Setup parameters for call to function osal_mem_alloc
   \   000017   7A02         MOV       R2,#0x2
   \   000019   7B00         MOV       R3,#0x0
   \   00001B   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00001E   8A..         MOV       ?V4,R2
   \   000020   8B..         MOV       ?V5,R3
   \   000022   85....       MOV       ?V0,?V4
   \   000025   85....       MOV       ?V1,?V5
   4257            if ( defaultRspCmd != NULL )
   \   000028   E5..         MOV       A,?V0
   \   00002A   45..         ORL       A,?V1
   \   00002C   602A         JZ        ??zclParseInDefaultRspCmd_0
   4258            {
   4259              defaultRspCmd->commandID = *pBuf++;
   \   00002E   8E82         MOV       DPL,R6
   \   000030   8F83         MOV       DPH,R7
   \   000032   E0           MOVX      A,@DPTR
   \   000033   C0E0         PUSH      A
   \   000035   85..82       MOV       DPL,?V0
   \   000038   85..83       MOV       DPH,?V1
   \   00003B   D0E0         POP       A
   \   00003D   F0           MOVX      @DPTR,A
   \   00003E   8E82         MOV       DPL,R6
   \   000040   8F83         MOV       DPH,R7
   \   000042   A3           INC       DPTR
   \   000043   AE82         MOV       R6,DPL
   \   000045   AF83         MOV       R7,DPH
   4260              defaultRspCmd->statusCode = *pBuf;
   \   000047   8E82         MOV       DPL,R6
   \   000049   8F83         MOV       DPH,R7
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   C0E0         PUSH      A
   \   00004E   85..82       MOV       DPL,?V0
   \   000051   85..83       MOV       DPH,?V1
   \   000054   A3           INC       DPTR
   \   000055   D0E0         POP       A
   \   000057   F0           MOVX      @DPTR,A
   4261            }
   4262          
   4263            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000058   AA..         MOV       R2,?V0
   \   00005A   AB..         MOV       R3,?V1
   \   00005C   7F06         MOV       R7,#0x6
   \   00005E   02....       LJMP      ?BANKED_LEAVE_XDATA
   4264          }
   4265          
   4266          #ifdef ZCL_DISCOVER
   4267          /*********************************************************************
   4268           * @fn      zclParseInDiscAttrsCmd
   4269           *
   4270           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   4271           *
   4272           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4273           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4274           *
   4275           * @param   pCmd - pointer to incoming data to parse
   4276           *
   4277           * @return  pointer to the parsed command structure
   4278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4279          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscAttrsCmd:
   4280          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   4281            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4282            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV       DPL,?V2
   \   00000C   85..83       MOV       DPH,?V3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   F8           MOV       R0,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   F9           MOV       R1,A
   \   000017   88..         MOV       ?V0,R0
   \   000019   89..         MOV       ?V1,R1
   4283          
   4284            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   \   00001B                ; Setup parameters for call to function osal_mem_alloc
   \   00001B   7A03         MOV       R2,#0x3
   \   00001D   7B00         MOV       R3,#0x0
   \   00001F   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000022   8A..         MOV       ?V4,R2
   \   000024   8B..         MOV       ?V5,R3
   \   000026   AE..         MOV       R6,?V4
   \   000028   AF..         MOV       R7,?V5
   4285            if ( pDiscoverCmd != NULL )
   \   00002A   EE           MOV       A,R6
   \   00002B   4F           ORL       A,R7
   \   00002C   6043         JZ        ??zclParseInDiscAttrsCmd_0
   4286            {
   4287              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00002E   85..82       MOV       DPL,?V0
   \   000031   85..83       MOV       DPH,?V1
   \   000034   E0           MOVX      A,@DPTR
   \   000035   FA           MOV       R2,A
   \   000036   7B00         MOV       R3,#0x0
   \   000038   85..82       MOV       DPL,?V0
   \   00003B   85..83       MOV       DPH,?V1
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F8           MOV       R0,A
   \   000041   7900         MOV       R1,#0x0
   \   000043   E4           CLR       A
   \   000044   C8           XCH       A,R0
   \   000045   F9           MOV       R1,A
   \   000046   EA           MOV       A,R2
   \   000047   28           ADD       A,R0
   \   000048   F8           MOV       R0,A
   \   000049   EB           MOV       A,R3
   \   00004A   39           ADDC      A,R1
   \   00004B   F9           MOV       R1,A
   \   00004C   8E82         MOV       DPL,R6
   \   00004E   8F83         MOV       DPH,R7
   \   000050   E8           MOV       A,R0
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   E9           MOV       A,R1
   \   000054   F0           MOVX      @DPTR,A
   4288              pBuf += 2;
   \   000055   E5..         MOV       A,?V0
   \   000057   2402         ADD       A,#0x2
   \   000059   F5..         MOV       ?V0,A
   \   00005B   5002         JNC       ??zclParseInDiscAttrsCmd_1
   \   00005D   05..         INC       ?V1
   4289              pDiscoverCmd->maxAttrIDs = *pBuf;
   \                     ??zclParseInDiscAttrsCmd_1:
   \   00005F   85..82       MOV       DPL,?V0
   \   000062   85..83       MOV       DPH,?V1
   \   000065   E0           MOVX      A,@DPTR
   \   000066   C0E0         PUSH      A
   \   000068   8E82         MOV       DPL,R6
   \   00006A   8F83         MOV       DPH,R7
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   D0E0         POP       A
   \   000070   F0           MOVX      @DPTR,A
   4290            }
   4291          
   4292            return ( (void *)pDiscoverCmd );
   \                     ??zclParseInDiscAttrsCmd_0:
   \   000071   EE           MOV       A,R6
   \   000072   FA           MOV       R2,A
   \   000073   EF           MOV       A,R7
   \   000074   FB           MOV       R3,A
   \   000075   7F06         MOV       R7,#0x6
   \   000077   02....       LJMP      ?BANKED_LEAVE_XDATA
   4293          }
   4294          
   4295          /*********************************************************************
   4296           * @fn      zclParseInDiscAttrsRspCmd
   4297           *
   4298           * @brief   Parse the "Profile" Discovery Response Commands
   4299           *
   4300           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4301           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4302           *
   4303           * @param   pCmd - pointer to incoming data to parse
   4304           *
   4305           * @return  pointer to the parsed command structure
   4306           */
   4307          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4308          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscAttrsRspCmd:
   4309          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   4310            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   4311            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV       DPL,?V2
   \   00000C   85..83       MOV       DPH,?V3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FE           MOV       R6,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FF           MOV       R7,A
   4312            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   \   000017   85..82       MOV       DPL,?V2
   \   00001A   85..83       MOV       DPH,?V3
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   24FF         ADD       A,#-0x1
   \   000021   F8           MOV       R0,A
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   34FF         ADDC      A,#-0x1
   \   000026   F9           MOV       R1,A
   \   000027   7A03         MOV       R2,#0x3
   \   000029   7B00         MOV       R3,#0x0
   \   00002B   12....       LCALL     ?US_DIV_MOD
   \   00002E   E8           MOV       A,R0
   \   00002F   F5..         MOV       ?V4,A
   4313          
   4314            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   4315                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   \   000031                ; Setup parameters for call to function osal_mem_alloc
   \   000031   E5..         MOV       A,?V4
   \   000033   F8           MOV       R0,A
   \   000034   7900         MOV       R1,#0x0
   \   000036   E8           MOV       A,R0
   \   000037   75F003       MOV       B,#0x3
   \   00003A   A4           MUL       AB
   \   00003B   C8           XCH       A,R0
   \   00003C   AAF0         MOV       R2,B
   \   00003E   75F000       MOV       B,#0x0
   \   000041   A4           MUL       AB
   \   000042   2A           ADD       A,R2
   \   000043   FA           MOV       R2,A
   \   000044   75F003       MOV       B,#0x3
   \   000047   E9           MOV       A,R1
   \   000048   A4           MUL       AB
   \   000049   2A           ADD       A,R2
   \   00004A   F9           MOV       R1,A
   \   00004B   E8           MOV       A,R0
   \   00004C   2402         ADD       A,#0x2
   \   00004E   FA           MOV       R2,A
   \   00004F   E4           CLR       A
   \   000050   39           ADDC      A,R1
   \   000051   FB           MOV       R3,A
   \   000052   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000055   8A..         MOV       ?V6,R2
   \   000057   8B..         MOV       ?V7,R3
   \   000059   85....       MOV       ?V0,?V6
   \   00005C   85....       MOV       ?V1,?V7
   4316          
   4317            if ( pDiscoverRspCmd != NULL )
   \   00005F   E5..         MOV       A,?V0
   \   000061   45..         ORL       A,?V1
   \   000063   7003         JNZ       $+5
   \   000065   02....       LJMP      ??zclParseInDiscAttrsRspCmd_0 & 0xFFFF
   4318            {
   4319              uint8 i;
   4320          
   4321              pDiscoverRspCmd->discComplete = *pBuf++;
   \   000068   8E82         MOV       DPL,R6
   \   00006A   8F83         MOV       DPH,R7
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   C0E0         PUSH      A
   \   00006F   85..82       MOV       DPL,?V0
   \   000072   85..83       MOV       DPH,?V1
   \   000075   D0E0         POP       A
   \   000077   F0           MOVX      @DPTR,A
   \   000078   8E82         MOV       DPL,R6
   \   00007A   8F83         MOV       DPH,R7
   \   00007C   A3           INC       DPTR
   \   00007D   AE82         MOV       R6,DPL
   \   00007F   AF83         MOV       R7,DPH
   4322              pDiscoverRspCmd->numAttr = numAttr;
   \   000081   E5..         MOV       A,?V4
   \   000083   C0E0         PUSH      A
   \   000085   85..82       MOV       DPL,?V0
   \   000088   85..83       MOV       DPH,?V1
   \   00008B   A3           INC       DPTR
   \   00008C   D0E0         POP       A
   \   00008E   F0           MOVX      @DPTR,A
   4323          
   4324              for ( i = 0; i < numAttr; i++ )
   \   00008F   7A00         MOV       R2,#0x0
   \                     ??zclParseInDiscAttrsRspCmd_1:
   \   000091   EA           MOV       A,R2
   \   000092   C3           CLR       C
   \   000093   95..         SUBB      A,?V4
   \   000095   4003         JC        $+5
   \   000097   02....       LJMP      ??zclParseInDiscAttrsRspCmd_0 & 0xFFFF
   4325              {
   4326                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00009A   8E82         MOV       DPL,R6
   \   00009C   8F83         MOV       DPH,R7
   \   00009E   E0           MOVX      A,@DPTR
   \   00009F   FC           MOV       R4,A
   \   0000A0   7D00         MOV       R5,#0x0
   \   0000A2   8E82         MOV       DPL,R6
   \   0000A4   8F83         MOV       DPH,R7
   \   0000A6   A3           INC       DPTR
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   F8           MOV       R0,A
   \   0000A9   7900         MOV       R1,#0x0
   \   0000AB   E4           CLR       A
   \   0000AC   C8           XCH       A,R0
   \   0000AD   F9           MOV       R1,A
   \   0000AE   EC           MOV       A,R4
   \   0000AF   28           ADD       A,R0
   \   0000B0   FC           MOV       R4,A
   \   0000B1   ED           MOV       A,R5
   \   0000B2   39           ADDC      A,R1
   \   0000B3   FD           MOV       R5,A
   \   0000B4   EA           MOV       A,R2
   \   0000B5   F8           MOV       R0,A
   \   0000B6   7900         MOV       R1,#0x0
   \   0000B8   E8           MOV       A,R0
   \   0000B9   75F003       MOV       B,#0x3
   \   0000BC   A4           MUL       AB
   \   0000BD   C8           XCH       A,R0
   \   0000BE   ABF0         MOV       R3,B
   \   0000C0   75F000       MOV       B,#0x0
   \   0000C3   A4           MUL       AB
   \   0000C4   2B           ADD       A,R3
   \   0000C5   FB           MOV       R3,A
   \   0000C6   75F003       MOV       B,#0x3
   \   0000C9   E9           MOV       A,R1
   \   0000CA   A4           MUL       AB
   \   0000CB   2B           ADD       A,R3
   \   0000CC   F9           MOV       R1,A
   \   0000CD   E5..         MOV       A,?V0
   \   0000CF   28           ADD       A,R0
   \   0000D0   F582         MOV       DPL,A
   \   0000D2   E5..         MOV       A,?V1
   \   0000D4   39           ADDC      A,R1
   \   0000D5   F583         MOV       DPH,A
   \   0000D7   A3           INC       DPTR
   \   0000D8   A3           INC       DPTR
   \   0000D9   EC           MOV       A,R4
   \   0000DA   F0           MOVX      @DPTR,A
   \   0000DB   A3           INC       DPTR
   \   0000DC   ED           MOV       A,R5
   \   0000DD   F0           MOVX      @DPTR,A
   4327                pBuf += 2;
   \   0000DE   EE           MOV       A,R6
   \   0000DF   2402         ADD       A,#0x2
   \   0000E1   FE           MOV       R6,A
   \   0000E2   5001         JNC       ??zclParseInDiscAttrsRspCmd_2
   \   0000E4   0F           INC       R7
   4328                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   \                     ??zclParseInDiscAttrsRspCmd_2:
   \   0000E5   8E82         MOV       DPL,R6
   \   0000E7   8F83         MOV       DPH,R7
   \   0000E9   E0           MOVX      A,@DPTR
   \   0000EA   C0E0         PUSH      A
   \   0000EC   EA           MOV       A,R2
   \   0000ED   F8           MOV       R0,A
   \   0000EE   7900         MOV       R1,#0x0
   \   0000F0   E8           MOV       A,R0
   \   0000F1   75F003       MOV       B,#0x3
   \   0000F4   A4           MUL       AB
   \   0000F5   C8           XCH       A,R0
   \   0000F6   ABF0         MOV       R3,B
   \   0000F8   75F000       MOV       B,#0x0
   \   0000FB   A4           MUL       AB
   \   0000FC   2B           ADD       A,R3
   \   0000FD   FB           MOV       R3,A
   \   0000FE   75F003       MOV       B,#0x3
   \   000101   E9           MOV       A,R1
   \   000102   A4           MUL       AB
   \   000103   2B           ADD       A,R3
   \   000104   F9           MOV       R1,A
   \   000105   E5..         MOV       A,?V0
   \   000107   28           ADD       A,R0
   \   000108   F582         MOV       DPL,A
   \   00010A   E5..         MOV       A,?V1
   \   00010C   39           ADDC      A,R1
   \   00010D   F583         MOV       DPH,A
   \   00010F   A3           INC       DPTR
   \   000110   A3           INC       DPTR
   \   000111   A3           INC       DPTR
   \   000112   A3           INC       DPTR
   \   000113   D0E0         POP       A
   \   000115   F0           MOVX      @DPTR,A
   \   000116   8E82         MOV       DPL,R6
   \   000118   8F83         MOV       DPH,R7
   \   00011A   A3           INC       DPTR
   \   00011B   AE82         MOV       R6,DPL
   \   00011D   AF83         MOV       R7,DPH
   4329              }
   \   00011F   0A           INC       R2
   \   000120   02....       LJMP      ??zclParseInDiscAttrsRspCmd_1 & 0xFFFF
   4330            }
   4331          
   4332            return ( (void *)pDiscoverRspCmd );
   \                     ??zclParseInDiscAttrsRspCmd_0:
   \   000123   AA..         MOV       R2,?V0
   \   000125   AB..         MOV       R3,?V1
   \   000127   7F08         MOV       R7,#0x8
   \   000129   02....       LJMP      ?BANKED_LEAVE_XDATA
   4333          }
   4334          
   4335          /*********************************************************************
   4336           * @fn      zclParseInDiscCmdsCmd
   4337           *
   4338           * @brief   Parse the "Profile" Discovery Commands
   4339           *
   4340           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4341           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4342           *
   4343           * @param   pCmd - pointer to incoming data to parse
   4344           *
   4345           * @return  pointer to the parsed command structure
   4346           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4347          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscCmdsCmd:
   4348          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   4349            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4350            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV       DPL,?V2
   \   00000C   85..83       MOV       DPH,?V3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FE           MOV       R6,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FF           MOV       R7,A
   4351          
   4352            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   \   000017                ; Setup parameters for call to function osal_mem_alloc
   \   000017   7A02         MOV       R2,#0x2
   \   000019   7B00         MOV       R3,#0x0
   \   00001B   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00001E   8A..         MOV       ?V4,R2
   \   000020   8B..         MOV       ?V5,R3
   \   000022   85....       MOV       ?V0,?V4
   \   000025   85....       MOV       ?V1,?V5
   4353            if ( pDiscoverCmd != NULL )
   \   000028   E5..         MOV       A,?V0
   \   00002A   45..         ORL       A,?V1
   \   00002C   6033         JZ        ??zclParseInDiscCmdsCmd_0
   4354            {
   4355              pDiscoverCmd->startCmdID = *pBuf++;
   \   00002E   8E82         MOV       DPL,R6
   \   000030   8F83         MOV       DPH,R7
   \   000032   E0           MOVX      A,@DPTR
   \   000033   C0E0         PUSH      A
   \   000035   85..82       MOV       DPL,?V0
   \   000038   85..83       MOV       DPH,?V1
   \   00003B   D0E0         POP       A
   \   00003D   F0           MOVX      @DPTR,A
   \   00003E   8E82         MOV       DPL,R6
   \   000040   8F83         MOV       DPH,R7
   \   000042   A3           INC       DPTR
   \   000043   AE82         MOV       R6,DPL
   \   000045   AF83         MOV       R7,DPH
   4356              pDiscoverCmd->maxCmdID = *pBuf++;
   \   000047   8E82         MOV       DPL,R6
   \   000049   8F83         MOV       DPH,R7
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   C0E0         PUSH      A
   \   00004E   85..82       MOV       DPL,?V0
   \   000051   85..83       MOV       DPH,?V1
   \   000054   A3           INC       DPTR
   \   000055   D0E0         POP       A
   \   000057   F0           MOVX      @DPTR,A
   \   000058   8E82         MOV       DPL,R6
   \   00005A   8F83         MOV       DPH,R7
   \   00005C   A3           INC       DPTR
   \   00005D   AE82         MOV       R6,DPL
   \   00005F   AF83         MOV       R7,DPH
   4357            }
   4358          
   4359            return ( (void *)pDiscoverCmd );
   \                     ??zclParseInDiscCmdsCmd_0:
   \   000061   AA..         MOV       R2,?V0
   \   000063   AB..         MOV       R3,?V1
   \   000065   7F06         MOV       R7,#0x6
   \   000067   02....       LJMP      ?BANKED_LEAVE_XDATA
   4360          }
   4361          
   4362          /*********************************************************************
   4363           * @fn      zclParseInDiscCmdsRspCmd
   4364           *
   4365           * @brief   Parse the Discover Commands Response Command
   4366           *
   4367           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4368           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4369           *
   4370           * @param   pCmd - pointer to incoming data to parse
   4371           *
   4372           * @return  pointer to the parsed command structure
   4373           */
   4374          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4375          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscCmdsRspCmd:
   4376          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   4377            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4378            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV       DPL,?V2
   \   00000C   85..83       MOV       DPH,?V3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FE           MOV       R6,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FF           MOV       R7,A
   4379            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   \   000017   85..82       MOV       DPL,?V2
   \   00001A   85..83       MOV       DPH,?V3
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F8           MOV       R0,A
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F9           MOV       R1,A
   \   000023   E8           MOV       A,R0
   \   000024   24FF         ADD       A,#-0x1
   \   000026   F5..         MOV       ?V4,A
   4380          
   4381              // allocate memory for size of structure plus variable array
   4382            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4383                              ( numCmds * sizeof(uint8) ) );
   \   000028                ; Setup parameters for call to function osal_mem_alloc
   \   000028   E5..         MOV       A,?V4
   \   00002A   F8           MOV       R0,A
   \   00002B   7900         MOV       R1,#0x0
   \   00002D   E8           MOV       A,R0
   \   00002E   2405         ADD       A,#0x5
   \   000030   FA           MOV       R2,A
   \   000031   E4           CLR       A
   \   000032   39           ADDC      A,R1
   \   000033   FB           MOV       R3,A
   \   000034   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000037   8A..         MOV       ?V6,R2
   \   000039   8B..         MOV       ?V7,R3
   \   00003B   85....       MOV       ?V0,?V6
   \   00003E   85....       MOV       ?V1,?V7
   4384            if ( pDiscoverRspCmd != NULL )
   \   000041   E5..         MOV       A,?V0
   \   000043   45..         ORL       A,?V1
   \   000045   605D         JZ        ??zclParseInDiscCmdsRspCmd_0
   4385            {
   4386              uint8 i;
   4387              pDiscoverRspCmd->discComplete = *pBuf++;
   \   000047   8E82         MOV       DPL,R6
   \   000049   8F83         MOV       DPH,R7
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   C0E0         PUSH      A
   \   00004E   85..82       MOV       DPL,?V0
   \   000051   85..83       MOV       DPH,?V1
   \   000054   D0E0         POP       A
   \   000056   F0           MOVX      @DPTR,A
   \   000057   8E82         MOV       DPL,R6
   \   000059   8F83         MOV       DPH,R7
   \   00005B   A3           INC       DPTR
   \   00005C   AE82         MOV       R6,DPL
   \   00005E   AF83         MOV       R7,DPH
   4388              pDiscoverRspCmd->numCmd = numCmds;
   \   000060   E5..         MOV       A,?V4
   \   000062   C0E0         PUSH      A
   \   000064   85..82       MOV       DPL,?V0
   \   000067   85..83       MOV       DPH,?V1
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   D0E0         POP       A
   \   00006E   F0           MOVX      @DPTR,A
   4389          
   4390              for ( i = 0; i < numCmds; i++ )
   \   00006F   7800         MOV       R0,#0x0
   \                     ??zclParseInDiscCmdsRspCmd_1:
   \   000071   E8           MOV       A,R0
   \   000072   C3           CLR       C
   \   000073   95..         SUBB      A,?V4
   \   000075   502D         JNC       ??zclParseInDiscCmdsRspCmd_0
   4391              {
   4392                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   \   000077   8E82         MOV       DPL,R6
   \   000079   8F83         MOV       DPH,R7
   \   00007B   E0           MOVX      A,@DPTR
   \   00007C   C0E0         PUSH      A
   \   00007E   E8           MOV       A,R0
   \   00007F   FA           MOV       R2,A
   \   000080   7B00         MOV       R3,#0x0
   \   000082   85..82       MOV       DPL,?V0
   \   000085   85..83       MOV       DPH,?V1
   \   000088   A3           INC       DPTR
   \   000089   A3           INC       DPTR
   \   00008A   A3           INC       DPTR
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   2A           ADD       A,R2
   \   00008D   F9           MOV       R1,A
   \   00008E   A3           INC       DPTR
   \   00008F   E0           MOVX      A,@DPTR
   \   000090   3B           ADDC      A,R3
   \   000091   8982         MOV       DPL,R1
   \   000093   F583         MOV       DPH,A
   \   000095   D0E0         POP       A
   \   000097   F0           MOVX      @DPTR,A
   \   000098   8E82         MOV       DPL,R6
   \   00009A   8F83         MOV       DPH,R7
   \   00009C   A3           INC       DPTR
   \   00009D   AE82         MOV       R6,DPL
   \   00009F   AF83         MOV       R7,DPH
   4393              }
   \   0000A1   08           INC       R0
   \   0000A2   80CD         SJMP      ??zclParseInDiscCmdsRspCmd_1
   4394            }
   4395          
   4396            return ( (void *)pDiscoverRspCmd );
   \                     ??zclParseInDiscCmdsRspCmd_0:
   \   0000A4   AA..         MOV       R2,?V0
   \   0000A6   AB..         MOV       R3,?V1
   \   0000A8   7F08         MOV       R7,#0x8
   \   0000AA   02....       LJMP      ?BANKED_LEAVE_XDATA
   4397          }
   4398          
   4399          /*********************************************************************
   4400           * @fn      zclParseInDiscAttrsExtRspCmd
   4401           *
   4402           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4403           *
   4404           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4405           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4406           *
   4407           * @param   pCmd - pointer to incoming data to parse
   4408           *
   4409           * @return  pointer to the parsed command structure
   4410           */
   4411          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4412          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscAttrsExtRspCmd:
   4413          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   4414            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4415            uint8 i;
   4416            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV       DPL,?V2
   \   00000C   85..83       MOV       DPH,?V3
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FE           MOV       R6,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FF           MOV       R7,A
   4417            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   \   000017   85..82       MOV       DPL,?V2
   \   00001A   85..83       MOV       DPH,?V3
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   24FF         ADD       A,#-0x1
   \   000021   F5..         MOV       ?V6,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   34FF         ADDC      A,#-0x1
   \   000027   F5..         MOV       ?V7,A
   \   000029   7402         MOV       A,#0x2
   \   00002B   78..         MOV       R0,#?V6
   \   00002D   12....       LCALL     ?US_SHR
   \   000030   E5..         MOV       A,?V6
   \   000032   F5..         MOV       ?V5,A
   4418          
   4419            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4420                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   \   000034                ; Setup parameters for call to function osal_mem_alloc
   \   000034   E5..         MOV       A,?V5
   \   000036   F8           MOV       R0,A
   \   000037   7900         MOV       R1,#0x0
   \   000039   E8           MOV       A,R0
   \   00003A   75F004       MOV       B,#0x4
   \   00003D   A4           MUL       AB
   \   00003E   C8           XCH       A,R0
   \   00003F   AAF0         MOV       R2,B
   \   000041   75F000       MOV       B,#0x0
   \   000044   A4           MUL       AB
   \   000045   2A           ADD       A,R2
   \   000046   FA           MOV       R2,A
   \   000047   75F004       MOV       B,#0x4
   \   00004A   E9           MOV       A,R1
   \   00004B   A4           MUL       AB
   \   00004C   2A           ADD       A,R2
   \   00004D   F9           MOV       R1,A
   \   00004E   E8           MOV       A,R0
   \   00004F   2402         ADD       A,#0x2
   \   000051   FA           MOV       R2,A
   \   000052   E4           CLR       A
   \   000053   39           ADDC      A,R1
   \   000054   FB           MOV       R3,A
   \   000055   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000058   8A..         MOV       ?V6,R2
   \   00005A   8B..         MOV       ?V7,R3
   \   00005C   85....       MOV       ?V0,?V6
   \   00005F   85....       MOV       ?V1,?V7
   4421          
   4422            if ( pDiscoverRspCmd != NULL )
   \   000062   E5..         MOV       A,?V0
   \   000064   45..         ORL       A,?V1
   \   000066   7003         JNZ       $+5
   \   000068   02....       LJMP      ??zclParseInDiscAttrsExtRspCmd_0 & 0xFFFF
   4423            {
   4424              pDiscoverRspCmd->discComplete = *pBuf++;
   \   00006B   8E82         MOV       DPL,R6
   \   00006D   8F83         MOV       DPH,R7
   \   00006F   E0           MOVX      A,@DPTR
   \   000070   C0E0         PUSH      A
   \   000072   85..82       MOV       DPL,?V0
   \   000075   85..83       MOV       DPH,?V1
   \   000078   D0E0         POP       A
   \   00007A   F0           MOVX      @DPTR,A
   \   00007B   8E82         MOV       DPL,R6
   \   00007D   8F83         MOV       DPH,R7
   \   00007F   A3           INC       DPTR
   \   000080   AE82         MOV       R6,DPL
   \   000082   AF83         MOV       R7,DPH
   4425              pDiscoverRspCmd->numAttr = numAttrs;
   \   000084   E5..         MOV       A,?V5
   \   000086   C0E0         PUSH      A
   \   000088   85..82       MOV       DPL,?V0
   \   00008B   85..83       MOV       DPH,?V1
   \   00008E   A3           INC       DPTR
   \   00008F   D0E0         POP       A
   \   000091   F0           MOVX      @DPTR,A
   4426          
   4427              for ( i = 0; i < numAttrs; i++ )
   \   000092   75..00       MOV       ?V4,#0x0
   \                     ??zclParseInDiscAttrsExtRspCmd_1:
   \   000095   E5..         MOV       A,?V4
   \   000097   C3           CLR       C
   \   000098   95..         SUBB      A,?V5
   \   00009A   4003         JC        $+5
   \   00009C   02....       LJMP      ??zclParseInDiscAttrsExtRspCmd_0 & 0xFFFF
   4428              {
   4429                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00009F   8E82         MOV       DPL,R6
   \   0000A1   8F83         MOV       DPH,R7
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   FA           MOV       R2,A
   \   0000A5   7B00         MOV       R3,#0x0
   \   0000A7   8E82         MOV       DPL,R6
   \   0000A9   8F83         MOV       DPH,R7
   \   0000AB   A3           INC       DPTR
   \   0000AC   E0           MOVX      A,@DPTR
   \   0000AD   F8           MOV       R0,A
   \   0000AE   7900         MOV       R1,#0x0
   \   0000B0   E4           CLR       A
   \   0000B1   C8           XCH       A,R0
   \   0000B2   F9           MOV       R1,A
   \   0000B3   EA           MOV       A,R2
   \   0000B4   28           ADD       A,R0
   \   0000B5   FA           MOV       R2,A
   \   0000B6   EB           MOV       A,R3
   \   0000B7   39           ADDC      A,R1
   \   0000B8   FB           MOV       R3,A
   \   0000B9   E5..         MOV       A,?V4
   \   0000BB   F8           MOV       R0,A
   \   0000BC   7900         MOV       R1,#0x0
   \   0000BE   E8           MOV       A,R0
   \   0000BF   75F004       MOV       B,#0x4
   \   0000C2   A4           MUL       AB
   \   0000C3   C8           XCH       A,R0
   \   0000C4   ACF0         MOV       R4,B
   \   0000C6   75F000       MOV       B,#0x0
   \   0000C9   A4           MUL       AB
   \   0000CA   2C           ADD       A,R4
   \   0000CB   FC           MOV       R4,A
   \   0000CC   75F004       MOV       B,#0x4
   \   0000CF   E9           MOV       A,R1
   \   0000D0   A4           MUL       AB
   \   0000D1   2C           ADD       A,R4
   \   0000D2   F9           MOV       R1,A
   \   0000D3   E5..         MOV       A,?V0
   \   0000D5   28           ADD       A,R0
   \   0000D6   F582         MOV       DPL,A
   \   0000D8   E5..         MOV       A,?V1
   \   0000DA   39           ADDC      A,R1
   \   0000DB   F583         MOV       DPH,A
   \   0000DD   A3           INC       DPTR
   \   0000DE   A3           INC       DPTR
   \   0000DF   EA           MOV       A,R2
   \   0000E0   F0           MOVX      @DPTR,A
   \   0000E1   A3           INC       DPTR
   \   0000E2   EB           MOV       A,R3
   \   0000E3   F0           MOVX      @DPTR,A
   4430                pBuf += 2;
   \   0000E4   EE           MOV       A,R6
   \   0000E5   2402         ADD       A,#0x2
   \   0000E7   FE           MOV       R6,A
   \   0000E8   5001         JNC       ??zclParseInDiscAttrsExtRspCmd_2
   \   0000EA   0F           INC       R7
   4431                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   \                     ??zclParseInDiscAttrsExtRspCmd_2:
   \   0000EB   8E82         MOV       DPL,R6
   \   0000ED   8F83         MOV       DPH,R7
   \   0000EF   E0           MOVX      A,@DPTR
   \   0000F0   C0E0         PUSH      A
   \   0000F2   E5..         MOV       A,?V4
   \   0000F4   F8           MOV       R0,A
   \   0000F5   7900         MOV       R1,#0x0
   \   0000F7   E8           MOV       A,R0
   \   0000F8   75F004       MOV       B,#0x4
   \   0000FB   A4           MUL       AB
   \   0000FC   C8           XCH       A,R0
   \   0000FD   AAF0         MOV       R2,B
   \   0000FF   75F000       MOV       B,#0x0
   \   000102   A4           MUL       AB
   \   000103   2A           ADD       A,R2
   \   000104   FA           MOV       R2,A
   \   000105   75F004       MOV       B,#0x4
   \   000108   E9           MOV       A,R1
   \   000109   A4           MUL       AB
   \   00010A   2A           ADD       A,R2
   \   00010B   F9           MOV       R1,A
   \   00010C   E5..         MOV       A,?V0
   \   00010E   28           ADD       A,R0
   \   00010F   F582         MOV       DPL,A
   \   000111   E5..         MOV       A,?V1
   \   000113   39           ADDC      A,R1
   \   000114   F583         MOV       DPH,A
   \   000116   A3           INC       DPTR
   \   000117   A3           INC       DPTR
   \   000118   A3           INC       DPTR
   \   000119   A3           INC       DPTR
   \   00011A   D0E0         POP       A
   \   00011C   F0           MOVX      @DPTR,A
   \   00011D   8E82         MOV       DPL,R6
   \   00011F   8F83         MOV       DPH,R7
   \   000121   A3           INC       DPTR
   \   000122   AE82         MOV       R6,DPL
   \   000124   AF83         MOV       R7,DPH
   4432                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   \   000126   8E82         MOV       DPL,R6
   \   000128   8F83         MOV       DPH,R7
   \   00012A   E0           MOVX      A,@DPTR
   \   00012B   C0E0         PUSH      A
   \   00012D   E5..         MOV       A,?V4
   \   00012F   F8           MOV       R0,A
   \   000130   7900         MOV       R1,#0x0
   \   000132   E8           MOV       A,R0
   \   000133   75F004       MOV       B,#0x4
   \   000136   A4           MUL       AB
   \   000137   C8           XCH       A,R0
   \   000138   AAF0         MOV       R2,B
   \   00013A   75F000       MOV       B,#0x0
   \   00013D   A4           MUL       AB
   \   00013E   2A           ADD       A,R2
   \   00013F   FA           MOV       R2,A
   \   000140   75F004       MOV       B,#0x4
   \   000143   E9           MOV       A,R1
   \   000144   A4           MUL       AB
   \   000145   2A           ADD       A,R2
   \   000146   F9           MOV       R1,A
   \   000147   E5..         MOV       A,?V0
   \   000149   28           ADD       A,R0
   \   00014A   F582         MOV       DPL,A
   \   00014C   E5..         MOV       A,?V1
   \   00014E   39           ADDC      A,R1
   \   00014F   F583         MOV       DPH,A
   \   000151   A3           INC       DPTR
   \   000152   A3           INC       DPTR
   \   000153   A3           INC       DPTR
   \   000154   A3           INC       DPTR
   \   000155   A3           INC       DPTR
   \   000156   D0E0         POP       A
   \   000158   F0           MOVX      @DPTR,A
   \   000159   8E82         MOV       DPL,R6
   \   00015B   8F83         MOV       DPH,R7
   \   00015D   A3           INC       DPTR
   \   00015E   AE82         MOV       R6,DPL
   \   000160   AF83         MOV       R7,DPH
   4433              }
   \   000162   05..         INC       ?V4
   \   000164   02....       LJMP      ??zclParseInDiscAttrsExtRspCmd_1 & 0xFFFF
   4434            }
   4435          
   4436            return ( (void *)pDiscoverRspCmd );
   \                     ??zclParseInDiscAttrsExtRspCmd_0:
   \   000167   AA..         MOV       R2,?V0
   \   000169   AB..         MOV       R3,?V1
   \   00016B   7F08         MOV       R7,#0x8
   \   00016D   02....       LJMP      ?BANKED_LEAVE_XDATA
   4437          }
   4438          #endif // ZCL_DISCOVER
   4439          
   4440          #ifdef ZCL_READ
   4441          /*********************************************************************
   4442           * @fn      zclProcessInReadCmd
   4443           *
   4444           * @brief   Process the "Profile" Read Command
   4445           *
   4446           * @param   pInMsg - incoming message to process
   4447           *
   4448           * @return  TRUE if command processed. FALSE, otherwise.
   4449           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4450          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4451          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   4452            zclReadCmd_t *readCmd;
   4453            zclReadRspCmd_t *readRspCmd;
   4454            zclAttrRec_t attrRec;
   4455            uint16 len;
   4456            uint8 i;
   4457            uint8 attrFound;
   4458          
   4459            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV       A,R6
   \   00000F   240C         ADD       A,#0xc
   \   000011   F582         MOV       DPL,A
   \   000013   E4           CLR       A
   \   000014   3F           ADDC      A,R7
   \   000015   F583         MOV       DPH,A
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F9           MOV       R1,A
   \   00001C   88..         MOV       ?V4,R0
   \   00001E   89..         MOV       ?V5,R1
   4460          
   4461            // calculate the length of the response status record
   4462            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   \   000020   85..82       MOV       DPL,?V4
   \   000023   85..83       MOV       DPH,?V5
   \   000026   E0           MOVX      A,@DPTR
   \   000027   F8           MOV       R0,A
   \   000028   7900         MOV       R1,#0x0
   \   00002A   E8           MOV       A,R0
   \   00002B   75F006       MOV       B,#0x6
   \   00002E   A4           MUL       AB
   \   00002F   C8           XCH       A,R0
   \   000030   AAF0         MOV       R2,B
   \   000032   75F000       MOV       B,#0x0
   \   000035   A4           MUL       AB
   \   000036   2A           ADD       A,R2
   \   000037   FA           MOV       R2,A
   \   000038   75F006       MOV       B,#0x6
   \   00003B   E9           MOV       A,R1
   \   00003C   A4           MUL       AB
   \   00003D   2A           ADD       A,R2
   \   00003E   F9           MOV       R1,A
   \   00003F   E8           MOV       A,R0
   \   000040   2401         ADD       A,#0x1
   \   000042   F8           MOV       R0,A
   \   000043   5001         JNC       ??zclProcessInReadCmd_0
   \   000045   09           INC       R1
   \                     ??zclProcessInReadCmd_0:
   \   000046   88..         MOV       ?V6,R0
   \   000048   89..         MOV       ?V7,R1
   4463          
   4464            readRspCmd = zcl_mem_alloc( len );
   \   00004A                ; Setup parameters for call to function osal_mem_alloc
   \   00004A   AA..         MOV       R2,?V6
   \   00004C   AB..         MOV       R3,?V7
   \   00004E   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000051   8A..         MOV       ?V0,R2
   \   000053   8B..         MOV       ?V1,R3
   \   000055   85....       MOV       ?V8,?V0
   \   000058   85....       MOV       ?V9,?V1
   4465            if ( readRspCmd == NULL )
   \   00005B   E5..         MOV       A,?V8
   \   00005D   45..         ORL       A,?V9
   \   00005F   7005         JNZ       ??zclProcessInReadCmd_1
   4466            {
   4467              return FALSE; // EMBEDDED RETURN
   \   000061   7900         MOV       R1,#0x0
   \   000063   02....       LJMP      ??zclProcessInReadCmd_2 & 0xFFFF
   4468            }
   4469          
   4470            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_1:
   \   000066   85..82       MOV       DPL,?V4
   \   000069   85..83       MOV       DPH,?V5
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   C0E0         PUSH      A
   \   00006F   85..82       MOV       DPL,?V8
   \   000072   85..83       MOV       DPH,?V9
   \   000075   D0E0         POP       A
   \   000077   F0           MOVX      @DPTR,A
   4471            for ( i = 0; i < readCmd->numAttr; i++ )
   \   000078   75..00       MOV       ?V2,#0x0
   \                     ??zclProcessInReadCmd_3:
   \   00007B   85..82       MOV       DPL,?V4
   \   00007E   85..83       MOV       DPH,?V5
   \   000081   E0           MOVX      A,@DPTR
   \   000082   F8           MOV       R0,A
   \   000083   E5..         MOV       A,?V2
   \   000085   C3           CLR       C
   \   000086   98           SUBB      A,R0
   \   000087   4003         JC        $+5
   \   000089   02....       LJMP      ??zclProcessInReadCmd_4 & 0xFFFF
   4472            {
   4473              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \   00008C   E5..         MOV       A,?V2
   \   00008E   F8           MOV       R0,A
   \   00008F   7900         MOV       R1,#0x0
   \   000091   E8           MOV       A,R0
   \   000092   75F006       MOV       B,#0x6
   \   000095   A4           MUL       AB
   \   000096   C8           XCH       A,R0
   \   000097   AAF0         MOV       R2,B
   \   000099   75F000       MOV       B,#0x0
   \   00009C   A4           MUL       AB
   \   00009D   2A           ADD       A,R2
   \   00009E   FA           MOV       R2,A
   \   00009F   75F006       MOV       B,#0x6
   \   0000A2   E9           MOV       A,R1
   \   0000A3   A4           MUL       AB
   \   0000A4   2A           ADD       A,R2
   \   0000A5   F9           MOV       R1,A
   \   0000A6   E5..         MOV       A,?V8
   \   0000A8   28           ADD       A,R0
   \   0000A9   F582         MOV       DPL,A
   \   0000AB   E5..         MOV       A,?V9
   \   0000AD   39           ADDC      A,R1
   \   0000AE   F583         MOV       DPH,A
   \   0000B0   A3           INC       DPTR
   \   0000B1   8582..       MOV       ?V0,DPL
   \   0000B4   8583..       MOV       ?V1,DPH
   4474          
   4475              statusRec->attrID = readCmd->attrID[i];
   \   0000B7   E5..         MOV       A,?V2
   \   0000B9   F8           MOV       R0,A
   \   0000BA   7900         MOV       R1,#0x0
   \   0000BC   E8           MOV       A,R0
   \   0000BD   75F002       MOV       B,#0x2
   \   0000C0   A4           MUL       AB
   \   0000C1   C8           XCH       A,R0
   \   0000C2   AAF0         MOV       R2,B
   \   0000C4   75F000       MOV       B,#0x0
   \   0000C7   A4           MUL       AB
   \   0000C8   2A           ADD       A,R2
   \   0000C9   FA           MOV       R2,A
   \   0000CA   75F002       MOV       B,#0x2
   \   0000CD   E9           MOV       A,R1
   \   0000CE   A4           MUL       AB
   \   0000CF   2A           ADD       A,R2
   \   0000D0   F9           MOV       R1,A
   \   0000D1   E5..         MOV       A,?V4
   \   0000D3   28           ADD       A,R0
   \   0000D4   F582         MOV       DPL,A
   \   0000D6   E5..         MOV       A,?V5
   \   0000D8   39           ADDC      A,R1
   \   0000D9   F583         MOV       DPH,A
   \   0000DB   A3           INC       DPTR
   \   0000DC   E0           MOVX      A,@DPTR
   \   0000DD   F8           MOV       R0,A
   \   0000DE   A3           INC       DPTR
   \   0000DF   E0           MOVX      A,@DPTR
   \   0000E0   F9           MOV       R1,A
   \   0000E1   85..82       MOV       DPL,?V0
   \   0000E4   85..83       MOV       DPH,?V1
   \   0000E7   E8           MOV       A,R0
   \   0000E8   F0           MOVX      @DPTR,A
   \   0000E9   A3           INC       DPTR
   \   0000EA   E9           MOV       A,R1
   \   0000EB   F0           MOVX      @DPTR,A
   4476              
   4477              attrFound = zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec );
   \   0000EC                ; Setup parameters for call to function zclFindAttrRec
   \   0000EC   A8..         MOV       R0,?XSP + 0
   \   0000EE   A9..         MOV       R1,?XSP + 1
   \   0000F0   88..         MOV       ?V10,R0
   \   0000F2   89..         MOV       ?V11,R1
   \   0000F4   78..         MOV       R0,#?V10
   \   0000F6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000F9   E5..         MOV       A,?V2
   \   0000FB   F8           MOV       R0,A
   \   0000FC   7900         MOV       R1,#0x0
   \   0000FE   E8           MOV       A,R0
   \   0000FF   75F002       MOV       B,#0x2
   \   000102   A4           MUL       AB
   \   000103   C8           XCH       A,R0
   \   000104   AAF0         MOV       R2,B
   \   000106   75F000       MOV       B,#0x0
   \   000109   A4           MUL       AB
   \   00010A   2A           ADD       A,R2
   \   00010B   FA           MOV       R2,A
   \   00010C   75F002       MOV       B,#0x2
   \   00010F   E9           MOV       A,R1
   \   000110   A4           MUL       AB
   \   000111   2A           ADD       A,R2
   \   000112   F9           MOV       R1,A
   \   000113   E5..         MOV       A,?V4
   \   000115   28           ADD       A,R0
   \   000116   F582         MOV       DPL,A
   \   000118   E5..         MOV       A,?V5
   \   00011A   39           ADDC      A,R1
   \   00011B   F583         MOV       DPH,A
   \   00011D   A3           INC       DPTR
   \   00011E   E0           MOVX      A,@DPTR
   \   00011F   FC           MOV       R4,A
   \   000120   A3           INC       DPTR
   \   000121   E0           MOVX      A,@DPTR
   \   000122   FD           MOV       R5,A
   \   000123   8E82         MOV       DPL,R6
   \   000125   8F83         MOV       DPH,R7
   \   000127   E0           MOVX      A,@DPTR
   \   000128   F8           MOV       R0,A
   \   000129   A3           INC       DPTR
   \   00012A   E0           MOVX      A,@DPTR
   \   00012B   F583         MOV       DPH,A
   \   00012D   8882         MOV       DPL,R0
   \   00012F   A3           INC       DPTR
   \   000130   A3           INC       DPTR
   \   000131   A3           INC       DPTR
   \   000132   A3           INC       DPTR
   \   000133   E0           MOVX      A,@DPTR
   \   000134   FA           MOV       R2,A
   \   000135   A3           INC       DPTR
   \   000136   E0           MOVX      A,@DPTR
   \   000137   FB           MOV       R3,A
   \   000138   8E82         MOV       DPL,R6
   \   00013A   8F83         MOV       DPH,R7
   \   00013C   E0           MOVX      A,@DPTR
   \   00013D   F8           MOV       R0,A
   \   00013E   A3           INC       DPTR
   \   00013F   E0           MOVX      A,@DPTR
   \   000140   C8           XCH       A,R0
   \   000141   2414         ADD       A,#0x14
   \   000143   F582         MOV       DPL,A
   \   000145   C8           XCH       A,R0
   \   000146   3400         ADDC      A,#0x0
   \   000148   F583         MOV       DPH,A
   \   00014A   E0           MOVX      A,@DPTR
   \   00014B   F9           MOV       R1,A
   \   00014C   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   00014F   7402         MOV       A,#0x2
   \   000151   12....       LCALL     ?DEALLOC_XSTACK8
   \   000154   E9           MOV       A,R1
   \   000155   F5..         MOV       ?V3,A
   4478              
   4479              //Validate the attribute is found and the access control
   4480              if ( ( attrFound == TRUE ) && 
   4481                   (  (attrRec.attr.accessControl & ACCESS_GLOBAL) || 
   4482                      (GET_BIT( &attrRec.attr.accessControl, ACCESS_CONTROL_MASK ) == pInMsg->hdr.fc.direction ) ) )
   \   000157   7401         MOV       A,#0x1
   \   000159   65..         XRL       A,?V3
   \   00015B   6003         JZ        $+5
   \   00015D   02....       LJMP      ??zclProcessInReadCmd_5 & 0xFFFF
   \   000160   7405         MOV       A,#0x5
   \   000162   12....       LCALL     ?XSTACK_DISP0_8
   \   000165   E0           MOVX      A,@DPTR
   \   000166   A2E6         MOV       C,0xE0 /* A   */.6
   \   000168   4028         JC        ??zclProcessInReadCmd_6
   \   00016A   8E82         MOV       DPL,R6
   \   00016C   8F83         MOV       DPH,R7
   \   00016E   A3           INC       DPTR
   \   00016F   A3           INC       DPTR
   \   000170   E0           MOVX      A,@DPTR
   \   000171   F8           MOV       R0,A
   \   000172   A3           INC       DPTR
   \   000173   E0           MOVX      A,@DPTR
   \   000174   F9           MOV       R1,A
   \   000175   E8           MOV       A,R0
   \   000176   13           RRC       A
   \   000177   13           RRC       A
   \   000178   13           RRC       A
   \   000179   541F         ANL       A,#0x1f
   \   00017B   5401         ANL       A,#0x1
   \   00017D   A2E0         MOV       C,0xE0 /* A   */.0
   \   00017F   92F0         MOV       B.0,C
   \   000181   7405         MOV       A,#0x5
   \   000183   12....       LCALL     ?XSTACK_DISP0_8
   \   000186   E0           MOVX      A,@DPTR
   \   000187   A2E7         MOV       C,0xE0 /* A   */.7
   \   000189   20F001       JB        B.0,??zclProcessInReadCmd_7
   \   00018C   B3           CPL       C
   \                     ??zclProcessInReadCmd_7:
   \   00018D   4003         JC        $+5
   \   00018F   02....       LJMP      ??zclProcessInReadCmd_5 & 0xFFFF
   4483              {
   4484                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   \                     ??zclProcessInReadCmd_6:
   \   000192   7405         MOV       A,#0x5
   \   000194   12....       LCALL     ?XSTACK_DISP0_8
   \   000197   E0           MOVX      A,@DPTR
   \   000198   A2E0         MOV       C,0xE0 /* A   */.0
   \   00019A   5070         JNC       ??zclProcessInReadCmd_8
   4485                {
   4486                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4487                                                        &(pInMsg->msg->srcAddr), &attrRec );
   \   00019C                ; Setup parameters for call to function zclAuthorizeRead
   \   00019C   AC..         MOV       R4,?XSP + 0
   \   00019E   AD..         MOV       R5,?XSP + 1
   \   0001A0   8E82         MOV       DPL,R6
   \   0001A2   8F83         MOV       DPH,R7
   \   0001A4   E0           MOVX      A,@DPTR
   \   0001A5   2406         ADD       A,#0x6
   \   0001A7   FA           MOV       R2,A
   \   0001A8   A3           INC       DPTR
   \   0001A9   E0           MOVX      A,@DPTR
   \   0001AA   3400         ADDC      A,#0x0
   \   0001AC   FB           MOV       R3,A
   \   0001AD   8E82         MOV       DPL,R6
   \   0001AF   8F83         MOV       DPH,R7
   \   0001B1   E0           MOVX      A,@DPTR
   \   0001B2   F8           MOV       R0,A
   \   0001B3   A3           INC       DPTR
   \   0001B4   E0           MOVX      A,@DPTR
   \   0001B5   C8           XCH       A,R0
   \   0001B6   2414         ADD       A,#0x14
   \   0001B8   F582         MOV       DPL,A
   \   0001BA   C8           XCH       A,R0
   \   0001BB   3400         ADDC      A,#0x0
   \   0001BD   F583         MOV       DPH,A
   \   0001BF   E0           MOVX      A,@DPTR
   \   0001C0   F9           MOV       R1,A
   \   0001C1   12....       LCALL     `??zclAuthorizeRead::?relay`; Banked call to: zclAuthorizeRead
   \   0001C4   E9           MOV       A,R1
   \   0001C5   C0E0         PUSH      A
   \   0001C7   85..82       MOV       DPL,?V0
   \   0001CA   85..83       MOV       DPH,?V1
   \   0001CD   A3           INC       DPTR
   \   0001CE   A3           INC       DPTR
   \   0001CF   D0E0         POP       A
   \   0001D1   F0           MOVX      @DPTR,A
   4488                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   0001D2   85..82       MOV       DPL,?V0
   \   0001D5   85..83       MOV       DPH,?V1
   \   0001D8   A3           INC       DPTR
   \   0001D9   A3           INC       DPTR
   \   0001DA   E0           MOVX      A,@DPTR
   \   0001DB   7047         JNZ       ??zclProcessInReadCmd_9
   4489                  {
   4490                    statusRec->data = attrRec.attr.dataPtr;
   \   0001DD   7406         MOV       A,#0x6
   \   0001DF   12....       LCALL     ?XSTACK_DISP0_8
   \   0001E2   E0           MOVX      A,@DPTR
   \   0001E3   F8           MOV       R0,A
   \   0001E4   A3           INC       DPTR
   \   0001E5   E0           MOVX      A,@DPTR
   \   0001E6   F9           MOV       R1,A
   \   0001E7   85..82       MOV       DPL,?V0
   \   0001EA   85..83       MOV       DPH,?V1
   \   0001ED   A3           INC       DPTR
   \   0001EE   A3           INC       DPTR
   \   0001EF   A3           INC       DPTR
   \   0001F0   A3           INC       DPTR
   \   0001F1   E8           MOV       A,R0
   \   0001F2   F0           MOVX      @DPTR,A
   \   0001F3   A3           INC       DPTR
   \   0001F4   E9           MOV       A,R1
   \   0001F5   F0           MOVX      @DPTR,A
   4491                    statusRec->dataType = attrRec.attr.dataType;
   \   0001F6   7404         MOV       A,#0x4
   \   0001F8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001FB   E0           MOVX      A,@DPTR
   \   0001FC   C0E0         PUSH      A
   \   0001FE   85..82       MOV       DPL,?V0
   \   000201   85..83       MOV       DPH,?V1
   \   000204   A3           INC       DPTR
   \   000205   A3           INC       DPTR
   \   000206   A3           INC       DPTR
   \   000207   D0E0         POP       A
   \   000209   F0           MOVX      @DPTR,A
   \   00020A   8018         SJMP      ??zclProcessInReadCmd_9
   4492                  }
   4493                }
   4494                else
   4495                {
   4496                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   \                     ??zclProcessInReadCmd_8:
   \   00020C   85..82       MOV       DPL,?V0
   \   00020F   85..83       MOV       DPH,?V1
   \   000212   A3           INC       DPTR
   \   000213   A3           INC       DPTR
   \   000214   748F         MOV       A,#-0x71
   \   000216   F0           MOVX      @DPTR,A
   \   000217   800B         SJMP      ??zclProcessInReadCmd_9
   4497                }
   4498              }
   4499              else
   4500              {
   4501                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_5:
   \   000219   85..82       MOV       DPL,?V0
   \   00021C   85..83       MOV       DPH,?V1
   \   00021F   A3           INC       DPTR
   \   000220   A3           INC       DPTR
   \   000221   7486         MOV       A,#-0x7a
   \   000223   F0           MOVX      @DPTR,A
   4502              }
   4503            }
   \                     ??zclProcessInReadCmd_9:
   \   000224   05..         INC       ?V2
   \   000226   02....       LJMP      ??zclProcessInReadCmd_3 & 0xFFFF
   4504          
   4505            // Build and send Read Response command
   4506            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4507                             readRspCmd, !pInMsg->hdr.fc.direction,
   4508                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_4:
   \   000229                ; Setup parameters for call to function zcl_SendReadRsp
   \   000229   8E82         MOV       DPL,R6
   \   00022B   8F83         MOV       DPH,R7
   \   00022D   A3           INC       DPTR
   \   00022E   A3           INC       DPTR
   \   00022F   A3           INC       DPTR
   \   000230   A3           INC       DPTR
   \   000231   A3           INC       DPTR
   \   000232   A3           INC       DPTR
   \   000233   E0           MOVX      A,@DPTR
   \   000234   F5..         MOV       ?V0,A
   \   000236   78..         MOV       R0,#?V0
   \   000238   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00023B   75..01       MOV       ?V0,#0x1
   \   00023E   78..         MOV       R0,#?V0
   \   000240   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000243   8E82         MOV       DPL,R6
   \   000245   8F83         MOV       DPH,R7
   \   000247   A3           INC       DPTR
   \   000248   A3           INC       DPTR
   \   000249   E0           MOVX      A,@DPTR
   \   00024A   F8           MOV       R0,A
   \   00024B   A3           INC       DPTR
   \   00024C   E0           MOVX      A,@DPTR
   \   00024D   F9           MOV       R1,A
   \   00024E   E8           MOV       A,R0
   \   00024F   13           RRC       A
   \   000250   13           RRC       A
   \   000251   13           RRC       A
   \   000252   541F         ANL       A,#0x1f
   \   000254   6401         XRL       A,#0x1
   \   000256   5401         ANL       A,#0x1
   \   000258   F5..         MOV       ?V0,A
   \   00025A   78..         MOV       R0,#?V0
   \   00025C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00025F   78..         MOV       R0,#?V8
   \   000261   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000264   8E82         MOV       DPL,R6
   \   000266   8F83         MOV       DPH,R7
   \   000268   E0           MOVX      A,@DPTR
   \   000269   F8           MOV       R0,A
   \   00026A   A3           INC       DPTR
   \   00026B   E0           MOVX      A,@DPTR
   \   00026C   F583         MOV       DPH,A
   \   00026E   8882         MOV       DPL,R0
   \   000270   A3           INC       DPTR
   \   000271   A3           INC       DPTR
   \   000272   A3           INC       DPTR
   \   000273   A3           INC       DPTR
   \   000274   E0           MOVX      A,@DPTR
   \   000275   FC           MOV       R4,A
   \   000276   A3           INC       DPTR
   \   000277   E0           MOVX      A,@DPTR
   \   000278   FD           MOV       R5,A
   \   000279   8E82         MOV       DPL,R6
   \   00027B   8F83         MOV       DPH,R7
   \   00027D   E0           MOVX      A,@DPTR
   \   00027E   2406         ADD       A,#0x6
   \   000280   FA           MOV       R2,A
   \   000281   A3           INC       DPTR
   \   000282   E0           MOVX      A,@DPTR
   \   000283   3400         ADDC      A,#0x0
   \   000285   FB           MOV       R3,A
   \   000286   8E82         MOV       DPL,R6
   \   000288   8F83         MOV       DPH,R7
   \   00028A   E0           MOVX      A,@DPTR
   \   00028B   F8           MOV       R0,A
   \   00028C   A3           INC       DPTR
   \   00028D   E0           MOVX      A,@DPTR
   \   00028E   C8           XCH       A,R0
   \   00028F   2414         ADD       A,#0x14
   \   000291   F582         MOV       DPL,A
   \   000293   C8           XCH       A,R0
   \   000294   3400         ADDC      A,#0x0
   \   000296   F583         MOV       DPH,A
   \   000298   E0           MOVX      A,@DPTR
   \   000299   F9           MOV       R1,A
   \   00029A   12....       LCALL     `??zcl_SendReadRsp::?relay`; Banked call to: zcl_SendReadRsp
   \   00029D   7405         MOV       A,#0x5
   \   00029F   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002A2   E9           MOV       A,R1
   4509            zcl_mem_free( readRspCmd );
   \   0002A3                ; Setup parameters for call to function osal_mem_free
   \   0002A3   AA..         MOV       R2,?V8
   \   0002A5   AB..         MOV       R3,?V9
   \   0002A7   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4510          
   4511            return TRUE;
   \   0002AA   7901         MOV       R1,#0x1
   \                     ??zclProcessInReadCmd_2:
   \   0002AC   7408         MOV       A,#0x8
   \   0002AE   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002B1   7F0C         MOV       R7,#0xc
   \   0002B3   02....       LJMP      ?BANKED_LEAVE_XDATA
   4512          }
   4513          #endif // ZCL_READ
   4514          
   4515          #ifdef ZCL_WRITE
   4516          /*********************************************************************
   4517           * @fn      processInWriteCmd
   4518           *
   4519           * @brief   Process the "Profile" Write and Write No Response Commands
   4520           *
   4521           * @param   pInMsg - incoming message to process
   4522           *
   4523           * @return  TRUE if command processed. FALSE, otherwise.
   4524           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4525          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4526          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   4527            zclWriteCmd_t *writeCmd;
   4528            zclWriteRspCmd_t *writeRspCmd;
   4529            uint8 sendRsp = FALSE;
   \   00000E   75..00       MOV       ?V7,#0x0
   4530            uint8 j = 0;
   \   000011   7E00         MOV       R6,#0x0
   4531            uint8 i;
   4532          
   4533            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000013   E5..         MOV       A,?V0
   \   000015   240C         ADD       A,#0xc
   \   000017   F582         MOV       DPL,A
   \   000019   E4           CLR       A
   \   00001A   35..         ADDC      A,?V1
   \   00001C   F583         MOV       DPH,A
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F8           MOV       R0,A
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F9           MOV       R1,A
   \   000023   88..         MOV       ?V12,R0
   \   000025   89..         MOV       ?V13,R1
   4534            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \   000027   85..82       MOV       DPL,?V0
   \   00002A   85..83       MOV       DPH,?V1
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   6402         XRL       A,#0x2
   \   000037   7041         JNZ       ??zclProcessInWriteCmd_0
   4535            {
   4536              // We need to send a response back - allocate space for it
   4537              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4538                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000039                ; Setup parameters for call to function osal_mem_alloc
   \   000039   85..82       MOV       DPL,?V12
   \   00003C   85..83       MOV       DPH,?V13
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F8           MOV       R0,A
   \   000041   7900         MOV       R1,#0x0
   \   000043   E8           MOV       A,R0
   \   000044   75F003       MOV       B,#0x3
   \   000047   A4           MUL       AB
   \   000048   C8           XCH       A,R0
   \   000049   AAF0         MOV       R2,B
   \   00004B   75F000       MOV       B,#0x0
   \   00004E   A4           MUL       AB
   \   00004F   2A           ADD       A,R2
   \   000050   FA           MOV       R2,A
   \   000051   75F003       MOV       B,#0x3
   \   000054   E9           MOV       A,R1
   \   000055   A4           MUL       AB
   \   000056   2A           ADD       A,R2
   \   000057   F9           MOV       R1,A
   \   000058   E8           MOV       A,R0
   \   000059   2401         ADD       A,#0x1
   \   00005B   FA           MOV       R2,A
   \   00005C   E4           CLR       A
   \   00005D   39           ADDC      A,R1
   \   00005E   FB           MOV       R3,A
   \   00005F   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000062   8A..         MOV       ?V4,R2
   \   000064   8B..         MOV       ?V5,R3
   \   000066   85....       MOV       ?V2,?V4
   \   000069   85....       MOV       ?V3,?V5
   4539              if ( writeRspCmd == NULL )
   \   00006C   E5..         MOV       A,?V2
   \   00006E   45..         ORL       A,?V3
   \   000070   7005         JNZ       ??zclProcessInWriteCmd_1
   4540              {
   4541                return FALSE; // EMBEDDED RETURN
   \   000072   7900         MOV       R1,#0x0
   \   000074   02....       LJMP      ??zclProcessInWriteCmd_2 & 0xFFFF
   4542              }
   4543          
   4544              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   000077   75..01       MOV       ?V7,#0x1
   4545            }
   4546          
   4547            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   00007A   75..00       MOV       ?V10,#0x0
   \                     ??zclProcessInWriteCmd_3:
   \   00007D   85..82       MOV       DPL,?V12
   \   000080   85..83       MOV       DPH,?V13
   \   000083   E0           MOVX      A,@DPTR
   \   000084   F8           MOV       R0,A
   \   000085   E5..         MOV       A,?V10
   \   000087   C3           CLR       C
   \   000088   98           SUBB      A,R0
   \   000089   4003         JC        $+5
   \   00008B   02....       LJMP      ??zclProcessInWriteCmd_4 & 0xFFFF
   4548            {
   4549              zclAttrRec_t attrRec;
   4550              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   00008E   E5..         MOV       A,?V10
   \   000090   F8           MOV       R0,A
   \   000091   7900         MOV       R1,#0x0
   \   000093   E8           MOV       A,R0
   \   000094   75F005       MOV       B,#0x5
   \   000097   A4           MUL       AB
   \   000098   C8           XCH       A,R0
   \   000099   AAF0         MOV       R2,B
   \   00009B   75F000       MOV       B,#0x0
   \   00009E   A4           MUL       AB
   \   00009F   2A           ADD       A,R2
   \   0000A0   FA           MOV       R2,A
   \   0000A1   75F005       MOV       B,#0x5
   \   0000A4   E9           MOV       A,R1
   \   0000A5   A4           MUL       AB
   \   0000A6   2A           ADD       A,R2
   \   0000A7   F9           MOV       R1,A
   \   0000A8   E5..         MOV       A,?V12
   \   0000AA   28           ADD       A,R0
   \   0000AB   F582         MOV       DPL,A
   \   0000AD   E5..         MOV       A,?V13
   \   0000AF   39           ADDC      A,R1
   \   0000B0   F583         MOV       DPH,A
   \   0000B2   A3           INC       DPTR
   \   0000B3   8582..       MOV       ?V8,DPL
   \   0000B6   8583..       MOV       ?V9,DPH
   4551          
   4552              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4553                                   statusRec->attrID, &attrRec ) )
   \   0000B9                ; Setup parameters for call to function zclFindAttrRec
   \   0000B9   7402         MOV       A,#0x2
   \   0000BB   12....       LCALL     ?XSTACK_DISP100_8
   \   0000BE   88..         MOV       ?V4,R0
   \   0000C0   89..         MOV       ?V5,R1
   \   0000C2   78..         MOV       R0,#?V4
   \   0000C4   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C7   85..82       MOV       DPL,?V8
   \   0000CA   85..83       MOV       DPH,?V9
   \   0000CD   E0           MOVX      A,@DPTR
   \   0000CE   FC           MOV       R4,A
   \   0000CF   A3           INC       DPTR
   \   0000D0   E0           MOVX      A,@DPTR
   \   0000D1   FD           MOV       R5,A
   \   0000D2   85..82       MOV       DPL,?V0
   \   0000D5   85..83       MOV       DPH,?V1
   \   0000D8   E0           MOVX      A,@DPTR
   \   0000D9   F8           MOV       R0,A
   \   0000DA   A3           INC       DPTR
   \   0000DB   E0           MOVX      A,@DPTR
   \   0000DC   F583         MOV       DPH,A
   \   0000DE   8882         MOV       DPL,R0
   \   0000E0   A3           INC       DPTR
   \   0000E1   A3           INC       DPTR
   \   0000E2   A3           INC       DPTR
   \   0000E3   A3           INC       DPTR
   \   0000E4   E0           MOVX      A,@DPTR
   \   0000E5   FA           MOV       R2,A
   \   0000E6   A3           INC       DPTR
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   FB           MOV       R3,A
   \   0000E9   85..82       MOV       DPL,?V0
   \   0000EC   85..83       MOV       DPH,?V1
   \   0000EF   E0           MOVX      A,@DPTR
   \   0000F0   F8           MOV       R0,A
   \   0000F1   A3           INC       DPTR
   \   0000F2   E0           MOVX      A,@DPTR
   \   0000F3   C8           XCH       A,R0
   \   0000F4   2414         ADD       A,#0x14
   \   0000F6   F582         MOV       DPL,A
   \   0000F8   C8           XCH       A,R0
   \   0000F9   3400         ADDC      A,#0x0
   \   0000FB   F583         MOV       DPH,A
   \   0000FD   E0           MOVX      A,@DPTR
   \   0000FE   F9           MOV       R1,A
   \   0000FF   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000102   7402         MOV       A,#0x2
   \   000104   12....       LCALL     ?DEALLOC_XSTACK8
   \   000107   E9           MOV       A,R1
   \   000108   7003         JNZ       $+5
   \   00010A   02....       LJMP      ??zclProcessInWriteCmd_5 & 0xFFFF
   4554              {
   4555                if ( GET_BIT( &attrRec.attr.accessControl, ACCESS_CONTROLEXT_MASK ) != pInMsg->hdr.fc.direction )
   \   00010D   85..82       MOV       DPL,?V0
   \   000110   85..83       MOV       DPH,?V1
   \   000113   A3           INC       DPTR
   \   000114   A3           INC       DPTR
   \   000115   E0           MOVX      A,@DPTR
   \   000116   F8           MOV       R0,A
   \   000117   A3           INC       DPTR
   \   000118   E0           MOVX      A,@DPTR
   \   000119   F9           MOV       R1,A
   \   00011A   E8           MOV       A,R0
   \   00011B   13           RRC       A
   \   00011C   13           RRC       A
   \   00011D   13           RRC       A
   \   00011E   541F         ANL       A,#0x1f
   \   000120   5401         ANL       A,#0x1
   \   000122   A2E0         MOV       C,0xE0 /* A   */.0
   \   000124   92F0         MOV       B.0,C
   \   000126   7407         MOV       A,#0x7
   \   000128   12....       LCALL     ?XSTACK_DISP0_8
   \   00012B   E0           MOVX      A,@DPTR
   \   00012C   A2E7         MOV       C,0xE0 /* A   */.7
   \   00012E   20F001       JB        B.0,??zclProcessInWriteCmd_6
   \   000131   B3           CPL       C
   \                     ??zclProcessInWriteCmd_6:
   \   000132   4060         JC        ??zclProcessInWriteCmd_7
   4556                {
   4557                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000134   EE           MOV       A,R6
   \   000135   F8           MOV       R0,A
   \   000136   7900         MOV       R1,#0x0
   \   000138   E8           MOV       A,R0
   \   000139   75F003       MOV       B,#0x3
   \   00013C   A4           MUL       AB
   \   00013D   C8           XCH       A,R0
   \   00013E   AAF0         MOV       R2,B
   \   000140   75F000       MOV       B,#0x0
   \   000143   A4           MUL       AB
   \   000144   2A           ADD       A,R2
   \   000145   FA           MOV       R2,A
   \   000146   75F003       MOV       B,#0x3
   \   000149   E9           MOV       A,R1
   \   00014A   A4           MUL       AB
   \   00014B   2A           ADD       A,R2
   \   00014C   F9           MOV       R1,A
   \   00014D   E5..         MOV       A,?V2
   \   00014F   28           ADD       A,R0
   \   000150   F582         MOV       DPL,A
   \   000152   E5..         MOV       A,?V3
   \   000154   39           ADDC      A,R1
   \   000155   F583         MOV       DPH,A
   \   000157   A3           INC       DPTR
   \   000158   7486         MOV       A,#-0x7a
   \   00015A   F0           MOVX      @DPTR,A
   4558                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   00015B   85..82       MOV       DPL,?V8
   \   00015E   85..83       MOV       DPH,?V9
   \   000161   E0           MOVX      A,@DPTR
   \   000162   FA           MOV       R2,A
   \   000163   A3           INC       DPTR
   \   000164   E0           MOVX      A,@DPTR
   \   000165   FB           MOV       R3,A
   \   000166   EE           MOV       A,R6
   \   000167   F8           MOV       R0,A
   \   000168   7900         MOV       R1,#0x0
   \   00016A   E8           MOV       A,R0
   \   00016B   75F003       MOV       B,#0x3
   \   00016E   A4           MUL       AB
   \   00016F   C8           XCH       A,R0
   \   000170   ACF0         MOV       R4,B
   \   000172   75F000       MOV       B,#0x0
   \   000175   A4           MUL       AB
   \   000176   2C           ADD       A,R4
   \   000177   FC           MOV       R4,A
   \   000178   75F003       MOV       B,#0x3
   \   00017B   E9           MOV       A,R1
   \   00017C   A4           MUL       AB
   \   00017D   2C           ADD       A,R4
   \   00017E   F9           MOV       R1,A
   \   00017F   E5..         MOV       A,?V2
   \   000181   28           ADD       A,R0
   \   000182   F582         MOV       DPL,A
   \   000184   E5..         MOV       A,?V3
   \   000186   39           ADDC      A,R1
   \   000187   F583         MOV       DPH,A
   \   000189   A3           INC       DPTR
   \   00018A   A3           INC       DPTR
   \   00018B   EA           MOV       A,R2
   \   00018C   F0           MOVX      @DPTR,A
   \   00018D   A3           INC       DPTR
   \   00018E   EB           MOV       A,R3
   \   00018F   F0           MOVX      @DPTR,A
   \   000190   0E           INC       R6
   4559                  break;
   \   000191   02....       LJMP      ??zclProcessInWriteCmd_4 & 0xFFFF
   4560                }
   4561                if ( statusRec->dataType == attrRec.attr.dataType )
   \                     ??zclProcessInWriteCmd_7:
   \   000194   85..82       MOV       DPL,?V8
   \   000197   85..83       MOV       DPH,?V9
   \   00019A   A3           INC       DPTR
   \   00019B   A3           INC       DPTR
   \   00019C   E0           MOVX      A,@DPTR
   \   00019D   F8           MOV       R0,A
   \   00019E   7406         MOV       A,#0x6
   \   0001A0   12....       LCALL     ?XSTACK_DISP0_8
   \   0001A3   E0           MOVX      A,@DPTR
   \   0001A4   68           XRL       A,R0
   \   0001A5   6003         JZ        $+5
   \   0001A7   02....       LJMP      ??zclProcessInWriteCmd_8 & 0xFFFF
   4562                {
   4563                  uint8 status;
   4564          
   4565                  // Write the new attribute value
   4566                  if ( attrRec.attr.dataPtr != NULL )
   \   0001AA   7408         MOV       A,#0x8
   \   0001AC   12....       LCALL     ?XSTACK_DISP0_8
   \   0001AF   E0           MOVX      A,@DPTR
   \   0001B0   F8           MOV       R0,A
   \   0001B1   A3           INC       DPTR
   \   0001B2   E0           MOVX      A,@DPTR
   \   0001B3   F9           MOV       R1,A
   \   0001B4   E8           MOV       A,R0
   \   0001B5   49           ORL       A,R1
   \   0001B6   7003         JNZ       $+5
   \   0001B8   02....       LJMP      ??zclProcessInWriteCmd_9 & 0xFFFF
   4567                  {
   4568                    //Handle special case for Identify
   4569                    if((pInMsg->msg->clusterId == ZCL_CLUSTER_ID_GEN_IDENTIFY) && (statusRec->attrID == ATTRID_IDENTIFY_TIME))
   \   0001BB   85..82       MOV       DPL,?V0
   \   0001BE   85..83       MOV       DPH,?V1
   \   0001C1   E0           MOVX      A,@DPTR
   \   0001C2   F8           MOV       R0,A
   \   0001C3   A3           INC       DPTR
   \   0001C4   E0           MOVX      A,@DPTR
   \   0001C5   F583         MOV       DPH,A
   \   0001C7   8882         MOV       DPL,R0
   \   0001C9   A3           INC       DPTR
   \   0001CA   A3           INC       DPTR
   \   0001CB   A3           INC       DPTR
   \   0001CC   A3           INC       DPTR
   \   0001CD   E0           MOVX      A,@DPTR
   \   0001CE   6403         XRL       A,#0x3
   \   0001D0   7004         JNZ       ??zclProcessInWriteCmd_10
   \   0001D2   A3           INC       DPTR
   \   0001D3   E0           MOVX      A,@DPTR
   \   0001D4   6400         XRL       A,#0x0
   \                     ??zclProcessInWriteCmd_10:
   \   0001D6   7060         JNZ       ??zclProcessInWriteCmd_11
   \   0001D8   85..82       MOV       DPL,?V8
   \   0001DB   85..83       MOV       DPH,?V9
   \   0001DE   E0           MOVX      A,@DPTR
   \   0001DF   F8           MOV       R0,A
   \   0001E0   A3           INC       DPTR
   \   0001E1   E0           MOVX      A,@DPTR
   \   0001E2   F9           MOV       R1,A
   \   0001E3   E8           MOV       A,R0
   \   0001E4   49           ORL       A,R1
   \   0001E5   7051         JNZ       ??zclProcessInWriteCmd_11
   4570                    {
   4571                      uint16 identifyTime; 
   4572                            
   4573                      osal_memcpy((uint8*)&identifyTime,statusRec->attrData,sizeof(uint16));
   \   0001E7                ; Setup parameters for call to function osal_memcpy
   \   0001E7   85..82       MOV       DPL,?V8
   \   0001EA   85..83       MOV       DPH,?V9
   \   0001ED   A3           INC       DPTR
   \   0001EE   A3           INC       DPTR
   \   0001EF   A3           INC       DPTR
   \   0001F0   E0           MOVX      A,@DPTR
   \   0001F1   F5..         MOV       ?V4,A
   \   0001F3   A3           INC       DPTR
   \   0001F4   E0           MOVX      A,@DPTR
   \   0001F5   F5..         MOV       ?V5,A
   \   0001F7   75..00       MOV       ?V6,#0x0
   \   0001FA   78..         MOV       R0,#?V4
   \   0001FC   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0001FF   7C02         MOV       R4,#0x2
   \   000201   7D00         MOV       R5,#0x0
   \   000203   7403         MOV       A,#0x3
   \   000205   12....       LCALL     ?XSTACK_DISP101_8
   \   000208   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00020B   7403         MOV       A,#0x3
   \   00020D   12....       LCALL     ?DEALLOC_XSTACK8
   4574                                  
   4575                      bdb_ZclIdentifyCmdInd(identifyTime, pInMsg->msg->endPoint);
   \   000210                ; Setup parameters for call to function bdb_ZclIdentifyCmdInd
   \   000210   85..82       MOV       DPL,?V0
   \   000213   85..83       MOV       DPH,?V1
   \   000216   E0           MOVX      A,@DPTR
   \   000217   F8           MOV       R0,A
   \   000218   A3           INC       DPTR
   \   000219   E0           MOVX      A,@DPTR
   \   00021A   C8           XCH       A,R0
   \   00021B   2414         ADD       A,#0x14
   \   00021D   F582         MOV       DPL,A
   \   00021F   C8           XCH       A,R0
   \   000220   3400         ADDC      A,#0x0
   \   000222   F583         MOV       DPH,A
   \   000224   E0           MOVX      A,@DPTR
   \   000225   F9           MOV       R1,A
   \   000226   85..82       MOV       DPL,?XSP + 0
   \   000229   85..83       MOV       DPH,?XSP + 1
   \   00022C   E0           MOVX      A,@DPTR
   \   00022D   FA           MOV       R2,A
   \   00022E   A3           INC       DPTR
   \   00022F   E0           MOVX      A,@DPTR
   \   000230   FB           MOV       R3,A
   \   000231   12....       LCALL     `??bdb_ZclIdentifyCmdInd::?relay`; Banked call to: bdb_ZclIdentifyCmdInd
   4576                      
   4577                      status = ZCL_STATUS_SUCCESS;
   \   000234   7F00         MOV       R7,#0x0
   \   000236   807B         SJMP      ??zclProcessInWriteCmd_12
   4578                    }          
   4579                    else
   4580                    {                
   4581                      status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4582                                                 &attrRec, statusRec );
   \                     ??zclProcessInWriteCmd_11:
   \   000238                ; Setup parameters for call to function zclWriteAttrData
   \   000238   78..         MOV       R0,#?V8
   \   00023A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00023D   7404         MOV       A,#0x4
   \   00023F   12....       LCALL     ?XSTACK_DISP102_8
   \   000242   85..82       MOV       DPL,?V0
   \   000245   85..83       MOV       DPH,?V1
   \   000248   E0           MOVX      A,@DPTR
   \   000249   2406         ADD       A,#0x6
   \   00024B   FA           MOV       R2,A
   \   00024C   A3           INC       DPTR
   \   00024D   E0           MOVX      A,@DPTR
   \   00024E   3400         ADDC      A,#0x0
   \   000250   FB           MOV       R3,A
   \   000251   85..82       MOV       DPL,?V0
   \   000254   85..83       MOV       DPH,?V1
   \   000257   E0           MOVX      A,@DPTR
   \   000258   F8           MOV       R0,A
   \   000259   A3           INC       DPTR
   \   00025A   E0           MOVX      A,@DPTR
   \   00025B   C8           XCH       A,R0
   \   00025C   2414         ADD       A,#0x14
   \   00025E   F582         MOV       DPL,A
   \   000260   C8           XCH       A,R0
   \   000261   3400         ADDC      A,#0x0
   \   000263   F583         MOV       DPH,A
   \   000265   E0           MOVX      A,@DPTR
   \   000266   F9           MOV       R1,A
   \   000267   12....       LCALL     `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   00026A   7402         MOV       A,#0x2
   \   00026C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00026F   E9           MOV       A,R1
   \   000270   FF           MOV       R7,A
   \   000271   8040         SJMP      ??zclProcessInWriteCmd_12
   4583                    }
   4584                  }
   4585                  else // Use CB
   4586                  {
   4587                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4588                                                      &attrRec, statusRec->attrData );
   \                     ??zclProcessInWriteCmd_9:
   \   000273                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000273   85..82       MOV       DPL,?V8
   \   000276   85..83       MOV       DPH,?V9
   \   000279   A3           INC       DPTR
   \   00027A   A3           INC       DPTR
   \   00027B   A3           INC       DPTR
   \   00027C   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00027F   7404         MOV       A,#0x4
   \   000281   12....       LCALL     ?XSTACK_DISP102_8
   \   000284   85..82       MOV       DPL,?V0
   \   000287   85..83       MOV       DPH,?V1
   \   00028A   E0           MOVX      A,@DPTR
   \   00028B   2406         ADD       A,#0x6
   \   00028D   FA           MOV       R2,A
   \   00028E   A3           INC       DPTR
   \   00028F   E0           MOVX      A,@DPTR
   \   000290   3400         ADDC      A,#0x0
   \   000292   FB           MOV       R3,A
   \   000293   85..82       MOV       DPL,?V0
   \   000296   85..83       MOV       DPH,?V1
   \   000299   E0           MOVX      A,@DPTR
   \   00029A   F8           MOV       R0,A
   \   00029B   A3           INC       DPTR
   \   00029C   E0           MOVX      A,@DPTR
   \   00029D   C8           XCH       A,R0
   \   00029E   2414         ADD       A,#0x14
   \   0002A0   F582         MOV       DPL,A
   \   0002A2   C8           XCH       A,R0
   \   0002A3   3400         ADDC      A,#0x0
   \   0002A5   F583         MOV       DPH,A
   \   0002A7   E0           MOVX      A,@DPTR
   \   0002A8   F9           MOV       R1,A
   \   0002A9   12....       LCALL     `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \   0002AC   7402         MOV       A,#0x2
   \   0002AE   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002B1   E9           MOV       A,R1
   \   0002B2   FF           MOV       R7,A
   4589                  }
   4590          
   4591                  // If successful, a write attribute status record shall NOT be generated
   4592                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   \                     ??zclProcessInWriteCmd_12:
   \   0002B3   E5..         MOV       A,?V7
   \   0002B5   7003         JNZ       $+5
   \   0002B7   02....       LJMP      ??zclProcessInWriteCmd_13 & 0xFFFF
   \   0002BA   EF           MOV       A,R7
   \   0002BB   7003         JNZ       $+5
   \   0002BD   02....       LJMP      ??zclProcessInWriteCmd_13 & 0xFFFF
   4593                  {
   4594                    // Attribute is read only - move on to the next write attribute record
   4595                    writeRspCmd->attrList[j].status = status;
   \   0002C0   EF           MOV       A,R7
   \   0002C1   C0E0         PUSH      A
   \   0002C3   EE           MOV       A,R6
   \   0002C4   F8           MOV       R0,A
   \   0002C5   7900         MOV       R1,#0x0
   \   0002C7   E8           MOV       A,R0
   \   0002C8   75F003       MOV       B,#0x3
   \   0002CB   A4           MUL       AB
   \   0002CC   C8           XCH       A,R0
   \   0002CD   AAF0         MOV       R2,B
   \   0002CF   75F000       MOV       B,#0x0
   \   0002D2   A4           MUL       AB
   \   0002D3   2A           ADD       A,R2
   \   0002D4   FA           MOV       R2,A
   \   0002D5   75F003       MOV       B,#0x3
   \   0002D8   E9           MOV       A,R1
   \   0002D9   A4           MUL       AB
   \   0002DA   2A           ADD       A,R2
   \   0002DB   F9           MOV       R1,A
   \   0002DC   E5..         MOV       A,?V2
   \   0002DE   28           ADD       A,R0
   \   0002DF   F582         MOV       DPL,A
   \   0002E1   E5..         MOV       A,?V3
   \   0002E3   39           ADDC      A,R1
   \   0002E4   F583         MOV       DPH,A
   \   0002E6   A3           INC       DPTR
   \   0002E7   D0E0         POP       A
   \   0002E9   F0           MOVX      @DPTR,A
   4596                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   0002EA   85..82       MOV       DPL,?V8
   \   0002ED   85..83       MOV       DPH,?V9
   \   0002F0   E0           MOVX      A,@DPTR
   \   0002F1   FA           MOV       R2,A
   \   0002F2   A3           INC       DPTR
   \   0002F3   E0           MOVX      A,@DPTR
   \   0002F4   FB           MOV       R3,A
   \   0002F5   EE           MOV       A,R6
   \   0002F6   F8           MOV       R0,A
   \   0002F7   7900         MOV       R1,#0x0
   \   0002F9   E8           MOV       A,R0
   \   0002FA   75F003       MOV       B,#0x3
   \   0002FD   A4           MUL       AB
   \   0002FE   C8           XCH       A,R0
   \   0002FF   ACF0         MOV       R4,B
   \   000301   75F000       MOV       B,#0x0
   \   000304   A4           MUL       AB
   \   000305   2C           ADD       A,R4
   \   000306   FC           MOV       R4,A
   \   000307   75F003       MOV       B,#0x3
   \   00030A   E9           MOV       A,R1
   \   00030B   A4           MUL       AB
   \   00030C   2C           ADD       A,R4
   \   00030D   F9           MOV       R1,A
   \   00030E   E5..         MOV       A,?V2
   \   000310   28           ADD       A,R0
   \   000311   F582         MOV       DPL,A
   \   000313   E5..         MOV       A,?V3
   \   000315   39           ADDC      A,R1
   \   000316   F583         MOV       DPH,A
   \   000318   A3           INC       DPTR
   \   000319   A3           INC       DPTR
   \   00031A   EA           MOV       A,R2
   \   00031B   F0           MOVX      @DPTR,A
   \   00031C   A3           INC       DPTR
   \   00031D   EB           MOV       A,R3
   \   00031E   F0           MOVX      @DPTR,A
   \   00031F   0E           INC       R6
   \   000320   02....       LJMP      ??zclProcessInWriteCmd_13 & 0xFFFF
   4597                  }
   4598                }
   4599                else
   4600                {
   4601                  // Attribute data type is incorrect - move on to the next write attribute record
   4602                  if ( sendRsp )
   \                     ??zclProcessInWriteCmd_8:
   \   000323   E5..         MOV       A,?V7
   \   000325   7003         JNZ       $+5
   \   000327   02....       LJMP      ??zclProcessInWriteCmd_13 & 0xFFFF
   4603                  {
   4604                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   \   00032A   EE           MOV       A,R6
   \   00032B   F8           MOV       R0,A
   \   00032C   7900         MOV       R1,#0x0
   \   00032E   E8           MOV       A,R0
   \   00032F   75F003       MOV       B,#0x3
   \   000332   A4           MUL       AB
   \   000333   C8           XCH       A,R0
   \   000334   AAF0         MOV       R2,B
   \   000336   75F000       MOV       B,#0x0
   \   000339   A4           MUL       AB
   \   00033A   2A           ADD       A,R2
   \   00033B   FA           MOV       R2,A
   \   00033C   75F003       MOV       B,#0x3
   \   00033F   E9           MOV       A,R1
   \   000340   A4           MUL       AB
   \   000341   2A           ADD       A,R2
   \   000342   F9           MOV       R1,A
   \   000343   E5..         MOV       A,?V2
   \   000345   28           ADD       A,R0
   \   000346   F582         MOV       DPL,A
   \   000348   E5..         MOV       A,?V3
   \   00034A   39           ADDC      A,R1
   \   00034B   F583         MOV       DPH,A
   \   00034D   A3           INC       DPTR
   \   00034E   748D         MOV       A,#-0x73
   \   000350   F0           MOVX      @DPTR,A
   4605                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000351   85..82       MOV       DPL,?V8
   \   000354   85..83       MOV       DPH,?V9
   \   000357   E0           MOVX      A,@DPTR
   \   000358   FA           MOV       R2,A
   \   000359   A3           INC       DPTR
   \   00035A   E0           MOVX      A,@DPTR
   \   00035B   FB           MOV       R3,A
   \   00035C   EE           MOV       A,R6
   \   00035D   F8           MOV       R0,A
   \   00035E   7900         MOV       R1,#0x0
   \   000360   E8           MOV       A,R0
   \   000361   75F003       MOV       B,#0x3
   \   000364   A4           MUL       AB
   \   000365   C8           XCH       A,R0
   \   000366   ACF0         MOV       R4,B
   \   000368   75F000       MOV       B,#0x0
   \   00036B   A4           MUL       AB
   \   00036C   2C           ADD       A,R4
   \   00036D   FC           MOV       R4,A
   \   00036E   75F003       MOV       B,#0x3
   \   000371   E9           MOV       A,R1
   \   000372   A4           MUL       AB
   \   000373   2C           ADD       A,R4
   \   000374   F9           MOV       R1,A
   \   000375   E5..         MOV       A,?V2
   \   000377   28           ADD       A,R0
   \   000378   F582         MOV       DPL,A
   \   00037A   E5..         MOV       A,?V3
   \   00037C   39           ADDC      A,R1
   \   00037D   F583         MOV       DPH,A
   \   00037F   A3           INC       DPTR
   \   000380   A3           INC       DPTR
   \   000381   EA           MOV       A,R2
   \   000382   F0           MOVX      @DPTR,A
   \   000383   A3           INC       DPTR
   \   000384   EB           MOV       A,R3
   \   000385   F0           MOVX      @DPTR,A
   \   000386   0E           INC       R6
   \   000387   8061         SJMP      ??zclProcessInWriteCmd_13
   4606                  }
   4607                }
   4608              }
   4609              else
   4610              {
   4611                // Attribute is not supported - move on to the next write attribute record
   4612                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_5:
   \   000389   E5..         MOV       A,?V7
   \   00038B   605D         JZ        ??zclProcessInWriteCmd_13
   4613                {
   4614                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   00038D   EE           MOV       A,R6
   \   00038E   F8           MOV       R0,A
   \   00038F   7900         MOV       R1,#0x0
   \   000391   E8           MOV       A,R0
   \   000392   75F003       MOV       B,#0x3
   \   000395   A4           MUL       AB
   \   000396   C8           XCH       A,R0
   \   000397   AAF0         MOV       R2,B
   \   000399   75F000       MOV       B,#0x0
   \   00039C   A4           MUL       AB
   \   00039D   2A           ADD       A,R2
   \   00039E   FA           MOV       R2,A
   \   00039F   75F003       MOV       B,#0x3
   \   0003A2   E9           MOV       A,R1
   \   0003A3   A4           MUL       AB
   \   0003A4   2A           ADD       A,R2
   \   0003A5   F9           MOV       R1,A
   \   0003A6   E5..         MOV       A,?V2
   \   0003A8   28           ADD       A,R0
   \   0003A9   F582         MOV       DPL,A
   \   0003AB   E5..         MOV       A,?V3
   \   0003AD   39           ADDC      A,R1
   \   0003AE   F583         MOV       DPH,A
   \   0003B0   A3           INC       DPTR
   \   0003B1   7486         MOV       A,#-0x7a
   \   0003B3   F0           MOVX      @DPTR,A
   4615                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   0003B4   85..82       MOV       DPL,?V8
   \   0003B7   85..83       MOV       DPH,?V9
   \   0003BA   E0           MOVX      A,@DPTR
   \   0003BB   FA           MOV       R2,A
   \   0003BC   A3           INC       DPTR
   \   0003BD   E0           MOVX      A,@DPTR
   \   0003BE   FB           MOV       R3,A
   \   0003BF   EE           MOV       A,R6
   \   0003C0   F8           MOV       R0,A
   \   0003C1   7900         MOV       R1,#0x0
   \   0003C3   E8           MOV       A,R0
   \   0003C4   75F003       MOV       B,#0x3
   \   0003C7   A4           MUL       AB
   \   0003C8   C8           XCH       A,R0
   \   0003C9   ACF0         MOV       R4,B
   \   0003CB   75F000       MOV       B,#0x0
   \   0003CE   A4           MUL       AB
   \   0003CF   2C           ADD       A,R4
   \   0003D0   FC           MOV       R4,A
   \   0003D1   75F003       MOV       B,#0x3
   \   0003D4   E9           MOV       A,R1
   \   0003D5   A4           MUL       AB
   \   0003D6   2C           ADD       A,R4
   \   0003D7   F9           MOV       R1,A
   \   0003D8   E5..         MOV       A,?V2
   \   0003DA   28           ADD       A,R0
   \   0003DB   F582         MOV       DPL,A
   \   0003DD   E5..         MOV       A,?V3
   \   0003DF   39           ADDC      A,R1
   \   0003E0   F583         MOV       DPH,A
   \   0003E2   A3           INC       DPTR
   \   0003E3   A3           INC       DPTR
   \   0003E4   EA           MOV       A,R2
   \   0003E5   F0           MOVX      @DPTR,A
   \   0003E6   A3           INC       DPTR
   \   0003E7   EB           MOV       A,R3
   \   0003E8   F0           MOVX      @DPTR,A
   \   0003E9   0E           INC       R6
   4616                }
   4617              }
   4618            } // for loop
   \                     ??zclProcessInWriteCmd_13:
   \   0003EA   05..         INC       ?V10
   \   0003EC   02....       LJMP      ??zclProcessInWriteCmd_3 & 0xFFFF
   4619          
   4620            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   0003EF   E5..         MOV       A,?V7
   \   0003F1   7003         JNZ       $+5
   \   0003F3   02....       LJMP      ??zclProcessInWriteCmd_14 & 0xFFFF
   4621            {
   4622              writeRspCmd->numAttr = j;
   \   0003F6   EE           MOV       A,R6
   \   0003F7   C0E0         PUSH      A
   \   0003F9   85..82       MOV       DPL,?V2
   \   0003FC   85..83       MOV       DPH,?V3
   \   0003FF   D0E0         POP       A
   \   000401   F0           MOVX      @DPTR,A
   4623              if ( writeRspCmd->numAttr == 0 )
   \   000402   85..82       MOV       DPL,?V2
   \   000405   85..83       MOV       DPH,?V3
   \   000408   E0           MOVX      A,@DPTR
   \   000409   7013         JNZ       ??zclProcessInWriteCmd_15
   4624              {
   4625                // Since all records were written successful, include a single status record
   4626                // in the resonse command with the status field set to SUCCESS and the
   4627                // attribute ID field omitted.
   4628                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00040B   85..82       MOV       DPL,?V2
   \   00040E   85..83       MOV       DPH,?V3
   \   000411   A3           INC       DPTR
   \   000412   7400         MOV       A,#0x0
   \   000414   F0           MOVX      @DPTR,A
   4629                writeRspCmd->numAttr = 1;
   \   000415   85..82       MOV       DPL,?V2
   \   000418   85..83       MOV       DPH,?V3
   \   00041B   7401         MOV       A,#0x1
   \   00041D   F0           MOVX      @DPTR,A
   4630              }
   4631          
   4632              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4633                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4634                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_15:
   \   00041E                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00041E   85..82       MOV       DPL,?V0
   \   000421   85..83       MOV       DPH,?V1
   \   000424   A3           INC       DPTR
   \   000425   A3           INC       DPTR
   \   000426   A3           INC       DPTR
   \   000427   A3           INC       DPTR
   \   000428   A3           INC       DPTR
   \   000429   A3           INC       DPTR
   \   00042A   E0           MOVX      A,@DPTR
   \   00042B   F5..         MOV       ?V4,A
   \   00042D   78..         MOV       R0,#?V4
   \   00042F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000432   75..01       MOV       ?V4,#0x1
   \   000435   78..         MOV       R0,#?V4
   \   000437   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00043A   85..82       MOV       DPL,?V0
   \   00043D   85..83       MOV       DPH,?V1
   \   000440   A3           INC       DPTR
   \   000441   A3           INC       DPTR
   \   000442   E0           MOVX      A,@DPTR
   \   000443   F8           MOV       R0,A
   \   000444   A3           INC       DPTR
   \   000445   E0           MOVX      A,@DPTR
   \   000446   F9           MOV       R1,A
   \   000447   E8           MOV       A,R0
   \   000448   13           RRC       A
   \   000449   13           RRC       A
   \   00044A   13           RRC       A
   \   00044B   541F         ANL       A,#0x1f
   \   00044D   6401         XRL       A,#0x1
   \   00044F   5401         ANL       A,#0x1
   \   000451   F5..         MOV       ?V4,A
   \   000453   78..         MOV       R0,#?V4
   \   000455   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000458   78..         MOV       R0,#?V2
   \   00045A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00045D   85..82       MOV       DPL,?V0
   \   000460   85..83       MOV       DPH,?V1
   \   000463   E0           MOVX      A,@DPTR
   \   000464   F8           MOV       R0,A
   \   000465   A3           INC       DPTR
   \   000466   E0           MOVX      A,@DPTR
   \   000467   F583         MOV       DPH,A
   \   000469   8882         MOV       DPL,R0
   \   00046B   A3           INC       DPTR
   \   00046C   A3           INC       DPTR
   \   00046D   A3           INC       DPTR
   \   00046E   A3           INC       DPTR
   \   00046F   E0           MOVX      A,@DPTR
   \   000470   FC           MOV       R4,A
   \   000471   A3           INC       DPTR
   \   000472   E0           MOVX      A,@DPTR
   \   000473   FD           MOV       R5,A
   \   000474   85..82       MOV       DPL,?V0
   \   000477   85..83       MOV       DPH,?V1
   \   00047A   E0           MOVX      A,@DPTR
   \   00047B   2406         ADD       A,#0x6
   \   00047D   FA           MOV       R2,A
   \   00047E   A3           INC       DPTR
   \   00047F   E0           MOVX      A,@DPTR
   \   000480   3400         ADDC      A,#0x0
   \   000482   FB           MOV       R3,A
   \   000483   85..82       MOV       DPL,?V0
   \   000486   85..83       MOV       DPH,?V1
   \   000489   E0           MOVX      A,@DPTR
   \   00048A   F8           MOV       R0,A
   \   00048B   A3           INC       DPTR
   \   00048C   E0           MOVX      A,@DPTR
   \   00048D   C8           XCH       A,R0
   \   00048E   2414         ADD       A,#0x14
   \   000490   F582         MOV       DPL,A
   \   000492   C8           XCH       A,R0
   \   000493   3400         ADDC      A,#0x0
   \   000495   F583         MOV       DPH,A
   \   000497   E0           MOVX      A,@DPTR
   \   000498   F9           MOV       R1,A
   \   000499   12....       LCALL     `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   00049C   7405         MOV       A,#0x5
   \   00049E   12....       LCALL     ?DEALLOC_XSTACK8
   \   0004A1   E9           MOV       A,R1
   4635              zcl_mem_free( writeRspCmd );
   \   0004A2                ; Setup parameters for call to function osal_mem_free
   \   0004A2   AA..         MOV       R2,?V2
   \   0004A4   AB..         MOV       R3,?V3
   \   0004A6   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4636            }
   4637          
   4638            return TRUE;
   \                     ??zclProcessInWriteCmd_14:
   \   0004A9   7901         MOV       R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   0004AB   740A         MOV       A,#0xa
   \   0004AD   12....       LCALL     ?DEALLOC_XSTACK8
   \   0004B0   7F0E         MOV       R7,#0xe
   \   0004B2   02....       LJMP      ?BANKED_LEAVE_XDATA
   4639          }
   4640          
   4641          /*********************************************************************
   4642           * @fn      zclRevertWriteUndividedCmd
   4643           *
   4644           * @brief   Revert the "Profile" Write Undevided Command
   4645           *
   4646           * @param   pInMsg - incoming message to process
   4647           * @param   curWriteRec - old data
   4648           * @param   numAttr - number of attributes to be reverted
   4649           *
   4650           * @return  none
   4651           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4652          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4653                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4654          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V8,R2
   \   00000C   8B..         MOV       ?V9,R3
   \   00000E   8C..         MOV       ?V12,R4
   \   000010   8D..         MOV       ?V13,R5
   \   000012   741E         MOV       A,#0x1e
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F5..         MOV       ?V10,A
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F5..         MOV       ?V11,A
   4655            uint8 i;
   4656          
   4657            for ( i = 0; i < numAttr; i++ )
   \   00001E   7E00         MOV       R6,#0x0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   000020   EE           MOV       A,R6
   \   000021   F8           MOV       R0,A
   \   000022   7900         MOV       R1,#0x0
   \   000024   C3           CLR       C
   \   000025   E8           MOV       A,R0
   \   000026   95..         SUBB      A,?V10
   \   000028   E9           MOV       A,R1
   \   000029   95..         SUBB      A,?V11
   \   00002B   4003         JC        $+5
   \   00002D   02....       LJMP      ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   4658            {
   4659              zclAttrRec_t attrRec;
   4660              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   \   000030   EE           MOV       A,R6
   \   000031   F8           MOV       R0,A
   \   000032   7900         MOV       R1,#0x0
   \   000034   E8           MOV       A,R0
   \   000035   75F005       MOV       B,#0x5
   \   000038   A4           MUL       AB
   \   000039   C8           XCH       A,R0
   \   00003A   AAF0         MOV       R2,B
   \   00003C   75F000       MOV       B,#0x0
   \   00003F   A4           MUL       AB
   \   000040   2A           ADD       A,R2
   \   000041   FA           MOV       R2,A
   \   000042   75F005       MOV       B,#0x5
   \   000045   E9           MOV       A,R1
   \   000046   A4           MUL       AB
   \   000047   2A           ADD       A,R2
   \   000048   F9           MOV       R1,A
   \   000049   E5..         MOV       A,?V12
   \   00004B   28           ADD       A,R0
   \   00004C   F5..         MOV       ?V0,A
   \   00004E   E5..         MOV       A,?V13
   \   000050   39           ADDC      A,R1
   \   000051   F5..         MOV       ?V1,A
   4661          
   4662              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4663                                    statusRec->attrID, &attrRec ) )
   \   000053                ; Setup parameters for call to function zclFindAttrRec
   \   000053   A8..         MOV       R0,?XSP + 0
   \   000055   A9..         MOV       R1,?XSP + 1
   \   000057   88..         MOV       ?V2,R0
   \   000059   89..         MOV       ?V3,R1
   \   00005B   78..         MOV       R0,#?V2
   \   00005D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000060   85..82       MOV       DPL,?V0
   \   000063   85..83       MOV       DPH,?V1
   \   000066   E0           MOVX      A,@DPTR
   \   000067   FC           MOV       R4,A
   \   000068   A3           INC       DPTR
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   FD           MOV       R5,A
   \   00006B   85..82       MOV       DPL,?V8
   \   00006E   85..83       MOV       DPH,?V9
   \   000071   E0           MOVX      A,@DPTR
   \   000072   F8           MOV       R0,A
   \   000073   A3           INC       DPTR
   \   000074   E0           MOVX      A,@DPTR
   \   000075   F583         MOV       DPH,A
   \   000077   8882         MOV       DPL,R0
   \   000079   A3           INC       DPTR
   \   00007A   A3           INC       DPTR
   \   00007B   A3           INC       DPTR
   \   00007C   A3           INC       DPTR
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   FA           MOV       R2,A
   \   00007F   A3           INC       DPTR
   \   000080   E0           MOVX      A,@DPTR
   \   000081   FB           MOV       R3,A
   \   000082   85..82       MOV       DPL,?V8
   \   000085   85..83       MOV       DPH,?V9
   \   000088   E0           MOVX      A,@DPTR
   \   000089   F8           MOV       R0,A
   \   00008A   A3           INC       DPTR
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   C8           XCH       A,R0
   \   00008D   2414         ADD       A,#0x14
   \   00008F   F582         MOV       DPL,A
   \   000091   C8           XCH       A,R0
   \   000092   3400         ADDC      A,#0x0
   \   000094   F583         MOV       DPH,A
   \   000096   E0           MOVX      A,@DPTR
   \   000097   F9           MOV       R1,A
   \   000098   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   00009B   7402         MOV       A,#0x2
   \   00009D   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A0   E9           MOV       A,R1
   \   0000A1   7003         JNZ       $+5
   \   0000A3   02....       LJMP      ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   4664              {
   4665                break; // should never happen
   4666              }
   4667          
   4668              if ( attrRec.attr.dataPtr != NULL )
   \   0000A6   7406         MOV       A,#0x6
   \   0000A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   F8           MOV       R0,A
   \   0000AD   A3           INC       DPTR
   \   0000AE   E0           MOVX      A,@DPTR
   \   0000AF   F9           MOV       R1,A
   \   0000B0   E8           MOV       A,R0
   \   0000B1   49           ORL       A,R1
   \   0000B2   6052         JZ        ??zclRevertWriteUndividedCmd_2
   4669              {
   4670                // Just copy the old data back - no need to validate the data
   4671                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   \   0000B4                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000B4   85..82       MOV       DPL,?V0
   \   0000B7   85..83       MOV       DPH,?V1
   \   0000BA   A3           INC       DPTR
   \   0000BB   A3           INC       DPTR
   \   0000BC   A3           INC       DPTR
   \   0000BD   E0           MOVX      A,@DPTR
   \   0000BE   FA           MOV       R2,A
   \   0000BF   A3           INC       DPTR
   \   0000C0   E0           MOVX      A,@DPTR
   \   0000C1   FB           MOV       R3,A
   \   0000C2   7404         MOV       A,#0x4
   \   0000C4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C7   E0           MOVX      A,@DPTR
   \   0000C8   F9           MOV       R1,A
   \   0000C9   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000CC   8A..         MOV       ?V4,R2
   \   0000CE   8B..         MOV       ?V5,R3
   \   0000D0   85....       MOV       ?V2,?V4
   \   0000D3   85....       MOV       ?V3,?V5
   4672                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   \   0000D6                ; Setup parameters for call to function osal_memcpy
   \   0000D6   85..82       MOV       DPL,?V0
   \   0000D9   85..83       MOV       DPH,?V1
   \   0000DC   A3           INC       DPTR
   \   0000DD   A3           INC       DPTR
   \   0000DE   A3           INC       DPTR
   \   0000DF   E0           MOVX      A,@DPTR
   \   0000E0   F5..         MOV       ?V4,A
   \   0000E2   A3           INC       DPTR
   \   0000E3   E0           MOVX      A,@DPTR
   \   0000E4   F5..         MOV       ?V5,A
   \   0000E6   75..00       MOV       ?V6,#0x0
   \   0000E9   78..         MOV       R0,#?V4
   \   0000EB   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000EE   AC..         MOV       R4,?V2
   \   0000F0   AD..         MOV       R5,?V3
   \   0000F2   7409         MOV       A,#0x9
   \   0000F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F7   E0           MOVX      A,@DPTR
   \   0000F8   FA           MOV       R2,A
   \   0000F9   A3           INC       DPTR
   \   0000FA   E0           MOVX      A,@DPTR
   \   0000FB   FB           MOV       R3,A
   \   0000FC   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000FF   7403         MOV       A,#0x3
   \   000101   12....       LCALL     ?DEALLOC_XSTACK8
   \   000104   803F         SJMP      ??zclRevertWriteUndividedCmd_3
   4673              }
   4674              else // Use CB
   4675              {
   4676                // Write the old data back
   4677                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4678                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_2:
   \   000106                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000106   85..82       MOV       DPL,?V0
   \   000109   85..83       MOV       DPH,?V1
   \   00010C   A3           INC       DPTR
   \   00010D   A3           INC       DPTR
   \   00010E   A3           INC       DPTR
   \   00010F   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000112   7402         MOV       A,#0x2
   \   000114   12....       LCALL     ?XSTACK_DISP102_8
   \   000117   85..82       MOV       DPL,?V8
   \   00011A   85..83       MOV       DPH,?V9
   \   00011D   E0           MOVX      A,@DPTR
   \   00011E   2406         ADD       A,#0x6
   \   000120   FA           MOV       R2,A
   \   000121   A3           INC       DPTR
   \   000122   E0           MOVX      A,@DPTR
   \   000123   3400         ADDC      A,#0x0
   \   000125   FB           MOV       R3,A
   \   000126   85..82       MOV       DPL,?V8
   \   000129   85..83       MOV       DPH,?V9
   \   00012C   E0           MOVX      A,@DPTR
   \   00012D   F8           MOV       R0,A
   \   00012E   A3           INC       DPTR
   \   00012F   E0           MOVX      A,@DPTR
   \   000130   C8           XCH       A,R0
   \   000131   2414         ADD       A,#0x14
   \   000133   F582         MOV       DPL,A
   \   000135   C8           XCH       A,R0
   \   000136   3400         ADDC      A,#0x0
   \   000138   F583         MOV       DPH,A
   \   00013A   E0           MOVX      A,@DPTR
   \   00013B   F9           MOV       R1,A
   \   00013C   12....       LCALL     `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \   00013F   7402         MOV       A,#0x2
   \   000141   12....       LCALL     ?DEALLOC_XSTACK8
   \   000144   E9           MOV       A,R1
   4679              }
   4680            } // for loop
   \                     ??zclRevertWriteUndividedCmd_3:
   \   000145   0E           INC       R6
   \   000146   02....       LJMP      ??zclRevertWriteUndividedCmd_0 & 0xFFFF
   4681          }
   \                     ??zclRevertWriteUndividedCmd_1:
   \   000149   7408         MOV       A,#0x8
   \   00014B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00014E   7F0E         MOV       R7,#0xe
   \   000150   02....       LJMP      ?BANKED_LEAVE_XDATA
   4682          
   4683          /*********************************************************************
   4684           * @fn      zclProcessInWriteUndividedCmd
   4685           *
   4686           * @brief   Process the "Profile" Write Undivided Command
   4687           *
   4688           * @param   pInMsg - incoming message to process
   4689           *
   4690           * @return  TRUE if command processed. FALSE, otherwise.
   4691           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4692          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4693          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV       A,#-0xe
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   4694            zclWriteCmd_t *writeCmd;
   4695            zclWriteRspCmd_t *writeRspCmd;
   4696            zclAttrRec_t attrRec;
   4697            uint16 dataLen;
   4698            uint16 curLen = 0;
   \   00000E   7404         MOV       A,#0x4
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   7400         MOV       A,#0x0
   \   000015   F0           MOVX      @DPTR,A
   \   000016   A3           INC       DPTR
   \   000017   7400         MOV       A,#0x0
   \   000019   F0           MOVX      @DPTR,A
   4699            uint8 j = 0;
   \   00001A   7E00         MOV       R6,#0x0
   4700            uint8 i;
   4701          
   4702            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   00001C   E5..         MOV       A,?V2
   \   00001E   240C         ADD       A,#0xc
   \   000020   F582         MOV       DPL,A
   \   000022   E4           CLR       A
   \   000023   35..         ADDC      A,?V3
   \   000025   F583         MOV       DPH,A
   \   000027   E0           MOVX      A,@DPTR
   \   000028   F8           MOV       R0,A
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F9           MOV       R1,A
   \   00002C   88..         MOV       ?V14,R0
   \   00002E   89..         MOV       ?V15,R1
   4703          
   4704            // Allocate space for Write Response Command
   4705            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4706                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \   000030                ; Setup parameters for call to function osal_mem_alloc
   \   000030   85..82       MOV       DPL,?V14
   \   000033   85..83       MOV       DPH,?V15
   \   000036   E0           MOVX      A,@DPTR
   \   000037   F8           MOV       R0,A
   \   000038   7900         MOV       R1,#0x0
   \   00003A   E8           MOV       A,R0
   \   00003B   75F003       MOV       B,#0x3
   \   00003E   A4           MUL       AB
   \   00003F   C8           XCH       A,R0
   \   000040   AAF0         MOV       R2,B
   \   000042   75F000       MOV       B,#0x0
   \   000045   A4           MUL       AB
   \   000046   2A           ADD       A,R2
   \   000047   FA           MOV       R2,A
   \   000048   75F003       MOV       B,#0x3
   \   00004B   E9           MOV       A,R1
   \   00004C   A4           MUL       AB
   \   00004D   2A           ADD       A,R2
   \   00004E   F9           MOV       R1,A
   \   00004F   E8           MOV       A,R0
   \   000050   2401         ADD       A,#0x1
   \   000052   FA           MOV       R2,A
   \   000053   E4           CLR       A
   \   000054   39           ADDC      A,R1
   \   000055   FB           MOV       R3,A
   \   000056   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000059   8A..         MOV       ?V4,R2
   \   00005B   8B..         MOV       ?V5,R3
   \   00005D   85....       MOV       ?V0,?V4
   \   000060   85....       MOV       ?V1,?V5
   4707            if ( writeRspCmd == NULL )
   \   000063   E5..         MOV       A,?V0
   \   000065   45..         ORL       A,?V1
   \   000067   7005         JNZ       ??zclProcessInWriteUndividedCmd_0
   4708            {
   4709              return FALSE; // EMBEDDED RETURN
   \   000069   7900         MOV       R1,#0x0
   \   00006B   02....       LJMP      ??zclProcessInWriteUndividedCmd_1 & 0xFFFF
   4710            }
   4711          
   4712            // If any attribute cannot be written, no attribute values are changed. Hence,
   4713            // make sure all the attributes are supported and writable
   4714            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   00006E   7F00         MOV       R7,#0x0
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000070   85..82       MOV       DPL,?V14
   \   000073   85..83       MOV       DPH,?V15
   \   000076   E0           MOVX      A,@DPTR
   \   000077   F8           MOV       R0,A
   \   000078   EF           MOV       A,R7
   \   000079   C3           CLR       C
   \   00007A   98           SUBB      A,R0
   \   00007B   4003         JC        $+5
   \   00007D   02....       LJMP      ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4715            {
   4716              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   000080   EF           MOV       A,R7
   \   000081   F8           MOV       R0,A
   \   000082   7900         MOV       R1,#0x0
   \   000084   E8           MOV       A,R0
   \   000085   75F005       MOV       B,#0x5
   \   000088   A4           MUL       AB
   \   000089   C8           XCH       A,R0
   \   00008A   AAF0         MOV       R2,B
   \   00008C   75F000       MOV       B,#0x0
   \   00008F   A4           MUL       AB
   \   000090   2A           ADD       A,R2
   \   000091   FA           MOV       R2,A
   \   000092   75F005       MOV       B,#0x5
   \   000095   E9           MOV       A,R1
   \   000096   A4           MUL       AB
   \   000097   2A           ADD       A,R2
   \   000098   F9           MOV       R1,A
   \   000099   E5..         MOV       A,?V14
   \   00009B   28           ADD       A,R0
   \   00009C   F582         MOV       DPL,A
   \   00009E   E5..         MOV       A,?V15
   \   0000A0   39           ADDC      A,R1
   \   0000A1   F583         MOV       DPH,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   8582..       MOV       ?V4,DPL
   \   0000A7   8583..       MOV       ?V5,DPH
   4717          
   4718              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4719                                    statusRec->attrID, &attrRec ) )
   \   0000AA                ; Setup parameters for call to function zclFindAttrRec
   \   0000AA   7406         MOV       A,#0x6
   \   0000AC   12....       LCALL     ?XSTACK_DISP100_8
   \   0000AF   88..         MOV       ?V6,R0
   \   0000B1   89..         MOV       ?V7,R1
   \   0000B3   78..         MOV       R0,#?V6
   \   0000B5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B8   85..82       MOV       DPL,?V4
   \   0000BB   85..83       MOV       DPH,?V5
   \   0000BE   E0           MOVX      A,@DPTR
   \   0000BF   FC           MOV       R4,A
   \   0000C0   A3           INC       DPTR
   \   0000C1   E0           MOVX      A,@DPTR
   \   0000C2   FD           MOV       R5,A
   \   0000C3   85..82       MOV       DPL,?V2
   \   0000C6   85..83       MOV       DPH,?V3
   \   0000C9   E0           MOVX      A,@DPTR
   \   0000CA   F8           MOV       R0,A
   \   0000CB   A3           INC       DPTR
   \   0000CC   E0           MOVX      A,@DPTR
   \   0000CD   F583         MOV       DPH,A
   \   0000CF   8882         MOV       DPL,R0
   \   0000D1   A3           INC       DPTR
   \   0000D2   A3           INC       DPTR
   \   0000D3   A3           INC       DPTR
   \   0000D4   A3           INC       DPTR
   \   0000D5   E0           MOVX      A,@DPTR
   \   0000D6   FA           MOV       R2,A
   \   0000D7   A3           INC       DPTR
   \   0000D8   E0           MOVX      A,@DPTR
   \   0000D9   FB           MOV       R3,A
   \   0000DA   85..82       MOV       DPL,?V2
   \   0000DD   85..83       MOV       DPH,?V3
   \   0000E0   E0           MOVX      A,@DPTR
   \   0000E1   F8           MOV       R0,A
   \   0000E2   A3           INC       DPTR
   \   0000E3   E0           MOVX      A,@DPTR
   \   0000E4   C8           XCH       A,R0
   \   0000E5   2414         ADD       A,#0x14
   \   0000E7   F582         MOV       DPL,A
   \   0000E9   C8           XCH       A,R0
   \   0000EA   3400         ADDC      A,#0x0
   \   0000EC   F583         MOV       DPH,A
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   F9           MOV       R1,A
   \   0000F0   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000F3   7402         MOV       A,#0x2
   \   0000F5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000F8   E9           MOV       A,R1
   \   0000F9   7060         JNZ       ??zclProcessInWriteUndividedCmd_4
   4720              {
   4721                // Attribute is not supported - stop here
   4722                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   0000FB   EE           MOV       A,R6
   \   0000FC   F8           MOV       R0,A
   \   0000FD   7900         MOV       R1,#0x0
   \   0000FF   E8           MOV       A,R0
   \   000100   75F003       MOV       B,#0x3
   \   000103   A4           MUL       AB
   \   000104   C8           XCH       A,R0
   \   000105   AAF0         MOV       R2,B
   \   000107   75F000       MOV       B,#0x0
   \   00010A   A4           MUL       AB
   \   00010B   2A           ADD       A,R2
   \   00010C   FA           MOV       R2,A
   \   00010D   75F003       MOV       B,#0x3
   \   000110   E9           MOV       A,R1
   \   000111   A4           MUL       AB
   \   000112   2A           ADD       A,R2
   \   000113   F9           MOV       R1,A
   \   000114   E5..         MOV       A,?V0
   \   000116   28           ADD       A,R0
   \   000117   F582         MOV       DPL,A
   \   000119   E5..         MOV       A,?V1
   \   00011B   39           ADDC      A,R1
   \   00011C   F583         MOV       DPH,A
   \   00011E   A3           INC       DPTR
   \   00011F   7486         MOV       A,#-0x7a
   \   000121   F0           MOVX      @DPTR,A
   4723                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000122   85..82       MOV       DPL,?V4
   \   000125   85..83       MOV       DPH,?V5
   \   000128   E0           MOVX      A,@DPTR
   \   000129   FA           MOV       R2,A
   \   00012A   A3           INC       DPTR
   \   00012B   E0           MOVX      A,@DPTR
   \   00012C   FB           MOV       R3,A
   \   00012D   EE           MOV       A,R6
   \   00012E   F8           MOV       R0,A
   \   00012F   7900         MOV       R1,#0x0
   \   000131   E8           MOV       A,R0
   \   000132   75F003       MOV       B,#0x3
   \   000135   A4           MUL       AB
   \   000136   C8           XCH       A,R0
   \   000137   ACF0         MOV       R4,B
   \   000139   75F000       MOV       B,#0x0
   \   00013C   A4           MUL       AB
   \   00013D   2C           ADD       A,R4
   \   00013E   FC           MOV       R4,A
   \   00013F   75F003       MOV       B,#0x3
   \   000142   E9           MOV       A,R1
   \   000143   A4           MUL       AB
   \   000144   2C           ADD       A,R4
   \   000145   F9           MOV       R1,A
   \   000146   E5..         MOV       A,?V0
   \   000148   28           ADD       A,R0
   \   000149   F582         MOV       DPL,A
   \   00014B   E5..         MOV       A,?V1
   \   00014D   39           ADDC      A,R1
   \   00014E   F583         MOV       DPH,A
   \   000150   A3           INC       DPTR
   \   000151   A3           INC       DPTR
   \   000152   EA           MOV       A,R2
   \   000153   F0           MOVX      @DPTR,A
   \   000154   A3           INC       DPTR
   \   000155   EB           MOV       A,R3
   \   000156   F0           MOVX      @DPTR,A
   \   000157   0E           INC       R6
   4724                break;
   \   000158   02....       LJMP      ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4725              }
   4726          
   4727              if ( statusRec->dataType != attrRec.attr.dataType )
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   00015B   85..82       MOV       DPL,?V4
   \   00015E   85..83       MOV       DPH,?V5
   \   000161   A3           INC       DPTR
   \   000162   A3           INC       DPTR
   \   000163   E0           MOVX      A,@DPTR
   \   000164   F8           MOV       R0,A
   \   000165   740A         MOV       A,#0xa
   \   000167   12....       LCALL     ?XSTACK_DISP0_8
   \   00016A   E0           MOVX      A,@DPTR
   \   00016B   68           XRL       A,R0
   \   00016C   6060         JZ        ??zclProcessInWriteUndividedCmd_5
   4728              {
   4729                // Attribute data type is incorrect - stope here
   4730                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   \   00016E   EE           MOV       A,R6
   \   00016F   F8           MOV       R0,A
   \   000170   7900         MOV       R1,#0x0
   \   000172   E8           MOV       A,R0
   \   000173   75F003       MOV       B,#0x3
   \   000176   A4           MUL       AB
   \   000177   C8           XCH       A,R0
   \   000178   AAF0         MOV       R2,B
   \   00017A   75F000       MOV       B,#0x0
   \   00017D   A4           MUL       AB
   \   00017E   2A           ADD       A,R2
   \   00017F   FA           MOV       R2,A
   \   000180   75F003       MOV       B,#0x3
   \   000183   E9           MOV       A,R1
   \   000184   A4           MUL       AB
   \   000185   2A           ADD       A,R2
   \   000186   F9           MOV       R1,A
   \   000187   E5..         MOV       A,?V0
   \   000189   28           ADD       A,R0
   \   00018A   F582         MOV       DPL,A
   \   00018C   E5..         MOV       A,?V1
   \   00018E   39           ADDC      A,R1
   \   00018F   F583         MOV       DPH,A
   \   000191   A3           INC       DPTR
   \   000192   748D         MOV       A,#-0x73
   \   000194   F0           MOVX      @DPTR,A
   4731                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000195   85..82       MOV       DPL,?V4
   \   000198   85..83       MOV       DPH,?V5
   \   00019B   E0           MOVX      A,@DPTR
   \   00019C   FA           MOV       R2,A
   \   00019D   A3           INC       DPTR
   \   00019E   E0           MOVX      A,@DPTR
   \   00019F   FB           MOV       R3,A
   \   0001A0   EE           MOV       A,R6
   \   0001A1   F8           MOV       R0,A
   \   0001A2   7900         MOV       R1,#0x0
   \   0001A4   E8           MOV       A,R0
   \   0001A5   75F003       MOV       B,#0x3
   \   0001A8   A4           MUL       AB
   \   0001A9   C8           XCH       A,R0
   \   0001AA   ACF0         MOV       R4,B
   \   0001AC   75F000       MOV       B,#0x0
   \   0001AF   A4           MUL       AB
   \   0001B0   2C           ADD       A,R4
   \   0001B1   FC           MOV       R4,A
   \   0001B2   75F003       MOV       B,#0x3
   \   0001B5   E9           MOV       A,R1
   \   0001B6   A4           MUL       AB
   \   0001B7   2C           ADD       A,R4
   \   0001B8   F9           MOV       R1,A
   \   0001B9   E5..         MOV       A,?V0
   \   0001BB   28           ADD       A,R0
   \   0001BC   F582         MOV       DPL,A
   \   0001BE   E5..         MOV       A,?V1
   \   0001C0   39           ADDC      A,R1
   \   0001C1   F583         MOV       DPH,A
   \   0001C3   A3           INC       DPTR
   \   0001C4   A3           INC       DPTR
   \   0001C5   EA           MOV       A,R2
   \   0001C6   F0           MOVX      @DPTR,A
   \   0001C7   A3           INC       DPTR
   \   0001C8   EB           MOV       A,R3
   \   0001C9   F0           MOVX      @DPTR,A
   \   0001CA   0E           INC       R6
   4732                break;
   \   0001CB   02....       LJMP      ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4733              }
   4734          
   4735              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   0001CE   740B         MOV       A,#0xb
   \   0001D0   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D3   E0           MOVX      A,@DPTR
   \   0001D4   A2E1         MOV       C,0xE0 /* A   */.1
   \   0001D6   4060         JC        ??zclProcessInWriteUndividedCmd_6
   4736              {
   4737                // Attribute is not writable - stop here
   4738                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   \   0001D8   EE           MOV       A,R6
   \   0001D9   F8           MOV       R0,A
   \   0001DA   7900         MOV       R1,#0x0
   \   0001DC   E8           MOV       A,R0
   \   0001DD   75F003       MOV       B,#0x3
   \   0001E0   A4           MUL       AB
   \   0001E1   C8           XCH       A,R0
   \   0001E2   AAF0         MOV       R2,B
   \   0001E4   75F000       MOV       B,#0x0
   \   0001E7   A4           MUL       AB
   \   0001E8   2A           ADD       A,R2
   \   0001E9   FA           MOV       R2,A
   \   0001EA   75F003       MOV       B,#0x3
   \   0001ED   E9           MOV       A,R1
   \   0001EE   A4           MUL       AB
   \   0001EF   2A           ADD       A,R2
   \   0001F0   F9           MOV       R1,A
   \   0001F1   E5..         MOV       A,?V0
   \   0001F3   28           ADD       A,R0
   \   0001F4   F582         MOV       DPL,A
   \   0001F6   E5..         MOV       A,?V1
   \   0001F8   39           ADDC      A,R1
   \   0001F9   F583         MOV       DPH,A
   \   0001FB   A3           INC       DPTR
   \   0001FC   7488         MOV       A,#-0x78
   \   0001FE   F0           MOVX      @DPTR,A
   4739                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   0001FF   85..82       MOV       DPL,?V4
   \   000202   85..83       MOV       DPH,?V5
   \   000205   E0           MOVX      A,@DPTR
   \   000206   FA           MOV       R2,A
   \   000207   A3           INC       DPTR
   \   000208   E0           MOVX      A,@DPTR
   \   000209   FB           MOV       R3,A
   \   00020A   EE           MOV       A,R6
   \   00020B   F8           MOV       R0,A
   \   00020C   7900         MOV       R1,#0x0
   \   00020E   E8           MOV       A,R0
   \   00020F   75F003       MOV       B,#0x3
   \   000212   A4           MUL       AB
   \   000213   C8           XCH       A,R0
   \   000214   ACF0         MOV       R4,B
   \   000216   75F000       MOV       B,#0x0
   \   000219   A4           MUL       AB
   \   00021A   2C           ADD       A,R4
   \   00021B   FC           MOV       R4,A
   \   00021C   75F003       MOV       B,#0x3
   \   00021F   E9           MOV       A,R1
   \   000220   A4           MUL       AB
   \   000221   2C           ADD       A,R4
   \   000222   F9           MOV       R1,A
   \   000223   E5..         MOV       A,?V0
   \   000225   28           ADD       A,R0
   \   000226   F582         MOV       DPL,A
   \   000228   E5..         MOV       A,?V1
   \   00022A   39           ADDC      A,R1
   \   00022B   F583         MOV       DPH,A
   \   00022D   A3           INC       DPTR
   \   00022E   A3           INC       DPTR
   \   00022F   EA           MOV       A,R2
   \   000230   F0           MOVX      @DPTR,A
   \   000231   A3           INC       DPTR
   \   000232   EB           MOV       A,R3
   \   000233   F0           MOVX      @DPTR,A
   \   000234   0E           INC       R6
   4740                break;
   \   000235   02....       LJMP      ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4741              }
   4742          
   4743              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   000238   740B         MOV       A,#0xb
   \   00023A   12....       LCALL     ?XSTACK_DISP0_8
   \   00023D   E0           MOVX      A,@DPTR
   \   00023E   A2E5         MOV       C,0xE0 /* A   */.5
   \   000240   5060         JNC       ??zclProcessInWriteUndividedCmd_7
   4744              {
   4745                // Not authorized to write - stop here
   4746                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   \   000242   EE           MOV       A,R6
   \   000243   F8           MOV       R0,A
   \   000244   7900         MOV       R1,#0x0
   \   000246   E8           MOV       A,R0
   \   000247   75F003       MOV       B,#0x3
   \   00024A   A4           MUL       AB
   \   00024B   C8           XCH       A,R0
   \   00024C   AAF0         MOV       R2,B
   \   00024E   75F000       MOV       B,#0x0
   \   000251   A4           MUL       AB
   \   000252   2A           ADD       A,R2
   \   000253   FA           MOV       R2,A
   \   000254   75F003       MOV       B,#0x3
   \   000257   E9           MOV       A,R1
   \   000258   A4           MUL       AB
   \   000259   2A           ADD       A,R2
   \   00025A   F9           MOV       R1,A
   \   00025B   E5..         MOV       A,?V0
   \   00025D   28           ADD       A,R0
   \   00025E   F582         MOV       DPL,A
   \   000260   E5..         MOV       A,?V1
   \   000262   39           ADDC      A,R1
   \   000263   F583         MOV       DPH,A
   \   000265   A3           INC       DPTR
   \   000266   747E         MOV       A,#0x7e
   \   000268   F0           MOVX      @DPTR,A
   4747                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000269   85..82       MOV       DPL,?V4
   \   00026C   85..83       MOV       DPH,?V5
   \   00026F   E0           MOVX      A,@DPTR
   \   000270   FA           MOV       R2,A
   \   000271   A3           INC       DPTR
   \   000272   E0           MOVX      A,@DPTR
   \   000273   FB           MOV       R3,A
   \   000274   EE           MOV       A,R6
   \   000275   F8           MOV       R0,A
   \   000276   7900         MOV       R1,#0x0
   \   000278   E8           MOV       A,R0
   \   000279   75F003       MOV       B,#0x3
   \   00027C   A4           MUL       AB
   \   00027D   C8           XCH       A,R0
   \   00027E   ACF0         MOV       R4,B
   \   000280   75F000       MOV       B,#0x0
   \   000283   A4           MUL       AB
   \   000284   2C           ADD       A,R4
   \   000285   FC           MOV       R4,A
   \   000286   75F003       MOV       B,#0x3
   \   000289   E9           MOV       A,R1
   \   00028A   A4           MUL       AB
   \   00028B   2C           ADD       A,R4
   \   00028C   F9           MOV       R1,A
   \   00028D   E5..         MOV       A,?V0
   \   00028F   28           ADD       A,R0
   \   000290   F582         MOV       DPL,A
   \   000292   E5..         MOV       A,?V1
   \   000294   39           ADDC      A,R1
   \   000295   F583         MOV       DPH,A
   \   000297   A3           INC       DPTR
   \   000298   A3           INC       DPTR
   \   000299   EA           MOV       A,R2
   \   00029A   F0           MOVX      @DPTR,A
   \   00029B   A3           INC       DPTR
   \   00029C   EB           MOV       A,R3
   \   00029D   F0           MOVX      @DPTR,A
   \   00029E   0E           INC       R6
   4748                break;
   \   00029F   02....       LJMP      ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4749              }
   4750          
   4751              // Attribute Data length
   4752              if ( attrRec.attr.dataPtr != NULL )
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002A2   740C         MOV       A,#0xc
   \   0002A4   12....       LCALL     ?XSTACK_DISP0_8
   \   0002A7   E0           MOVX      A,@DPTR
   \   0002A8   F8           MOV       R0,A
   \   0002A9   A3           INC       DPTR
   \   0002AA   E0           MOVX      A,@DPTR
   \   0002AB   F9           MOV       R1,A
   \   0002AC   E8           MOV       A,R0
   \   0002AD   49           ORL       A,R1
   \   0002AE   6021         JZ        ??zclProcessInWriteUndividedCmd_8
   4753              {
   4754                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   \   0002B0                ; Setup parameters for call to function zclGetAttrDataLength
   \   0002B0   740C         MOV       A,#0xc
   \   0002B2   12....       LCALL     ?XSTACK_DISP0_8
   \   0002B5   E0           MOVX      A,@DPTR
   \   0002B6   FA           MOV       R2,A
   \   0002B7   A3           INC       DPTR
   \   0002B8   E0           MOVX      A,@DPTR
   \   0002B9   FB           MOV       R3,A
   \   0002BA   740A         MOV       A,#0xa
   \   0002BC   12....       LCALL     ?XSTACK_DISP0_8
   \   0002BF   E0           MOVX      A,@DPTR
   \   0002C0   F9           MOV       R1,A
   \   0002C1   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0002C4   85..82       MOV       DPL,?XSP + 0
   \   0002C7   85..83       MOV       DPH,?XSP + 1
   \   0002CA   EA           MOV       A,R2
   \   0002CB   F0           MOVX      @DPTR,A
   \   0002CC   A3           INC       DPTR
   \   0002CD   EB           MOV       A,R3
   \   0002CE   F0           MOVX      @DPTR,A
   \   0002CF   8046         SJMP      ??zclProcessInWriteUndividedCmd_9
   4755              }
   4756              else // Use CB
   4757              {
   4758                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4759                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   0002D1                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   0002D1   85..82       MOV       DPL,?V4
   \   0002D4   85..83       MOV       DPH,?V5
   \   0002D7   E0           MOVX      A,@DPTR
   \   0002D8   FC           MOV       R4,A
   \   0002D9   A3           INC       DPTR
   \   0002DA   E0           MOVX      A,@DPTR
   \   0002DB   FD           MOV       R5,A
   \   0002DC   85..82       MOV       DPL,?V2
   \   0002DF   85..83       MOV       DPH,?V3
   \   0002E2   E0           MOVX      A,@DPTR
   \   0002E3   F8           MOV       R0,A
   \   0002E4   A3           INC       DPTR
   \   0002E5   E0           MOVX      A,@DPTR
   \   0002E6   F583         MOV       DPH,A
   \   0002E8   8882         MOV       DPL,R0
   \   0002EA   A3           INC       DPTR
   \   0002EB   A3           INC       DPTR
   \   0002EC   A3           INC       DPTR
   \   0002ED   A3           INC       DPTR
   \   0002EE   E0           MOVX      A,@DPTR
   \   0002EF   FA           MOV       R2,A
   \   0002F0   A3           INC       DPTR
   \   0002F1   E0           MOVX      A,@DPTR
   \   0002F2   FB           MOV       R3,A
   \   0002F3   85..82       MOV       DPL,?V2
   \   0002F6   85..83       MOV       DPH,?V3
   \   0002F9   E0           MOVX      A,@DPTR
   \   0002FA   F8           MOV       R0,A
   \   0002FB   A3           INC       DPTR
   \   0002FC   E0           MOVX      A,@DPTR
   \   0002FD   C8           XCH       A,R0
   \   0002FE   2414         ADD       A,#0x14
   \   000300   F582         MOV       DPL,A
   \   000302   C8           XCH       A,R0
   \   000303   3400         ADDC      A,#0x0
   \   000305   F583         MOV       DPH,A
   \   000307   E0           MOVX      A,@DPTR
   \   000308   F9           MOV       R1,A
   \   000309   12....       LCALL     `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \   00030C   85..82       MOV       DPL,?XSP + 0
   \   00030F   85..83       MOV       DPH,?XSP + 1
   \   000312   EA           MOV       A,R2
   \   000313   F0           MOVX      @DPTR,A
   \   000314   A3           INC       DPTR
   \   000315   EB           MOV       A,R3
   \   000316   F0           MOVX      @DPTR,A
   4760              }
   4761          
   4762              // add padding if needed
   4763              if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   000317   85..82       MOV       DPL,?XSP + 0
   \   00031A   85..83       MOV       DPH,?XSP + 1
   \   00031D   E0           MOVX      A,@DPTR
   \   00031E   F8           MOV       R0,A
   \   00031F   A3           INC       DPTR
   \   000320   E0           MOVX      A,@DPTR
   \   000321   F9           MOV       R1,A
   \   000322   E8           MOV       A,R0
   \   000323   A2E0         MOV       C,0xE0 /* A   */.0
   \   000325   500F         JNC       ??zclProcessInWriteUndividedCmd_10
   4764              {
   4765                dataLen++;
   \   000327   85..82       MOV       DPL,?XSP + 0
   \   00032A   85..83       MOV       DPH,?XSP + 1
   \   00032D   E0           MOVX      A,@DPTR
   \   00032E   2401         ADD       A,#0x1
   \   000330   F0           MOVX      @DPTR,A
   \   000331   A3           INC       DPTR
   \   000332   E0           MOVX      A,@DPTR
   \   000333   3400         ADDC      A,#0x0
   \   000335   F0           MOVX      @DPTR,A
   4766              }
   4767          
   4768              curLen += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   000336   85..82       MOV       DPL,?XSP + 0
   \   000339   85..83       MOV       DPH,?XSP + 1
   \   00033C   E0           MOVX      A,@DPTR
   \   00033D   F8           MOV       R0,A
   \   00033E   A3           INC       DPTR
   \   00033F   E0           MOVX      A,@DPTR
   \   000340   F9           MOV       R1,A
   \   000341   7404         MOV       A,#0x4
   \   000343   12....       LCALL     ?XSTACK_DISP0_8
   \   000346   E0           MOVX      A,@DPTR
   \   000347   28           ADD       A,R0
   \   000348   F0           MOVX      @DPTR,A
   \   000349   A3           INC       DPTR
   \   00034A   E0           MOVX      A,@DPTR
   \   00034B   39           ADDC      A,R1
   \   00034C   F0           MOVX      @DPTR,A
   4769            } // for loop
   \   00034D   0F           INC       R7
   \   00034E   02....       LJMP      ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   4770          
   4771            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   000351   EE           MOV       A,R6
   \   000352   C0E0         PUSH      A
   \   000354   85..82       MOV       DPL,?V0
   \   000357   85..83       MOV       DPH,?V1
   \   00035A   D0E0         POP       A
   \   00035C   F0           MOVX      @DPTR,A
   4772            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   00035D   85..82       MOV       DPL,?V0
   \   000360   85..83       MOV       DPH,?V1
   \   000363   E0           MOVX      A,@DPTR
   \   000364   6003         JZ        $+5
   \   000366   02....       LJMP      ??zclProcessInWriteUndividedCmd_11 & 0xFFFF
   4773            {
   4774              uint8 *curDataPtr;
   4775              zclWriteRec_t *curWriteRec;
   4776          
   4777              // calculate the length of the current data header
   4778              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   000369   75F005       MOV       B,#0x5
   \   00036C   EE           MOV       A,R6
   \   00036D   A4           MUL       AB
   \   00036E   F5..         MOV       ?V5,A
   4779          
   4780              // Allocate space to keep a copy of the current data
   4781              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   000370                ; Setup parameters for call to function osal_mem_alloc
   \   000370   E5..         MOV       A,?V5
   \   000372   F8           MOV       R0,A
   \   000373   7900         MOV       R1,#0x0
   \   000375   7404         MOV       A,#0x4
   \   000377   12....       LCALL     ?XSTACK_DISP0_8
   \   00037A   E0           MOVX      A,@DPTR
   \   00037B   28           ADD       A,R0
   \   00037C   FA           MOV       R2,A
   \   00037D   A3           INC       DPTR
   \   00037E   E0           MOVX      A,@DPTR
   \   00037F   39           ADDC      A,R1
   \   000380   FB           MOV       R3,A
   \   000381   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000384   8A..         MOV       ?V8,R2
   \   000386   8B..         MOV       ?V9,R3
   \   000388   85....       MOV       ?V12,?V8
   \   00038B   85....       MOV       ?V13,?V9
   4782              if ( curWriteRec == NULL )
   \   00038E   E5..         MOV       A,?V12
   \   000390   45..         ORL       A,?V13
   \   000392   700C         JNZ       ??zclProcessInWriteUndividedCmd_12
   4783              {
   4784                zcl_mem_free(writeRspCmd );
   \   000394                ; Setup parameters for call to function osal_mem_free
   \   000394   AA..         MOV       R2,?V0
   \   000396   AB..         MOV       R3,?V1
   \   000398   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4785                return FALSE; // EMBEDDED RETURN
   \   00039B   7900         MOV       R1,#0x0
   \   00039D   02....       LJMP      ??zclProcessInWriteUndividedCmd_1 & 0xFFFF
   4786              }
   4787          
   4788              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0003A0   E5..         MOV       A,?V5
   \   0003A2   F8           MOV       R0,A
   \   0003A3   7900         MOV       R1,#0x0
   \   0003A5   E5..         MOV       A,?V12
   \   0003A7   28           ADD       A,R0
   \   0003A8   F8           MOV       R0,A
   \   0003A9   E5..         MOV       A,?V13
   \   0003AB   39           ADDC      A,R1
   \   0003AC   F9           MOV       R1,A
   \   0003AD   88..         MOV       ?V6,R0
   \   0003AF   89..         MOV       ?V7,R1
   4789          
   4790              // Write the new data over
   4791              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   0003B1   7F00         MOV       R7,#0x0
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0003B3   85..82       MOV       DPL,?V14
   \   0003B6   85..83       MOV       DPH,?V15
   \   0003B9   E0           MOVX      A,@DPTR
   \   0003BA   F8           MOV       R0,A
   \   0003BB   EF           MOV       A,R7
   \   0003BC   C3           CLR       C
   \   0003BD   98           SUBB      A,R0
   \   0003BE   4003         JC        $+5
   \   0003C0   02....       LJMP      ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   4792              {
   4793                uint8 status;
   4794                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   0003C3   EF           MOV       A,R7
   \   0003C4   F8           MOV       R0,A
   \   0003C5   7900         MOV       R1,#0x0
   \   0003C7   E8           MOV       A,R0
   \   0003C8   75F005       MOV       B,#0x5
   \   0003CB   A4           MUL       AB
   \   0003CC   C8           XCH       A,R0
   \   0003CD   AAF0         MOV       R2,B
   \   0003CF   75F000       MOV       B,#0x0
   \   0003D2   A4           MUL       AB
   \   0003D3   2A           ADD       A,R2
   \   0003D4   FA           MOV       R2,A
   \   0003D5   75F005       MOV       B,#0x5
   \   0003D8   E9           MOV       A,R1
   \   0003D9   A4           MUL       AB
   \   0003DA   2A           ADD       A,R2
   \   0003DB   F9           MOV       R1,A
   \   0003DC   E5..         MOV       A,?V14
   \   0003DE   28           ADD       A,R0
   \   0003DF   F582         MOV       DPL,A
   \   0003E1   E5..         MOV       A,?V15
   \   0003E3   39           ADDC      A,R1
   \   0003E4   F583         MOV       DPH,A
   \   0003E6   A3           INC       DPTR
   \   0003E7   8582..       MOV       ?V8,DPL
   \   0003EA   8583..       MOV       ?V9,DPH
   4795                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   \   0003ED   EF           MOV       A,R7
   \   0003EE   F8           MOV       R0,A
   \   0003EF   7900         MOV       R1,#0x0
   \   0003F1   E8           MOV       A,R0
   \   0003F2   75F005       MOV       B,#0x5
   \   0003F5   A4           MUL       AB
   \   0003F6   C8           XCH       A,R0
   \   0003F7   AAF0         MOV       R2,B
   \   0003F9   75F000       MOV       B,#0x0
   \   0003FC   A4           MUL       AB
   \   0003FD   2A           ADD       A,R2
   \   0003FE   FA           MOV       R2,A
   \   0003FF   75F005       MOV       B,#0x5
   \   000402   E9           MOV       A,R1
   \   000403   A4           MUL       AB
   \   000404   2A           ADD       A,R2
   \   000405   F9           MOV       R1,A
   \   000406   E5..         MOV       A,?V12
   \   000408   28           ADD       A,R0
   \   000409   F8           MOV       R0,A
   \   00040A   E5..         MOV       A,?V13
   \   00040C   39           ADDC      A,R1
   \   00040D   F9           MOV       R1,A
   \   00040E   7402         MOV       A,#0x2
   \   000410   12....       LCALL     ?XSTACK_DISP0_8
   \   000413   E8           MOV       A,R0
   \   000414   F0           MOVX      @DPTR,A
   \   000415   A3           INC       DPTR
   \   000416   E9           MOV       A,R1
   \   000417   F0           MOVX      @DPTR,A
   4796          
   4797                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4798                                      statusRec->attrID, &attrRec ) )
   \   000418                ; Setup parameters for call to function zclFindAttrRec
   \   000418   7406         MOV       A,#0x6
   \   00041A   12....       LCALL     ?XSTACK_DISP100_8
   \   00041D   88..         MOV       ?V10,R0
   \   00041F   89..         MOV       ?V11,R1
   \   000421   78..         MOV       R0,#?V10
   \   000423   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000426   85..82       MOV       DPL,?V8
   \   000429   85..83       MOV       DPH,?V9
   \   00042C   E0           MOVX      A,@DPTR
   \   00042D   FC           MOV       R4,A
   \   00042E   A3           INC       DPTR
   \   00042F   E0           MOVX      A,@DPTR
   \   000430   FD           MOV       R5,A
   \   000431   85..82       MOV       DPL,?V2
   \   000434   85..83       MOV       DPH,?V3
   \   000437   E0           MOVX      A,@DPTR
   \   000438   F8           MOV       R0,A
   \   000439   A3           INC       DPTR
   \   00043A   E0           MOVX      A,@DPTR
   \   00043B   F583         MOV       DPH,A
   \   00043D   8882         MOV       DPL,R0
   \   00043F   A3           INC       DPTR
   \   000440   A3           INC       DPTR
   \   000441   A3           INC       DPTR
   \   000442   A3           INC       DPTR
   \   000443   E0           MOVX      A,@DPTR
   \   000444   FA           MOV       R2,A
   \   000445   A3           INC       DPTR
   \   000446   E0           MOVX      A,@DPTR
   \   000447   FB           MOV       R3,A
   \   000448   85..82       MOV       DPL,?V2
   \   00044B   85..83       MOV       DPH,?V3
   \   00044E   E0           MOVX      A,@DPTR
   \   00044F   F8           MOV       R0,A
   \   000450   A3           INC       DPTR
   \   000451   E0           MOVX      A,@DPTR
   \   000452   C8           XCH       A,R0
   \   000453   2414         ADD       A,#0x14
   \   000455   F582         MOV       DPL,A
   \   000457   C8           XCH       A,R0
   \   000458   3400         ADDC      A,#0x0
   \   00045A   F583         MOV       DPH,A
   \   00045C   E0           MOVX      A,@DPTR
   \   00045D   F9           MOV       R1,A
   \   00045E   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000461   7402         MOV       A,#0x2
   \   000463   12....       LCALL     ?DEALLOC_XSTACK8
   \   000466   E9           MOV       A,R1
   \   000467   7003         JNZ       $+5
   \   000469   02....       LJMP      ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   4799                {
   4800                  break; // should never happen
   4801                }
   4802          
   4803                // Keep a copy of the current data before before writing the new data over
   4804                curStatusRec->attrID = statusRec->attrID;
   \   00046C   85..82       MOV       DPL,?V8
   \   00046F   85..83       MOV       DPH,?V9
   \   000472   E0           MOVX      A,@DPTR
   \   000473   FA           MOV       R2,A
   \   000474   A3           INC       DPTR
   \   000475   E0           MOVX      A,@DPTR
   \   000476   FB           MOV       R3,A
   \   000477   7402         MOV       A,#0x2
   \   000479   12....       LCALL     ?XSTACK_DISP0_8
   \   00047C   E0           MOVX      A,@DPTR
   \   00047D   F8           MOV       R0,A
   \   00047E   A3           INC       DPTR
   \   00047F   E0           MOVX      A,@DPTR
   \   000480   F583         MOV       DPH,A
   \   000482   8882         MOV       DPL,R0
   \   000484   EA           MOV       A,R2
   \   000485   F0           MOVX      @DPTR,A
   \   000486   A3           INC       DPTR
   \   000487   EB           MOV       A,R3
   \   000488   F0           MOVX      @DPTR,A
   4805                curStatusRec->attrData = curDataPtr;
   \   000489   7402         MOV       A,#0x2
   \   00048B   12....       LCALL     ?XSTACK_DISP0_8
   \   00048E   E0           MOVX      A,@DPTR
   \   00048F   F8           MOV       R0,A
   \   000490   A3           INC       DPTR
   \   000491   E0           MOVX      A,@DPTR
   \   000492   F583         MOV       DPH,A
   \   000494   8882         MOV       DPL,R0
   \   000496   A3           INC       DPTR
   \   000497   A3           INC       DPTR
   \   000498   A3           INC       DPTR
   \   000499   E5..         MOV       A,?V6
   \   00049B   F0           MOVX      @DPTR,A
   \   00049C   A3           INC       DPTR
   \   00049D   E5..         MOV       A,?V7
   \   00049F   F0           MOVX      @DPTR,A
   4806          
   4807                if ( attrRec.attr.dataPtr != NULL )
   \   0004A0   740C         MOV       A,#0xc
   \   0004A2   12....       LCALL     ?XSTACK_DISP0_8
   \   0004A5   E0           MOVX      A,@DPTR
   \   0004A6   F8           MOV       R0,A
   \   0004A7   A3           INC       DPTR
   \   0004A8   E0           MOVX      A,@DPTR
   \   0004A9   F9           MOV       R1,A
   \   0004AA   E8           MOV       A,R0
   \   0004AB   49           ORL       A,R1
   \   0004AC   605C         JZ        ??zclProcessInWriteUndividedCmd_15
   4808                {
   4809                  // Read the current value
   4810                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   \   0004AE                ; Setup parameters for call to function zclReadAttrData
   \   0004AE   A8..         MOV       R0,?XSP + 0
   \   0004B0   A9..         MOV       R1,?XSP + 1
   \   0004B2   88..         MOV       ?V10,R0
   \   0004B4   89..         MOV       ?V11,R1
   \   0004B6   78..         MOV       R0,#?V10
   \   0004B8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0004BB   7408         MOV       A,#0x8
   \   0004BD   12....       LCALL     ?XSTACK_DISP102_8
   \   0004C0   AA..         MOV       R2,?V6
   \   0004C2   AB..         MOV       R3,?V7
   \   0004C4   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   0004C7   7402         MOV       A,#0x2
   \   0004C9   12....       LCALL     ?DEALLOC_XSTACK8
   \   0004CC   E9           MOV       A,R1
   4811          
   4812                  // Write the new attribute value
   4813                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4814                                             &attrRec, statusRec );
   \   0004CD                ; Setup parameters for call to function zclWriteAttrData
   \   0004CD   78..         MOV       R0,#?V8
   \   0004CF   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0004D2   7408         MOV       A,#0x8
   \   0004D4   12....       LCALL     ?XSTACK_DISP102_8
   \   0004D7   85..82       MOV       DPL,?V2
   \   0004DA   85..83       MOV       DPH,?V3
   \   0004DD   E0           MOVX      A,@DPTR
   \   0004DE   2406         ADD       A,#0x6
   \   0004E0   FA           MOV       R2,A
   \   0004E1   A3           INC       DPTR
   \   0004E2   E0           MOVX      A,@DPTR
   \   0004E3   3400         ADDC      A,#0x0
   \   0004E5   FB           MOV       R3,A
   \   0004E6   85..82       MOV       DPL,?V2
   \   0004E9   85..83       MOV       DPH,?V3
   \   0004EC   E0           MOVX      A,@DPTR
   \   0004ED   F8           MOV       R0,A
   \   0004EE   A3           INC       DPTR
   \   0004EF   E0           MOVX      A,@DPTR
   \   0004F0   C8           XCH       A,R0
   \   0004F1   2414         ADD       A,#0x14
   \   0004F3   F582         MOV       DPL,A
   \   0004F5   C8           XCH       A,R0
   \   0004F6   3400         ADDC      A,#0x0
   \   0004F8   F583         MOV       DPH,A
   \   0004FA   E0           MOVX      A,@DPTR
   \   0004FB   F9           MOV       R1,A
   \   0004FC   12....       LCALL     `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   0004FF   7402         MOV       A,#0x2
   \   000501   12....       LCALL     ?DEALLOC_XSTACK8
   \   000504   E9           MOV       A,R1
   \   000505   F5..         MOV       ?V4,A
   \   000507   02....       LJMP      ??zclProcessInWriteUndividedCmd_16 & 0xFFFF
   4815                }
   4816                else // Use CBs
   4817                {
   4818                  // Read the current value
   4819                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4820                                          statusRec->attrID, curDataPtr, &dataLen );
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   00050A                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00050A   A8..         MOV       R0,?XSP + 0
   \   00050C   A9..         MOV       R1,?XSP + 1
   \   00050E   88..         MOV       ?V10,R0
   \   000510   89..         MOV       ?V11,R1
   \   000512   78..         MOV       R0,#?V10
   \   000514   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000517   78..         MOV       R0,#?V6
   \   000519   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00051C   85..82       MOV       DPL,?V8
   \   00051F   85..83       MOV       DPH,?V9
   \   000522   E0           MOVX      A,@DPTR
   \   000523   FC           MOV       R4,A
   \   000524   A3           INC       DPTR
   \   000525   E0           MOVX      A,@DPTR
   \   000526   FD           MOV       R5,A
   \   000527   85..82       MOV       DPL,?V2
   \   00052A   85..83       MOV       DPH,?V3
   \   00052D   E0           MOVX      A,@DPTR
   \   00052E   F8           MOV       R0,A
   \   00052F   A3           INC       DPTR
   \   000530   E0           MOVX      A,@DPTR
   \   000531   F583         MOV       DPH,A
   \   000533   8882         MOV       DPL,R0
   \   000535   A3           INC       DPTR
   \   000536   A3           INC       DPTR
   \   000537   A3           INC       DPTR
   \   000538   A3           INC       DPTR
   \   000539   E0           MOVX      A,@DPTR
   \   00053A   FA           MOV       R2,A
   \   00053B   A3           INC       DPTR
   \   00053C   E0           MOVX      A,@DPTR
   \   00053D   FB           MOV       R3,A
   \   00053E   85..82       MOV       DPL,?V2
   \   000541   85..83       MOV       DPH,?V3
   \   000544   E0           MOVX      A,@DPTR
   \   000545   F8           MOV       R0,A
   \   000546   A3           INC       DPTR
   \   000547   E0           MOVX      A,@DPTR
   \   000548   C8           XCH       A,R0
   \   000549   2414         ADD       A,#0x14
   \   00054B   F582         MOV       DPL,A
   \   00054D   C8           XCH       A,R0
   \   00054E   3400         ADDC      A,#0x0
   \   000550   F583         MOV       DPH,A
   \   000552   E0           MOVX      A,@DPTR
   \   000553   F9           MOV       R1,A
   \   000554   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   000557   7404         MOV       A,#0x4
   \   000559   12....       LCALL     ?DEALLOC_XSTACK8
   \   00055C   E9           MOV       A,R1
   4821                  // Write the new attribute value
   4822                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4823                                                    &attrRec, statusRec->attrData );
   \   00055D                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   00055D   85..82       MOV       DPL,?V8
   \   000560   85..83       MOV       DPH,?V9
   \   000563   A3           INC       DPTR
   \   000564   A3           INC       DPTR
   \   000565   A3           INC       DPTR
   \   000566   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000569   7408         MOV       A,#0x8
   \   00056B   12....       LCALL     ?XSTACK_DISP102_8
   \   00056E   85..82       MOV       DPL,?V2
   \   000571   85..83       MOV       DPH,?V3
   \   000574   E0           MOVX      A,@DPTR
   \   000575   2406         ADD       A,#0x6
   \   000577   FA           MOV       R2,A
   \   000578   A3           INC       DPTR
   \   000579   E0           MOVX      A,@DPTR
   \   00057A   3400         ADDC      A,#0x0
   \   00057C   FB           MOV       R3,A
   \   00057D   85..82       MOV       DPL,?V2
   \   000580   85..83       MOV       DPH,?V3
   \   000583   E0           MOVX      A,@DPTR
   \   000584   F8           MOV       R0,A
   \   000585   A3           INC       DPTR
   \   000586   E0           MOVX      A,@DPTR
   \   000587   C8           XCH       A,R0
   \   000588   2414         ADD       A,#0x14
   \   00058A   F582         MOV       DPL,A
   \   00058C   C8           XCH       A,R0
   \   00058D   3400         ADDC      A,#0x0
   \   00058F   F583         MOV       DPH,A
   \   000591   E0           MOVX      A,@DPTR
   \   000592   F9           MOV       R1,A
   \   000593   12....       LCALL     `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \   000596   7402         MOV       A,#0x2
   \   000598   12....       LCALL     ?DEALLOC_XSTACK8
   \   00059B   E9           MOV       A,R1
   \   00059C   F5..         MOV       ?V4,A
   4824                }
   4825          
   4826                // If successful, a write attribute status record shall NOT be generated
   4827                if ( status != ZCL_STATUS_SUCCESS )
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   00059E   E5..         MOV       A,?V4
   \   0005A0   607E         JZ        ??zclProcessInWriteUndividedCmd_17
   4828                {
   4829                  writeRspCmd->attrList[j].status = status;
   \   0005A2   E5..         MOV       A,?V4
   \   0005A4   C0E0         PUSH      A
   \   0005A6   EE           MOV       A,R6
   \   0005A7   F8           MOV       R0,A
   \   0005A8   7900         MOV       R1,#0x0
   \   0005AA   E8           MOV       A,R0
   \   0005AB   75F003       MOV       B,#0x3
   \   0005AE   A4           MUL       AB
   \   0005AF   C8           XCH       A,R0
   \   0005B0   AAF0         MOV       R2,B
   \   0005B2   75F000       MOV       B,#0x0
   \   0005B5   A4           MUL       AB
   \   0005B6   2A           ADD       A,R2
   \   0005B7   FA           MOV       R2,A
   \   0005B8   75F003       MOV       B,#0x3
   \   0005BB   E9           MOV       A,R1
   \   0005BC   A4           MUL       AB
   \   0005BD   2A           ADD       A,R2
   \   0005BE   F9           MOV       R1,A
   \   0005BF   E5..         MOV       A,?V0
   \   0005C1   28           ADD       A,R0
   \   0005C2   F582         MOV       DPL,A
   \   0005C4   E5..         MOV       A,?V1
   \   0005C6   39           ADDC      A,R1
   \   0005C7   F583         MOV       DPH,A
   \   0005C9   A3           INC       DPTR
   \   0005CA   D0E0         POP       A
   \   0005CC   F0           MOVX      @DPTR,A
   4830                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   0005CD   85..82       MOV       DPL,?V8
   \   0005D0   85..83       MOV       DPH,?V9
   \   0005D3   E0           MOVX      A,@DPTR
   \   0005D4   FA           MOV       R2,A
   \   0005D5   A3           INC       DPTR
   \   0005D6   E0           MOVX      A,@DPTR
   \   0005D7   FB           MOV       R3,A
   \   0005D8   EE           MOV       A,R6
   \   0005D9   F8           MOV       R0,A
   \   0005DA   7900         MOV       R1,#0x0
   \   0005DC   E8           MOV       A,R0
   \   0005DD   75F003       MOV       B,#0x3
   \   0005E0   A4           MUL       AB
   \   0005E1   C8           XCH       A,R0
   \   0005E2   ACF0         MOV       R4,B
   \   0005E4   75F000       MOV       B,#0x0
   \   0005E7   A4           MUL       AB
   \   0005E8   2C           ADD       A,R4
   \   0005E9   FC           MOV       R4,A
   \   0005EA   75F003       MOV       B,#0x3
   \   0005ED   E9           MOV       A,R1
   \   0005EE   A4           MUL       AB
   \   0005EF   2C           ADD       A,R4
   \   0005F0   F9           MOV       R1,A
   \   0005F1   E5..         MOV       A,?V0
   \   0005F3   28           ADD       A,R0
   \   0005F4   F582         MOV       DPL,A
   \   0005F6   E5..         MOV       A,?V1
   \   0005F8   39           ADDC      A,R1
   \   0005F9   F583         MOV       DPH,A
   \   0005FB   A3           INC       DPTR
   \   0005FC   A3           INC       DPTR
   \   0005FD   EA           MOV       A,R2
   \   0005FE   F0           MOVX      @DPTR,A
   \   0005FF   A3           INC       DPTR
   \   000600   EB           MOV       A,R3
   \   000601   F0           MOVX      @DPTR,A
   \   000602   0E           INC       R6
   4831          
   4832                  // Since this write failed, we need to revert all the pervious writes
   4833                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   \   000603                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   000603   EF           MOV       A,R7
   \   000604   F5..         MOV       ?V10,A
   \   000606   75..00       MOV       ?V11,#0x0
   \   000609   78..         MOV       R0,#?V10
   \   00060B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00060E   AC..         MOV       R4,?V12
   \   000610   AD..         MOV       R5,?V13
   \   000612   AA..         MOV       R2,?V2
   \   000614   AB..         MOV       R3,?V3
   \   000616   12....       LCALL     `??zclRevertWriteUndividedCmd::?relay`; Banked call to: zclRevertWriteUndividedCmd
   \   000619   7402         MOV       A,#0x2
   \   00061B   12....       LCALL     ?DEALLOC_XSTACK8
   4834                  break;
   \   00061E   8038         SJMP      ??zclProcessInWriteUndividedCmd_14
   4835                }
   4836          
   4837                // add padding if needed
   4838                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000620   85..82       MOV       DPL,?XSP + 0
   \   000623   85..83       MOV       DPH,?XSP + 1
   \   000626   E0           MOVX      A,@DPTR
   \   000627   F8           MOV       R0,A
   \   000628   A3           INC       DPTR
   \   000629   E0           MOVX      A,@DPTR
   \   00062A   F9           MOV       R1,A
   \   00062B   E8           MOV       A,R0
   \   00062C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00062E   500F         JNC       ??zclProcessInWriteUndividedCmd_18
   4839                {
   4840                  dataLen++;
   \   000630   85..82       MOV       DPL,?XSP + 0
   \   000633   85..83       MOV       DPH,?XSP + 1
   \   000636   E0           MOVX      A,@DPTR
   \   000637   2401         ADD       A,#0x1
   \   000639   F0           MOVX      @DPTR,A
   \   00063A   A3           INC       DPTR
   \   00063B   E0           MOVX      A,@DPTR
   \   00063C   3400         ADDC      A,#0x0
   \   00063E   F0           MOVX      @DPTR,A
   4841                }
   4842          
   4843                curDataPtr += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   00063F   85..82       MOV       DPL,?XSP + 0
   \   000642   85..83       MOV       DPH,?XSP + 1
   \   000645   E0           MOVX      A,@DPTR
   \   000646   F8           MOV       R0,A
   \   000647   A3           INC       DPTR
   \   000648   E0           MOVX      A,@DPTR
   \   000649   F9           MOV       R1,A
   \   00064A   E5..         MOV       A,?V6
   \   00064C   28           ADD       A,R0
   \   00064D   F5..         MOV       ?V6,A
   \   00064F   E5..         MOV       A,?V7
   \   000651   39           ADDC      A,R1
   \   000652   F5..         MOV       ?V7,A
   4844              } // for loop
   \   000654   0F           INC       R7
   \   000655   02....       LJMP      ??zclProcessInWriteUndividedCmd_13 & 0xFFFF
   4845          
   4846              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000658   EE           MOV       A,R6
   \   000659   C0E0         PUSH      A
   \   00065B   85..82       MOV       DPL,?V0
   \   00065E   85..83       MOV       DPH,?V1
   \   000661   D0E0         POP       A
   \   000663   F0           MOVX      @DPTR,A
   4847              if ( writeRspCmd->numAttr  == 0 )
   \   000664   85..82       MOV       DPL,?V0
   \   000667   85..83       MOV       DPH,?V1
   \   00066A   E0           MOVX      A,@DPTR
   \   00066B   7013         JNZ       ??zclProcessInWriteUndividedCmd_19
   4848              {
   4849                // Since all records were written successful, include a single status record
   4850                // in the resonse command with the status field set to SUCCESS and the
   4851                // attribute ID field omitted.
   4852                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00066D   85..82       MOV       DPL,?V0
   \   000670   85..83       MOV       DPH,?V1
   \   000673   A3           INC       DPTR
   \   000674   7400         MOV       A,#0x0
   \   000676   F0           MOVX      @DPTR,A
   4853                writeRspCmd->numAttr = 1;
   \   000677   85..82       MOV       DPL,?V0
   \   00067A   85..83       MOV       DPH,?V1
   \   00067D   7401         MOV       A,#0x1
   \   00067F   F0           MOVX      @DPTR,A
   4854              }
   4855          
   4856              zcl_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   000680                ; Setup parameters for call to function osal_mem_free
   \   000680   AA..         MOV       R2,?V12
   \   000682   AB..         MOV       R3,?V13
   \   000684   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4857            }
   4858          
   4859            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4860                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4861                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000687                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000687   85..82       MOV       DPL,?V2
   \   00068A   85..83       MOV       DPH,?V3
   \   00068D   A3           INC       DPTR
   \   00068E   A3           INC       DPTR
   \   00068F   A3           INC       DPTR
   \   000690   A3           INC       DPTR
   \   000691   A3           INC       DPTR
   \   000692   A3           INC       DPTR
   \   000693   E0           MOVX      A,@DPTR
   \   000694   F5..         MOV       ?V4,A
   \   000696   78..         MOV       R0,#?V4
   \   000698   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00069B   75..01       MOV       ?V4,#0x1
   \   00069E   78..         MOV       R0,#?V4
   \   0006A0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0006A3   85..82       MOV       DPL,?V2
   \   0006A6   85..83       MOV       DPH,?V3
   \   0006A9   A3           INC       DPTR
   \   0006AA   A3           INC       DPTR
   \   0006AB   E0           MOVX      A,@DPTR
   \   0006AC   F8           MOV       R0,A
   \   0006AD   A3           INC       DPTR
   \   0006AE   E0           MOVX      A,@DPTR
   \   0006AF   F9           MOV       R1,A
   \   0006B0   E8           MOV       A,R0
   \   0006B1   13           RRC       A
   \   0006B2   13           RRC       A
   \   0006B3   13           RRC       A
   \   0006B4   541F         ANL       A,#0x1f
   \   0006B6   6401         XRL       A,#0x1
   \   0006B8   5401         ANL       A,#0x1
   \   0006BA   F5..         MOV       ?V4,A
   \   0006BC   78..         MOV       R0,#?V4
   \   0006BE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0006C1   78..         MOV       R0,#?V0
   \   0006C3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0006C6   85..82       MOV       DPL,?V2
   \   0006C9   85..83       MOV       DPH,?V3
   \   0006CC   E0           MOVX      A,@DPTR
   \   0006CD   F8           MOV       R0,A
   \   0006CE   A3           INC       DPTR
   \   0006CF   E0           MOVX      A,@DPTR
   \   0006D0   F583         MOV       DPH,A
   \   0006D2   8882         MOV       DPL,R0
   \   0006D4   A3           INC       DPTR
   \   0006D5   A3           INC       DPTR
   \   0006D6   A3           INC       DPTR
   \   0006D7   A3           INC       DPTR
   \   0006D8   E0           MOVX      A,@DPTR
   \   0006D9   FC           MOV       R4,A
   \   0006DA   A3           INC       DPTR
   \   0006DB   E0           MOVX      A,@DPTR
   \   0006DC   FD           MOV       R5,A
   \   0006DD   85..82       MOV       DPL,?V2
   \   0006E0   85..83       MOV       DPH,?V3
   \   0006E3   E0           MOVX      A,@DPTR
   \   0006E4   2406         ADD       A,#0x6
   \   0006E6   FA           MOV       R2,A
   \   0006E7   A3           INC       DPTR
   \   0006E8   E0           MOVX      A,@DPTR
   \   0006E9   3400         ADDC      A,#0x0
   \   0006EB   FB           MOV       R3,A
   \   0006EC   85..82       MOV       DPL,?V2
   \   0006EF   85..83       MOV       DPH,?V3
   \   0006F2   E0           MOVX      A,@DPTR
   \   0006F3   F8           MOV       R0,A
   \   0006F4   A3           INC       DPTR
   \   0006F5   E0           MOVX      A,@DPTR
   \   0006F6   C8           XCH       A,R0
   \   0006F7   2414         ADD       A,#0x14
   \   0006F9   F582         MOV       DPL,A
   \   0006FB   C8           XCH       A,R0
   \   0006FC   3400         ADDC      A,#0x0
   \   0006FE   F583         MOV       DPH,A
   \   000700   E0           MOVX      A,@DPTR
   \   000701   F9           MOV       R1,A
   \   000702   12....       LCALL     `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   000705   7405         MOV       A,#0x5
   \   000707   12....       LCALL     ?DEALLOC_XSTACK8
   \   00070A   E9           MOV       A,R1
   4862            zcl_mem_free( writeRspCmd );
   \   00070B                ; Setup parameters for call to function osal_mem_free
   \   00070B   AA..         MOV       R2,?V0
   \   00070D   AB..         MOV       R3,?V1
   \   00070F   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4863          
   4864            return TRUE;
   \   000712   7901         MOV       R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000714   740E         MOV       A,#0xe
   \   000716   12....       LCALL     ?DEALLOC_XSTACK8
   \   000719   7F10         MOV       R7,#0x10
   \   00071B   02....       LJMP      ?BANKED_LEAVE_XDATA
   4865          }
   4866          #endif // ZCL_WRITE
   4867          
   4868          #ifdef ZCL_DISCOVER
   4869          /*********************************************************************
   4870           * @fn      zclProcessInDiscAttrs
   4871           *
   4872           * @brief   Process the "Profile" Discover Attributes Commands
   4873           *
   4874           * @param   pInMsg - incoming message to process
   4875           *
   4876           * @return  TRUE if command processed. FALSE, otherwise.
   4877           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4878          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   \                     zclProcessInDiscAttrs:
   4879          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   4880            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4881            zclAttrRec_t attrRec;
   4882            uint16 attrID;
   4883            uint8 numAttrs;
   4884            uint8 i;
   4885          
   4886            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV       A,R6
   \   00000F   240C         ADD       A,#0xc
   \   000011   F582         MOV       DPL,A
   \   000013   E4           CLR       A
   \   000014   3F           ADDC      A,R7
   \   000015   F583         MOV       DPH,A
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F9           MOV       R1,A
   \   00001C   88..         MOV       ?V2,R0
   \   00001E   89..         MOV       ?V3,R1
   4887          
   4888            // Find out the number of attributes supported within the specified range
   4889            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   \   000020   75..00       MOV       ?V1,#0x0
   \   000023   85..82       MOV       DPL,?V2
   \   000026   85..83       MOV       DPH,?V3
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   F8           MOV       R0,A
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F9           MOV       R1,A
   \   00002E   85..82       MOV       DPL,?XSP + 0
   \   000031   85..83       MOV       DPH,?XSP + 1
   \   000034   E8           MOV       A,R0
   \   000035   F0           MOVX      @DPTR,A
   \   000036   A3           INC       DPTR
   \   000037   E9           MOV       A,R1
   \   000038   F0           MOVX      @DPTR,A
   \                     ??zclProcessInDiscAttrs_0:
   \   000039   85..82       MOV       DPL,?V2
   \   00003C   85..83       MOV       DPH,?V3
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   F8           MOV       R0,A
   \   000043   E5..         MOV       A,?V1
   \   000045   C3           CLR       C
   \   000046   98           SUBB      A,R0
   \   000047   5078         JNC       ??zclProcessInDiscAttrs_1
   4890            {
   4891              // finds the next attribute on this endpoint/cluster after the range.
   4892              // attributes must be in numerical order in the list.
   4893              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \   000049                ; Setup parameters for call to function zclFindNextAttrRec
   \   000049   7402         MOV       A,#0x2
   \   00004B   12....       LCALL     ?XSTACK_DISP100_8
   \   00004E   88..         MOV       ?V4,R0
   \   000050   89..         MOV       ?V5,R1
   \   000052   78..         MOV       R0,#?V4
   \   000054   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000057   7402         MOV       A,#0x2
   \   000059   12....       LCALL     ?XSTACK_DISP100_8
   \   00005C   88..         MOV       ?V4,R0
   \   00005E   89..         MOV       ?V5,R1
   \   000060   78..         MOV       R0,#?V4
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000065   8E82         MOV       DPL,R6
   \   000067   8F83         MOV       DPH,R7
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   F8           MOV       R0,A
   \   00006D   A3           INC       DPTR
   \   00006E   E0           MOVX      A,@DPTR
   \   00006F   F9           MOV       R1,A
   \   000070   E8           MOV       A,R0
   \   000071   13           RRC       A
   \   000072   13           RRC       A
   \   000073   13           RRC       A
   \   000074   541F         ANL       A,#0x1f
   \   000076   5401         ANL       A,#0x1
   \   000078   FC           MOV       R4,A
   \   000079   8E82         MOV       DPL,R6
   \   00007B   8F83         MOV       DPH,R7
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   F8           MOV       R0,A
   \   00007F   A3           INC       DPTR
   \   000080   E0           MOVX      A,@DPTR
   \   000081   F583         MOV       DPH,A
   \   000083   8882         MOV       DPL,R0
   \   000085   A3           INC       DPTR
   \   000086   A3           INC       DPTR
   \   000087   A3           INC       DPTR
   \   000088   A3           INC       DPTR
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   FA           MOV       R2,A
   \   00008B   A3           INC       DPTR
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   FB           MOV       R3,A
   \   00008E   8E82         MOV       DPL,R6
   \   000090   8F83         MOV       DPH,R7
   \   000092   E0           MOVX      A,@DPTR
   \   000093   F8           MOV       R0,A
   \   000094   A3           INC       DPTR
   \   000095   E0           MOVX      A,@DPTR
   \   000096   C8           XCH       A,R0
   \   000097   2414         ADD       A,#0x14
   \   000099   F582         MOV       DPL,A
   \   00009B   C8           XCH       A,R0
   \   00009C   3400         ADDC      A,#0x0
   \   00009E   F583         MOV       DPH,A
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   F9           MOV       R1,A
   \   0000A2   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   0000A5   7404         MOV       A,#0x4
   \   0000A7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV       A,R1
   \   0000AB   6014         JZ        ??zclProcessInDiscAttrs_1
   4894              {
   4895                break;
   4896              }
   4897            }
   \   0000AD   05..         INC       ?V1
   \   0000AF   85..82       MOV       DPL,?XSP + 0
   \   0000B2   85..83       MOV       DPH,?XSP + 1
   \   0000B5   E0           MOVX      A,@DPTR
   \   0000B6   2401         ADD       A,#0x1
   \   0000B8   F0           MOVX      @DPTR,A
   \   0000B9   A3           INC       DPTR
   \   0000BA   E0           MOVX      A,@DPTR
   \   0000BB   3400         ADDC      A,#0x0
   \   0000BD   F0           MOVX      @DPTR,A
   \   0000BE   02....       LJMP      ??zclProcessInDiscAttrs_0 & 0xFFFF
   4898          
   4899            numAttrs = i;  // store range of attributes in buffer
   \                     ??zclProcessInDiscAttrs_1:
   \   0000C1   85....       MOV       ?V0,?V1
   4900          
   4901              // Process message for either attributes or extended attributes
   4902            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   \   0000C4   8E82         MOV       DPL,R6
   \   0000C6   8F83         MOV       DPH,R7
   \   0000C8   A3           INC       DPTR
   \   0000C9   A3           INC       DPTR
   \   0000CA   A3           INC       DPTR
   \   0000CB   A3           INC       DPTR
   \   0000CC   A3           INC       DPTR
   \   0000CD   A3           INC       DPTR
   \   0000CE   A3           INC       DPTR
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   640C         XRL       A,#0xc
   \   0000D2   700F         JNZ       ??zclProcessInDiscAttrs_2
   4903            {
   4904              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   \   0000D4                ; Setup parameters for call to function zclProcessInDiscAttrsCmd
   \   0000D4   A9..         MOV       R1,?V0
   \   0000D6   AC..         MOV       R4,?V2
   \   0000D8   AD..         MOV       R5,?V3
   \   0000DA   EE           MOV       A,R6
   \   0000DB   FA           MOV       R2,A
   \   0000DC   EF           MOV       A,R7
   \   0000DD   FB           MOV       R3,A
   \   0000DE   12....       LCALL     `??zclProcessInDiscAttrsCmd::?relay`; Banked call to: zclProcessInDiscAttrsCmd
   \   0000E1   801D         SJMP      ??zclProcessInDiscAttrs_3
   4905            }
   4906            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   \                     ??zclProcessInDiscAttrs_2:
   \   0000E3   8E82         MOV       DPL,R6
   \   0000E5   8F83         MOV       DPH,R7
   \   0000E7   A3           INC       DPTR
   \   0000E8   A3           INC       DPTR
   \   0000E9   A3           INC       DPTR
   \   0000EA   A3           INC       DPTR
   \   0000EB   A3           INC       DPTR
   \   0000EC   A3           INC       DPTR
   \   0000ED   A3           INC       DPTR
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   6415         XRL       A,#0x15
   \   0000F1   700D         JNZ       ??zclProcessInDiscAttrs_3
   4907            {
   4908              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   \   0000F3                ; Setup parameters for call to function zclProcessInDiscAttrsExtCmd
   \   0000F3   A9..         MOV       R1,?V0
   \   0000F5   AC..         MOV       R4,?V2
   \   0000F7   AD..         MOV       R5,?V3
   \   0000F9   EE           MOV       A,R6
   \   0000FA   FA           MOV       R2,A
   \   0000FB   EF           MOV       A,R7
   \   0000FC   FB           MOV       R3,A
   \   0000FD   12....       LCALL     `??zclProcessInDiscAttrsExtCmd::?relay`; Banked call to: zclProcessInDiscAttrsExtCmd
   4909            }
   4910          
   4911            return TRUE;
   \                     ??zclProcessInDiscAttrs_3:
   \   000100   7901         MOV       R1,#0x1
   \   000102   740A         MOV       A,#0xa
   \   000104   12....       LCALL     ?DEALLOC_XSTACK8
   \   000107   7F06         MOV       R7,#0x6
   \   000109   02....       LJMP      ?BANKED_LEAVE_XDATA
   4912          }
   4913          
   4914          /*********************************************************************
   4915           * @fn      zclProcessInDiscAttrsCmd
   4916           *
   4917           * @brief   Process the Discover Attributes Command
   4918           *
   4919           * @param   pInMsg - incoming message to process
   4920           *
   4921           * @param   pDiscoverCmd - structure from requesting command
   4922           *
   4923           * @param   attrLenBuf - describes the amount of attributes to be processed
   4924           *
   4925           * @return  none
   4926           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4927          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   \                     zclProcessInDiscAttrsCmd:
   4928          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V4,R4
   \   000010   8D..         MOV       ?V5,R5
   \   000012   89..         MOV       ?V2,R1
   4929            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4930            uint8 discComplete = TRUE;
   \   000014   75..01       MOV       ?V1,#0x1
   4931            zclAttrRec_t attrRec;
   4932            uint16 attrID;
   4933            uint8 i;
   4934          
   4935            // Allocate space for the response command
   4936            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4937                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   \   000017                ; Setup parameters for call to function osal_mem_alloc
   \   000017   E5..         MOV       A,?V2
   \   000019   F8           MOV       R0,A
   \   00001A   7900         MOV       R1,#0x0
   \   00001C   E8           MOV       A,R0
   \   00001D   75F003       MOV       B,#0x3
   \   000020   A4           MUL       AB
   \   000021   C8           XCH       A,R0
   \   000022   AAF0         MOV       R2,B
   \   000024   75F000       MOV       B,#0x0
   \   000027   A4           MUL       AB
   \   000028   2A           ADD       A,R2
   \   000029   FA           MOV       R2,A
   \   00002A   75F003       MOV       B,#0x3
   \   00002D   E9           MOV       A,R1
   \   00002E   A4           MUL       AB
   \   00002F   2A           ADD       A,R2
   \   000030   F9           MOV       R1,A
   \   000031   E8           MOV       A,R0
   \   000032   2402         ADD       A,#0x2
   \   000034   FA           MOV       R2,A
   \   000035   E4           CLR       A
   \   000036   39           ADDC      A,R1
   \   000037   FB           MOV       R3,A
   \   000038   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV       ?V8,R2
   \   00003D   8B..         MOV       ?V9,R3
   \   00003F   85....       MOV       ?V6,?V8
   \   000042   85....       MOV       ?V7,?V9
   4938            if ( pDiscoverRsp == NULL )
   \   000045   E5..         MOV       A,?V6
   \   000047   45..         ORL       A,?V7
   \   000049   7003         JNZ       $+5
   \   00004B   02....       LJMP      ??zclProcessInDiscAttrsCmd_0 & 0xFFFF
   4939            {
   4940              return; // EMBEDDED RETURN
   4941            }
   4942          
   4943            if ( numAttrs != 0 )
   \   00004E   E5..         MOV       A,?V2
   \   000050   7003         JNZ       $+5
   \   000052   02....       LJMP      ??zclProcessInDiscAttrsCmd_1 & 0xFFFF
   4944            {
   4945              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   \   000055   75..00       MOV       ?V0,#0x0
   \   000058   85..82       MOV       DPL,?V4
   \   00005B   85..83       MOV       DPH,?V5
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F8           MOV       R0,A
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   F9           MOV       R1,A
   \   000063   85..82       MOV       DPL,?XSP + 0
   \   000066   85..83       MOV       DPH,?XSP + 1
   \   000069   E8           MOV       A,R0
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   A3           INC       DPTR
   \   00006C   E9           MOV       A,R1
   \   00006D   F0           MOVX      @DPTR,A
   \                     ??zclProcessInDiscAttrsCmd_2:
   \   00006E   E5..         MOV       A,?V0
   \   000070   C3           CLR       C
   \   000071   95..         SUBB      A,?V2
   \   000073   4003         JC        $+5
   \   000075   02....       LJMP      ??zclProcessInDiscAttrsCmd_3 & 0xFFFF
   4946              {
   4947                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \   000078                ; Setup parameters for call to function zclFindNextAttrRec
   \   000078   7402         MOV       A,#0x2
   \   00007A   12....       LCALL     ?XSTACK_DISP100_8
   \   00007D   88..         MOV       ?V8,R0
   \   00007F   89..         MOV       ?V9,R1
   \   000081   78..         MOV       R0,#?V8
   \   000083   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000086   7402         MOV       A,#0x2
   \   000088   12....       LCALL     ?XSTACK_DISP100_8
   \   00008B   88..         MOV       ?V8,R0
   \   00008D   89..         MOV       ?V9,R1
   \   00008F   78..         MOV       R0,#?V8
   \   000091   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000094   8E82         MOV       DPL,R6
   \   000096   8F83         MOV       DPH,R7
   \   000098   A3           INC       DPTR
   \   000099   A3           INC       DPTR
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   F8           MOV       R0,A
   \   00009C   A3           INC       DPTR
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   F9           MOV       R1,A
   \   00009F   E8           MOV       A,R0
   \   0000A0   13           RRC       A
   \   0000A1   13           RRC       A
   \   0000A2   13           RRC       A
   \   0000A3   541F         ANL       A,#0x1f
   \   0000A5   5401         ANL       A,#0x1
   \   0000A7   FC           MOV       R4,A
   \   0000A8   8E82         MOV       DPL,R6
   \   0000AA   8F83         MOV       DPH,R7
   \   0000AC   E0           MOVX      A,@DPTR
   \   0000AD   F8           MOV       R0,A
   \   0000AE   A3           INC       DPTR
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   F583         MOV       DPH,A
   \   0000B2   8882         MOV       DPL,R0
   \   0000B4   A3           INC       DPTR
   \   0000B5   A3           INC       DPTR
   \   0000B6   A3           INC       DPTR
   \   0000B7   A3           INC       DPTR
   \   0000B8   E0           MOVX      A,@DPTR
   \   0000B9   FA           MOV       R2,A
   \   0000BA   A3           INC       DPTR
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   FB           MOV       R3,A
   \   0000BD   8E82         MOV       DPL,R6
   \   0000BF   8F83         MOV       DPH,R7
   \   0000C1   E0           MOVX      A,@DPTR
   \   0000C2   F8           MOV       R0,A
   \   0000C3   A3           INC       DPTR
   \   0000C4   E0           MOVX      A,@DPTR
   \   0000C5   C8           XCH       A,R0
   \   0000C6   2414         ADD       A,#0x14
   \   0000C8   F582         MOV       DPL,A
   \   0000CA   C8           XCH       A,R0
   \   0000CB   3400         ADDC      A,#0x0
   \   0000CD   F583         MOV       DPH,A
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   F9           MOV       R1,A
   \   0000D1   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   0000D4   7404         MOV       A,#0x4
   \   0000D6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000D9   E9           MOV       A,R1
   \   0000DA   607C         JZ        ??zclProcessInDiscAttrsCmd_3
   4948                {
   4949                  break; // should not happen, as numAttrs already calculated
   4950                }
   4951          
   4952                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   \   0000DC   7404         MOV       A,#0x4
   \   0000DE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E1   E0           MOVX      A,@DPTR
   \   0000E2   FA           MOV       R2,A
   \   0000E3   A3           INC       DPTR
   \   0000E4   E0           MOVX      A,@DPTR
   \   0000E5   FB           MOV       R3,A
   \   0000E6   E5..         MOV       A,?V0
   \   0000E8   F8           MOV       R0,A
   \   0000E9   7900         MOV       R1,#0x0
   \   0000EB   E8           MOV       A,R0
   \   0000EC   75F003       MOV       B,#0x3
   \   0000EF   A4           MUL       AB
   \   0000F0   C8           XCH       A,R0
   \   0000F1   ACF0         MOV       R4,B
   \   0000F3   75F000       MOV       B,#0x0
   \   0000F6   A4           MUL       AB
   \   0000F7   2C           ADD       A,R4
   \   0000F8   FC           MOV       R4,A
   \   0000F9   75F003       MOV       B,#0x3
   \   0000FC   E9           MOV       A,R1
   \   0000FD   A4           MUL       AB
   \   0000FE   2C           ADD       A,R4
   \   0000FF   F9           MOV       R1,A
   \   000100   E5..         MOV       A,?V6
   \   000102   28           ADD       A,R0
   \   000103   F582         MOV       DPL,A
   \   000105   E5..         MOV       A,?V7
   \   000107   39           ADDC      A,R1
   \   000108   F583         MOV       DPH,A
   \   00010A   A3           INC       DPTR
   \   00010B   A3           INC       DPTR
   \   00010C   EA           MOV       A,R2
   \   00010D   F0           MOVX      @DPTR,A
   \   00010E   A3           INC       DPTR
   \   00010F   EB           MOV       A,R3
   \   000110   F0           MOVX      @DPTR,A
   4953                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   \   000111   7406         MOV       A,#0x6
   \   000113   12....       LCALL     ?XSTACK_DISP0_8
   \   000116   E0           MOVX      A,@DPTR
   \   000117   C0E0         PUSH      A
   \   000119   E5..         MOV       A,?V0
   \   00011B   F8           MOV       R0,A
   \   00011C   7900         MOV       R1,#0x0
   \   00011E   E8           MOV       A,R0
   \   00011F   75F003       MOV       B,#0x3
   \   000122   A4           MUL       AB
   \   000123   C8           XCH       A,R0
   \   000124   AAF0         MOV       R2,B
   \   000126   75F000       MOV       B,#0x0
   \   000129   A4           MUL       AB
   \   00012A   2A           ADD       A,R2
   \   00012B   FA           MOV       R2,A
   \   00012C   75F003       MOV       B,#0x3
   \   00012F   E9           MOV       A,R1
   \   000130   A4           MUL       AB
   \   000131   2A           ADD       A,R2
   \   000132   F9           MOV       R1,A
   \   000133   E5..         MOV       A,?V6
   \   000135   28           ADD       A,R0
   \   000136   F582         MOV       DPL,A
   \   000138   E5..         MOV       A,?V7
   \   00013A   39           ADDC      A,R1
   \   00013B   F583         MOV       DPH,A
   \   00013D   A3           INC       DPTR
   \   00013E   A3           INC       DPTR
   \   00013F   A3           INC       DPTR
   \   000140   A3           INC       DPTR
   \   000141   D0E0         POP       A
   \   000143   F0           MOVX      @DPTR,A
   4954              }
   \   000144   05..         INC       ?V0
   \   000146   85..82       MOV       DPL,?XSP + 0
   \   000149   85..83       MOV       DPH,?XSP + 1
   \   00014C   E0           MOVX      A,@DPTR
   \   00014D   2401         ADD       A,#0x1
   \   00014F   F0           MOVX      @DPTR,A
   \   000150   A3           INC       DPTR
   \   000151   E0           MOVX      A,@DPTR
   \   000152   3400         ADDC      A,#0x0
   \   000154   F0           MOVX      @DPTR,A
   \   000155   02....       LJMP      ??zclProcessInDiscAttrsCmd_2 & 0xFFFF
   4955          
   4956              // Are there more attributes to be discovered?
   4957              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \                     ??zclProcessInDiscAttrsCmd_3:
   \   000158                ; Setup parameters for call to function zclFindNextAttrRec
   \   000158   7402         MOV       A,#0x2
   \   00015A   12....       LCALL     ?XSTACK_DISP100_8
   \   00015D   88..         MOV       ?V8,R0
   \   00015F   89..         MOV       ?V9,R1
   \   000161   78..         MOV       R0,#?V8
   \   000163   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000166   7402         MOV       A,#0x2
   \   000168   12....       LCALL     ?XSTACK_DISP100_8
   \   00016B   88..         MOV       ?V8,R0
   \   00016D   89..         MOV       ?V9,R1
   \   00016F   78..         MOV       R0,#?V8
   \   000171   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000174   8E82         MOV       DPL,R6
   \   000176   8F83         MOV       DPH,R7
   \   000178   A3           INC       DPTR
   \   000179   A3           INC       DPTR
   \   00017A   E0           MOVX      A,@DPTR
   \   00017B   F8           MOV       R0,A
   \   00017C   A3           INC       DPTR
   \   00017D   E0           MOVX      A,@DPTR
   \   00017E   F9           MOV       R1,A
   \   00017F   E8           MOV       A,R0
   \   000180   13           RRC       A
   \   000181   13           RRC       A
   \   000182   13           RRC       A
   \   000183   541F         ANL       A,#0x1f
   \   000185   5401         ANL       A,#0x1
   \   000187   FC           MOV       R4,A
   \   000188   8E82         MOV       DPL,R6
   \   00018A   8F83         MOV       DPH,R7
   \   00018C   E0           MOVX      A,@DPTR
   \   00018D   F8           MOV       R0,A
   \   00018E   A3           INC       DPTR
   \   00018F   E0           MOVX      A,@DPTR
   \   000190   F583         MOV       DPH,A
   \   000192   8882         MOV       DPL,R0
   \   000194   A3           INC       DPTR
   \   000195   A3           INC       DPTR
   \   000196   A3           INC       DPTR
   \   000197   A3           INC       DPTR
   \   000198   E0           MOVX      A,@DPTR
   \   000199   FA           MOV       R2,A
   \   00019A   A3           INC       DPTR
   \   00019B   E0           MOVX      A,@DPTR
   \   00019C   FB           MOV       R3,A
   \   00019D   8E82         MOV       DPL,R6
   \   00019F   8F83         MOV       DPH,R7
   \   0001A1   E0           MOVX      A,@DPTR
   \   0001A2   F8           MOV       R0,A
   \   0001A3   A3           INC       DPTR
   \   0001A4   E0           MOVX      A,@DPTR
   \   0001A5   C8           XCH       A,R0
   \   0001A6   2414         ADD       A,#0x14
   \   0001A8   F582         MOV       DPL,A
   \   0001AA   C8           XCH       A,R0
   \   0001AB   3400         ADDC      A,#0x0
   \   0001AD   F583         MOV       DPH,A
   \   0001AF   E0           MOVX      A,@DPTR
   \   0001B0   F9           MOV       R1,A
   \   0001B1   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   0001B4   7404         MOV       A,#0x4
   \   0001B6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001B9   E9           MOV       A,R1
   \   0001BA   6003         JZ        ??zclProcessInDiscAttrsCmd_1
   4958              {
   4959                discComplete = FALSE;
   \   0001BC   75..00       MOV       ?V1,#0x0
   4960              }
   4961            }
   4962          
   4963            pDiscoverRsp->discComplete = discComplete;
   \                     ??zclProcessInDiscAttrsCmd_1:
   \   0001BF   E5..         MOV       A,?V1
   \   0001C1   C0E0         PUSH      A
   \   0001C3   85..82       MOV       DPL,?V6
   \   0001C6   85..83       MOV       DPH,?V7
   \   0001C9   D0E0         POP       A
   \   0001CB   F0           MOVX      @DPTR,A
   4964            pDiscoverRsp->numAttr = numAttrs;
   \   0001CC   E5..         MOV       A,?V2
   \   0001CE   C0E0         PUSH      A
   \   0001D0   85..82       MOV       DPL,?V6
   \   0001D3   85..83       MOV       DPH,?V7
   \   0001D6   A3           INC       DPTR
   \   0001D7   D0E0         POP       A
   \   0001D9   F0           MOVX      @DPTR,A
   4965          
   4966            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4967                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4968                                         true, pInMsg->hdr.transSeqNum );
   \   0001DA                ; Setup parameters for call to function zcl_SendDiscoverAttrsRspCmd
   \   0001DA   8E82         MOV       DPL,R6
   \   0001DC   8F83         MOV       DPH,R7
   \   0001DE   A3           INC       DPTR
   \   0001DF   A3           INC       DPTR
   \   0001E0   A3           INC       DPTR
   \   0001E1   A3           INC       DPTR
   \   0001E2   A3           INC       DPTR
   \   0001E3   A3           INC       DPTR
   \   0001E4   E0           MOVX      A,@DPTR
   \   0001E5   F5..         MOV       ?V3,A
   \   0001E7   78..         MOV       R0,#?V3
   \   0001E9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001EC   75..01       MOV       ?V3,#0x1
   \   0001EF   78..         MOV       R0,#?V3
   \   0001F1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001F4   8E82         MOV       DPL,R6
   \   0001F6   8F83         MOV       DPH,R7
   \   0001F8   A3           INC       DPTR
   \   0001F9   A3           INC       DPTR
   \   0001FA   E0           MOVX      A,@DPTR
   \   0001FB   F8           MOV       R0,A
   \   0001FC   A3           INC       DPTR
   \   0001FD   E0           MOVX      A,@DPTR
   \   0001FE   F9           MOV       R1,A
   \   0001FF   E8           MOV       A,R0
   \   000200   13           RRC       A
   \   000201   13           RRC       A
   \   000202   13           RRC       A
   \   000203   541F         ANL       A,#0x1f
   \   000205   6401         XRL       A,#0x1
   \   000207   5401         ANL       A,#0x1
   \   000209   F5..         MOV       ?V3,A
   \   00020B   78..         MOV       R0,#?V3
   \   00020D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000210   78..         MOV       R0,#?V6
   \   000212   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000215   8E82         MOV       DPL,R6
   \   000217   8F83         MOV       DPH,R7
   \   000219   E0           MOVX      A,@DPTR
   \   00021A   F8           MOV       R0,A
   \   00021B   A3           INC       DPTR
   \   00021C   E0           MOVX      A,@DPTR
   \   00021D   F583         MOV       DPH,A
   \   00021F   8882         MOV       DPL,R0
   \   000221   A3           INC       DPTR
   \   000222   A3           INC       DPTR
   \   000223   A3           INC       DPTR
   \   000224   A3           INC       DPTR
   \   000225   E0           MOVX      A,@DPTR
   \   000226   FC           MOV       R4,A
   \   000227   A3           INC       DPTR
   \   000228   E0           MOVX      A,@DPTR
   \   000229   FD           MOV       R5,A
   \   00022A   8E82         MOV       DPL,R6
   \   00022C   8F83         MOV       DPH,R7
   \   00022E   E0           MOVX      A,@DPTR
   \   00022F   2406         ADD       A,#0x6
   \   000231   FA           MOV       R2,A
   \   000232   A3           INC       DPTR
   \   000233   E0           MOVX      A,@DPTR
   \   000234   3400         ADDC      A,#0x0
   \   000236   FB           MOV       R3,A
   \   000237   8E82         MOV       DPL,R6
   \   000239   8F83         MOV       DPH,R7
   \   00023B   E0           MOVX      A,@DPTR
   \   00023C   F8           MOV       R0,A
   \   00023D   A3           INC       DPTR
   \   00023E   E0           MOVX      A,@DPTR
   \   00023F   C8           XCH       A,R0
   \   000240   2414         ADD       A,#0x14
   \   000242   F582         MOV       DPL,A
   \   000244   C8           XCH       A,R0
   \   000245   3400         ADDC      A,#0x0
   \   000247   F583         MOV       DPH,A
   \   000249   E0           MOVX      A,@DPTR
   \   00024A   F9           MOV       R1,A
   \   00024B   12....       LCALL     `??zcl_SendDiscoverAttrsRspCmd::?relay`; Banked call to: zcl_SendDiscoverAttrsRspCmd
   \   00024E   7405         MOV       A,#0x5
   \   000250   12....       LCALL     ?DEALLOC_XSTACK8
   \   000253   E9           MOV       A,R1
   4969            zcl_mem_free( pDiscoverRsp );
   \   000254                ; Setup parameters for call to function osal_mem_free
   \   000254   AA..         MOV       R2,?V6
   \   000256   AB..         MOV       R3,?V7
   \   000258   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4970          
   4971            return;
   \                     ??zclProcessInDiscAttrsCmd_0:
   \   00025B   740A         MOV       A,#0xa
   \   00025D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000260   7F0A         MOV       R7,#0xa
   \   000262   02....       LJMP      ?BANKED_LEAVE_XDATA
   4972          }
   4973          
   4974          /*********************************************************************
   4975           * @fn      zclProcessInDiscAttrsExtCmd
   4976           *
   4977           * @brief   Process the Discover Attributes Extended Command
   4978           *
   4979           * @param   pInMsg - incoming message to process
   4980           *
   4981           * @param   pDiscoverCmd - structure from requesting command
   4982           *
   4983           * @param   attrLenBuf - describes the amount of attributes to be processed
   4984           *
   4985           * @return  none
   4986           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4987          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   \                     zclProcessInDiscAttrsExtCmd:
   4988          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V4,R4
   \   000010   8D..         MOV       ?V5,R5
   \   000012   89..         MOV       ?V2,R1
   4989            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4990            uint8 discComplete = TRUE;
   \   000014   75..01       MOV       ?V1,#0x1
   4991            zclAttrRec_t attrRec;
   4992            uint16 attrID;
   4993            uint8 i;
   4994          
   4995              // Allocate space for the response command
   4996            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4997                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   \   000017                ; Setup parameters for call to function osal_mem_alloc
   \   000017   E5..         MOV       A,?V2
   \   000019   F8           MOV       R0,A
   \   00001A   7900         MOV       R1,#0x0
   \   00001C   E8           MOV       A,R0
   \   00001D   75F004       MOV       B,#0x4
   \   000020   A4           MUL       AB
   \   000021   C8           XCH       A,R0
   \   000022   AAF0         MOV       R2,B
   \   000024   75F000       MOV       B,#0x0
   \   000027   A4           MUL       AB
   \   000028   2A           ADD       A,R2
   \   000029   FA           MOV       R2,A
   \   00002A   75F004       MOV       B,#0x4
   \   00002D   E9           MOV       A,R1
   \   00002E   A4           MUL       AB
   \   00002F   2A           ADD       A,R2
   \   000030   F9           MOV       R1,A
   \   000031   E8           MOV       A,R0
   \   000032   2402         ADD       A,#0x2
   \   000034   FA           MOV       R2,A
   \   000035   E4           CLR       A
   \   000036   39           ADDC      A,R1
   \   000037   FB           MOV       R3,A
   \   000038   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV       ?V8,R2
   \   00003D   8B..         MOV       ?V9,R3
   \   00003F   85....       MOV       ?V6,?V8
   \   000042   85....       MOV       ?V7,?V9
   4998            if ( pDiscoverExtRsp == NULL )
   \   000045   E5..         MOV       A,?V6
   \   000047   45..         ORL       A,?V7
   \   000049   7003         JNZ       $+5
   \   00004B   02....       LJMP      ??zclProcessInDiscAttrsExtCmd_0 & 0xFFFF
   4999            {
   5000              return; // EMBEDDED RETURN
   5001            }
   5002          
   5003          
   5004            if ( numAttrs != 0 )
   \   00004E   E5..         MOV       A,?V2
   \   000050   7003         JNZ       $+5
   \   000052   02....       LJMP      ??zclProcessInDiscAttrsExtCmd_1 & 0xFFFF
   5005            {
   5006              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   \   000055   75..00       MOV       ?V0,#0x0
   \   000058   85..82       MOV       DPL,?V4
   \   00005B   85..83       MOV       DPH,?V5
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F8           MOV       R0,A
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   F9           MOV       R1,A
   \   000063   85..82       MOV       DPL,?XSP + 0
   \   000066   85..83       MOV       DPH,?XSP + 1
   \   000069   E8           MOV       A,R0
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   A3           INC       DPTR
   \   00006C   E9           MOV       A,R1
   \   00006D   F0           MOVX      @DPTR,A
   \                     ??zclProcessInDiscAttrsExtCmd_2:
   \   00006E   E5..         MOV       A,?V0
   \   000070   C3           CLR       C
   \   000071   95..         SUBB      A,?V2
   \   000073   4003         JC        $+5
   \   000075   02....       LJMP      ??zclProcessInDiscAttrsExtCmd_3 & 0xFFFF
   5007              {
   5008                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \   000078                ; Setup parameters for call to function zclFindNextAttrRec
   \   000078   7402         MOV       A,#0x2
   \   00007A   12....       LCALL     ?XSTACK_DISP100_8
   \   00007D   88..         MOV       ?V8,R0
   \   00007F   89..         MOV       ?V9,R1
   \   000081   78..         MOV       R0,#?V8
   \   000083   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000086   7402         MOV       A,#0x2
   \   000088   12....       LCALL     ?XSTACK_DISP100_8
   \   00008B   88..         MOV       ?V8,R0
   \   00008D   89..         MOV       ?V9,R1
   \   00008F   78..         MOV       R0,#?V8
   \   000091   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000094   8E82         MOV       DPL,R6
   \   000096   8F83         MOV       DPH,R7
   \   000098   A3           INC       DPTR
   \   000099   A3           INC       DPTR
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   F8           MOV       R0,A
   \   00009C   A3           INC       DPTR
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   F9           MOV       R1,A
   \   00009F   E8           MOV       A,R0
   \   0000A0   13           RRC       A
   \   0000A1   13           RRC       A
   \   0000A2   13           RRC       A
   \   0000A3   541F         ANL       A,#0x1f
   \   0000A5   5401         ANL       A,#0x1
   \   0000A7   FC           MOV       R4,A
   \   0000A8   8E82         MOV       DPL,R6
   \   0000AA   8F83         MOV       DPH,R7
   \   0000AC   E0           MOVX      A,@DPTR
   \   0000AD   F8           MOV       R0,A
   \   0000AE   A3           INC       DPTR
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   F583         MOV       DPH,A
   \   0000B2   8882         MOV       DPL,R0
   \   0000B4   A3           INC       DPTR
   \   0000B5   A3           INC       DPTR
   \   0000B6   A3           INC       DPTR
   \   0000B7   A3           INC       DPTR
   \   0000B8   E0           MOVX      A,@DPTR
   \   0000B9   FA           MOV       R2,A
   \   0000BA   A3           INC       DPTR
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   FB           MOV       R3,A
   \   0000BD   8E82         MOV       DPL,R6
   \   0000BF   8F83         MOV       DPH,R7
   \   0000C1   E0           MOVX      A,@DPTR
   \   0000C2   F8           MOV       R0,A
   \   0000C3   A3           INC       DPTR
   \   0000C4   E0           MOVX      A,@DPTR
   \   0000C5   C8           XCH       A,R0
   \   0000C6   2414         ADD       A,#0x14
   \   0000C8   F582         MOV       DPL,A
   \   0000CA   C8           XCH       A,R0
   \   0000CB   3400         ADDC      A,#0x0
   \   0000CD   F583         MOV       DPH,A
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   F9           MOV       R1,A
   \   0000D1   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   0000D4   7404         MOV       A,#0x4
   \   0000D6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000D9   E9           MOV       A,R1
   \   0000DA   7003         JNZ       $+5
   \   0000DC   02....       LJMP      ??zclProcessInDiscAttrsExtCmd_3 & 0xFFFF
   5009                {
   5010                  break; // Should not happen, as numAttrs already calculated
   5011                }
   5012          
   5013                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   \   0000DF   7404         MOV       A,#0x4
   \   0000E1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E4   E0           MOVX      A,@DPTR
   \   0000E5   FA           MOV       R2,A
   \   0000E6   A3           INC       DPTR
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   FB           MOV       R3,A
   \   0000E9   E5..         MOV       A,?V0
   \   0000EB   F8           MOV       R0,A
   \   0000EC   7900         MOV       R1,#0x0
   \   0000EE   E8           MOV       A,R0
   \   0000EF   75F004       MOV       B,#0x4
   \   0000F2   A4           MUL       AB
   \   0000F3   C8           XCH       A,R0
   \   0000F4   ACF0         MOV       R4,B
   \   0000F6   75F000       MOV       B,#0x0
   \   0000F9   A4           MUL       AB
   \   0000FA   2C           ADD       A,R4
   \   0000FB   FC           MOV       R4,A
   \   0000FC   75F004       MOV       B,#0x4
   \   0000FF   E9           MOV       A,R1
   \   000100   A4           MUL       AB
   \   000101   2C           ADD       A,R4
   \   000102   F9           MOV       R1,A
   \   000103   E5..         MOV       A,?V6
   \   000105   28           ADD       A,R0
   \   000106   F582         MOV       DPL,A
   \   000108   E5..         MOV       A,?V7
   \   00010A   39           ADDC      A,R1
   \   00010B   F583         MOV       DPH,A
   \   00010D   A3           INC       DPTR
   \   00010E   A3           INC       DPTR
   \   00010F   EA           MOV       A,R2
   \   000110   F0           MOVX      @DPTR,A
   \   000111   A3           INC       DPTR
   \   000112   EB           MOV       A,R3
   \   000113   F0           MOVX      @DPTR,A
   5014                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   \   000114   7406         MOV       A,#0x6
   \   000116   12....       LCALL     ?XSTACK_DISP0_8
   \   000119   E0           MOVX      A,@DPTR
   \   00011A   C0E0         PUSH      A
   \   00011C   E5..         MOV       A,?V0
   \   00011E   F8           MOV       R0,A
   \   00011F   7900         MOV       R1,#0x0
   \   000121   E8           MOV       A,R0
   \   000122   75F004       MOV       B,#0x4
   \   000125   A4           MUL       AB
   \   000126   C8           XCH       A,R0
   \   000127   AAF0         MOV       R2,B
   \   000129   75F000       MOV       B,#0x0
   \   00012C   A4           MUL       AB
   \   00012D   2A           ADD       A,R2
   \   00012E   FA           MOV       R2,A
   \   00012F   75F004       MOV       B,#0x4
   \   000132   E9           MOV       A,R1
   \   000133   A4           MUL       AB
   \   000134   2A           ADD       A,R2
   \   000135   F9           MOV       R1,A
   \   000136   E5..         MOV       A,?V6
   \   000138   28           ADD       A,R0
   \   000139   F582         MOV       DPL,A
   \   00013B   E5..         MOV       A,?V7
   \   00013D   39           ADDC      A,R1
   \   00013E   F583         MOV       DPH,A
   \   000140   A3           INC       DPTR
   \   000141   A3           INC       DPTR
   \   000142   A3           INC       DPTR
   \   000143   A3           INC       DPTR
   \   000144   D0E0         POP       A
   \   000146   F0           MOVX      @DPTR,A
   5015                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   \   000147   7407         MOV       A,#0x7
   \   000149   12....       LCALL     ?XSTACK_DISP0_8
   \   00014C   E0           MOVX      A,@DPTR
   \   00014D   5407         ANL       A,#0x7
   \   00014F   C0E0         PUSH      A
   \   000151   E5..         MOV       A,?V0
   \   000153   F8           MOV       R0,A
   \   000154   7900         MOV       R1,#0x0
   \   000156   E8           MOV       A,R0
   \   000157   75F004       MOV       B,#0x4
   \   00015A   A4           MUL       AB
   \   00015B   C8           XCH       A,R0
   \   00015C   AAF0         MOV       R2,B
   \   00015E   75F000       MOV       B,#0x0
   \   000161   A4           MUL       AB
   \   000162   2A           ADD       A,R2
   \   000163   FA           MOV       R2,A
   \   000164   75F004       MOV       B,#0x4
   \   000167   E9           MOV       A,R1
   \   000168   A4           MUL       AB
   \   000169   2A           ADD       A,R2
   \   00016A   F9           MOV       R1,A
   \   00016B   E5..         MOV       A,?V6
   \   00016D   28           ADD       A,R0
   \   00016E   F582         MOV       DPL,A
   \   000170   E5..         MOV       A,?V7
   \   000172   39           ADDC      A,R1
   \   000173   F583         MOV       DPH,A
   \   000175   A3           INC       DPTR
   \   000176   A3           INC       DPTR
   \   000177   A3           INC       DPTR
   \   000178   A3           INC       DPTR
   \   000179   A3           INC       DPTR
   \   00017A   D0E0         POP       A
   \   00017C   F0           MOVX      @DPTR,A
   5016              }
   \   00017D   05..         INC       ?V0
   \   00017F   85..82       MOV       DPL,?XSP + 0
   \   000182   85..83       MOV       DPH,?XSP + 1
   \   000185   E0           MOVX      A,@DPTR
   \   000186   2401         ADD       A,#0x1
   \   000188   F0           MOVX      @DPTR,A
   \   000189   A3           INC       DPTR
   \   00018A   E0           MOVX      A,@DPTR
   \   00018B   3400         ADDC      A,#0x0
   \   00018D   F0           MOVX      @DPTR,A
   \   00018E   02....       LJMP      ??zclProcessInDiscAttrsExtCmd_2 & 0xFFFF
   5017          
   5018              // Are there more attributes to be discovered?
   5019              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \                     ??zclProcessInDiscAttrsExtCmd_3:
   \   000191                ; Setup parameters for call to function zclFindNextAttrRec
   \   000191   7402         MOV       A,#0x2
   \   000193   12....       LCALL     ?XSTACK_DISP100_8
   \   000196   88..         MOV       ?V8,R0
   \   000198   89..         MOV       ?V9,R1
   \   00019A   78..         MOV       R0,#?V8
   \   00019C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00019F   7402         MOV       A,#0x2
   \   0001A1   12....       LCALL     ?XSTACK_DISP100_8
   \   0001A4   88..         MOV       ?V8,R0
   \   0001A6   89..         MOV       ?V9,R1
   \   0001A8   78..         MOV       R0,#?V8
   \   0001AA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001AD   8E82         MOV       DPL,R6
   \   0001AF   8F83         MOV       DPH,R7
   \   0001B1   A3           INC       DPTR
   \   0001B2   A3           INC       DPTR
   \   0001B3   E0           MOVX      A,@DPTR
   \   0001B4   F8           MOV       R0,A
   \   0001B5   A3           INC       DPTR
   \   0001B6   E0           MOVX      A,@DPTR
   \   0001B7   F9           MOV       R1,A
   \   0001B8   E8           MOV       A,R0
   \   0001B9   13           RRC       A
   \   0001BA   13           RRC       A
   \   0001BB   13           RRC       A
   \   0001BC   541F         ANL       A,#0x1f
   \   0001BE   5401         ANL       A,#0x1
   \   0001C0   FC           MOV       R4,A
   \   0001C1   8E82         MOV       DPL,R6
   \   0001C3   8F83         MOV       DPH,R7
   \   0001C5   E0           MOVX      A,@DPTR
   \   0001C6   F8           MOV       R0,A
   \   0001C7   A3           INC       DPTR
   \   0001C8   E0           MOVX      A,@DPTR
   \   0001C9   F583         MOV       DPH,A
   \   0001CB   8882         MOV       DPL,R0
   \   0001CD   A3           INC       DPTR
   \   0001CE   A3           INC       DPTR
   \   0001CF   A3           INC       DPTR
   \   0001D0   A3           INC       DPTR
   \   0001D1   E0           MOVX      A,@DPTR
   \   0001D2   FA           MOV       R2,A
   \   0001D3   A3           INC       DPTR
   \   0001D4   E0           MOVX      A,@DPTR
   \   0001D5   FB           MOV       R3,A
   \   0001D6   8E82         MOV       DPL,R6
   \   0001D8   8F83         MOV       DPH,R7
   \   0001DA   E0           MOVX      A,@DPTR
   \   0001DB   F8           MOV       R0,A
   \   0001DC   A3           INC       DPTR
   \   0001DD   E0           MOVX      A,@DPTR
   \   0001DE   C8           XCH       A,R0
   \   0001DF   2414         ADD       A,#0x14
   \   0001E1   F582         MOV       DPL,A
   \   0001E3   C8           XCH       A,R0
   \   0001E4   3400         ADDC      A,#0x0
   \   0001E6   F583         MOV       DPH,A
   \   0001E8   E0           MOVX      A,@DPTR
   \   0001E9   F9           MOV       R1,A
   \   0001EA   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   0001ED   7404         MOV       A,#0x4
   \   0001EF   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001F2   E9           MOV       A,R1
   \   0001F3   6003         JZ        ??zclProcessInDiscAttrsExtCmd_1
   5020              {
   5021                discComplete = FALSE;
   \   0001F5   75..00       MOV       ?V1,#0x0
   5022              }
   5023            }
   5024          
   5025            pDiscoverExtRsp->discComplete = discComplete;
   \                     ??zclProcessInDiscAttrsExtCmd_1:
   \   0001F8   E5..         MOV       A,?V1
   \   0001FA   C0E0         PUSH      A
   \   0001FC   85..82       MOV       DPL,?V6
   \   0001FF   85..83       MOV       DPH,?V7
   \   000202   D0E0         POP       A
   \   000204   F0           MOVX      @DPTR,A
   5026            pDiscoverExtRsp->numAttr = numAttrs;
   \   000205   E5..         MOV       A,?V2
   \   000207   C0E0         PUSH      A
   \   000209   85..82       MOV       DPL,?V6
   \   00020C   85..83       MOV       DPH,?V7
   \   00020F   A3           INC       DPTR
   \   000210   D0E0         POP       A
   \   000212   F0           MOVX      @DPTR,A
   5027          
   5028            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   5029                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   5030                                         true, pInMsg->hdr.transSeqNum );
   \   000213                ; Setup parameters for call to function zcl_SendDiscoverAttrsExtRsp
   \   000213   8E82         MOV       DPL,R6
   \   000215   8F83         MOV       DPH,R7
   \   000217   A3           INC       DPTR
   \   000218   A3           INC       DPTR
   \   000219   A3           INC       DPTR
   \   00021A   A3           INC       DPTR
   \   00021B   A3           INC       DPTR
   \   00021C   A3           INC       DPTR
   \   00021D   E0           MOVX      A,@DPTR
   \   00021E   F5..         MOV       ?V3,A
   \   000220   78..         MOV       R0,#?V3
   \   000222   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000225   75..01       MOV       ?V3,#0x1
   \   000228   78..         MOV       R0,#?V3
   \   00022A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00022D   8E82         MOV       DPL,R6
   \   00022F   8F83         MOV       DPH,R7
   \   000231   A3           INC       DPTR
   \   000232   A3           INC       DPTR
   \   000233   E0           MOVX      A,@DPTR
   \   000234   F8           MOV       R0,A
   \   000235   A3           INC       DPTR
   \   000236   E0           MOVX      A,@DPTR
   \   000237   F9           MOV       R1,A
   \   000238   E8           MOV       A,R0
   \   000239   13           RRC       A
   \   00023A   13           RRC       A
   \   00023B   13           RRC       A
   \   00023C   541F         ANL       A,#0x1f
   \   00023E   6401         XRL       A,#0x1
   \   000240   5401         ANL       A,#0x1
   \   000242   F5..         MOV       ?V3,A
   \   000244   78..         MOV       R0,#?V3
   \   000246   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000249   78..         MOV       R0,#?V6
   \   00024B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00024E   8E82         MOV       DPL,R6
   \   000250   8F83         MOV       DPH,R7
   \   000252   E0           MOVX      A,@DPTR
   \   000253   F8           MOV       R0,A
   \   000254   A3           INC       DPTR
   \   000255   E0           MOVX      A,@DPTR
   \   000256   F583         MOV       DPH,A
   \   000258   8882         MOV       DPL,R0
   \   00025A   A3           INC       DPTR
   \   00025B   A3           INC       DPTR
   \   00025C   A3           INC       DPTR
   \   00025D   A3           INC       DPTR
   \   00025E   E0           MOVX      A,@DPTR
   \   00025F   FC           MOV       R4,A
   \   000260   A3           INC       DPTR
   \   000261   E0           MOVX      A,@DPTR
   \   000262   FD           MOV       R5,A
   \   000263   8E82         MOV       DPL,R6
   \   000265   8F83         MOV       DPH,R7
   \   000267   E0           MOVX      A,@DPTR
   \   000268   2406         ADD       A,#0x6
   \   00026A   FA           MOV       R2,A
   \   00026B   A3           INC       DPTR
   \   00026C   E0           MOVX      A,@DPTR
   \   00026D   3400         ADDC      A,#0x0
   \   00026F   FB           MOV       R3,A
   \   000270   8E82         MOV       DPL,R6
   \   000272   8F83         MOV       DPH,R7
   \   000274   E0           MOVX      A,@DPTR
   \   000275   F8           MOV       R0,A
   \   000276   A3           INC       DPTR
   \   000277   E0           MOVX      A,@DPTR
   \   000278   C8           XCH       A,R0
   \   000279   2414         ADD       A,#0x14
   \   00027B   F582         MOV       DPL,A
   \   00027D   C8           XCH       A,R0
   \   00027E   3400         ADDC      A,#0x0
   \   000280   F583         MOV       DPH,A
   \   000282   E0           MOVX      A,@DPTR
   \   000283   F9           MOV       R1,A
   \   000284   12....       LCALL     `??zcl_SendDiscoverAttrsExtRsp::?relay`; Banked call to: zcl_SendDiscoverAttrsExtRsp
   \   000287   7405         MOV       A,#0x5
   \   000289   12....       LCALL     ?DEALLOC_XSTACK8
   \   00028C   E9           MOV       A,R1
   5031          
   5032            zcl_mem_free( pDiscoverExtRsp );
   \   00028D                ; Setup parameters for call to function osal_mem_free
   \   00028D   AA..         MOV       R2,?V6
   \   00028F   AB..         MOV       R3,?V7
   \   000291   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   5033          
   5034            return;
   \                     ??zclProcessInDiscAttrsExtCmd_0:
   \   000294   740A         MOV       A,#0xa
   \   000296   12....       LCALL     ?DEALLOC_XSTACK8
   \   000299   7F0A         MOV       R7,#0xa
   \   00029B   02....       LJMP      ?BANKED_LEAVE_XDATA
   5035          }
   5036          
   5037          /*********************************************************************
   5038           * @fn      zclProcessInDiscCmd
   5039           *
   5040           * @brief   Process the "Profile" Discover Command
   5041           *
   5042           * @param   pInMsg - incoming message to process
   5043           *
   5044           * @return  TRUE if command processed. FALSE, otherwise.
   5045           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   5046          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInDiscCmd:
   5047          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   5048            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   5049            zclDiscoverCmdsCmdRsp_t cmdRsp;
   5050            ZStatus_t status;
   5051            zclCommandRec_t cmdRec;
   5052            uint8 cmdID;
   5053            uint8 i;
   5054            uint8 j;
   5055          
   5056            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV       A,R6
   \   00000F   240C         ADD       A,#0xc
   \   000011   F582         MOV       DPL,A
   \   000013   E4           CLR       A
   \   000014   3F           ADDC      A,R7
   \   000015   F583         MOV       DPH,A
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F9           MOV       R1,A
   \   00001C   88..         MOV       ?V4,R0
   \   00001E   89..         MOV       ?V5,R1
   5057          
   5058            // Find out the number of commands supported within the specified range
   5059            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   \   000020   75..00       MOV       ?V0,#0x0
   \   000023   85..82       MOV       DPL,?V4
   \   000026   85..83       MOV       DPH,?V5
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   C0E0         PUSH      A
   \   00002C   85..82       MOV       DPL,?XSP + 0
   \   00002F   85..83       MOV       DPH,?XSP + 1
   \   000032   D0E0         POP       A
   \   000034   F0           MOVX      @DPTR,A
   \                     ??zclProcessInDiscCmd_0:
   \   000035   85..82       MOV       DPL,?V4
   \   000038   85..83       MOV       DPH,?V5
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F8           MOV       R0,A
   \   00003E   E5..         MOV       A,?V0
   \   000040   C3           CLR       C
   \   000041   98           SUBB      A,R0
   \   000042   4003         JC        $+5
   \   000044   02....       LJMP      ??zclProcessInDiscCmd_1 & 0xFFFF
   5060            {
   5061              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   \   000047                ; Setup parameters for call to function zclFindNextCmdRec
   \   000047   7406         MOV       A,#0x6
   \   000049   12....       LCALL     ?XSTACK_DISP100_8
   \   00004C   88..         MOV       ?V6,R0
   \   00004E   89..         MOV       ?V7,R1
   \   000050   78..         MOV       R0,#?V6
   \   000052   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000055   7402         MOV       A,#0x2
   \   000057   12....       LCALL     ?XSTACK_DISP100_8
   \   00005A   88..         MOV       ?V6,R0
   \   00005C   89..         MOV       ?V7,R1
   \   00005E   78..         MOV       R0,#?V6
   \   000060   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000063   8E82         MOV       DPL,R6
   \   000065   8F83         MOV       DPH,R7
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   F8           MOV       R0,A
   \   00006B   A3           INC       DPTR
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   F9           MOV       R1,A
   \   00006E   E8           MOV       A,R0
   \   00006F   13           RRC       A
   \   000070   13           RRC       A
   \   000071   13           RRC       A
   \   000072   541F         ANL       A,#0x1f
   \   000074   5401         ANL       A,#0x1
   \   000076   FD           MOV       R5,A
   \   000077   8E82         MOV       DPL,R6
   \   000079   8F83         MOV       DPH,R7
   \   00007B   A3           INC       DPTR
   \   00007C   A3           INC       DPTR
   \   00007D   A3           INC       DPTR
   \   00007E   A3           INC       DPTR
   \   00007F   A3           INC       DPTR
   \   000080   A3           INC       DPTR
   \   000081   A3           INC       DPTR
   \   000082   E0           MOVX      A,@DPTR
   \   000083   FC           MOV       R4,A
   \   000084   8E82         MOV       DPL,R6
   \   000086   8F83         MOV       DPH,R7
   \   000088   E0           MOVX      A,@DPTR
   \   000089   F8           MOV       R0,A
   \   00008A   A3           INC       DPTR
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   F583         MOV       DPH,A
   \   00008E   8882         MOV       DPL,R0
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   A3           INC       DPTR
   \   000094   E0           MOVX      A,@DPTR
   \   000095   FA           MOV       R2,A
   \   000096   A3           INC       DPTR
   \   000097   E0           MOVX      A,@DPTR
   \   000098   FB           MOV       R3,A
   \   000099   8E82         MOV       DPL,R6
   \   00009B   8F83         MOV       DPH,R7
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   F8           MOV       R0,A
   \   00009F   A3           INC       DPTR
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   C8           XCH       A,R0
   \   0000A2   2414         ADD       A,#0x14
   \   0000A4   F582         MOV       DPL,A
   \   0000A6   C8           XCH       A,R0
   \   0000A7   3400         ADDC      A,#0x0
   \   0000A9   F583         MOV       DPH,A
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   F9           MOV       R1,A
   \   0000AD   12....       LCALL     `??zclFindNextCmdRec::?relay`; Banked call to: zclFindNextCmdRec
   \   0000B0   7404         MOV       A,#0x4
   \   0000B2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B5   E9           MOV       A,R1
   \   0000B6   600F         JZ        ??zclProcessInDiscCmd_1
   5062              {
   5063                break;  // Command not supported
   5064              }
   5065            }
   \   0000B8   05..         INC       ?V0
   \   0000BA   85..82       MOV       DPL,?XSP + 0
   \   0000BD   85..83       MOV       DPH,?XSP + 1
   \   0000C0   E0           MOVX      A,@DPTR
   \   0000C1   2401         ADD       A,#0x1
   \   0000C3   F0           MOVX      @DPTR,A
   \   0000C4   02....       LJMP      ??zclProcessInDiscCmd_0 & 0xFFFF
   5066          
   5067            // Allocate space for the response command
   5068            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   \                     ??zclProcessInDiscCmd_1:
   \   0000C7                ; Setup parameters for call to function osal_mem_alloc
   \   0000C7   E5..         MOV       A,?V0
   \   0000C9   FA           MOV       R2,A
   \   0000CA   7B00         MOV       R3,#0x0
   \   0000CC   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000CF   7404         MOV       A,#0x4
   \   0000D1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D4   EA           MOV       A,R2
   \   0000D5   F0           MOVX      @DPTR,A
   \   0000D6   A3           INC       DPTR
   \   0000D7   EB           MOV       A,R3
   \   0000D8   F0           MOVX      @DPTR,A
   5069          
   5070            if ( cmdRsp.pCmdID == NULL )
   \   0000D9   7404         MOV       A,#0x4
   \   0000DB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DE   E0           MOVX      A,@DPTR
   \   0000DF   F8           MOV       R0,A
   \   0000E0   A3           INC       DPTR
   \   0000E1   E0           MOVX      A,@DPTR
   \   0000E2   F9           MOV       R1,A
   \   0000E3   E8           MOV       A,R0
   \   0000E4   49           ORL       A,R1
   \   0000E5   7005         JNZ       ??zclProcessInDiscCmd_2
   5071            {
   5072              return FALSE; // EMBEDDED RETURN
   \   0000E7   7900         MOV       R1,#0x0
   \   0000E9   02....       LJMP      ??zclProcessInDiscCmd_3 & 0xFFFF
   5073            }
   5074          
   5075            if ( i != 0 )
   \                     ??zclProcessInDiscCmd_2:
   \   0000EC   E5..         MOV       A,?V0
   \   0000EE   7003         JNZ       $+5
   \   0000F0   02....       LJMP      ??zclProcessInDiscCmd_4 & 0xFFFF
   5076            {
   5077              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   \   0000F3   75..00       MOV       ?V1,#0x0
   \   0000F6   85..82       MOV       DPL,?V4
   \   0000F9   85..83       MOV       DPH,?V5
   \   0000FC   E0           MOVX      A,@DPTR
   \   0000FD   C0E0         PUSH      A
   \   0000FF   85..82       MOV       DPL,?XSP + 0
   \   000102   85..83       MOV       DPH,?XSP + 1
   \   000105   D0E0         POP       A
   \   000107   F0           MOVX      @DPTR,A
   \                     ??zclProcessInDiscCmd_5:
   \   000108   E5..         MOV       A,?V1
   \   00010A   C3           CLR       C
   \   00010B   95..         SUBB      A,?V0
   \   00010D   4003         JC        $+5
   \   00010F   02....       LJMP      ??zclProcessInDiscCmd_4 & 0xFFFF
   5078              {
   5079                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   \   000112                ; Setup parameters for call to function zclFindNextCmdRec
   \   000112   7406         MOV       A,#0x6
   \   000114   12....       LCALL     ?XSTACK_DISP100_8
   \   000117   88..         MOV       ?V6,R0
   \   000119   89..         MOV       ?V7,R1
   \   00011B   78..         MOV       R0,#?V6
   \   00011D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000120   7402         MOV       A,#0x2
   \   000122   12....       LCALL     ?XSTACK_DISP100_8
   \   000125   88..         MOV       ?V6,R0
   \   000127   89..         MOV       ?V7,R1
   \   000129   78..         MOV       R0,#?V6
   \   00012B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00012E   8E82         MOV       DPL,R6
   \   000130   8F83         MOV       DPH,R7
   \   000132   A3           INC       DPTR
   \   000133   A3           INC       DPTR
   \   000134   E0           MOVX      A,@DPTR
   \   000135   F8           MOV       R0,A
   \   000136   A3           INC       DPTR
   \   000137   E0           MOVX      A,@DPTR
   \   000138   F9           MOV       R1,A
   \   000139   E8           MOV       A,R0
   \   00013A   13           RRC       A
   \   00013B   13           RRC       A
   \   00013C   13           RRC       A
   \   00013D   541F         ANL       A,#0x1f
   \   00013F   5401         ANL       A,#0x1
   \   000141   FD           MOV       R5,A
   \   000142   8E82         MOV       DPL,R6
   \   000144   8F83         MOV       DPH,R7
   \   000146   A3           INC       DPTR
   \   000147   A3           INC       DPTR
   \   000148   A3           INC       DPTR
   \   000149   A3           INC       DPTR
   \   00014A   A3           INC       DPTR
   \   00014B   A3           INC       DPTR
   \   00014C   A3           INC       DPTR
   \   00014D   E0           MOVX      A,@DPTR
   \   00014E   FC           MOV       R4,A
   \   00014F   8E82         MOV       DPL,R6
   \   000151   8F83         MOV       DPH,R7
   \   000153   E0           MOVX      A,@DPTR
   \   000154   F8           MOV       R0,A
   \   000155   A3           INC       DPTR
   \   000156   E0           MOVX      A,@DPTR
   \   000157   F583         MOV       DPH,A
   \   000159   8882         MOV       DPL,R0
   \   00015B   A3           INC       DPTR
   \   00015C   A3           INC       DPTR
   \   00015D   A3           INC       DPTR
   \   00015E   A3           INC       DPTR
   \   00015F   E0           MOVX      A,@DPTR
   \   000160   FA           MOV       R2,A
   \   000161   A3           INC       DPTR
   \   000162   E0           MOVX      A,@DPTR
   \   000163   FB           MOV       R3,A
   \   000164   8E82         MOV       DPL,R6
   \   000166   8F83         MOV       DPH,R7
   \   000168   E0           MOVX      A,@DPTR
   \   000169   F8           MOV       R0,A
   \   00016A   A3           INC       DPTR
   \   00016B   E0           MOVX      A,@DPTR
   \   00016C   C8           XCH       A,R0
   \   00016D   2414         ADD       A,#0x14
   \   00016F   F582         MOV       DPL,A
   \   000171   C8           XCH       A,R0
   \   000172   3400         ADDC      A,#0x0
   \   000174   F583         MOV       DPH,A
   \   000176   E0           MOVX      A,@DPTR
   \   000177   F9           MOV       R1,A
   \   000178   12....       LCALL     `??zclFindNextCmdRec::?relay`; Banked call to: zclFindNextCmdRec
   \   00017B   7404         MOV       A,#0x4
   \   00017D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000180   E9           MOV       A,R1
   \   000181   602E         JZ        ??zclProcessInDiscCmd_4
   5080                {
   5081                  break; // Attribute not supported
   5082                }
   5083          
   5084                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   \   000183   7408         MOV       A,#0x8
   \   000185   12....       LCALL     ?XSTACK_DISP0_8
   \   000188   E0           MOVX      A,@DPTR
   \   000189   C0E0         PUSH      A
   \   00018B   E5..         MOV       A,?V1
   \   00018D   F8           MOV       R0,A
   \   00018E   7900         MOV       R1,#0x0
   \   000190   7404         MOV       A,#0x4
   \   000192   12....       LCALL     ?XSTACK_DISP0_8
   \   000195   E0           MOVX      A,@DPTR
   \   000196   28           ADD       A,R0
   \   000197   FA           MOV       R2,A
   \   000198   A3           INC       DPTR
   \   000199   E0           MOVX      A,@DPTR
   \   00019A   39           ADDC      A,R1
   \   00019B   8A82         MOV       DPL,R2
   \   00019D   F583         MOV       DPH,A
   \   00019F   D0E0         POP       A
   \   0001A1   F0           MOVX      @DPTR,A
   5085              }
   \   0001A2   05..         INC       ?V1
   \   0001A4   85..82       MOV       DPL,?XSP + 0
   \   0001A7   85..83       MOV       DPH,?XSP + 1
   \   0001AA   E0           MOVX      A,@DPTR
   \   0001AB   2401         ADD       A,#0x1
   \   0001AD   F0           MOVX      @DPTR,A
   \   0001AE   02....       LJMP      ??zclProcessInDiscCmd_5 & 0xFFFF
   5086            }
   5087          
   5088            // Are there more commands to be discovered?
   5089            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   \                     ??zclProcessInDiscCmd_4:
   \   0001B1                ; Setup parameters for call to function zclFindNextCmdRec
   \   0001B1   7406         MOV       A,#0x6
   \   0001B3   12....       LCALL     ?XSTACK_DISP100_8
   \   0001B6   88..         MOV       ?V6,R0
   \   0001B8   89..         MOV       ?V7,R1
   \   0001BA   78..         MOV       R0,#?V6
   \   0001BC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001BF   7402         MOV       A,#0x2
   \   0001C1   12....       LCALL     ?XSTACK_DISP100_8
   \   0001C4   88..         MOV       ?V6,R0
   \   0001C6   89..         MOV       ?V7,R1
   \   0001C8   78..         MOV       R0,#?V6
   \   0001CA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001CD   8E82         MOV       DPL,R6
   \   0001CF   8F83         MOV       DPH,R7
   \   0001D1   A3           INC       DPTR
   \   0001D2   A3           INC       DPTR
   \   0001D3   E0           MOVX      A,@DPTR
   \   0001D4   F8           MOV       R0,A
   \   0001D5   A3           INC       DPTR
   \   0001D6   E0           MOVX      A,@DPTR
   \   0001D7   F9           MOV       R1,A
   \   0001D8   E8           MOV       A,R0
   \   0001D9   13           RRC       A
   \   0001DA   13           RRC       A
   \   0001DB   13           RRC       A
   \   0001DC   541F         ANL       A,#0x1f
   \   0001DE   5401         ANL       A,#0x1
   \   0001E0   FD           MOV       R5,A
   \   0001E1   8E82         MOV       DPL,R6
   \   0001E3   8F83         MOV       DPH,R7
   \   0001E5   A3           INC       DPTR
   \   0001E6   A3           INC       DPTR
   \   0001E7   A3           INC       DPTR
   \   0001E8   A3           INC       DPTR
   \   0001E9   A3           INC       DPTR
   \   0001EA   A3           INC       DPTR
   \   0001EB   A3           INC       DPTR
   \   0001EC   E0           MOVX      A,@DPTR
   \   0001ED   FC           MOV       R4,A
   \   0001EE   8E82         MOV       DPL,R6
   \   0001F0   8F83         MOV       DPH,R7
   \   0001F2   E0           MOVX      A,@DPTR
   \   0001F3   F8           MOV       R0,A
   \   0001F4   A3           INC       DPTR
   \   0001F5   E0           MOVX      A,@DPTR
   \   0001F6   F583         MOV       DPH,A
   \   0001F8   8882         MOV       DPL,R0
   \   0001FA   A3           INC       DPTR
   \   0001FB   A3           INC       DPTR
   \   0001FC   A3           INC       DPTR
   \   0001FD   A3           INC       DPTR
   \   0001FE   E0           MOVX      A,@DPTR
   \   0001FF   FA           MOV       R2,A
   \   000200   A3           INC       DPTR
   \   000201   E0           MOVX      A,@DPTR
   \   000202   FB           MOV       R3,A
   \   000203   8E82         MOV       DPL,R6
   \   000205   8F83         MOV       DPH,R7
   \   000207   E0           MOVX      A,@DPTR
   \   000208   F8           MOV       R0,A
   \   000209   A3           INC       DPTR
   \   00020A   E0           MOVX      A,@DPTR
   \   00020B   C8           XCH       A,R0
   \   00020C   2414         ADD       A,#0x14
   \   00020E   F582         MOV       DPL,A
   \   000210   C8           XCH       A,R0
   \   000211   3400         ADDC      A,#0x0
   \   000213   F583         MOV       DPH,A
   \   000215   E0           MOVX      A,@DPTR
   \   000216   F9           MOV       R1,A
   \   000217   12....       LCALL     `??zclFindNextCmdRec::?relay`; Banked call to: zclFindNextCmdRec
   \   00021A   7404         MOV       A,#0x4
   \   00021C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00021F   E9           MOV       A,R1
   \   000220   600A         JZ        ??zclProcessInDiscCmd_6
   5090            {
   5091              cmdRsp.discComplete = FALSE;
   \   000222   7401         MOV       A,#0x1
   \   000224   12....       LCALL     ?XSTACK_DISP0_8
   \   000227   7400         MOV       A,#0x0
   \   000229   F0           MOVX      @DPTR,A
   \   00022A   8008         SJMP      ??zclProcessInDiscCmd_7
   5092            }
   5093            else
   5094            {
   5095              cmdRsp.discComplete = TRUE;
   \                     ??zclProcessInDiscCmd_6:
   \   00022C   7401         MOV       A,#0x1
   \   00022E   12....       LCALL     ?XSTACK_DISP0_8
   \   000231   7401         MOV       A,#0x1
   \   000233   F0           MOVX      @DPTR,A
   5096            }
   5097          
   5098            // pass the command requested
   5099            cmdRsp.cmdType = pInMsg->hdr.commandID;
   \                     ??zclProcessInDiscCmd_7:
   \   000234   8E82         MOV       DPL,R6
   \   000236   8F83         MOV       DPH,R7
   \   000238   A3           INC       DPTR
   \   000239   A3           INC       DPTR
   \   00023A   A3           INC       DPTR
   \   00023B   A3           INC       DPTR
   \   00023C   A3           INC       DPTR
   \   00023D   A3           INC       DPTR
   \   00023E   A3           INC       DPTR
   \   00023F   E0           MOVX      A,@DPTR
   \   000240   C0E0         PUSH      A
   \   000242   7402         MOV       A,#0x2
   \   000244   12....       LCALL     ?XSTACK_DISP0_8
   \   000247   D0E0         POP       A
   \   000249   F0           MOVX      @DPTR,A
   5100          
   5101            // store number of commands returned
   5102            cmdRsp.numCmd = j;
   \   00024A   E5..         MOV       A,?V1
   \   00024C   C0E0         PUSH      A
   \   00024E   7403         MOV       A,#0x3
   \   000250   12....       LCALL     ?XSTACK_DISP0_8
   \   000253   D0E0         POP       A
   \   000255   F0           MOVX      @DPTR,A
   5103          
   5104            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   5105                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   5106                                                true, pInMsg->hdr.transSeqNum );
   \   000256                ; Setup parameters for call to function zcl_SendDiscoverCmdsRspCmd
   \   000256   8E82         MOV       DPL,R6
   \   000258   8F83         MOV       DPH,R7
   \   00025A   A3           INC       DPTR
   \   00025B   A3           INC       DPTR
   \   00025C   A3           INC       DPTR
   \   00025D   A3           INC       DPTR
   \   00025E   A3           INC       DPTR
   \   00025F   A3           INC       DPTR
   \   000260   E0           MOVX      A,@DPTR
   \   000261   F5..         MOV       ?V3,A
   \   000263   78..         MOV       R0,#?V3
   \   000265   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000268   75..01       MOV       ?V3,#0x1
   \   00026B   78..         MOV       R0,#?V3
   \   00026D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000270   8E82         MOV       DPL,R6
   \   000272   8F83         MOV       DPH,R7
   \   000274   A3           INC       DPTR
   \   000275   A3           INC       DPTR
   \   000276   E0           MOVX      A,@DPTR
   \   000277   F8           MOV       R0,A
   \   000278   A3           INC       DPTR
   \   000279   E0           MOVX      A,@DPTR
   \   00027A   F9           MOV       R1,A
   \   00027B   E8           MOV       A,R0
   \   00027C   13           RRC       A
   \   00027D   13           RRC       A
   \   00027E   13           RRC       A
   \   00027F   541F         ANL       A,#0x1f
   \   000281   6401         XRL       A,#0x1
   \   000283   5401         ANL       A,#0x1
   \   000285   F5..         MOV       ?V3,A
   \   000287   78..         MOV       R0,#?V3
   \   000289   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00028C   7404         MOV       A,#0x4
   \   00028E   12....       LCALL     ?XSTACK_DISP100_8
   \   000291   88..         MOV       ?V6,R0
   \   000293   89..         MOV       ?V7,R1
   \   000295   78..         MOV       R0,#?V6
   \   000297   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00029A   8E82         MOV       DPL,R6
   \   00029C   8F83         MOV       DPH,R7
   \   00029E   E0           MOVX      A,@DPTR
   \   00029F   F8           MOV       R0,A
   \   0002A0   A3           INC       DPTR
   \   0002A1   E0           MOVX      A,@DPTR
   \   0002A2   F583         MOV       DPH,A
   \   0002A4   8882         MOV       DPL,R0
   \   0002A6   A3           INC       DPTR
   \   0002A7   A3           INC       DPTR
   \   0002A8   A3           INC       DPTR
   \   0002A9   A3           INC       DPTR
   \   0002AA   E0           MOVX      A,@DPTR
   \   0002AB   FC           MOV       R4,A
   \   0002AC   A3           INC       DPTR
   \   0002AD   E0           MOVX      A,@DPTR
   \   0002AE   FD           MOV       R5,A
   \   0002AF   8E82         MOV       DPL,R6
   \   0002B1   8F83         MOV       DPH,R7
   \   0002B3   E0           MOVX      A,@DPTR
   \   0002B4   2406         ADD       A,#0x6
   \   0002B6   FA           MOV       R2,A
   \   0002B7   A3           INC       DPTR
   \   0002B8   E0           MOVX      A,@DPTR
   \   0002B9   3400         ADDC      A,#0x0
   \   0002BB   FB           MOV       R3,A
   \   0002BC   8E82         MOV       DPL,R6
   \   0002BE   8F83         MOV       DPH,R7
   \   0002C0   E0           MOVX      A,@DPTR
   \   0002C1   F8           MOV       R0,A
   \   0002C2   A3           INC       DPTR
   \   0002C3   E0           MOVX      A,@DPTR
   \   0002C4   C8           XCH       A,R0
   \   0002C5   2414         ADD       A,#0x14
   \   0002C7   F582         MOV       DPL,A
   \   0002C9   C8           XCH       A,R0
   \   0002CA   3400         ADDC      A,#0x0
   \   0002CC   F583         MOV       DPH,A
   \   0002CE   E0           MOVX      A,@DPTR
   \   0002CF   F9           MOV       R1,A
   \   0002D0   12....       LCALL     `??zcl_SendDiscoverCmdsRspCmd::?relay`; Banked call to: zcl_SendDiscoverCmdsRspCmd
   \   0002D3   7405         MOV       A,#0x5
   \   0002D5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002D8   E9           MOV       A,R1
   \   0002D9   F5..         MOV       ?V2,A
   5107          
   5108            zcl_mem_free( cmdRsp.pCmdID );
   \   0002DB                ; Setup parameters for call to function osal_mem_free
   \   0002DB   7404         MOV       A,#0x4
   \   0002DD   12....       LCALL     ?XSTACK_DISP0_8
   \   0002E0   E0           MOVX      A,@DPTR
   \   0002E1   FA           MOV       R2,A
   \   0002E2   A3           INC       DPTR
   \   0002E3   E0           MOVX      A,@DPTR
   \   0002E4   FB           MOV       R3,A
   \   0002E5   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   5109          
   5110            if ( status == ZSuccess )
   \   0002E8   E5..         MOV       A,?V2
   \   0002EA   7004         JNZ       ??zclProcessInDiscCmd_8
   5111            {
   5112              return TRUE;
   \   0002EC   7901         MOV       R1,#0x1
   \   0002EE   8002         SJMP      ??zclProcessInDiscCmd_3
   5113            }
   5114            else
   5115            {
   5116              return FALSE;
   \                     ??zclProcessInDiscCmd_8:
   \   0002F0   7900         MOV       R1,#0x0
   \                     ??zclProcessInDiscCmd_3:
   \   0002F2   740A         MOV       A,#0xa
   \   0002F4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002F7   7F08         MOV       R7,#0x8
   \   0002F9   02....       LJMP      ?BANKED_LEAVE_XDATA
   5117            }
   5118          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_radius>`:
   \   000000   1E           DB 30
   5119          
   5120          #endif // ZCL_DISCOVER
   5121          
   5122          
   5123          /*********************************************************************
   5124          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     44   zclAuthorizeRead
        0     16   -> zclGetAuthorizeCB
      0     36   zclAuthorizeWrite
        0     16   -> zclGetAuthorizeCB
      3     34   zclBuildHdr
      2     34   zclCalcHdrSize
      0     56   zclFindAttrRec
        0     16   -> zclFindAttrRecsList
      2     18   zclFindAttrRecsList
      0     23   zclFindClusterOption
      0     18   zclFindCmdRec
        0     16   -> zclFindCmdRecsList
      2     18   zclFindCmdRecsList
      0     50   zclFindNextAttrRec
        0     18   -> zclFindAttrRecsList
      1     48   zclFindNextCmdRec
        0     18   -> zclFindCmdRecsList
      0     49   zclFindPlugin
      0     49   zclGetAttrDataLength
        0     11   -> zclGetDataTypeLength
      0     60   zclGetAttrDataLengthUsingCB
        0     18   -> zclGetReadWriteCB
      0     26   zclGetAuthorizeCB
        0     10   -> zclFindAttrRecsList
      0     54   zclGetClusterOption
        0     14   -> zclFindClusterOption
      0     11   zclGetDataTypeLength
      0     30   zclGetReadWriteCB
        0     10   -> zclFindAttrRecsList
      1     52   zclParseHdr
        0     12   -> osal_memset
      1     14   zclParseInDefaultRspCmd
        0     14   -> osal_mem_alloc
      1     14   zclParseInDiscAttrsCmd
        0     14   -> osal_mem_alloc
      1     16   zclParseInDiscAttrsExtRspCmd
        0     16   -> osal_mem_alloc
      1     16   zclParseInDiscAttrsRspCmd
        0     16   -> osal_mem_alloc
      1     14   zclParseInDiscCmdsCmd
        0     14   -> osal_mem_alloc
      1     16   zclParseInDiscCmdsRspCmd
        0     16   -> osal_mem_alloc
      1     14   zclParseInReadCmd
        0     14   -> osal_mem_alloc
      1     29   zclParseInReadRspCmd
        0     26   -> osal_mem_alloc
        0     29   -> osal_memcpy
        0     26   -> zclGetAttrDataLength
      1     29   zclParseInWriteCmd
        0     26   -> osal_mem_alloc
        0     29   -> osal_memcpy
        0     26   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      0     28   zclProcessInDiscAttrs
        0     28   -> zclFindNextAttrRec
        0     24   -> zclProcessInDiscAttrsCmd
        0     24   -> zclProcessInDiscAttrsExtCmd
      1     57   zclProcessInDiscAttrsCmd
        0     28   -> osal_mem_alloc
        0     28   -> osal_mem_free
        0     32   -> zclFindNextAttrRec
        0     33   -> zcl_SendDiscoverAttrsRspCmd
      1     57   zclProcessInDiscAttrsExtCmd
        0     28   -> osal_mem_alloc
        0     28   -> osal_mem_free
        0     32   -> zclFindNextAttrRec
        0     33   -> zcl_SendDiscoverAttrsExtRsp
      1     31   zclProcessInDiscCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     30   -> zclFindNextCmdRec
        0     31   -> zcl_SendDiscoverCmdsRspCmd
      1     33   zclProcessInReadCmd
        0     28   -> osal_mem_alloc
        0     28   -> osal_mem_free
        0     28   -> zclAuthorizeRead
        0     30   -> zclFindAttrRec
        0     33   -> zcl_SendReadRsp
      1     37   zclProcessInWriteCmd
        0     32   -> bdb_ZclIdentifyCmdInd
        0     32   -> osal_mem_alloc
        0     32   -> osal_mem_free
        0     35   -> osal_memcpy
        0     34   -> zclFindAttrRec
        0     34   -> zclWriteAttrData
        0     34   -> zclWriteAttrDataUsingCB
        0     37   -> zcl_SendWriteRsp
      1     43   zclProcessInWriteUndividedCmd
        0     38   -> osal_mem_alloc
        0     38   -> osal_mem_free
        0     40   -> zclFindAttrRec
        0     38   -> zclGetAttrDataLength
        0     38   -> zclGetAttrDataLengthUsingCB
        0     40   -> zclReadAttrData
        0     42   -> zclReadAttrDataUsingCB
        0     40   -> zclRevertWriteUndividedCmd
        0     40   -> zclWriteAttrData
        0     40   -> zclWriteAttrDataUsingCB
        0     43   -> zcl_SendWriteRsp
      0     61   zclReadAttrData
        0     21   -> osal_memcpy
        0     18   -> zclGetAttrDataLength
      0     66   zclReadAttrDataUsingCB
        0     20   -> zclGetReadWriteCB
      0     73   zclRevertWriteUndividedCmd
        0     33   -> osal_memcpy
        0     32   -> zclFindAttrRec
        0     30   -> zclGetAttrDataLength
        0     32   -> zclWriteAttrDataUsingCB
      1     51   zclSerializeData
        0     23   -> osal_buffer_uint32
        0     22   -> osal_memcpy
      0     54   zclSetSecurityOption
        0     14   -> zclFindClusterOption
      0     63   zclWriteAttrData
        0     23   -> osal_memcpy
        0     20   -> zclAuthorizeWrite
        0     20   -> zclGetAttrDataLength
      0     62   zclWriteAttrDataUsingCB
        0     18   -> zclAuthorizeWrite
        0     18   -> zclGetReadWriteCB
      0     67   zcl_DeviceOperational
        0     25   -> zclFindAttrRec
        0     25   -> zclReadAttrData
      1     14   zcl_HandleExternal
        0     14   -> osal_msg_allocate
        0     14   -> osal_msg_send
        0     14   -> zcl_getExternalFoundationHandler
      2      0   zcl_Init
      2     63   zcl_ProcessMessageMSG
        0     40   -> StubAPS_InterPan
        0     40   -> afFindEndPointDesc
        0     40   -> osal_mem_free
        0     40   -> zclFindPlugin
        0     40   -> zclGetClusterOption
        0     40   -> zclParseHdr
        0     40   -> zclSetSecurityOption
        0     42   -> zcl_DeviceOperational
        0     47   -> zcl_SendDefaultRspCmd
      0     34   zcl_ReadAttrData
        0     28   -> zclFindAttrRec
        0     28   -> zclReadAttrData
        0     30   -> zclReadAttrDataUsingCB
      1     82   zcl_SendCommand
        0     43   -> AF_DataRequest
        0     34   -> StubAPS_InterPan
        0     34   -> afFindEndPointDesc
        0     34   -> osal_mem_alloc
        0     34   -> osal_mem_free
        0     37   -> osal_memcpy
        0     34   -> osal_memset
        0     34   -> zclBuildHdr
        0     34   -> zclCalcHdrSize
        0     34   -> zclGetClusterOption
        0     36   -> zcl_DeviceOperational
        0     34   -> zcl_getRawAFMsg
      1     80   zcl_SendDefaultRspCmd
        0     33   -> zcl_SendCommand
      1     40   zcl_SendDiscoverAttrsCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     35   -> zcl_SendCommand
      1     39   zcl_SendDiscoverAttrsExt
        0     34   -> zcl_SendCommand
      1     70   zcl_SendDiscoverAttrsExtRsp
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     37   -> zcl_SendCommand
      1     70   zcl_SendDiscoverAttrsRspCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     37   -> zcl_SendCommand
      1     39   zcl_SendDiscoverCmdsCmd
        0     33   -> zcl_SendCommand
      1     68   zcl_SendDiscoverCmdsRspCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     37   -> zcl_SendCommand
      1     42   zcl_SendRead
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     37   -> zcl_SendCommand
      1     72   zcl_SendReadRsp
        0     28   -> osal_mem_alloc
        0     28   -> osal_mem_free
        0     28   -> zclGetAttrDataLength
        0     28   -> zclGetAttrDataLengthUsingCB
        0     32   -> zclReadAttrDataUsingCB
        0     28   -> zclSerializeData
        0     39   -> zcl_SendCommand
      1     45   zcl_SendWriteRequest
        0     28   -> osal_mem_alloc
        0     28   -> osal_mem_free
        0     28   -> zclGetAttrDataLength
        0     28   -> zclSerializeData
        0     39   -> zcl_SendCommand
      1     80   zcl_SendWriteRsp
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     37   -> zcl_SendCommand
      1     25   zcl_addExternalFoundationHandler
        0     16   -> osal_mem_alloc
        0     16   -> osal_mem_free
      0     16   zcl_event_loop
        0     16   -> osal_msg_deallocate
        0     16   -> osal_msg_receive
        0     16   -> osal_msg_send
        0     16   -> zcl_ProcessMessageMSG
        0     16   -> zcl_getExternalFoundationHandler
      0     25   zcl_getExternalFoundationHandler
      2      0   zcl_getParsedTransSeqNum
      2     34   zcl_getRawAFMsg
      1     16   zcl_registerAttrList
        0     16   -> osal_mem_alloc
      1     16   zcl_registerClusterOptionList
        0     16   -> osal_mem_alloc
      1     16   zcl_registerCmdList
        0     16   -> osal_mem_alloc
      0      9   zcl_registerForMsg
        0      9   -> zcl_addExternalFoundationHandler
      0      9   zcl_registerForMsgExt
        0      9   -> zcl_addExternalFoundationHandler
      0     20   zcl_registerPlugin
        0     18   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_radius>
       2  attrList
       2  clusterOptionList
       2  externalEndPointHandlerList
       2  gpCmdList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      74  zclAuthorizeRead
      74  zclAuthorizeWrite
     271  zclBuildHdr
      37  zclCalcHdrSize
      92  zclCmdTable
     278  zclFindAttrRec
      54  zclFindAttrRecsList
     180  zclFindClusterOption
     246  zclFindCmdRec
      54  zclFindCmdRecsList
     465  zclFindNextAttrRec
     789  zclFindNextCmdRec
      81  zclFindPlugin
     123  zclGetAttrDataLength
     117  zclGetAttrDataLengthUsingCB
      49  zclGetAuthorizeCB
      58  zclGetClusterOption
     168  zclGetDataTypeLength
      47  zclGetReadWriteCB
     386  zclParseHdr
      97  zclParseInDefaultRspCmd
     122  zclParseInDiscAttrsCmd
     368  zclParseInDiscAttrsExtRspCmd
     300  zclParseInDiscAttrsRspCmd
     106  zclParseInDiscCmdsCmd
     173  zclParseInDiscCmdsRspCmd
     191  zclParseInReadCmd
     576  zclParseInReadRspCmd
     511  zclParseInWriteCmd
     338  zclParseInWriteRspCmd
     268  zclProcessInDiscAttrs
     613  zclProcessInDiscAttrsCmd
     670  zclProcessInDiscAttrsExtCmd
     764  zclProcessInDiscCmd
     694  zclProcessInReadCmd
    1205  zclProcessInWriteCmd
    1822  zclProcessInWriteUndividedCmd
     153  zclReadAttrData
     116  zclReadAttrDataUsingCB
     339  zclRevertWriteUndividedCmd
     790  zclSerializeData
      73  zclSetSecurityOption
     212  zclWriteAttrData
     153  zclWriteAttrDataUsingCB
     149  zcl_DeviceOperational
     258  zcl_HandleExternal
       1  zcl_InSeqNum
      16  zcl_Init
    1888  zcl_ProcessMessageMSG
     158  zcl_ReadAttrData
     704  zcl_SendCommand
     206  zcl_SendDefaultRspCmd
     285  zcl_SendDiscoverAttrsCmd
     225  zcl_SendDiscoverAttrsExt
     552  zcl_SendDiscoverAttrsExtRsp
     492  zcl_SendDiscoverAttrsRspCmd
     314  zcl_SendDiscoverCmdsCmd
     451  zcl_SendDiscoverCmdsRspCmd
     410  zcl_SendRead
     747  zcl_SendReadRsp
     562  zcl_SendWriteRequest
     499  zcl_SendWriteRsp
       1  zcl_TaskID
       2  zcl_ValidateAttrDataCB
     234  zcl_addExternalFoundationHandler
     147  zcl_event_loop
      87  zcl_getExternalFoundationHandler
      16  zcl_getParsedTransSeqNum
      19  zcl_getRawAFMsg
       1  zcl_radius
     198  zcl_registerAttrList
     176  zcl_registerClusterOptionList
     176  zcl_registerCmdList
      19  zcl_registerForMsg
      21  zcl_registerForMsgExt
     187  zcl_registerPlugin
      71  zcl_registerReadWriteCB
      21  zcl_registerValidateAttrData
     438  -- Other

 
 23 493 bytes in segment BANKED_CODE
    438 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
     17 bytes in segment XDATA_Z
 
    531 bytes of CODE     memory
 23 493 bytes of HUGECODE memory
     18 bytes of XDATA    memory

Errors: none
Warnings: none
