###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               05/Aug/2020  22:51:08
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack 3.0.2\Projects\zstack\ZMain\TI2530DB\OnBoard.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EW41E2.tmp ("D:\AA\Z-Stack
#        3.0.2\Projects\zstack\ZMain\TI2530DB\OnBoard.c" -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D POWER_SAVING -D
#        NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC
#        -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_GROUPS -D BDB_TL_INITIATOR -D INTER_PAN -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=0
#        -DQUEUED_POLL_RATE=0 -DRESPONSE_POLL_RATE=0 -DREJOIN_POLL_RATE=0
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\" -I
#        "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -On --require_prototypes --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_cross_call)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List\OnBoard.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj\OnBoard.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Projects\zstack\ZMain\TI2530DB\OnBoard.c
      1          /**************************************************************************************************
      2            Filename:       OnBoard.c
      3            Revised:        $Date: 2012-11-15 11:48:16 -0800 (Thu, 15 Nov 2012) $
      4            Revision:       $Revision: 32196 $
      5          
      6            Description:    This file contains the UI and control for the
      7                            peripherals on the EVAL development board
      8            Notes:          This file targets the Chipcon CC2530/31
      9          
     10          
     11            Copyright 2005-2011 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License").  You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product.  Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          
     46          #include "ZComDef.h"
     47          #include "ZGlobals.h"
     48          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1
     49          #include "OSAL.h"
     50          #include "MT.h"
     51          #include "MT_SYS.h"
     52          #include "DebugTrace.h"
     53          
     54          /* Hal */
     55          #include "hal_lcd.h"
     56          #include "hal_mcu.h"
     57          #include "hal_timer.h"
     58          #include "hal_key.h"
     59          #include "hal_led.h"
     60          #include "hal_adc.h"
     61          
     62          /* Allow access macRandomByte() */
     63          #include "mac_radio_defs.h"
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          
     69          // Task ID not initialized
     70          #define NO_TASK_ID 0xFF
     71          
     72          // Minimum length RAM "pattern" for Stack check
     73          #define MIN_RAM_INIT 12
     74          
     75          /*********************************************************************
     76           * GLOBAL VARIABLES
     77           */
     78          
     79          #if defined MAKE_CRC_SHDW
     80          #pragma location="CRC_SHDW"
     81          const CODE uint16 _crcShdw = 0xFFFF;
     82          #pragma required=_crcShdw
     83          
     84          #elif !defined MT_UBL_FUNC
     85          
     86          #pragma location="LOCK_BITS_ADDRESS_SPACE"

   \                                 In  segment LOCK_BITS_ADDRESS_SPACE, align 1
     87          __no_init uint8 _lockBits[16];
   \                     _lockBits:
   \   000000                DS 16
     88          #pragma required=_lockBits
     89          
     90          #if defined ZCL_KEY_ESTABLISH
     91          #include "zcl_cert_data.c"
     92          #else
     93          #pragma location="IEEE_ADDRESS_SPACE"

   \                                 In  segment IEEE_ADDRESS_SPACE, align 1
     94          __no_init uint8 _nvIEEE[Z_EXTADDR_LEN];
   \                     _nvIEEE:
   \   000000                DS 8
   \   000008                REQUIRE _lockBits
     95          #pragma required=_nvIEEE
     96          #endif
     97          
     98          #pragma location="RESERVED_ADDRESS_SPACE"

   \                                 In  segment RESERVED_ADDRESS_SPACE, align 1
     99          __no_init uint8 _reserved[1932];
   \                     _reserved:
   \   000000                DS 1932
   \   00078C                REQUIRE _nvIEEE
    100          #pragma required=_reserved
    101          #endif
    102          
    103          // 64-bit Extended Address of this device

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    104          uint8 aExtendedAddress[8];
   \                     aExtendedAddress:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
   \   000008                REQUIRE _reserved
    105          
    106          /*********************************************************************
    107           * LOCAL VARIABLES
    108           */
    109          
    110          // Registered keys task ID, initialized to NOT USED.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    111          static uint8 registeredKeysTaskID = NO_TASK_ID;
   \                     registeredKeysTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for registeredKeysTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    112          static uint8 registeredSW2KeysTaskID = NO_TASK_ID;
   \                     registeredSW2KeysTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for registeredSW2KeysTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    113          static uint8 registeredSW3KeysTaskID = NO_TASK_ID;
   \                     registeredSW3KeysTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for registeredSW3KeysTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    114          
    115          /*********************************************************************
    116           * LOCAL FUNCTIONS
    117           */
    118          static void ChkReset( void );
    119          // function pointer for low voltage warning callback

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    120          static void (*gpLowVoltageWarning)( uint8 voltLevel ) = (void*) NULL;
   \                     gpLowVoltageWarning:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    121          
    122          /*********************************************************************
    123           * @fn      InitBoard()
    124           * @brief   Initialize the CC2420DB Board Peripherals
    125           * @param   level: COLD,WARM,READY
    126           * @return  None
    127           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    128          void InitBoard( uint8 level )
   \                     InitBoard:
    129          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    130            if ( level == OB_COLD )
   \   000007   EE           MOV       A,R6
   \   000008   7011         JNZ       ??InitBoard_0
    131            {
    132              // IAR does not zero-out this byte below the XSTACK.
    133              *(uint8 *)0x0 = 0;
   \   00000A   900000       MOV       DPTR,#0x0
   \   00000D   7400         MOV       A,#0x0
   \   00000F   F0           MOVX      @DPTR,A
    134              // Interrupts off
    135              osal_int_disable( INTS_ALL );
   \   000010                ; Setup parameters for call to function osal_int_disable
   \   000010   79FF         MOV       R1,#-0x1
   \   000012   12....       LCALL     `??osal_int_disable::?relay`; Banked call to: osal_int_disable
   \   000015   E9           MOV       A,R1
    136              // Check for Brown-Out reset
    137              ChkReset();
   \   000016                ; Setup parameters for call to function ChkReset
   \   000016   12....       LCALL     `??ChkReset::?relay`; Banked call to: ChkReset
   \   000019   8009         SJMP      ??InitBoard_1
    138            }
    139            else  // !OB_COLD
    140            {
    141              /* Initialize Key stuff */
    142              HalKeyConfig(HAL_KEY_INTERRUPT_ENABLE , OnBoard_KeyCallback);
   \                     ??InitBoard_0:
   \   00001B                ; Setup parameters for call to function HalKeyConfig
   \   00001B   7A..         MOV       R2,#`??OnBoard_KeyCallback::?relay` & 0xff
   \   00001D   7B..         MOV       R3,#(`??OnBoard_KeyCallback::?relay` >> 8) & 0xff
   \   00001F   7901         MOV       R1,#0x1
   \   000021   12....       LCALL     `??HalKeyConfig::?relay`; Banked call to: HalKeyConfig
    143            }
    144          }
   \                     ??InitBoard_1:
   \   000024   7F01         MOV       R7,#0x1
   \   000026   02....       LJMP      ?BANKED_LEAVE_XDATA
    145          
    146          /*********************************************************************
    147           * @fn      ChkReset()
    148           * @brief   Check reset bits - if reset cause is unknown, assume a
    149           *          brown-out (low power), assume batteries are not reliable,
    150           *          hang in a loop and sequence through the LEDs.
    151           * @param   None
    152           * @return  None
    153           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    154          void ChkReset( void )
   \                     ChkReset:
    155          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    156            uint8 rib;
    157          
    158            // Isolate reset indicator bits
    159            rib = SLEEPSTA & LRESET;
   \   000005   E59D         MOV       A,0x9d
   \   000007   5418         ANL       A,#0x18
   \   000009   FE           MOV       R6,A
    160          
    161            if ( rib == RESETPO )
   \   00000A   EE           MOV       A,R6
   \   00000B   600D         JZ        ??ChkReset_0
    162            {
    163              // Put code here to handle Power-On reset
    164            }
    165            else if ( rib == RESETEX )
   \   00000D   7408         MOV       A,#0x8
   \   00000F   6E           XRL       A,R6
   \   000010   6008         JZ        ??ChkReset_0
    166            {
    167              // Put code here to handle External reset
    168            }
    169            else if ( rib == RESETWD )
   \   000012   7410         MOV       A,#0x10
   \   000014   6E           XRL       A,R6
   \   000015   6003         JZ        ??ChkReset_0
    170            {
    171              // Put code here to handle WatchDog reset
    172            }
    173            else  // Unknown reason - not expected.
    174            {
    175              HAL_ASSERT(0);
   \   000017                ; Setup parameters for call to function halAssertHandler
   \   000017   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    176            }
    177          }
   \                     ??ChkReset_0:
   \   00001A   7F01         MOV       R7,#0x1
   \   00001C   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   00001F                REQUIRE SLEEPSTA
    178          
    179          /*********************************************************************
    180           *                        "Keyboard" Support
    181           *********************************************************************/
    182          
    183          /*********************************************************************
    184           * Keyboard Register function
    185           *
    186           * The keyboard handler is setup to send all keyboard changes to
    187           * one task (if a task is registered).
    188           *
    189           * If a task registers, it will get all the keys. You can change this
    190           * to register for individual keys.
    191           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    192          uint8 RegisterForKeys( uint8 task_id )
   \                     RegisterForKeys:
    193          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   F8           MOV       R0,A
    194            // Allow only the first task
    195            if ( registeredKeysTaskID == NO_TASK_ID )
   \   000006   90....       MOV       DPTR,#registeredKeysTaskID
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   64FF         XRL       A,#0xff
   \   00000C   7009         JNZ       ??RegisterForKeys_0
    196            {
    197              registeredKeysTaskID = task_id;
   \   00000E   E8           MOV       A,R0
   \   00000F   90....       MOV       DPTR,#registeredKeysTaskID
   \   000012   F0           MOVX      @DPTR,A
    198              return ( true );
   \   000013   7901         MOV       R1,#0x1
   \   000015   8002         SJMP      ??RegisterForKeys_1
    199            }
    200            else
    201              return ( false );
   \                     ??RegisterForKeys_0:
   \   000017   7900         MOV       R1,#0x0
   \                     ??RegisterForKeys_1:
   \   000019   D083         POP       DPH
   \   00001B   D082         POP       DPL
   \   00001D   02....       LJMP      ?BRET
    202          }
    203          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    204          uint8 RegisterSW2ForKeys( uint8 task_id )
   \                     RegisterSW2ForKeys:
    205          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   F8           MOV       R0,A
    206            // Allow only the first task
    207            if ( registeredSW2KeysTaskID == NO_TASK_ID )
   \   000006   90....       MOV       DPTR,#registeredSW2KeysTaskID
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   64FF         XRL       A,#0xff
   \   00000C   7009         JNZ       ??RegisterSW2ForKeys_0
    208            {
    209              registeredSW2KeysTaskID = task_id;
   \   00000E   E8           MOV       A,R0
   \   00000F   90....       MOV       DPTR,#registeredSW2KeysTaskID
   \   000012   F0           MOVX      @DPTR,A
    210              return ( true );
   \   000013   7901         MOV       R1,#0x1
   \   000015   8002         SJMP      ??RegisterSW2ForKeys_1
    211            }
    212            else
    213              return ( false );
   \                     ??RegisterSW2ForKeys_0:
   \   000017   7900         MOV       R1,#0x0
   \                     ??RegisterSW2ForKeys_1:
   \   000019   D083         POP       DPH
   \   00001B   D082         POP       DPL
   \   00001D   02....       LJMP      ?BRET
    214          }
    215          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    216          uint8 RegisterSW3ForKeys( uint8 task_id )
   \                     RegisterSW3ForKeys:
    217          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   F8           MOV       R0,A
    218            // Allow only the first task
    219            if ( registeredSW3KeysTaskID == NO_TASK_ID )
   \   000006   90....       MOV       DPTR,#registeredSW3KeysTaskID
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   64FF         XRL       A,#0xff
   \   00000C   7009         JNZ       ??RegisterSW3ForKeys_0
    220            {
    221              registeredSW3KeysTaskID = task_id;
   \   00000E   E8           MOV       A,R0
   \   00000F   90....       MOV       DPTR,#registeredSW3KeysTaskID
   \   000012   F0           MOVX      @DPTR,A
    222              return ( true );
   \   000013   7901         MOV       R1,#0x1
   \   000015   8002         SJMP      ??RegisterSW3ForKeys_1
    223            }
    224            else
    225              return ( false );
   \                     ??RegisterSW3ForKeys_0:
   \   000017   7900         MOV       R1,#0x0
   \                     ??RegisterSW3ForKeys_1:
   \   000019   D083         POP       DPH
   \   00001B   D082         POP       DPL
   \   00001D   02....       LJMP      ?BRET
    226          }
    227          
    228          /*********************************************************************
    229           * @fn      OnBoard_SendKeys
    230           *
    231           * @brief   Send "Key Pressed" message to application.
    232           *
    233           * @param   keys  - keys that were pressed
    234           *          state - shifted
    235           *
    236           * @return  status
    237           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    238          uint8 OnBoard_SendKeys( uint8 keys, uint8 state )
   \                     OnBoard_SendKeys:
    239          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   8A..         MOV       ?V1,R2
    240            keyChange_t *msgPtr;
    241          
    242            if ( registeredKeysTaskID != NO_TASK_ID )
   \   000009   90....       MOV       DPTR,#registeredKeysTaskID
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   64FF         XRL       A,#0xff
   \   00000F   6046         JZ        ??OnBoard_SendKeys_0
    243            {
    244              // Send the address to the task
    245              msgPtr = (keyChange_t *)osal_msg_allocate( sizeof(keyChange_t) );
   \   000011                ; Setup parameters for call to function osal_msg_allocate
   \   000011   7A04         MOV       R2,#0x4
   \   000013   7B00         MOV       R3,#0x0
   \   000015   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   000018   8A..         MOV       ?V2,R2
   \   00001A   8B..         MOV       ?V3,R3
   \   00001C   AE..         MOV       R6,?V2
   \   00001E   AF..         MOV       R7,?V3
    246              if ( msgPtr )
   \   000020   EE           MOV       A,R6
   \   000021   4F           ORL       A,R7
   \   000022   602F         JZ        ??OnBoard_SendKeys_1
    247              {
    248                msgPtr->hdr.event = KEY_CHANGE;
   \   000024   8E82         MOV       DPL,R6
   \   000026   8F83         MOV       DPH,R7
   \   000028   74C0         MOV       A,#-0x40
   \   00002A   F0           MOVX      @DPTR,A
    249                msgPtr->state = state;
   \   00002B   E5..         MOV       A,?V1
   \   00002D   C0E0         PUSH      A
   \   00002F   8E82         MOV       DPL,R6
   \   000031   8F83         MOV       DPH,R7
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   D0E0         POP       A
   \   000037   F0           MOVX      @DPTR,A
    250                msgPtr->keys = keys;
   \   000038   E5..         MOV       A,?V0
   \   00003A   C0E0         PUSH      A
   \   00003C   8E82         MOV       DPL,R6
   \   00003E   8F83         MOV       DPH,R7
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   D0E0         POP       A
   \   000045   F0           MOVX      @DPTR,A
    251          
    252          //      if ( keys & HAL_KEY_SW_6 )
    253          //      {
    254          //        osal_msg_send( registeredKeysTaskID, (uint8 *)msgPtr );
    255          //      }
    256          //      else if ( keys & HAL_KEY_SW_5 )
    257          //      {
    258          //        osal_msg_send( registeredSW2KeysTaskID, (uint8 *)msgPtr );
    259          //      }
    260          //      else if ( keys & HAL_KEY_SW3 )
    261          //      {
    262          //        osal_msg_send( registeredSW3KeysTaskID, (uint8 *)msgPtr );
    263          //      }
    264                osal_msg_send( registeredKeysTaskID, (uint8 *)msgPtr );
   \   000046                ; Setup parameters for call to function osal_msg_send
   \   000046   EE           MOV       A,R6
   \   000047   FA           MOV       R2,A
   \   000048   EF           MOV       A,R7
   \   000049   FB           MOV       R3,A
   \   00004A   90....       MOV       DPTR,#registeredKeysTaskID
   \   00004D   E0           MOVX      A,@DPTR
   \   00004E   F9           MOV       R1,A
   \   00004F   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   000052   E9           MOV       A,R1
    265              }
    266              return ( ZSuccess );
   \                     ??OnBoard_SendKeys_1:
   \   000053   7900         MOV       R1,#0x0
   \   000055   8002         SJMP      ??OnBoard_SendKeys_2
    267            }
    268            else
    269              return ( ZFailure );
   \                     ??OnBoard_SendKeys_0:
   \   000057   7901         MOV       R1,#0x1
   \                     ??OnBoard_SendKeys_2:
   \   000059   7F04         MOV       R7,#0x4
   \   00005B   02....       LJMP      ?BANKED_LEAVE_XDATA
    270          }
    271          
    272          /*********************************************************************
    273           * @fn      OnBoard_KeyCallback
    274           *
    275           * @brief   Callback service for keys
    276           *
    277           * @param   keys  - keys that were pressed
    278           *          state - shifted
    279           *
    280           * @return  void
    281           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    282          void OnBoard_KeyCallback ( uint8 keys, uint8 state )
   \                     OnBoard_KeyCallback:
    283          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FF           MOV       R7,A
   \   000007   8A..         MOV       ?V0,R2
    284            uint8 shift;
    285            (void)state;
    286          
    287          //  shift = (keys & HAL_KEY_SW_6) ? true : false;
    288            shift = 1;
   \   000009   7E01         MOV       R6,#0x1
    289            if ( OnBoard_SendKeys( keys, shift ) != ZSuccess )
   \   00000B                ; Setup parameters for call to function OnBoard_SendKeys
   \   00000B   EE           MOV       A,R6
   \   00000C   FA           MOV       R2,A
   \   00000D   EF           MOV       A,R7
   \   00000E   F9           MOV       R1,A
   \   00000F   12....       LCALL     `??OnBoard_SendKeys::?relay`; Banked call to: OnBoard_SendKeys
   \   000012   E9           MOV       A,R1
    290            {
    291              // Process SW1 here
    292              if ( keys & HAL_KEY_SW_1 )  // Switch 1
    293              {
    294              }
    295              // Process SW2 here
    296              if ( keys & HAL_KEY_SW_2 )  // Switch 2
    297              {
    298              }
    299              // Process SW3 here
    300              if ( keys & HAL_KEY_SW_3 )  // Switch 3
    301              {
    302              }
    303              // Process SW4 here
    304              if ( keys & HAL_KEY_SW_4 )  // Switch 4
    305              {
    306              }
    307              // Process SW5 here
    308              if ( keys & HAL_KEY_SW_5 )  // Switch 5
    309              {
    310              }
    311              // Process SW6 here
    312              if ( keys & HAL_KEY_SW_6 )  // Switch 6
    313              {
    314              }
    315            }
    316          }
   \   000013   7F01         MOV       R7,#0x1
   \   000015   02....       LJMP      ?BANKED_LEAVE_XDATA
    317          
    318          /*********************************************************************
    319           *                  Low Voltage Protectiion Support
    320           *********************************************************************/
    321          
    322          /*********************************************************************
    323           * @fn      RegisterVoltageWarningCB
    324           *
    325           * @brief   Register Low Voltage Warning Callback
    326           *
    327           * @param   pVoltWarnCB - fundion pointer of the callback
    328           *
    329           * @return  none
    330           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    331          void RegisterVoltageWarningCB( void (*pVoltWarnCB)(uint8) )
   \                     RegisterVoltageWarningCB:
    332          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    333            gpLowVoltageWarning = pVoltWarnCB;
   \   000004   90....       MOV       DPTR,#gpLowVoltageWarning
   \   000007   EA           MOV       A,R2
   \   000008   F0           MOVX      @DPTR,A
   \   000009   A3           INC       DPTR
   \   00000A   EB           MOV       A,R3
   \   00000B   F0           MOVX      @DPTR,A
    334          }
   \   00000C   D083         POP       DPH
   \   00000E   D082         POP       DPL
   \   000010   02....       LJMP      ?BRET
    335          
    336          /*********************************************************************
    337           * @fn      OnBoard_CheckVoltage
    338           *
    339           * @brief   Check voltage and notify the callback of the status
    340           *
    341           * @param   none
    342           *
    343           * @return  TRUE  - The voltage is good for NV writing
    344           *          FALSE - The voltage is not high enough for NV writing
    345           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    346          bool OnBoard_CheckVoltage( void )
   \                     OnBoard_CheckVoltage:
    347          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    348            uint8 voltageMeasured;
    349            uint8 howGood;
    350          
    351            voltageMeasured = HalAdcCheckVddRaw();
   \   000005                ; Setup parameters for call to function HalAdcCheckVddRaw
   \   000005   12....       LCALL     `??HalAdcCheckVddRaw::?relay`; Banked call to: HalAdcCheckVddRaw
   \   000008   E9           MOV       A,R1
   \   000009   FF           MOV       R7,A
    352          
    353            if ( voltageMeasured > VDD_MIN_GOOD )
   \   00000A   EF           MOV       A,R7
   \   00000B   C3           CLR       C
   \   00000C   9453         SUBB      A,#0x53
   \   00000E   4004         JC        ??OnBoard_CheckVoltage_0
    354            {
    355              howGood = VOLT_LEVEL_GOOD;
   \   000010   7E02         MOV       R6,#0x2
   \   000012   800C         SJMP      ??OnBoard_CheckVoltage_1
    356            }
    357            else if ( voltageMeasured > VDD_MIN_NV )
   \                     ??OnBoard_CheckVoltage_0:
   \   000014   EF           MOV       A,R7
   \   000015   C3           CLR       C
   \   000016   944F         SUBB      A,#0x4f
   \   000018   4004         JC        ??OnBoard_CheckVoltage_2
    358            {
    359              howGood = VOLT_LEVEL_CAUTIOUS;
   \   00001A   7E01         MOV       R6,#0x1
   \   00001C   8002         SJMP      ??OnBoard_CheckVoltage_1
    360            }
    361            else
    362            {
    363              howGood = VOLT_LEVEL_BAD;
   \                     ??OnBoard_CheckVoltage_2:
   \   00001E   7E00         MOV       R6,#0x0
    364            }
    365              
    366            if ( gpLowVoltageWarning )
   \                     ??OnBoard_CheckVoltage_1:
   \   000020   90....       MOV       DPTR,#gpLowVoltageWarning
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F8           MOV       R0,A
   \   000025   A3           INC       DPTR
   \   000026   E0           MOVX      A,@DPTR
   \   000027   F9           MOV       R1,A
   \   000028   E8           MOV       A,R0
   \   000029   49           ORL       A,R1
   \   00002A   6016         JZ        ??OnBoard_CheckVoltage_3
    367            {
    368              if ( howGood < VOLT_LEVEL_GOOD )
   \   00002C   EE           MOV       A,R6
   \   00002D   C3           CLR       C
   \   00002E   9402         SUBB      A,#0x2
   \   000030   5010         JNC       ??OnBoard_CheckVoltage_3
    369              {
    370                gpLowVoltageWarning( howGood );
   \   000032                ; Setup parameters for indirect call
   \   000032   EE           MOV       A,R6
   \   000033   F9           MOV       R1,A
   \   000034   90....       MOV       DPTR,#gpLowVoltageWarning
   \   000037   E0           MOVX      A,@DPTR
   \   000038   F8           MOV       R0,A
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   F583         MOV       DPH,A
   \   00003D   8882         MOV       DPL,R0
   \   00003F   12....       LCALL     ?CALL_IND
    371              }
    372            }
    373          
    374            return ( howGood > VOLT_LEVEL_BAD );
   \                     ??OnBoard_CheckVoltage_3:
   \   000042   EE           MOV       A,R6
   \   000043   6004         JZ        ??OnBoard_CheckVoltage_4
   \   000045   7901         MOV       R1,#0x1
   \   000047   8002         SJMP      ??OnBoard_CheckVoltage_5
   \                     ??OnBoard_CheckVoltage_4:
   \   000049   7900         MOV       R1,#0x0
   \                     ??OnBoard_CheckVoltage_5:
   \   00004B   7F01         MOV       R7,#0x1
   \   00004D   02....       LJMP      ?BANKED_LEAVE_XDATA
    375          }
    376          
    377          /*********************************************************************
    378           * @fn      OnBoard_stack_used
    379           *
    380           * @brief   Runs through the stack looking for touched memory.
    381           *
    382           * @param   none
    383           *
    384           * @return  Maximum number of bytes used by the stack.
    385           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    386          uint16 OnBoard_stack_used(void)
   \                     OnBoard_stack_used:
    387          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    388            uint8 const *ptr;
    389            uint8 cnt = 0;
   \   000004   7800         MOV       R0,#0x0
    390          
    391            for (ptr = CSTACK_END; ptr > CSTACK_BEG; ptr--)
   \   000006   7582..       MOV       DPL,#(SFE(XSTACK) + 255) & 0xff
   \   000009   7583..       MOV       DPH,#((SFE(XSTACK) - 1) >> 8) & 0xff
   \                     ??OnBoard_stack_used_0:
   \   00000C   C3           CLR       C
   \   00000D   74..         MOV       A,#SFB(XSTACK) & 0xff
   \   00000F   9582         SUBB      A,DPL
   \   000011   74..         MOV       A,#(SFB(XSTACK) >> 8) & 0xff
   \   000013   9583         SUBB      A,DPH
   \   000015   5028         JNC       ??OnBoard_stack_used_1
    392            {
    393              if (STACK_INIT_VALUE == *ptr)
   \   000017   E0           MOVX      A,@DPTR
   \   000018   64CD         XRL       A,#0xcd
   \   00001A   7013         JNZ       ??OnBoard_stack_used_2
    394              {
    395                if (++cnt >= MIN_RAM_INIT)
   \   00001C   08           INC       R0
   \   00001D   E8           MOV       A,R0
   \   00001E   C3           CLR       C
   \   00001F   940C         SUBB      A,#0xc
   \   000021   400E         JC        ??OnBoard_stack_used_3
    396                {
    397                  ptr += MIN_RAM_INIT;
   \   000023   E582         MOV       A,DPL
   \   000025   240C         ADD       A,#0xc
   \   000027   F582         MOV       DPL,A
   \   000029   5014         JNC       ??OnBoard_stack_used_1
   \   00002B   0583         INC       DPH
    398                  break;
   \   00002D   8010         SJMP      ??OnBoard_stack_used_1
    399                }
    400              }
    401              else
    402              {
    403                cnt = 0;
   \                     ??OnBoard_stack_used_2:
   \   00002F   7800         MOV       R0,#0x0
    404              }
    405            }
   \                     ??OnBoard_stack_used_3:
   \   000031   E582         MOV       A,DPL
   \   000033   24FF         ADD       A,#-0x1
   \   000035   F582         MOV       DPL,A
   \   000037   E583         MOV       A,DPH
   \   000039   34FF         ADDC      A,#-0x1
   \   00003B   F583         MOV       DPH,A
   \   00003D   80CD         SJMP      ??OnBoard_stack_used_0
    406          
    407            return (uint16)(CSTACK_END - ptr + 1);
   \                     ??OnBoard_stack_used_1:
   \   00003F   74..         MOV       A,#(SFE(XSTACK) + 255) & 0xff
   \   000041   C3           CLR       C
   \   000042   9582         SUBB      A,DPL
   \   000044   FA           MOV       R2,A
   \   000045   74..         MOV       A,#((SFE(XSTACK) - 1) >> 8) & 0xff
   \   000047   9583         SUBB      A,DPH
   \   000049   FB           MOV       R3,A
   \   00004A   EA           MOV       A,R2
   \   00004B   2401         ADD       A,#0x1
   \   00004D   FA           MOV       R2,A
   \   00004E   5001         JNC       ??OnBoard_stack_used_4
   \   000050   0B           INC       R3
   \                     ??OnBoard_stack_used_4:
   \   000051   D083         POP       DPH
   \   000053   D082         POP       DPL
   \   000055   02....       LJMP      ?BRET
    408          }
    409          
    410          /*********************************************************************
    411           * @fn      _itoa
    412           *
    413           * @brief   convert a 16bit number to ASCII
    414           *
    415           * @param   num -
    416           *          buf -
    417           *          radix -
    418           *
    419           * @return  void
    420           *
    421           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    422          void _itoa(uint16 num, uint8 *buf, uint8 radix)
   \                     _itoa:
    423          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV       A,#-0x5
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   89..         MOV       ?V4,R1
    424            char c,i;
    425            uint8 *p, rst[5];
    426          
    427            p = rst;
   \   000010   A8..         MOV       R0,?XSP + 0
   \   000012   A9..         MOV       R1,?XSP + 1
   \   000014   88..         MOV       ?V6,R0
   \   000016   89..         MOV       ?V7,R1
   \   000018   85....       MOV       ?V0,?V6
   \   00001B   85....       MOV       ?V1,?V7
    428            for ( i=0; i<5; i++,p++ )
   \   00001E   75..00       MOV       ?V3,#0x0
   \                     ??_itoa_0:
   \   000021   E5..         MOV       A,?V3
   \   000023   C3           CLR       C
   \   000024   9405         SUBB      A,#0x5
   \   000026   5057         JNC       ??_itoa_1
    429            {
    430              c = num % radix;  // Isolate a digit
   \   000028   EE           MOV       A,R6
   \   000029   F8           MOV       R0,A
   \   00002A   EF           MOV       A,R7
   \   00002B   F9           MOV       R1,A
   \   00002C   E5..         MOV       A,?V4
   \   00002E   FA           MOV       R2,A
   \   00002F   7B00         MOV       R3,#0x0
   \   000031   12....       LCALL     ?US_DIV_MOD
   \   000034   EA           MOV       A,R2
   \   000035   F5..         MOV       ?V2,A
    431              *p = c + (( c < 10 ) ? '0' : '7');  // Convert to Ascii
   \   000037   E5..         MOV       A,?V2
   \   000039   C3           CLR       C
   \   00003A   940A         SUBB      A,#0xa
   \   00003C   5006         JNC       ??_itoa_2
   \   00003E   7830         MOV       R0,#0x30
   \   000040   7900         MOV       R1,#0x0
   \   000042   8004         SJMP      ??_itoa_3
   \                     ??_itoa_2:
   \   000044   7837         MOV       R0,#0x37
   \   000046   7900         MOV       R1,#0x0
   \                     ??_itoa_3:
   \   000048   E8           MOV       A,R0
   \   000049   25..         ADD       A,?V2
   \   00004B   C0E0         PUSH      A
   \   00004D   85..82       MOV       DPL,?V0
   \   000050   85..83       MOV       DPH,?V1
   \   000053   D0E0         POP       A
   \   000055   F0           MOVX      @DPTR,A
    432              num /= radix;
   \   000056   EE           MOV       A,R6
   \   000057   F8           MOV       R0,A
   \   000058   EF           MOV       A,R7
   \   000059   F9           MOV       R1,A
   \   00005A   E5..         MOV       A,?V4
   \   00005C   FA           MOV       R2,A
   \   00005D   7B00         MOV       R3,#0x0
   \   00005F   12....       LCALL     ?US_DIV_MOD
   \   000062   88..         MOV       ?V6,R0
   \   000064   89..         MOV       ?V7,R1
   \   000066   AE..         MOV       R6,?V6
   \   000068   AF..         MOV       R7,?V7
    433              if ( !num )
   \   00006A   EE           MOV       A,R6
   \   00006B   4F           ORL       A,R7
   \   00006C   6011         JZ        ??_itoa_1
    434                break;
    435            }
   \   00006E   05..         INC       ?V3
   \   000070   85..82       MOV       DPL,?V0
   \   000073   85..83       MOV       DPH,?V1
   \   000076   A3           INC       DPTR
   \   000077   8582..       MOV       ?V0,DPL
   \   00007A   8583..       MOV       ?V1,DPH
   \   00007D   80A2         SJMP      ??_itoa_0
    436          
    437            for ( c=0 ; c<=i; c++ )
   \                     ??_itoa_1:
   \   00007F   75..00       MOV       ?V2,#0x0
   \                     ??_itoa_4:
   \   000082   E5..         MOV       A,?V3
   \   000084   C3           CLR       C
   \   000085   95..         SUBB      A,?V2
   \   000087   4029         JC        ??_itoa_5
    438              *buf++ = *p--;  // Reverse character order
   \   000089   85..82       MOV       DPL,?V0
   \   00008C   85..83       MOV       DPH,?V1
   \   00008F   E0           MOVX      A,@DPTR
   \   000090   C0E0         PUSH      A
   \   000092   8C82         MOV       DPL,R4
   \   000094   8D83         MOV       DPH,R5
   \   000096   D0E0         POP       A
   \   000098   F0           MOVX      @DPTR,A
   \   000099   E5..         MOV       A,?V0
   \   00009B   24FF         ADD       A,#-0x1
   \   00009D   F5..         MOV       ?V0,A
   \   00009F   E5..         MOV       A,?V1
   \   0000A1   34FF         ADDC      A,#-0x1
   \   0000A3   F5..         MOV       ?V1,A
   \   0000A5   8C82         MOV       DPL,R4
   \   0000A7   8D83         MOV       DPH,R5
   \   0000A9   A3           INC       DPTR
   \   0000AA   AC82         MOV       R4,DPL
   \   0000AC   AD83         MOV       R5,DPH
   \   0000AE   05..         INC       ?V2
   \   0000B0   80D0         SJMP      ??_itoa_4
    439          
    440            *buf = '\0';
   \                     ??_itoa_5:
   \   0000B2   8C82         MOV       DPL,R4
   \   0000B4   8D83         MOV       DPH,R5
   \   0000B6   7400         MOV       A,#0x0
   \   0000B8   F0           MOVX      @DPTR,A
    441          }
   \   0000B9   7405         MOV       A,#0x5
   \   0000BB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000BE   7F08         MOV       R7,#0x8
   \   0000C0   02....       LJMP      ?BANKED_LEAVE_XDATA
    442          
    443          /*********************************************************************
    444           * @fn        Onboard_rand
    445           *
    446           * @brief    Random number generator
    447           *
    448           * @param   none
    449           *
    450           * @return  uint16 - new random number
    451           *
    452           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    453          uint16 Onboard_rand( void )
   \                     Onboard_rand:
    454          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    455            return ( MAC_RADIO_RANDOM_WORD() );
   \   000004                ; Setup parameters for call to function macMcuRandomWord
   \   000004   12....       LCALL     `??macMcuRandomWord::?relay`; Banked call to: macMcuRandomWord
   \   000007   D083         POP       DPH
   \   000009   D082         POP       DPL
   \   00000B   02....       LJMP      ?BRET
    456          }
    457          
    458          /*********************************************************************
    459           * @fn        Onboard_wait
    460           *
    461           * @brief    Delay wait
    462           *
    463           * @param   uint16 - time to wait
    464           *
    465           * @return  none
    466           *
    467           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    468          void Onboard_wait( uint16 timeout )
   \                     Onboard_wait:
    469          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    470            while (timeout--)
   \                     ??Onboard_wait_0:
   \   000000   EA           MOV       A,R2
   \   000001   F8           MOV       R0,A
   \   000002   EB           MOV       A,R3
   \   000003   F9           MOV       R1,A
   \   000004   E8           MOV       A,R0
   \   000005   24FF         ADD       A,#-0x1
   \   000007   FA           MOV       R2,A
   \   000008   E9           MOV       A,R1
   \   000009   34FF         ADDC      A,#-0x1
   \   00000B   FB           MOV       R3,A
   \   00000C   E8           MOV       A,R0
   \   00000D   49           ORL       A,R1
   \   00000E   6005         JZ        ??Onboard_wait_1
    471            {
    472              asm("NOP");
   \   000010   00           NOP
    473              asm("NOP");
   \   000011   00           NOP
    474              asm("NOP");
   \   000012   00           NOP
   \   000013   80EB         SJMP      ??Onboard_wait_0
    475            }
    476          }
   \                     ??Onboard_wait_1:
   \   000015   02....       LJMP      ?BRET
    477          
    478          /*********************************************************************
    479           * @fn      Onboard_soft_reset
    480           *
    481           * @brief   Effect a soft reset.
    482           *
    483           * @param   none
    484           *
    485           * @return  none
    486           *
    487           *********************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    488          __near_func void Onboard_soft_reset( void )
   \                     Onboard_soft_reset:
    489          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    490            HAL_DISABLE_INTERRUPTS();
   \   000000   C2AF         CLR       0xa8.7
    491            // Abort all DMA channels to insure that ongoing operations do not
    492            // interfere with re-configuration.
    493            DMAARM = 0x80 | 0x1F;
   \   000002   75D69F       MOV       0xd6,#-0x61
    494            asm("LJMP 0x0");
   \   000005   020000       LJMP 0x0
    495          }
   \   000008   22           RET
   \   000009                REQUIRE _A_IEN0
   \   000009                REQUIRE DMAARM
    496          
    497          #if defined MT_UBL_FUNC
    498          #if !defined UBL_RC_IMG_PG_BEG
    499          #define UBL_RC_IMG_PG_BEG  (HAL_SB_CRC_ADDR / HAL_FLASH_PAGE_SIZE)
    500          #endif
    501          #if !defined UBL_MD_PG_OFFSET
    502          #define UBL_MD_PG_OFFSET   (HAL_SB_CRC_ADDR % HAL_FLASH_PAGE_SIZE + 2)
    503          #endif
    504          #if !defined UBL_ADDR
    505          #define UBL_MD_ADDR        (HAL_SB_CRC_ADDR + 2)
    506          #endif
    507          
    508          /*********************************************************************
    509           * @fn      MT_UblCommandProcessing
    510           *
    511           * @brief   Effect a soft reset.
    512           *
    513           * @param   pBuf - Pointer to the received MT buffer.
    514           *
    515           * @return  MT_RPC_ERR_COMMAND_ID if the MT command is not MT_UBL_ERASE.
    516           *
    517           *********************************************************************/
    518          uint8 MT_UblCommandProcessing(uint8 *pBuf);
    519          uint8 MT_UblCommandProcessing(uint8 *pBuf)
    520          {
    521            if (pBuf[MT_RPC_POS_CMD1] == MT_UBL_ERASE)
    522            {
    523              uint16 crc[2];
    524              HalFlashRead(UBL_RC_IMG_PG_BEG, UBL_MD_PG_OFFSET, (uint8 *)(crc+1), 2);
    525          
    526              if (crc[1] != 0)
    527              {
    528                crc[1] ^= 0xFFFF;  // Only write to zero bits that are not already zero.
    529                crc[0] = 0xFFFF;
    530                HalFlashWrite((UBL_MD_ADDR - 2) / HAL_FLASH_WORD_SIZE, (uint8 *)crc, 1);
    531              }
    532          
    533              Onboard_soft_reset();
    534            }
    535          
    536            return MT_RPC_ERR_COMMAND_ID;
    537          }
    538          #endif
    539          
    540          /*********************************************************************
    541           *                    EXTERNAL I/O FUNCTIONS
    542           *
    543           * User defined functions to control external devices. Add your code
    544           * to the following functions to control devices wired to DB outputs.
    545           *
    546           *********************************************************************/
    547          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    548          void BigLight_On( void )
   \                     BigLight_On:
    549          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    550            // Put code here to turn on an external light
    551          }
   \   000000   02....       LJMP      ?BRET
    552          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    553          void BigLight_Off( void )
   \                     BigLight_Off:
    554          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    555            // Put code here to turn off an external light
    556          }
   \   000000   02....       LJMP      ?BRET
    557          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    558          void BuzzerControl( uint8 on )
   \                     BuzzerControl:
    559          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    560            // Put code here to turn a buzzer on/off
    561            (void)on;
    562          }
   \   000000   02....       LJMP      ?BRET
    563          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    564          void Dimmer( uint8 lvl )
   \                     Dimmer:
    565          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    566            // Put code here to control a dimmer
    567            (void)lvl;
    568          }
   \   000000   02....       LJMP      ?BRET
    569          
    570          // No dip switches on this board

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    571          uint8 GetUserDipSw( void )
   \                     GetUserDipSw:
    572          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    573            return 0;
   \   000000   7900         MOV       R1,#0x0
   \   000002   02....       LJMP      ?BRET
    574          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for registeredKeysTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for registeredSW2KeysTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for registeredSW3KeysTaskID>`:
   \   000000   FF           DB 255
    575          
    576          /*********************************************************************
    577          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      0   BigLight_Off
      0      0   BigLight_On
      0      0   BuzzerControl
      0     18   ChkReset
        0      9   -> halAssertHandler
      0      0   Dimmer
      0      0   GetUserDipSw
      0      9   InitBoard
        0      9   -> ChkReset
        0      9   -> HalKeyConfig
        0      9   -> osal_int_disable
      0      9   OnBoard_CheckVoltage
        0      9   -> HalAdcCheckVddRaw
      0      9   OnBoard_KeyCallback
        0      9   -> OnBoard_SendKeys
      1     21   OnBoard_SendKeys
        0     12   -> osal_msg_allocate
        0     12   -> osal_msg_send
      2      0   OnBoard_stack_used
      2      0   Onboard_rand
        2      0   -> macMcuRandomWord
      0      0   Onboard_soft_reset
      0      0   Onboard_wait
      2      0   RegisterForKeys
      2      0   RegisterSW2ForKeys
      2      0   RegisterSW3ForKeys
      2      0   RegisterVoltageWarningCB
      1     21   _itoa


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for registeredKeysTaskID>
       1  ?<Initializer for registeredSW2KeysTaskID>
       1  ?<Initializer for registeredSW3KeysTaskID>
       3  BigLight_Off
       3  BigLight_On
       3  BuzzerControl
      31  ChkReset
       1  DMAARM
       3  Dimmer
       5  GetUserDipSw
      41  InitBoard
      80  OnBoard_CheckVoltage
      24  OnBoard_KeyCallback
      94  OnBoard_SendKeys
      88  OnBoard_stack_used
      14  Onboard_rand
       9  Onboard_soft_reset
      24  Onboard_wait
      32  RegisterForKeys
      32  RegisterSW2ForKeys
      32  RegisterSW3ForKeys
      19  RegisterVoltageWarningCB
       1  SLEEPSTA
       1  _A_IEN0
     195  _itoa
      16  _lockBits
       8  _nvIEEE
    1932  _reserved
       8  aExtendedAddress
       2  gpLowVoltageWarning
       1  registeredKeysTaskID
       1  registeredSW2KeysTaskID
       1  registeredSW3KeysTaskID
     108  -- Other

 
   723 bytes in segment BANKED_CODE
   108 bytes in segment BANK_RELAYS
     8 bytes in segment IEEE_ADDRESS_SPACE
    16 bytes in segment LOCK_BITS_ADDRESS_SPACE
     9 bytes in segment NEAR_CODE
 1 932 bytes in segment RESERVED_ADDRESS_SPACE
     3 bytes in segment SFR_AN
     3 bytes in segment XDATA_I
     3 bytes in segment XDATA_ID
    10 bytes in segment XDATA_Z
 
   120 bytes of CODE     memory
     0 bytes of DATA     memory (+ 3 bytes shared)
   723 bytes of HUGECODE memory
 1 969 bytes of XDATA    memory

Errors: none
Warnings: none
