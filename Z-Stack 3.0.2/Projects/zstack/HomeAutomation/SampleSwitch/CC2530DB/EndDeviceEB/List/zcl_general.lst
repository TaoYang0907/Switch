###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               31/Jul/2020  11:47:29
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EWDB51.tmp ("D:\AA\Z-Stack
#        3.0.2\Components\stack\zcl\zcl_general.c" -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D POWER_SAVING -D
#        NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC
#        -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_GROUPS -D BDB_TL_INITIATOR -D INTER_PAN -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\" -I
#        "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -On --require_prototypes --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_cross_call)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\List\zcl_general.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\EndDeviceEB\Obj\zcl_general.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2015-09-10 09:36:48 -0700 (Thu, 10 Sep 2015) $
      4            Revision:       $Revision: 44493 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License"). You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product. Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "zcl.h"
     46          #include "zcl_general.h"
     47          //#include "ZDApp.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          #include "bdb.h"
     53          
     54          /*********************************************************************
     55           * MACROS
     56           */
     57          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     58          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     59          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     60          
     61          #ifdef ZCL_SCENES
     62          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     63          #endif // ZCL_SCENES
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          
     69          /*********************************************************************
     70           * TYPEDEFS
     71           */
     72          typedef struct zclGenCBRec
     73          {
     74            struct zclGenCBRec        *next;
     75            uint8                     endpoint; // Used to link it into the endpoint descriptor
     76            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     77          } zclGenCBRec_t;
     78          
     79          typedef struct zclGenSceneItem
     80          {
     81            struct zclGenSceneItem    *next;
     82            uint8                     endpoint; // Used to link it into the endpoint descriptor
     83            zclGeneral_Scene_t        scene;    // Scene info
     84          } zclGenSceneItem_t;
     85          
     86          typedef struct zclGenAlarmItem
     87          {
     88            struct zclGenAlarmItem    *next;
     89            uint8                     endpoint; // Used to link it into the endpoint descriptor
     90            zclGeneral_Alarm_t        alarm;    // Alarm info
     91          } zclGenAlarmItem_t;
     92          
     93          // Scene NV types
     94          typedef struct
     95          {
     96            uint16                    numRecs;
     97          } nvGenScenesHdr_t;
     98          
     99          typedef struct zclGenSceneNVItem
    100          {
    101            uint8                     endpoint;
    102            zclGeneral_Scene_t        scene;
    103          } zclGenSceneNVItem_t;
    104          
    105          /*********************************************************************
    106           * GLOBAL VARIABLES
    107           */
    108          
    109          /*********************************************************************
    110           * GLOBAL FUNCTIONS
    111           */
    112          
    113          /*********************************************************************
    114           * LOCAL VARIABLES
    115           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    116          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    117          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    118          
    119          #if defined( ZCL_SCENES )
    120            #if !defined ( ZCL_STANDALONE )
    121              static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    122            #endif
    123          #endif // ZCL_SCENES
    124          
    125          #ifdef ZCL_ALARMS
    126          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    127          #endif // ZCL_ALARMS
    128          
    129          /*********************************************************************
    130           * LOCAL FUNCTIONS
    131           */
    132          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    133          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    134          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    135          
    136          // Device Configuration and Installation clusters
    137          #ifdef ZCL_BASIC
    138          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    139          #endif // ZCL_BASIC
    140          
    141          #ifdef ZCL_IDENTIFY
    142          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    143          #endif // ZCL_IDENTIFY
    144          
    145          // Groups and Scenes clusters
    146          #ifdef ZCL_GROUPS
    147          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    148          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    149          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    150          #endif // ZCL_GROUPS
    151          
    152          #ifdef ZCL_SCENES
    153          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    154          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    155          #endif // ZCL_SCENES
    156          
    157          // On/Off and Level Control Configuration clusters
    158          #ifdef ZCL_ON_OFF
    159          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    160          #endif // ZCL_ONOFF
    161          
    162          #ifdef ZCL_LEVEL_CTRL
    163          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    164          #endif // ZCL_LEVEL_CTRL
    165          
    166          // Alarms cluster
    167          #ifdef ZCL_ALARMS
    168          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    169          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    170          #endif // ZCL_ALARMS
    171          
    172          // Location cluster
    173          #ifdef ZCL_LOCATION
    174          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    175          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    176          #endif // ZCL_LOCATION
    177          
    178          #ifdef ZCL_SCENES
    179            #if !defined ( ZCL_STANDALONE )
    180              static uint8 zclGeneral_ScenesInitNV( void );
    181              static void zclGeneral_ScenesSetDefaultNV( void );
    182              static void zclGeneral_ScenesWriteNV( void );
    183              static uint16 zclGeneral_ScenesRestoreFromNV( void );
    184            #endif
    185          #endif // ZCL_SCENES
    186          
    187          /*********************************************************************
    188           * @fn      zclGeneral_RegisterCmdCallbacks
    189           *
    190           * @brief   Register an applications command callbacks
    191           *
    192           * @param   endpoint - application's endpoint
    193           * @param   callbacks - pointer to the callback record.
    194           *
    195           * @return  ZMemError if not able to allocate
    196           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    197          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    198          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V2,R2
   \   000009   8B..         MOV       ?V3,R3
    199            zclGenCBRec_t *pNewItem;
    200            zclGenCBRec_t *pLoop;
    201          
    202            // Register as a ZCL Plugin
    203            if ( zclGenPluginRegisted == FALSE )
   \   00000B   90....       MOV       DPTR,#zclGenPluginRegisted
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   7022         JNZ       ??zclGeneral_RegisterCmdCallbacks_0
    204            {
    205              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    206                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    207                                  zclGeneral_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV       ?V6,#`??zclGeneral_HdlIncoming::?relay` & 0xff
   \   000014   75....       MOV       ?V7,#(`??zclGeneral_HdlIncoming::?relay` >> 8) & 0xff
   \   000017   78..         MOV       R0,#?V6
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   7C14         MOV       R4,#0x14
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7A00         MOV       R2,#0x0
   \   000022   7B00         MOV       R3,#0x0
   \   000024   12....       LCALL     `??zcl_registerPlugin::?relay`; Banked call to: zcl_registerPlugin
   \   000027   7402         MOV       A,#0x2
   \   000029   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002C   E9           MOV       A,R1
    208          
    209          #ifdef ZCL_SCENES
    210              // Initialize the Scenes Table
    211              zclGeneral_ScenesInit();
    212          #endif // ZCL_SCENES
    213          
    214              zclGenPluginRegisted = TRUE;
   \   00002D   90....       MOV       DPTR,#zclGenPluginRegisted
   \   000030   7401         MOV       A,#0x1
   \   000032   F0           MOVX      @DPTR,A
    215            }
    216          
    217            // Fill in the new profile list
    218            pNewItem = zcl_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   000033                ; Setup parameters for call to function osal_mem_alloc
   \   000033   7A05         MOV       R2,#0x5
   \   000035   7B00         MOV       R3,#0x0
   \   000037   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003A   8A..         MOV       ?V6,R2
   \   00003C   8B..         MOV       ?V7,R3
   \   00003E   AE..         MOV       R6,?V6
   \   000040   AF..         MOV       R7,?V7
    219            if ( pNewItem == NULL )
   \   000042   EE           MOV       A,R6
   \   000043   4F           ORL       A,R7
   \   000044   7004         JNZ       ??zclGeneral_RegisterCmdCallbacks_1
    220              return (ZMemError);
   \   000046   7910         MOV       R1,#0x10
   \   000048   8073         SJMP      ??zclGeneral_RegisterCmdCallbacks_2
    221          
    222            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_1:
   \   00004A   8E82         MOV       DPL,R6
   \   00004C   8F83         MOV       DPH,R7
   \   00004E   7400         MOV       A,#0x0
   \   000050   F0           MOVX      @DPTR,A
   \   000051   A3           INC       DPTR
   \   000052   7400         MOV       A,#0x0
   \   000054   F0           MOVX      @DPTR,A
    223            pNewItem->endpoint = endpoint;
   \   000055   E5..         MOV       A,?V4
   \   000057   C0E0         PUSH      A
   \   000059   8E82         MOV       DPL,R6
   \   00005B   8F83         MOV       DPH,R7
   \   00005D   A3           INC       DPTR
   \   00005E   A3           INC       DPTR
   \   00005F   D0E0         POP       A
   \   000061   F0           MOVX      @DPTR,A
    224            pNewItem->CBs = callbacks;
   \   000062   8E82         MOV       DPL,R6
   \   000064   8F83         MOV       DPH,R7
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   E5..         MOV       A,?V2
   \   00006B   F0           MOVX      @DPTR,A
   \   00006C   A3           INC       DPTR
   \   00006D   E5..         MOV       A,?V3
   \   00006F   F0           MOVX      @DPTR,A
    225          
    226            // Find spot in list
    227            if (  zclGenCBs == NULL )
   \   000070   90....       MOV       DPTR,#zclGenCBs
   \   000073   E0           MOVX      A,@DPTR
   \   000074   F8           MOV       R0,A
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   F9           MOV       R1,A
   \   000078   E8           MOV       A,R0
   \   000079   49           ORL       A,R1
   \   00007A   700A         JNZ       ??zclGeneral_RegisterCmdCallbacks_3
    228            {
    229              zclGenCBs = pNewItem;
   \   00007C   90....       MOV       DPTR,#zclGenCBs
   \   00007F   EE           MOV       A,R6
   \   000080   F0           MOVX      @DPTR,A
   \   000081   A3           INC       DPTR
   \   000082   EF           MOV       A,R7
   \   000083   F0           MOVX      @DPTR,A
   \   000084   8035         SJMP      ??zclGeneral_RegisterCmdCallbacks_4
    230            }
    231            else
    232            {
    233              // Look for end of list
    234              pLoop = zclGenCBs;
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000086   90....       MOV       DPTR,#zclGenCBs
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   F8           MOV       R0,A
   \   00008B   A3           INC       DPTR
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   F9           MOV       R1,A
   \   00008E   88..         MOV       ?V0,R0
   \   000090   89..         MOV       ?V1,R1
    235              while ( pLoop->next != NULL )
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   000092   85..82       MOV       DPL,?V0
   \   000095   85..83       MOV       DPH,?V1
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F8           MOV       R0,A
   \   00009A   A3           INC       DPTR
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   F9           MOV       R1,A
   \   00009D   E8           MOV       A,R0
   \   00009E   49           ORL       A,R1
   \   00009F   600F         JZ        ??zclGeneral_RegisterCmdCallbacks_6
    236                pLoop = pLoop->next;
   \   0000A1   85..82       MOV       DPL,?V0
   \   0000A4   85..83       MOV       DPH,?V1
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   F5..         MOV       ?V0,A
   \   0000AA   A3           INC       DPTR
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   F5..         MOV       ?V1,A
   \   0000AE   80E2         SJMP      ??zclGeneral_RegisterCmdCallbacks_5
    237          
    238              // Put new item at end of list
    239              pLoop->next = pNewItem;
   \                     ??zclGeneral_RegisterCmdCallbacks_6:
   \   0000B0   85..82       MOV       DPL,?V0
   \   0000B3   85..83       MOV       DPH,?V1
   \   0000B6   EE           MOV       A,R6
   \   0000B7   F0           MOVX      @DPTR,A
   \   0000B8   A3           INC       DPTR
   \   0000B9   EF           MOV       A,R7
   \   0000BA   F0           MOVX      @DPTR,A
    240            }
    241          
    242            return ( ZSuccess );
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   0000BB   7900         MOV       R1,#0x0
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   0000BD   7F08         MOV       R7,#0x8
   \   0000BF   02....       LJMP      ?BANKED_LEAVE_XDATA
    243          }
    244          
    245          #ifdef ZCL_IDENTIFY
    246          /*********************************************************************
    247           * @fn      zclGeneral_SendIdentify
    248           *
    249           * @brief   Call to send out an Identify Command
    250           *
    251           * @param   srcEP - Sending application's endpoint
    252           * @param   dstAddr - where you want the message to go
    253           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    254           * @param   seqNum - identification number for the transaction
    255           *
    256           * @return  ZStatus_t
    257           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    258          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    259                                             uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    260          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V2,R1
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   EC           MOV       A,R4
   \   000011   FE           MOV       R6,A
   \   000012   ED           MOV       A,R5
   \   000013   FF           MOV       R7,A
   \   000014   7412         MOV       A,#0x12
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V0,A
   \   00001C   7413         MOV       A,#0x13
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F5..         MOV       ?V1,A
    261            uint8 buf[2];
    262          
    263            buf[0] = LO_UINT16( identifyTime );
   \   000024   EE           MOV       A,R6
   \   000025   C0E0         PUSH      A
   \   000027   85..82       MOV       DPL,?XSP + 0
   \   00002A   85..83       MOV       DPH,?XSP + 1
   \   00002D   D0E0         POP       A
   \   00002F   F0           MOVX      @DPTR,A
    264            buf[1] = HI_UINT16( identifyTime );
   \   000030   EE           MOV       A,R6
   \   000031   F8           MOV       R0,A
   \   000032   EF           MOV       A,R7
   \   000033   F9           MOV       R1,A
   \   000034   E4           CLR       A
   \   000035   C9           XCH       A,R1
   \   000036   F8           MOV       R0,A
   \   000037   E8           MOV       A,R0
   \   000038   C0E0         PUSH      A
   \   00003A   7401         MOV       A,#0x1
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   D0E0         POP       A
   \   000041   F0           MOVX      @DPTR,A
    265          
    266            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    267                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    268                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \   000042                ; Setup parameters for call to function zcl_SendCommand
   \   000042   A8..         MOV       R0,?XSP + 0
   \   000044   A9..         MOV       R1,?XSP + 1
   \   000046   88..         MOV       ?V6,R0
   \   000048   89..         MOV       ?V7,R1
   \   00004A   78..         MOV       R0,#?V6
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004F   75..02       MOV       ?V6,#0x2
   \   000052   75..00       MOV       ?V7,#0x0
   \   000055   78..         MOV       R0,#?V6
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005A   E5..         MOV       A,?V1
   \   00005C   F5..         MOV       ?V3,A
   \   00005E   78..         MOV       R0,#?V3
   \   000060   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000063   E4           CLR       A
   \   000064   F5..         MOV       ?V6,A
   \   000066   F5..         MOV       ?V7,A
   \   000068   78..         MOV       R0,#?V6
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006D   E5..         MOV       A,?V0
   \   00006F   F5..         MOV       ?V3,A
   \   000071   78..         MOV       R0,#?V3
   \   000073   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000076   75..00       MOV       ?V3,#0x0
   \   000079   78..         MOV       R0,#?V3
   \   00007B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00007E   75..01       MOV       ?V3,#0x1
   \   000081   78..         MOV       R0,#?V3
   \   000083   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000086   75..00       MOV       ?V3,#0x0
   \   000089   78..         MOV       R0,#?V3
   \   00008B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008E   7C03         MOV       R4,#0x3
   \   000090   7D00         MOV       R5,#0x0
   \   000092   AA..         MOV       R2,?V4
   \   000094   AB..         MOV       R3,?V5
   \   000096   A9..         MOV       R1,?V2
   \   000098   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00009B   740B         MOV       A,#0xb
   \   00009D   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A0   7402         MOV       A,#0x2
   \   0000A2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A5   7F08         MOV       R7,#0x8
   \   0000A7   02....       LJMP      ?BANKED_LEAVE_XDATA
    269          }
    270          
    271          /*********************************************************************
    272           * @fn      zclGeneral_SendIdentifyEZModeInvoke
    273           *
    274           * @brief   Call to send out an Identify EZ-Mode Invoke Command
    275           *
    276           * @param   srcEP - Sending application's endpoint
    277           * @param   dstAddr - where you want the message to go
    278           * @param   action - describes the EZ-Mode action to be performed
    279           * @param   seqNum - identification number for the transaction
    280           *
    281           * @return  ZStatus_t
    282           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    283          ZStatus_t zclGeneral_SendIdentifyEZModeInvoke( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyEZModeInvoke:
    284                                                         uint8 action, uint8 disableDefaultRsp, uint8 seqNum )
    285          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V1,R1
   \   00000C   EA           MOV       A,R2
   \   00000D   FE           MOV       R6,A
   \   00000E   EB           MOV       A,R3
   \   00000F   FF           MOV       R7,A
   \   000010   8C..         MOV       ?V3,R4
   \   000012   8D..         MOV       ?V2,R5
   \   000014   740F         MOV       A,#0xf
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V0,A
    286            uint8 buf[1];
    287          
    288            buf[0] = action;
   \   00001C   E5..         MOV       A,?V3
   \   00001E   C0E0         PUSH      A
   \   000020   85..82       MOV       DPL,?XSP + 0
   \   000023   85..83       MOV       DPH,?XSP + 1
   \   000026   D0E0         POP       A
   \   000028   F0           MOVX      @DPTR,A
    289          
    290            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    291                                    COMMAND_IDENTIFY_EZMODE_INVOKE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    292                                    disableDefaultRsp, 0, seqNum, 1, buf );
   \   000029                ; Setup parameters for call to function zcl_SendCommand
   \   000029   A8..         MOV       R0,?XSP + 0
   \   00002B   A9..         MOV       R1,?XSP + 1
   \   00002D   88..         MOV       ?V4,R0
   \   00002F   89..         MOV       ?V5,R1
   \   000031   78..         MOV       R0,#?V4
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000036   75..01       MOV       ?V4,#0x1
   \   000039   75..00       MOV       ?V5,#0x0
   \   00003C   78..         MOV       R0,#?V4
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000041   E5..         MOV       A,?V0
   \   000043   F5..         MOV       ?V4,A
   \   000045   78..         MOV       R0,#?V4
   \   000047   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004A   E4           CLR       A
   \   00004B   F5..         MOV       ?V4,A
   \   00004D   F5..         MOV       ?V5,A
   \   00004F   78..         MOV       R0,#?V4
   \   000051   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000054   E5..         MOV       A,?V2
   \   000056   F5..         MOV       ?V4,A
   \   000058   78..         MOV       R0,#?V4
   \   00005A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005D   75..00       MOV       ?V4,#0x0
   \   000060   78..         MOV       R0,#?V4
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000065   75..01       MOV       ?V4,#0x1
   \   000068   78..         MOV       R0,#?V4
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006D   75..02       MOV       ?V4,#0x2
   \   000070   78..         MOV       R0,#?V4
   \   000072   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000075   7C03         MOV       R4,#0x3
   \   000077   7D00         MOV       R5,#0x0
   \   000079   EE           MOV       A,R6
   \   00007A   FA           MOV       R2,A
   \   00007B   EF           MOV       A,R7
   \   00007C   FB           MOV       R3,A
   \   00007D   A9..         MOV       R1,?V1
   \   00007F   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000082   740B         MOV       A,#0xb
   \   000084   12....       LCALL     ?DEALLOC_XSTACK8
   \   000087   7401         MOV       A,#0x1
   \   000089   12....       LCALL     ?DEALLOC_XSTACK8
   \   00008C   7F06         MOV       R7,#0x6
   \   00008E   02....       LJMP      ?BANKED_LEAVE_XDATA
    293          }
    294          
    295          /*********************************************************************
    296           * @fn      zclGeneral_SendIdentifyUpdateCommState
    297           *
    298           * @brief   Call to send out an Identify Update Commission State Command
    299           *
    300           * @param   srcEP - Sending application's endpoint
    301           * @param   dstAddr - where you want the message to go
    302           * @param   action - describes the EZ-Mode action to be performed
    303           * @param   commissionStateMask - updates the device's commission state
    304           * @param   seqNum - identification number for the transaction
    305           *
    306           * @return  ZStatus_t
    307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    308          ZStatus_t zclGeneral_SendIdentifyUpdateCommState( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyUpdateCommState:
    309                                                            uint8 action, uint8 commissionStateMask,
    310                                                            uint8 disableDefaultRsp, uint8 seqNum )
    311          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   8C..         MOV       ?V1,R4
   \   000012   8D..         MOV       ?V2,R5
   \   000014   7412         MOV       A,#0x12
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   FE           MOV       R6,A
   \   00001B   7413         MOV       A,#0x13
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   FF           MOV       R7,A
    312            uint8 buf[2];
    313          
    314            buf[0] = action;
   \   000022   E5..         MOV       A,?V1
   \   000024   C0E0         PUSH      A
   \   000026   85..82       MOV       DPL,?XSP + 0
   \   000029   85..83       MOV       DPH,?XSP + 1
   \   00002C   D0E0         POP       A
   \   00002E   F0           MOVX      @DPTR,A
    315            buf[1] = commissionStateMask;
   \   00002F   E5..         MOV       A,?V2
   \   000031   C0E0         PUSH      A
   \   000033   7401         MOV       A,#0x1
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   D0E0         POP       A
   \   00003A   F0           MOVX      @DPTR,A
    316          
    317            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    318                                    COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    319                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \   00003B                ; Setup parameters for call to function zcl_SendCommand
   \   00003B   A8..         MOV       R0,?XSP + 0
   \   00003D   A9..         MOV       R1,?XSP + 1
   \   00003F   88..         MOV       ?V6,R0
   \   000041   89..         MOV       ?V7,R1
   \   000043   78..         MOV       R0,#?V6
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000048   75..02       MOV       ?V6,#0x2
   \   00004B   75..00       MOV       ?V7,#0x0
   \   00004E   78..         MOV       R0,#?V6
   \   000050   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000053   EF           MOV       A,R7
   \   000054   F5..         MOV       ?V3,A
   \   000056   78..         MOV       R0,#?V3
   \   000058   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005B   E4           CLR       A
   \   00005C   F5..         MOV       ?V6,A
   \   00005E   F5..         MOV       ?V7,A
   \   000060   78..         MOV       R0,#?V6
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000065   EE           MOV       A,R6
   \   000066   F5..         MOV       ?V3,A
   \   000068   78..         MOV       R0,#?V3
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006D   75..00       MOV       ?V3,#0x0
   \   000070   78..         MOV       R0,#?V3
   \   000072   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000075   75..01       MOV       ?V3,#0x1
   \   000078   78..         MOV       R0,#?V3
   \   00007A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00007D   75..03       MOV       ?V3,#0x3
   \   000080   78..         MOV       R0,#?V3
   \   000082   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000085   7C03         MOV       R4,#0x3
   \   000087   7D00         MOV       R5,#0x0
   \   000089   AA..         MOV       R2,?V4
   \   00008B   AB..         MOV       R3,?V5
   \   00008D   A9..         MOV       R1,?V0
   \   00008F   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000092   740B         MOV       A,#0xb
   \   000094   12....       LCALL     ?DEALLOC_XSTACK8
   \   000097   7402         MOV       A,#0x2
   \   000099   12....       LCALL     ?DEALLOC_XSTACK8
   \   00009C   7F08         MOV       R7,#0x8
   \   00009E   02....       LJMP      ?BANKED_LEAVE_XDATA
    320          }
    321          
    322          #ifdef ZCL_LIGHT_LINK_ENHANCE
    323          /*********************************************************************
    324           * @fn      zclGeneral_SendIdentifyTriggerEffect
    325           *
    326           * @brief   Call to send out a Trigger Effect Command
    327           *
    328           * @param   srcEP - Sending application's endpoint
    329           * @param   dstAddr - where you want the message to go
    330           * @param   effectId - identify effect to use
    331           * @param   effectVariant - which variant of effect to be triggered
    332           * @param   disableDefaultRsp - whether to disable the Default Response command
    333           * @param   seqNum - identification number for the transaction
    334           *
    335           * @return  ZStatus_t
    336           */
    337          ZStatus_t zclGeneral_SendIdentifyTriggerEffect( uint8 srcEP, afAddrType_t *dstAddr,
    338                                                          uint8 effectId, uint8 effectVariant,
    339                                                          uint8 disableDefaultRsp, uint8 seqNum )
    340          {
    341            uint8 buf[2];
    342          
    343            buf[0] = effectId;
    344            buf[1] = effectVariant;
    345          
    346            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    347                                    COMMAND_IDENTIFY_TRIGGER_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    348                                    disableDefaultRsp, 0, seqNum, 2, buf );
    349          }
    350          #endif // ZCL_LIGHT_LINK_ENHANCE
    351          
    352          /*********************************************************************
    353           * @fn      zclGeneral_SendIdentifyQueryResponse
    354           *
    355           * @brief   Call to send out an Identify Query Response Command
    356           *
    357           * @param   srcEP - Sending application's endpoint
    358           * @param   dstAddr - where you want the message to go
    359           * @param   timeout - how long the device will continue to identify itself (in seconds)
    360           * @param   seqNum - identification number for the transaction
    361           *
    362           * @return  ZStatus_t
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    365                                                          uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    366          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V2,R1
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   EC           MOV       A,R4
   \   000011   FE           MOV       R6,A
   \   000012   ED           MOV       A,R5
   \   000013   FF           MOV       R7,A
   \   000014   7412         MOV       A,#0x12
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V0,A
   \   00001C   7413         MOV       A,#0x13
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F5..         MOV       ?V1,A
    367            uint8 buf[2];
    368          
    369            buf[0] = LO_UINT16( timeout );
   \   000024   EE           MOV       A,R6
   \   000025   C0E0         PUSH      A
   \   000027   85..82       MOV       DPL,?XSP + 0
   \   00002A   85..83       MOV       DPH,?XSP + 1
   \   00002D   D0E0         POP       A
   \   00002F   F0           MOVX      @DPTR,A
    370            buf[1] = HI_UINT16( timeout );
   \   000030   EE           MOV       A,R6
   \   000031   F8           MOV       R0,A
   \   000032   EF           MOV       A,R7
   \   000033   F9           MOV       R1,A
   \   000034   E4           CLR       A
   \   000035   C9           XCH       A,R1
   \   000036   F8           MOV       R0,A
   \   000037   E8           MOV       A,R0
   \   000038   C0E0         PUSH      A
   \   00003A   7401         MOV       A,#0x1
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   D0E0         POP       A
   \   000041   F0           MOVX      @DPTR,A
    371          
    372            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    373                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    374                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \   000042                ; Setup parameters for call to function zcl_SendCommand
   \   000042   A8..         MOV       R0,?XSP + 0
   \   000044   A9..         MOV       R1,?XSP + 1
   \   000046   88..         MOV       ?V6,R0
   \   000048   89..         MOV       ?V7,R1
   \   00004A   78..         MOV       R0,#?V6
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004F   75..02       MOV       ?V6,#0x2
   \   000052   75..00       MOV       ?V7,#0x0
   \   000055   78..         MOV       R0,#?V6
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005A   E5..         MOV       A,?V1
   \   00005C   F5..         MOV       ?V3,A
   \   00005E   78..         MOV       R0,#?V3
   \   000060   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000063   E4           CLR       A
   \   000064   F5..         MOV       ?V6,A
   \   000066   F5..         MOV       ?V7,A
   \   000068   78..         MOV       R0,#?V6
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006D   E5..         MOV       A,?V0
   \   00006F   F5..         MOV       ?V3,A
   \   000071   78..         MOV       R0,#?V3
   \   000073   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000076   75..01       MOV       ?V3,#0x1
   \   000079   78..         MOV       R0,#?V3
   \   00007B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00007E   75..01       MOV       ?V3,#0x1
   \   000081   78..         MOV       R0,#?V3
   \   000083   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000086   75..00       MOV       ?V3,#0x0
   \   000089   78..         MOV       R0,#?V3
   \   00008B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008E   7C03         MOV       R4,#0x3
   \   000090   7D00         MOV       R5,#0x0
   \   000092   AA..         MOV       R2,?V4
   \   000094   AB..         MOV       R3,?V5
   \   000096   A9..         MOV       R1,?V2
   \   000098   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00009B   740B         MOV       A,#0xb
   \   00009D   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A0   7402         MOV       A,#0x2
   \   0000A2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A5   7F08         MOV       R7,#0x8
   \   0000A7   02....       LJMP      ?BANKED_LEAVE_XDATA
    375          }
    376          #endif // ZCL_IDENTIFY
    377          
    378          #ifdef ZCL_GROUPS
    379          /*********************************************************************
    380           * @fn      zclGeneral_SendGroupRequest
    381           *
    382           * @brief   Send a Group Request to a device.  You can also use the
    383           *          appropriate macro.
    384           *
    385           * @param   srcEP - Sending Apps endpoint
    386           * @param   dstAddr - where to send the request
    387           * @param   cmd - one of the following:
    388           *              COMMAND_GROUP_VIEW
    389           *              COMMAND_GROUP_REMOVE
    390           * @param   groupID -
    391           *
    392           * @return  ZStatus_t
    393           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    394          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupRequest:
    395                                                 uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    396          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V2,R1
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   8C..         MOV       ?V3,R4
   \   000012   8D..         MOV       ?V1,R5
   \   000014   7412         MOV       A,#0x12
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   FE           MOV       R6,A
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   FF           MOV       R7,A
   \   00001E   7414         MOV       A,#0x14
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F5..         MOV       ?V0,A
    397            uint8 buf[2];
    398          
    399            buf[0] = LO_UINT16( groupID );
   \   000026   EE           MOV       A,R6
   \   000027   C0E0         PUSH      A
   \   000029   85..82       MOV       DPL,?XSP + 0
   \   00002C   85..83       MOV       DPH,?XSP + 1
   \   00002F   D0E0         POP       A
   \   000031   F0           MOVX      @DPTR,A
    400            buf[1] = HI_UINT16( groupID );
   \   000032   EE           MOV       A,R6
   \   000033   F8           MOV       R0,A
   \   000034   EF           MOV       A,R7
   \   000035   F9           MOV       R1,A
   \   000036   E4           CLR       A
   \   000037   C9           XCH       A,R1
   \   000038   F8           MOV       R0,A
   \   000039   E8           MOV       A,R0
   \   00003A   C0E0         PUSH      A
   \   00003C   7401         MOV       A,#0x1
   \   00003E   12....       LCALL     ?XSTACK_DISP0_8
   \   000041   D0E0         POP       A
   \   000043   F0           MOVX      @DPTR,A
    401          
    402            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    403                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    404                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
   \   000044                ; Setup parameters for call to function zcl_SendCommand
   \   000044   A8..         MOV       R0,?XSP + 0
   \   000046   A9..         MOV       R1,?XSP + 1
   \   000048   88..         MOV       ?V6,R0
   \   00004A   89..         MOV       ?V7,R1
   \   00004C   78..         MOV       R0,#?V6
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   75..02       MOV       ?V6,#0x2
   \   000054   75..00       MOV       ?V7,#0x0
   \   000057   78..         MOV       R0,#?V6
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005C   E5..         MOV       A,?V0
   \   00005E   F5..         MOV       ?V6,A
   \   000060   78..         MOV       R0,#?V6
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000065   E4           CLR       A
   \   000066   F5..         MOV       ?V6,A
   \   000068   F5..         MOV       ?V7,A
   \   00006A   78..         MOV       R0,#?V6
   \   00006C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006F   E5..         MOV       A,?V1
   \   000071   F5..         MOV       ?V6,A
   \   000073   78..         MOV       R0,#?V6
   \   000075   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000078   75..00       MOV       ?V6,#0x0
   \   00007B   78..         MOV       R0,#?V6
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000080   75..01       MOV       ?V6,#0x1
   \   000083   78..         MOV       R0,#?V6
   \   000085   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000088   E5..         MOV       A,?V3
   \   00008A   F5..         MOV       ?V6,A
   \   00008C   78..         MOV       R0,#?V6
   \   00008E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000091   7C04         MOV       R4,#0x4
   \   000093   7D00         MOV       R5,#0x0
   \   000095   AA..         MOV       R2,?V4
   \   000097   AB..         MOV       R3,?V5
   \   000099   A9..         MOV       R1,?V2
   \   00009B   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00009E   740B         MOV       A,#0xb
   \   0000A0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A3   7402         MOV       A,#0x2
   \   0000A5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A8   7F08         MOV       R7,#0x8
   \   0000AA   02....       LJMP      ?BANKED_LEAVE_XDATA
    405          }
    406          
    407          /*********************************************************************
    408           * @fn      zclGeneral_SendAddGroupRequest
    409           *
    410           * @brief   Send the Add Group Request to a device
    411           *
    412           * @param   srcEP - Sending Apps endpoint
    413           * @param   dstAddr - where to send the request
    414           * @param   cmd - one of the following:
    415           *                COMMAND_GROUP_ADD
    416           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    417           * @param   groupID - pointer to the group structure
    418           * @param   groupName - pointer to Group Name.  This is a Zigbee
    419           *          string data type, so the first byte is the length of the
    420           *          name (in bytes), then the name.
    421           *
    422           * @return  ZStatus_t
    423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    424          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendAddGroupRequest:
    425                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    426                                                    uint8 disableDefaultRsp, uint8 seqNum )
    427          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000   74E9         MOV       A,#-0x17
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 23
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   89..         MOV       ?V7,R1
   \   000017   8C..         MOV       ?V14,R4
   \   000019   8D..         MOV       ?V13,R5
   \   00001B   7419         MOV       A,#0x19
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V0,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F5..         MOV       ?V1,A
   \   000027   741B         MOV       A,#0x1b
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F5..         MOV       ?V10,A
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F5..         MOV       ?V11,A
   \   000033   741D         MOV       A,#0x1d
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F5..         MOV       ?V12,A
    428            uint8 *buf;
    429            uint8 *pBuf;
    430            uint8 len;
    431            ZStatus_t status;
    432          
    433            len = 2;    // Group ID
   \   00003B   75..02       MOV       ?V3,#0x2
    434            len += groupName[0] + 1;  // String + 1 for length
   \   00003E   85..82       MOV       DPL,?V10
   \   000041   85..83       MOV       DPH,?V11
   \   000044   E0           MOVX      A,@DPTR
   \   000045   2401         ADD       A,#0x1
   \   000047   25..         ADD       A,?V3
   \   000049   F5..         MOV       ?V3,A
    435          
    436            buf = zcl_mem_alloc( len );
   \   00004B                ; Setup parameters for call to function osal_mem_alloc
   \   00004B   E5..         MOV       A,?V3
   \   00004D   FA           MOV       R2,A
   \   00004E   7B00         MOV       R3,#0x0
   \   000050   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000053   8A..         MOV       ?V4,R2
   \   000055   8B..         MOV       ?V5,R3
   \   000057   85....       MOV       ?V8,?V4
   \   00005A   85....       MOV       ?V9,?V5
    437            if ( buf )
   \   00005D   E5..         MOV       A,?V8
   \   00005F   45..         ORL       A,?V9
   \   000061   7003         JNZ       $+5
   \   000063   02....       LJMP      ??zclGeneral_SendAddGroupRequest_0 & 0xFFFF
    438            {
    439              pBuf = buf;
   \   000066   AE..         MOV       R6,?V8
   \   000068   AF..         MOV       R7,?V9
    440              *pBuf++ = LO_UINT16( groupID );
   \   00006A   E5..         MOV       A,?V0
   \   00006C   C0E0         PUSH      A
   \   00006E   8E82         MOV       DPL,R6
   \   000070   8F83         MOV       DPH,R7
   \   000072   D0E0         POP       A
   \   000074   F0           MOVX      @DPTR,A
   \   000075   8E82         MOV       DPL,R6
   \   000077   8F83         MOV       DPH,R7
   \   000079   A3           INC       DPTR
   \   00007A   AE82         MOV       R6,DPL
   \   00007C   AF83         MOV       R7,DPH
    441              *pBuf++ = HI_UINT16( groupID );
   \   00007E   A8..         MOV       R0,?V0
   \   000080   A9..         MOV       R1,?V1
   \   000082   E4           CLR       A
   \   000083   C9           XCH       A,R1
   \   000084   F8           MOV       R0,A
   \   000085   E8           MOV       A,R0
   \   000086   C0E0         PUSH      A
   \   000088   8E82         MOV       DPL,R6
   \   00008A   8F83         MOV       DPH,R7
   \   00008C   D0E0         POP       A
   \   00008E   F0           MOVX      @DPTR,A
   \   00008F   8E82         MOV       DPL,R6
   \   000091   8F83         MOV       DPH,R7
   \   000093   A3           INC       DPTR
   \   000094   AE82         MOV       R6,DPL
   \   000096   AF83         MOV       R7,DPH
    442              *pBuf++ = groupName[0]; // string length
   \   000098   85..82       MOV       DPL,?V10
   \   00009B   85..83       MOV       DPH,?V11
   \   00009E   E0           MOVX      A,@DPTR
   \   00009F   C0E0         PUSH      A
   \   0000A1   8E82         MOV       DPL,R6
   \   0000A3   8F83         MOV       DPH,R7
   \   0000A5   D0E0         POP       A
   \   0000A7   F0           MOVX      @DPTR,A
   \   0000A8   8E82         MOV       DPL,R6
   \   0000AA   8F83         MOV       DPH,R7
   \   0000AC   A3           INC       DPTR
   \   0000AD   AE82         MOV       R6,DPL
   \   0000AF   AF83         MOV       R7,DPH
    443              zcl_memcpy( pBuf, &(groupName[1]), groupName[0] );
   \   0000B1                ; Setup parameters for call to function osal_memcpy
   \   0000B1   85..82       MOV       DPL,?V10
   \   0000B4   85..83       MOV       DPH,?V11
   \   0000B7   A3           INC       DPTR
   \   0000B8   A982         MOV       R1,DPL
   \   0000BA   AA83         MOV       R2,DPH
   \   0000BC   7B00         MOV       R3,#0x0
   \   0000BE   89..         MOV       ?V4,R1
   \   0000C0   8A..         MOV       ?V5,R2
   \   0000C2   8B..         MOV       ?V6,R3
   \   0000C4   78..         MOV       R0,#?V4
   \   0000C6   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000C9   85..82       MOV       DPL,?V10
   \   0000CC   85..83       MOV       DPH,?V11
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   FC           MOV       R4,A
   \   0000D1   7D00         MOV       R5,#0x0
   \   0000D3   EE           MOV       A,R6
   \   0000D4   FA           MOV       R2,A
   \   0000D5   EF           MOV       A,R7
   \   0000D6   FB           MOV       R3,A
   \   0000D7   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000DA   7403         MOV       A,#0x3
   \   0000DC   12....       LCALL     ?DEALLOC_XSTACK8
    444          
    445              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    446                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    447                                        disableDefaultRsp, 0, seqNum, len, buf );
   \   0000DF                ; Setup parameters for call to function zcl_SendCommand
   \   0000DF   78..         MOV       R0,#?V8
   \   0000E1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000E4   E5..         MOV       A,?V3
   \   0000E6   F5..         MOV       ?V4,A
   \   0000E8   75..00       MOV       ?V5,#0x0
   \   0000EB   78..         MOV       R0,#?V4
   \   0000ED   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000F0   E5..         MOV       A,?V12
   \   0000F2   F5..         MOV       ?V4,A
   \   0000F4   78..         MOV       R0,#?V4
   \   0000F6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000F9   E4           CLR       A
   \   0000FA   F5..         MOV       ?V4,A
   \   0000FC   F5..         MOV       ?V5,A
   \   0000FE   78..         MOV       R0,#?V4
   \   000100   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000103   E5..         MOV       A,?V13
   \   000105   F5..         MOV       ?V4,A
   \   000107   78..         MOV       R0,#?V4
   \   000109   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00010C   75..00       MOV       ?V4,#0x0
   \   00010F   78..         MOV       R0,#?V4
   \   000111   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000114   75..01       MOV       ?V4,#0x1
   \   000117   78..         MOV       R0,#?V4
   \   000119   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00011C   E5..         MOV       A,?V14
   \   00011E   F5..         MOV       ?V4,A
   \   000120   78..         MOV       R0,#?V4
   \   000122   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000125   7C04         MOV       R4,#0x4
   \   000127   7D00         MOV       R5,#0x0
   \   000129   740B         MOV       A,#0xb
   \   00012B   12....       LCALL     ?XSTACK_DISP0_8
   \   00012E   E0           MOVX      A,@DPTR
   \   00012F   FA           MOV       R2,A
   \   000130   A3           INC       DPTR
   \   000131   E0           MOVX      A,@DPTR
   \   000132   FB           MOV       R3,A
   \   000133   A9..         MOV       R1,?V7
   \   000135   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000138   740B         MOV       A,#0xb
   \   00013A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00013D   E9           MOV       A,R1
   \   00013E   F5..         MOV       ?V2,A
    448              zcl_mem_free( buf );
   \   000140                ; Setup parameters for call to function osal_mem_free
   \   000140   AA..         MOV       R2,?V8
   \   000142   AB..         MOV       R3,?V9
   \   000144   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000147   8003         SJMP      ??zclGeneral_SendAddGroupRequest_1
    449            }
    450            else
    451              status = ZMemError;
   \                     ??zclGeneral_SendAddGroupRequest_0:
   \   000149   75..10       MOV       ?V2,#0x10
    452          
    453            return ( status );
   \                     ??zclGeneral_SendAddGroupRequest_1:
   \   00014C   A9..         MOV       R1,?V2
   \   00014E   7402         MOV       A,#0x2
   \   000150   12....       LCALL     ?DEALLOC_XSTACK8
   \   000153   7F0F         MOV       R7,#0xf
   \   000155   02....       LJMP      ?BANKED_LEAVE_XDATA
    454          }
    455          
    456          /*********************************************************************
    457           * @fn      zclGeneral_SendGroupGetMembershipRequest
    458           *
    459           * @brief   Send a Get Group Membership (Resposne) Command to a device
    460           *
    461           * @param   srcEP - Sending Apps endpoint
    462           * @param   dstAddr - where to send the request
    463           * @param   cmd - one of the following:
    464           *                COMMAND_GROUP_GET_MEMBERSHIP
    465           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    466           * @param   groupID - pointer to the group structure
    467           * @param   groupName - pointer to Group Name.  This is a Zigbee
    468           *          string data type, so the first byte is the length of the
    469           *          name (in bytes), then the name.
    470           *
    471           * @return  ZStatus_t
    472           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    473          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupGetMembershipRequest:
    474                                                              uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    475                                                              uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    476          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000   74E9         MOV       A,#-0x17
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 23
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   89..         MOV       ?V10,R1
   \   000017   8C..         MOV       ?V14,R4
   \   000019   8D..         MOV       ?V6,R5
   \   00001B   7419         MOV       A,#0x19
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V13,A
   \   000023   741A         MOV       A,#0x1a
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F5..         MOV       ?V7,A
   \   00002B   741B         MOV       A,#0x1b
   \   00002D   12....       LCALL     ?XSTACK_DISP0_8
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F5..         MOV       ?V3,A
   \   000033   741E         MOV       A,#0x1e
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F5..         MOV       ?V12,A
   \   00003B   741F         MOV       A,#0x1f
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   E0           MOVX      A,@DPTR
   \   000041   F5..         MOV       ?V11,A
    477            uint8 *buf;
    478            uint8 *pBuf;
    479            uint8 len = 0;
   \   000043   75..00       MOV       ?V1,#0x0
    480            uint8 i;
    481            ZStatus_t status;
    482          
    483            if ( rspCmd )
   \   000046   E5..         MOV       A,?V6
   \   000048   6002         JZ        ??zclGeneral_SendGroupGetMembershipRequest_0
    484              len++;  // Capacity
   \   00004A   05..         INC       ?V1
    485          
    486            len++;  // Group Count
   \                     ??zclGeneral_SendGroupGetMembershipRequest_0:
   \   00004C   05..         INC       ?V1
    487            len += sizeof ( uint16 ) * grpCnt;  // Group List
   \   00004E   75F002       MOV       B,#0x2
   \   000051   E5..         MOV       A,?V3
   \   000053   A4           MUL       AB
   \   000054   25..         ADD       A,?V1
   \   000056   F5..         MOV       ?V1,A
    488          
    489            buf = zcl_mem_alloc( len );
   \   000058                ; Setup parameters for call to function osal_mem_alloc
   \   000058   E5..         MOV       A,?V1
   \   00005A   FA           MOV       R2,A
   \   00005B   7B00         MOV       R3,#0x0
   \   00005D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000060   8A..         MOV       ?V8,R2
   \   000062   8B..         MOV       ?V9,R3
   \   000064   85....       MOV       ?V4,?V8
   \   000067   85....       MOV       ?V5,?V9
    490            if ( buf )
   \   00006A   E5..         MOV       A,?V4
   \   00006C   45..         ORL       A,?V5
   \   00006E   7003         JNZ       $+5
   \   000070   02....       LJMP      ??zclGeneral_SendGroupGetMembershipRequest_1 & 0xFFFF
    491            {
    492              pBuf = buf;
   \   000073   AE..         MOV       R6,?V4
   \   000075   AF..         MOV       R7,?V5
    493              if ( rspCmd )
   \   000077   E5..         MOV       A,?V6
   \   000079   6014         JZ        ??zclGeneral_SendGroupGetMembershipRequest_2
    494                *pBuf++ = capacity;
   \   00007B   E5..         MOV       A,?V7
   \   00007D   C0E0         PUSH      A
   \   00007F   8E82         MOV       DPL,R6
   \   000081   8F83         MOV       DPH,R7
   \   000083   D0E0         POP       A
   \   000085   F0           MOVX      @DPTR,A
   \   000086   8E82         MOV       DPL,R6
   \   000088   8F83         MOV       DPH,R7
   \   00008A   A3           INC       DPTR
   \   00008B   AE82         MOV       R6,DPL
   \   00008D   AF83         MOV       R7,DPH
    495          
    496              *pBuf++ = grpCnt;
   \                     ??zclGeneral_SendGroupGetMembershipRequest_2:
   \   00008F   E5..         MOV       A,?V3
   \   000091   C0E0         PUSH      A
   \   000093   8E82         MOV       DPL,R6
   \   000095   8F83         MOV       DPH,R7
   \   000097   D0E0         POP       A
   \   000099   F0           MOVX      @DPTR,A
   \   00009A   8E82         MOV       DPL,R6
   \   00009C   8F83         MOV       DPH,R7
   \   00009E   A3           INC       DPTR
   \   00009F   AE82         MOV       R6,DPL
   \   0000A1   AF83         MOV       R7,DPH
    497              for ( i = 0; i < grpCnt; i++ )
   \   0000A3   75..00       MOV       ?V2,#0x0
   \                     ??zclGeneral_SendGroupGetMembershipRequest_3:
   \   0000A6   E5..         MOV       A,?V2
   \   0000A8   C3           CLR       C
   \   0000A9   95..         SUBB      A,?V3
   \   0000AB   4003         JC        $+5
   \   0000AD   02....       LJMP      ??zclGeneral_SendGroupGetMembershipRequest_4 & 0xFFFF
    498              {
    499                *pBuf++ = LO_UINT16( grpList[i] );
   \   0000B0   E5..         MOV       A,?V2
   \   0000B2   F8           MOV       R0,A
   \   0000B3   7900         MOV       R1,#0x0
   \   0000B5   E8           MOV       A,R0
   \   0000B6   75F002       MOV       B,#0x2
   \   0000B9   A4           MUL       AB
   \   0000BA   C8           XCH       A,R0
   \   0000BB   AAF0         MOV       R2,B
   \   0000BD   75F000       MOV       B,#0x0
   \   0000C0   A4           MUL       AB
   \   0000C1   2A           ADD       A,R2
   \   0000C2   FA           MOV       R2,A
   \   0000C3   75F002       MOV       B,#0x2
   \   0000C6   E9           MOV       A,R1
   \   0000C7   A4           MUL       AB
   \   0000C8   2A           ADD       A,R2
   \   0000C9   F9           MOV       R1,A
   \   0000CA   741C         MOV       A,#0x1c
   \   0000CC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   28           ADD       A,R0
   \   0000D1   FA           MOV       R2,A
   \   0000D2   A3           INC       DPTR
   \   0000D3   E0           MOVX      A,@DPTR
   \   0000D4   39           ADDC      A,R1
   \   0000D5   8A82         MOV       DPL,R2
   \   0000D7   F583         MOV       DPH,A
   \   0000D9   E0           MOVX      A,@DPTR
   \   0000DA   F8           MOV       R0,A
   \   0000DB   A3           INC       DPTR
   \   0000DC   E0           MOVX      A,@DPTR
   \   0000DD   F9           MOV       R1,A
   \   0000DE   E8           MOV       A,R0
   \   0000DF   C0E0         PUSH      A
   \   0000E1   8E82         MOV       DPL,R6
   \   0000E3   8F83         MOV       DPH,R7
   \   0000E5   D0E0         POP       A
   \   0000E7   F0           MOVX      @DPTR,A
   \   0000E8   8E82         MOV       DPL,R6
   \   0000EA   8F83         MOV       DPH,R7
   \   0000EC   A3           INC       DPTR
   \   0000ED   AE82         MOV       R6,DPL
   \   0000EF   AF83         MOV       R7,DPH
    500                *pBuf++ = HI_UINT16( grpList[i] );
   \   0000F1   E5..         MOV       A,?V2
   \   0000F3   F8           MOV       R0,A
   \   0000F4   7900         MOV       R1,#0x0
   \   0000F6   E8           MOV       A,R0
   \   0000F7   75F002       MOV       B,#0x2
   \   0000FA   A4           MUL       AB
   \   0000FB   C8           XCH       A,R0
   \   0000FC   AAF0         MOV       R2,B
   \   0000FE   75F000       MOV       B,#0x0
   \   000101   A4           MUL       AB
   \   000102   2A           ADD       A,R2
   \   000103   FA           MOV       R2,A
   \   000104   75F002       MOV       B,#0x2
   \   000107   E9           MOV       A,R1
   \   000108   A4           MUL       AB
   \   000109   2A           ADD       A,R2
   \   00010A   F9           MOV       R1,A
   \   00010B   741C         MOV       A,#0x1c
   \   00010D   12....       LCALL     ?XSTACK_DISP0_8
   \   000110   E0           MOVX      A,@DPTR
   \   000111   28           ADD       A,R0
   \   000112   FA           MOV       R2,A
   \   000113   A3           INC       DPTR
   \   000114   E0           MOVX      A,@DPTR
   \   000115   39           ADDC      A,R1
   \   000116   8A82         MOV       DPL,R2
   \   000118   F583         MOV       DPH,A
   \   00011A   E0           MOVX      A,@DPTR
   \   00011B   F8           MOV       R0,A
   \   00011C   A3           INC       DPTR
   \   00011D   E0           MOVX      A,@DPTR
   \   00011E   F9           MOV       R1,A
   \   00011F   E4           CLR       A
   \   000120   C9           XCH       A,R1
   \   000121   F8           MOV       R0,A
   \   000122   E8           MOV       A,R0
   \   000123   C0E0         PUSH      A
   \   000125   8E82         MOV       DPL,R6
   \   000127   8F83         MOV       DPH,R7
   \   000129   D0E0         POP       A
   \   00012B   F0           MOVX      @DPTR,A
   \   00012C   8E82         MOV       DPL,R6
   \   00012E   8F83         MOV       DPH,R7
   \   000130   A3           INC       DPTR
   \   000131   AE82         MOV       R6,DPL
   \   000133   AF83         MOV       R7,DPH
    501              }
   \   000135   05..         INC       ?V2
   \   000137   02....       LJMP      ??zclGeneral_SendGroupGetMembershipRequest_3 & 0xFFFF
    502          
    503              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    504                                        cmd, TRUE, direction,
    505                                        disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zclGeneral_SendGroupGetMembershipRequest_4:
   \   00013A                ; Setup parameters for call to function zcl_SendCommand
   \   00013A   78..         MOV       R0,#?V4
   \   00013C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00013F   E5..         MOV       A,?V1
   \   000141   F5..         MOV       ?V8,A
   \   000143   75..00       MOV       ?V9,#0x0
   \   000146   78..         MOV       R0,#?V8
   \   000148   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00014B   E5..         MOV       A,?V11
   \   00014D   F5..         MOV       ?V8,A
   \   00014F   78..         MOV       R0,#?V8
   \   000151   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000154   E4           CLR       A
   \   000155   F5..         MOV       ?V8,A
   \   000157   F5..         MOV       ?V9,A
   \   000159   78..         MOV       R0,#?V8
   \   00015B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00015E   E5..         MOV       A,?V12
   \   000160   F5..         MOV       ?V8,A
   \   000162   78..         MOV       R0,#?V8
   \   000164   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000167   E5..         MOV       A,?V13
   \   000169   F5..         MOV       ?V8,A
   \   00016B   78..         MOV       R0,#?V8
   \   00016D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000170   75..01       MOV       ?V8,#0x1
   \   000173   78..         MOV       R0,#?V8
   \   000175   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000178   E5..         MOV       A,?V14
   \   00017A   F5..         MOV       ?V8,A
   \   00017C   78..         MOV       R0,#?V8
   \   00017E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000181   7C04         MOV       R4,#0x4
   \   000183   7D00         MOV       R5,#0x0
   \   000185   740B         MOV       A,#0xb
   \   000187   12....       LCALL     ?XSTACK_DISP0_8
   \   00018A   E0           MOVX      A,@DPTR
   \   00018B   FA           MOV       R2,A
   \   00018C   A3           INC       DPTR
   \   00018D   E0           MOVX      A,@DPTR
   \   00018E   FB           MOV       R3,A
   \   00018F   A9..         MOV       R1,?V10
   \   000191   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000194   740B         MOV       A,#0xb
   \   000196   12....       LCALL     ?DEALLOC_XSTACK8
   \   000199   E9           MOV       A,R1
   \   00019A   F5..         MOV       ?V0,A
    506              zcl_mem_free( buf );
   \   00019C                ; Setup parameters for call to function osal_mem_free
   \   00019C   AA..         MOV       R2,?V4
   \   00019E   AB..         MOV       R3,?V5
   \   0001A0   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001A3   8003         SJMP      ??zclGeneral_SendGroupGetMembershipRequest_5
    507            }
    508            else
    509              status = ZMemError;
   \                     ??zclGeneral_SendGroupGetMembershipRequest_1:
   \   0001A5   75..10       MOV       ?V0,#0x10
    510          
    511            return ( status );
   \                     ??zclGeneral_SendGroupGetMembershipRequest_5:
   \   0001A8   A9..         MOV       R1,?V0
   \   0001AA   7402         MOV       A,#0x2
   \   0001AC   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001AF   7F0F         MOV       R7,#0xf
   \   0001B1   02....       LJMP      ?BANKED_LEAVE_XDATA
    512          }
    513          
    514          /*********************************************************************
    515           * @fn      zclGeneral_SendGroupResponse
    516           *
    517           * @brief   Send Group Response (not Group View Response)
    518           *
    519           * @param   srcEP - Sending application's endpoint
    520           * @param   dstAddr - where you want the message to go
    521           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    522           * @param   status - group command status
    523           * @param   groupID - what group
    524           *
    525           * @return  ZStatus_t
    526           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    527          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupResponse:
    528                                                  uint8 cmd, uint8 status, uint16 groupID,
    529                                                  uint8 disableDefaultRsp, uint8 seqNum )
    530          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
   \   00000C   8A..         MOV       ?V6,R2
   \   00000E   8B..         MOV       ?V7,R3
   \   000010   8C..         MOV       ?V4,R4
   \   000012   8D..         MOV       ?V1,R5
   \   000014   7415         MOV       A,#0x15
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   FE           MOV       R6,A
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   FF           MOV       R7,A
   \   00001E   7417         MOV       A,#0x17
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F5..         MOV       ?V3,A
   \   000026   7418         MOV       A,#0x18
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   F5..         MOV       ?V2,A
    531            uint8 buf[3];
    532          
    533            buf[0] = status;
   \   00002E   E5..         MOV       A,?V1
   \   000030   C0E0         PUSH      A
   \   000032   85..82       MOV       DPL,?XSP + 0
   \   000035   85..83       MOV       DPH,?XSP + 1
   \   000038   D0E0         POP       A
   \   00003A   F0           MOVX      @DPTR,A
    534            buf[1] = LO_UINT16( groupID );
   \   00003B   EE           MOV       A,R6
   \   00003C   C0E0         PUSH      A
   \   00003E   7401         MOV       A,#0x1
   \   000040   12....       LCALL     ?XSTACK_DISP0_8
   \   000043   D0E0         POP       A
   \   000045   F0           MOVX      @DPTR,A
    535            buf[2] = HI_UINT16( groupID );
   \   000046   EE           MOV       A,R6
   \   000047   F8           MOV       R0,A
   \   000048   EF           MOV       A,R7
   \   000049   F9           MOV       R1,A
   \   00004A   E4           CLR       A
   \   00004B   C9           XCH       A,R1
   \   00004C   F8           MOV       R0,A
   \   00004D   E8           MOV       A,R0
   \   00004E   C0E0         PUSH      A
   \   000050   7402         MOV       A,#0x2
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   D0E0         POP       A
   \   000057   F0           MOVX      @DPTR,A
    536          
    537            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    538                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    539                                    disableDefaultRsp, 0, seqNum, 3, buf );
   \   000058                ; Setup parameters for call to function zcl_SendCommand
   \   000058   A8..         MOV       R0,?XSP + 0
   \   00005A   A9..         MOV       R1,?XSP + 1
   \   00005C   88..         MOV       ?V8,R0
   \   00005E   89..         MOV       ?V9,R1
   \   000060   78..         MOV       R0,#?V8
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000065   75..03       MOV       ?V8,#0x3
   \   000068   75..00       MOV       ?V9,#0x0
   \   00006B   78..         MOV       R0,#?V8
   \   00006D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000070   E5..         MOV       A,?V2
   \   000072   F5..         MOV       ?V5,A
   \   000074   78..         MOV       R0,#?V5
   \   000076   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000079   E4           CLR       A
   \   00007A   F5..         MOV       ?V8,A
   \   00007C   F5..         MOV       ?V9,A
   \   00007E   78..         MOV       R0,#?V8
   \   000080   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000083   E5..         MOV       A,?V3
   \   000085   F5..         MOV       ?V5,A
   \   000087   78..         MOV       R0,#?V5
   \   000089   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008C   75..01       MOV       ?V5,#0x1
   \   00008F   78..         MOV       R0,#?V5
   \   000091   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000094   75..01       MOV       ?V5,#0x1
   \   000097   78..         MOV       R0,#?V5
   \   000099   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00009C   E5..         MOV       A,?V4
   \   00009E   F5..         MOV       ?V5,A
   \   0000A0   78..         MOV       R0,#?V5
   \   0000A2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A5   7C04         MOV       R4,#0x4
   \   0000A7   7D00         MOV       R5,#0x0
   \   0000A9   AA..         MOV       R2,?V6
   \   0000AB   AB..         MOV       R3,?V7
   \   0000AD   A9..         MOV       R1,?V0
   \   0000AF   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000B2   740B         MOV       A,#0xb
   \   0000B4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B7   7403         MOV       A,#0x3
   \   0000B9   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000BC   7F0A         MOV       R7,#0xa
   \   0000BE   02....       LJMP      ?BANKED_LEAVE_XDATA
    540          }
    541          
    542          /*********************************************************************
    543           * @fn      zclGeneral_SendGroupViewResponse
    544           *
    545           * @brief   Call to send Group Response Command
    546           *
    547           * @param   srcEP - Sending application's endpoint
    548           * @param   dstAddr - where you want the message to go
    549           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    550           * @param   status - group command status
    551           * @param   grp - group info
    552           *
    553           * @return  ZStatus_t
    554           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    555          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupViewResponse:
    556                                                      uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    557          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V8,R1
   \   000007   8A..         MOV       ?V12,R2
   \   000009   8B..         MOV       ?V13,R3
   \   00000B   8C..         MOV       ?V7,R4
   \   00000D   8D..         MOV       ?V10,R5
   \   00000F   7416         MOV       A,#0x16
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   E0           MOVX      A,@DPTR
   \   000015   FE           MOV       R6,A
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   FF           MOV       R7,A
   \   000019   7418         MOV       A,#0x18
   \   00001B   12....       LCALL     ?XSTACK_DISP0_8
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F5..         MOV       ?V9,A
    558            uint8 *buf;
    559            uint8 len;
    560            ZStatus_t stat;
    561          
    562            len = 1 + 2 + 1; // Status + Group ID + name length
   \   000021   75..04       MOV       ?V3,#0x4
    563          
    564            if ( status == ZCL_STATUS_SUCCESS )
   \   000024   E5..         MOV       A,?V7
   \   000026   700B         JNZ       ??zclGeneral_SendGroupViewResponse_0
    565            {
    566              len += grp->name[0];  // String length
   \   000028   8E82         MOV       DPL,R6
   \   00002A   8F83         MOV       DPH,R7
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   25..         ADD       A,?V3
   \   000031   F5..         MOV       ?V3,A
    567            }
    568          
    569            buf = zcl_mem_alloc( len );
   \                     ??zclGeneral_SendGroupViewResponse_0:
   \   000033                ; Setup parameters for call to function osal_mem_alloc
   \   000033   E5..         MOV       A,?V3
   \   000035   FA           MOV       R2,A
   \   000036   7B00         MOV       R3,#0x0
   \   000038   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV       ?V4,R2
   \   00003D   8B..         MOV       ?V5,R3
   \   00003F   85....       MOV       ?V0,?V4
   \   000042   85....       MOV       ?V1,?V5
    570            if ( buf )
   \   000045   E5..         MOV       A,?V0
   \   000047   45..         ORL       A,?V1
   \   000049   7003         JNZ       $+5
   \   00004B   02....       LJMP      ??zclGeneral_SendGroupViewResponse_1 & 0xFFFF
    571            {
    572              buf[0] = status;
   \   00004E   E5..         MOV       A,?V7
   \   000050   C0E0         PUSH      A
   \   000052   85..82       MOV       DPL,?V0
   \   000055   85..83       MOV       DPH,?V1
   \   000058   D0E0         POP       A
   \   00005A   F0           MOVX      @DPTR,A
    573              buf[1] = LO_UINT16( grp->ID );
   \   00005B   8E82         MOV       DPL,R6
   \   00005D   8F83         MOV       DPH,R7
   \   00005F   E0           MOVX      A,@DPTR
   \   000060   F8           MOV       R0,A
   \   000061   A3           INC       DPTR
   \   000062   E0           MOVX      A,@DPTR
   \   000063   F9           MOV       R1,A
   \   000064   E8           MOV       A,R0
   \   000065   C0E0         PUSH      A
   \   000067   85..82       MOV       DPL,?V0
   \   00006A   85..83       MOV       DPH,?V1
   \   00006D   A3           INC       DPTR
   \   00006E   D0E0         POP       A
   \   000070   F0           MOVX      @DPTR,A
    574              buf[2] = HI_UINT16( grp->ID );
   \   000071   8E82         MOV       DPL,R6
   \   000073   8F83         MOV       DPH,R7
   \   000075   E0           MOVX      A,@DPTR
   \   000076   F8           MOV       R0,A
   \   000077   A3           INC       DPTR
   \   000078   E0           MOVX      A,@DPTR
   \   000079   F9           MOV       R1,A
   \   00007A   E4           CLR       A
   \   00007B   C9           XCH       A,R1
   \   00007C   F8           MOV       R0,A
   \   00007D   E8           MOV       A,R0
   \   00007E   C0E0         PUSH      A
   \   000080   85..82       MOV       DPL,?V0
   \   000083   85..83       MOV       DPH,?V1
   \   000086   A3           INC       DPTR
   \   000087   A3           INC       DPTR
   \   000088   D0E0         POP       A
   \   00008A   F0           MOVX      @DPTR,A
    575          
    576              if ( status == ZCL_STATUS_SUCCESS )
   \   00008B   E5..         MOV       A,?V7
   \   00008D   704A         JNZ       ??zclGeneral_SendGroupViewResponse_2
    577              {
    578                buf[3] = grp->name[0]; // string length
   \   00008F   8E82         MOV       DPL,R6
   \   000091   8F83         MOV       DPH,R7
   \   000093   A3           INC       DPTR
   \   000094   A3           INC       DPTR
   \   000095   E0           MOVX      A,@DPTR
   \   000096   C0E0         PUSH      A
   \   000098   85..82       MOV       DPL,?V0
   \   00009B   85..83       MOV       DPH,?V1
   \   00009E   A3           INC       DPTR
   \   00009F   A3           INC       DPTR
   \   0000A0   A3           INC       DPTR
   \   0000A1   D0E0         POP       A
   \   0000A3   F0           MOVX      @DPTR,A
    579                zcl_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
   \   0000A4                ; Setup parameters for call to function osal_memcpy
   \   0000A4   8E82         MOV       DPL,R6
   \   0000A6   8F83         MOV       DPH,R7
   \   0000A8   A3           INC       DPTR
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   A982         MOV       R1,DPL
   \   0000AD   AA83         MOV       R2,DPH
   \   0000AF   7B00         MOV       R3,#0x0
   \   0000B1   89..         MOV       ?V4,R1
   \   0000B3   8A..         MOV       ?V5,R2
   \   0000B5   8B..         MOV       ?V6,R3
   \   0000B7   78..         MOV       R0,#?V4
   \   0000B9   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000BC   8E82         MOV       DPL,R6
   \   0000BE   8F83         MOV       DPH,R7
   \   0000C0   A3           INC       DPTR
   \   0000C1   A3           INC       DPTR
   \   0000C2   E0           MOVX      A,@DPTR
   \   0000C3   FC           MOV       R4,A
   \   0000C4   7D00         MOV       R5,#0x0
   \   0000C6   E5..         MOV       A,?V0
   \   0000C8   2404         ADD       A,#0x4
   \   0000CA   FA           MOV       R2,A
   \   0000CB   E4           CLR       A
   \   0000CC   35..         ADDC      A,?V1
   \   0000CE   FB           MOV       R3,A
   \   0000CF   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000D2   7403         MOV       A,#0x3
   \   0000D4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000D7   800C         SJMP      ??zclGeneral_SendGroupViewResponse_3
    580              }
    581              else //ZCL_STATUS_NOT_FOUND
    582              {
    583                buf[3] = 0;
   \                     ??zclGeneral_SendGroupViewResponse_2:
   \   0000D9   85..82       MOV       DPL,?V0
   \   0000DC   85..83       MOV       DPH,?V1
   \   0000DF   A3           INC       DPTR
   \   0000E0   A3           INC       DPTR
   \   0000E1   A3           INC       DPTR
   \   0000E2   7400         MOV       A,#0x0
   \   0000E4   F0           MOVX      @DPTR,A
    584              }
    585          
    586              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    587                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    588                                      disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zclGeneral_SendGroupViewResponse_3:
   \   0000E5                ; Setup parameters for call to function zcl_SendCommand
   \   0000E5   78..         MOV       R0,#?V0
   \   0000E7   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000EA   E5..         MOV       A,?V3
   \   0000EC   F5..         MOV       ?V4,A
   \   0000EE   75..00       MOV       ?V5,#0x0
   \   0000F1   78..         MOV       R0,#?V4
   \   0000F3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000F6   E5..         MOV       A,?V9
   \   0000F8   F5..         MOV       ?V4,A
   \   0000FA   78..         MOV       R0,#?V4
   \   0000FC   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000FF   E4           CLR       A
   \   000100   F5..         MOV       ?V4,A
   \   000102   F5..         MOV       ?V5,A
   \   000104   78..         MOV       R0,#?V4
   \   000106   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000109   E5..         MOV       A,?V10
   \   00010B   F5..         MOV       ?V4,A
   \   00010D   78..         MOV       R0,#?V4
   \   00010F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000112   75..01       MOV       ?V4,#0x1
   \   000115   78..         MOV       R0,#?V4
   \   000117   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00011A   75..01       MOV       ?V4,#0x1
   \   00011D   78..         MOV       R0,#?V4
   \   00011F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000122   75..01       MOV       ?V4,#0x1
   \   000125   78..         MOV       R0,#?V4
   \   000127   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00012A   7C04         MOV       R4,#0x4
   \   00012C   7D00         MOV       R5,#0x0
   \   00012E   AA..         MOV       R2,?V12
   \   000130   AB..         MOV       R3,?V13
   \   000132   A9..         MOV       R1,?V8
   \   000134   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000137   740B         MOV       A,#0xb
   \   000139   12....       LCALL     ?DEALLOC_XSTACK8
   \   00013C   E9           MOV       A,R1
   \   00013D   F5..         MOV       ?V2,A
    589              zcl_mem_free( buf );
   \   00013F                ; Setup parameters for call to function osal_mem_free
   \   00013F   AA..         MOV       R2,?V0
   \   000141   AB..         MOV       R3,?V1
   \   000143   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000146   8003         SJMP      ??zclGeneral_SendGroupViewResponse_4
    590            }
    591            else
    592            {
    593              stat = ZMemError;
   \                     ??zclGeneral_SendGroupViewResponse_1:
   \   000148   75..10       MOV       ?V2,#0x10
    594            }
    595          
    596            return ( stat );
   \                     ??zclGeneral_SendGroupViewResponse_4:
   \   00014B   A9..         MOV       R1,?V2
   \   00014D   7F0E         MOV       R7,#0xe
   \   00014F   02....       LJMP      ?BANKED_LEAVE_XDATA
    597          }
    598          #endif // ZCL_GROUPS
    599          
    600          #ifdef ZCL_SCENES
    601          /*********************************************************************
    602           * @fn      zclGeneral_SendAddSceneRequest
    603           *
    604           * @brief   Send the (Enhanced) Add Scene Request to a device. You can
    605           *           also use the appropriate macro.
    606           *
    607           * @param   srcEP - Sending Apps endpoint
    608           * @param   dstAddr - where to send the request
    609           * @param   scene - pointer to the scene structure
    610           * @param  cmd - COMMAND_SCENE_ADD or COMMAND_SCENE_ENHANCED_ADD
    611           * @param   disableDefaultRsp - whether to disable the Default Response command
    612           * @param   seqNum - sequence number
    613           *
    614           * @return  ZStatus_t
    615           */
    616          ZStatus_t zclGeneral_SendAddSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    617                                                    uint8 cmd, zclGeneral_Scene_t *scene,
    618                                                    uint8 disableDefaultRsp, uint8 seqNum )
    619          {
    620            uint8 *buf;
    621            uint8 *pBuf;
    622            uint8 len;
    623            ZStatus_t status;
    624          
    625            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    626            len += scene->name[0] + 1; // String + 1 for length
    627          
    628            // Add something for the extension field length
    629            len += scene->extLen;
    630          
    631            buf = zcl_mem_alloc( len );
    632            if ( buf )
    633            {
    634              pBuf = buf;
    635              *pBuf++ = LO_UINT16( scene->groupID );
    636              *pBuf++ = HI_UINT16( scene->groupID );
    637              *pBuf++ = scene->ID;
    638              *pBuf++ = LO_UINT16( scene->transTime );
    639              *pBuf++ = HI_UINT16( scene->transTime );
    640              *pBuf++ = scene->name[0]; // string length
    641              zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    642              pBuf += scene->name[0]; // move pass name
    643          
    644              // Add the extension fields
    645              if ( scene->extLen > 0 )
    646                zcl_memcpy( pBuf, scene->extField, scene->extLen );
    647          
    648              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    649                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    650                                        disableDefaultRsp, 0, seqNum, len, buf );
    651              zcl_mem_free( buf );
    652            }
    653            else
    654              status = ZMemError;
    655          
    656            return ( status );
    657          }
    658          
    659          /*********************************************************************
    660           * @fn      zclGeneral_SendSceneRequest
    661           *
    662           * @brief   Send a Scene Request to a device.  You can also use the
    663           *          appropriate macro.
    664           *
    665           * @param   srcEP - Sending Apps endpoint
    666           * @param   dstAddr - where to send the request
    667           * @param   cmd - one of the following:
    668           *              COMMAND_SCENE_VIEW
    669           *              COMMAND_SCENE_REMOVE
    670           *              COMMAND_SCENE_REMOVE_ALL
    671           *              COMMAND_SCENE_STORE
    672           *              COMMAND_SCENE_RECALL
    673           *              COMMAND_SCENE_GET_MEMBERSHIP
    674           *              COMMAND_SCENE_ENHANCED_VIEW
    675           * @param   groupID - group ID
    676           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    677           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    678           * @param   disableDefaultRsp - whether to disable the Default Response command
    679           * @param   seqNum - sequence number
    680           * @return  ZStatus_t
    681           */
    682          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    683                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    684                                                 uint8 disableDefaultRsp, uint8 seqNum )
    685          {
    686            uint8 buf[3];
    687            uint8 len = 2;
    688          
    689            buf[0] = LO_UINT16( groupID );
    690            buf[1] = HI_UINT16( groupID );
    691          
    692            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    693            {
    694              buf[2] = sceneID;
    695              len++;
    696            }
    697          
    698            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    699                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    700                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    701          }
    702          
    703          /*********************************************************************
    704           * @fn      zclGeneral_SendSceneResponse
    705           *
    706           * @brief   Send Group Response (not Group View Response)
    707           *
    708           * @param   srcEP - Sending application's endpoint
    709           * @param   dstAddr - where you want the message to go
    710           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    711           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    712           * @param   status - scene command status
    713           * @param   groupID - what group
    714           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    715           *
    716           * @return  ZStatus_t
    717           */
    718          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    719                                                  uint8 cmd, uint8 status, uint16 groupID,
    720                                                  uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    721          {
    722            uint8 buf[4];
    723            uint8 len = 1 + 2; // Status + Group ID
    724          
    725            buf[0] = status;
    726            buf[1] = LO_UINT16( groupID );
    727            buf[2] = HI_UINT16( groupID );
    728          
    729            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    730            {
    731              buf[3] = sceneID;
    732              len++;
    733            }
    734          
    735            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    736                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    737                                    disableDefaultRsp, 0, seqNum, len, buf );
    738          }
    739          
    740          /*********************************************************************
    741           * @fn      zclGeneral_SendSceneViewResponse
    742           *
    743           * @brief   Call to send Scene (Enahced) View Response Command. You can
    744           *           also use the appropriate macro.
    745           *
    746           * @param   srcEP - Sending application's endpoint
    747           * @param   dstAddr - where you want the message to go
    748           * @param   cmd - either COMMAND_SCENE_VIEW_RSP or COMMAND_SCENE_ENHANCED_VIEW_RSP
    749           * @param   status - scene command status
    750           * @param   scene - scene info
    751           *
    752           * @return  ZStatus_t
    753           */
    754          ZStatus_t zclGeneral_SendSceneViewRsp( uint8 srcEP, afAddrType_t *dstAddr,
    755                                                 uint8 cmd, uint8 status, zclGeneral_Scene_t *scene,
    756                                                 uint8 disableDefaultRsp, uint8 seqNum )
    757          {
    758            uint8 *buf;
    759            uint8 *pBuf;
    760            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    761            ZStatus_t stat;
    762          
    763            if ( status == ZCL_STATUS_SUCCESS )
    764            {
    765              len += 2; // Transition Time
    766              len += scene->name[0] + 1; // string + 1 for length
    767          
    768              // Add something for the extension field length
    769              len += scene->extLen;
    770            }
    771          
    772            buf = zcl_mem_alloc( len );
    773            if ( buf )
    774            {
    775              pBuf = buf;
    776              *pBuf++ = status;
    777              *pBuf++ = LO_UINT16( scene->groupID );
    778              *pBuf++ = HI_UINT16( scene->groupID );
    779              *pBuf++ = scene->ID;
    780              if ( status == ZCL_STATUS_SUCCESS )
    781              {
    782                uint16 transTime = scene->transTime;
    783                if ( cmd == COMMAND_SCENE_ENHANCED_VIEW_RSP )
    784                {
    785                  // Transition time is in 1/10s
    786                  transTime *= 10;
    787                  transTime += scene->transTime100ms;
    788                }
    789          
    790                *pBuf++ = LO_UINT16( transTime );
    791                *pBuf++ = HI_UINT16( transTime );
    792                *pBuf++ = scene->name[0]; // string length
    793                if ( scene->name[0] != 0 )
    794                {
    795                  zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    796                  pBuf += scene->name[0]; // move pass name
    797                }
    798          
    799                // Add the extension fields
    800                if ( scene->extLen > 0 )
    801                  zcl_memcpy( pBuf, scene->extField, scene->extLen );
    802              }
    803          
    804              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    805                                      cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    806                                      disableDefaultRsp, 0, seqNum, len, buf );
    807              zcl_mem_free( buf );
    808            }
    809            else
    810              stat = ZMemError;
    811          
    812            return ( stat );
    813          }
    814          
    815          /*********************************************************************
    816           * @fn      zclGeneral_SendSceneGetMembershipResponse
    817           *
    818           * @brief   Call to send Scene Get Membership Response Command
    819           *
    820           * @param   srcEP - Sending application's endpoint
    821           * @param   dstAddr - where you want the message to go
    822           * @param   status - scene command status
    823           * @param   capacity - remaining capacity of the scene table
    824           * @param   sceneCnt - number of scenes in the scene list
    825           * @param   sceneList - list of scene IDs
    826           * @param   groupID - group ID that scene belongs to
    827           * @param   seqNum - sequence number
    828           *
    829           * @return  ZStatus_t
    830           */
    831          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    832                                                               uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    833                                                               uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    834          {
    835            uint8 *buf;
    836            uint8 *pBuf;
    837            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    838            uint8 i;
    839            ZStatus_t stat;
    840          
    841            if ( status == ZCL_STATUS_SUCCESS )
    842            {
    843              len++; // Scene Count
    844              len += sceneCnt; // Scene List (Scene ID is a single octet)
    845            }
    846          
    847            buf = zcl_mem_alloc( len );
    848            if ( buf )
    849            {
    850              pBuf = buf;
    851              *pBuf++ = status;
    852              *pBuf++ = capacity;
    853              *pBuf++ = LO_UINT16( groupID );
    854              *pBuf++ = HI_UINT16( groupID );
    855              if ( status == ZCL_STATUS_SUCCESS )
    856              {
    857                *pBuf++ = sceneCnt;
    858                for ( i = 0; i < sceneCnt; i++ )
    859                  *pBuf++ = sceneList[i];
    860              }
    861          
    862              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    863                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    864                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    865              zcl_mem_free( buf );
    866            }
    867            else
    868              stat = ZMemError;
    869          
    870            return ( stat );
    871          }
    872          
    873          #ifdef ZCL_LIGHT_LINK_ENHANCE
    874          /*********************************************************************
    875           * @fn      zclGeneral_SendSceneCopy
    876           *
    877           * @brief   Send Scene Copy Request to a device
    878           *
    879           * @param   srcEP - sending application's endpoint
    880           * @param   dstAddr - where to send the request
    881           * @param   mode - how scene copy is to proceed
    882           * @param   groupIDFrom - group from which scene to be copied
    883           * @param   sceneIDFrom - scene from which scene to be copied
    884           * @param   groupIDTo - group to which scene to be copied
    885           * @param   sceneIDTo - scene to which scene to be copied
    886           * @param   disableDefaultRsp - disable Default Response command
    887           * @param   seqNum - the identification number for the transaction
    888           *
    889           * @return  ZStatus_t
    890           */
    891          ZStatus_t zclGeneral_SendSceneCopy( uint8 srcEP, afAddrType_t *dstAddr,
    892                                              uint8 mode, uint16 groupIDFrom, uint8 sceneIDFrom,
    893                                              uint16 groupIDTo, uint8 sceneIDTo,
    894                                              uint8 disableDefaultRsp, uint8 seqNum )
    895          {
    896            uint8 buf[7];
    897          
    898            buf[0] = mode;
    899            buf[1] = LO_UINT16( groupIDFrom );
    900            buf[2] = HI_UINT16( groupIDFrom );
    901            buf[3] = sceneIDFrom;
    902            buf[4] = LO_UINT16( groupIDTo );
    903            buf[5] = HI_UINT16( groupIDTo );
    904            buf[6] = sceneIDTo;
    905          
    906            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    907                                      COMMAND_SCENE_COPY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    908                                      disableDefaultRsp, 0, seqNum, 7, buf ) );
    909          }
    910          
    911          /*********************************************************************
    912           * @fn      zclGeneral_SendSceneCopyResponse
    913           *
    914           * @brief   Send Scene Copy Response to a device
    915           *
    916           * @param   srcEP - sending application's endpoint
    917           * @param   dstAddr - where to send the request
    918           * @param   status - status of copy scene attemp
    919           * @param   groupIDFrom - group from which scene was copied
    920           * @param   sceneIDFrom - scene from which scene was copied
    921           * @param   disableDefaultRsp - disable Default Response command
    922           * @param   seqNum - the identification number for the transaction
    923           *
    924           * @return  ZStatus_t
    925           */
    926          ZStatus_t zclGeneral_SendSceneCopyResponse( uint8 srcEP, afAddrType_t *dstAddr,
    927                                                      uint8 status, uint16 groupIDFrom, uint8 sceneIDFrom,
    928                                                      uint8 disableDefaultRsp, uint8 seqNum )
    929          {
    930            uint8 buf[4];
    931          
    932            buf[0] = status;
    933            buf[1] = LO_UINT16( groupIDFrom );
    934            buf[2] = HI_UINT16( groupIDFrom );
    935            buf[3] = sceneIDFrom;
    936          
    937            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    938                                      COMMAND_SCENE_COPY_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    939                                      disableDefaultRsp, 0, seqNum, 4, buf ) );
    940          }
    941          #endif // ZCL_LIGHT_LINK_ENHANCE
    942          #endif // ZCL_SCENES
    943          
    944          #ifdef ZCL_ON_OFF
    945          #ifdef ZCL_LIGHT_LINK_ENHANCE
    946          /*********************************************************************
    947           * @fn      zclGeneral_SendOnOff_CmdOffWithEffect
    948           *
    949           * @brief   Call to send out an Off with Effect Command.
    950           *
    951           * @param   srcEP - Sending application's endpoint
    952           * @param   dstAddr - where you want the message to go
    953           * @param   effectId - fading effect to use when switching light off
    954           * @param   effectVariant - which variant of effect to be triggered
    955           * @param   disableDefaultRsp - whether to disable the Default Response command
    956           * @param   seqNum - sequence number
    957           *
    958           * @return  ZStatus_t
    959           */
    960          ZStatus_t zclGeneral_SendOnOff_CmdOffWithEffect( uint8 srcEP, afAddrType_t *dstAddr,
    961                                                           uint8 effectId, uint8 effectVariant,
    962                                                           uint8 disableDefaultRsp, uint8 seqNum )
    963          {
    964            uint8 buf[2];
    965          
    966            buf[0] = effectId;
    967            buf[1] = effectVariant;
    968          
    969            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
    970                                    COMMAND_OFF_WITH_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    971                                    disableDefaultRsp, 0, seqNum, 2, buf );
    972          }
    973          
    974          /*********************************************************************
    975           * @fn      zclGeneral_SendOnOff_CmdOnWithTimedOff
    976           *
    977           * @brief   Call to send out an On with Timed Off Command.
    978           *
    979           * @param   srcEP - Sending application's endpoint
    980           * @param   dstAddr - where you want the message to go
    981           * @param   onOffCtrl - how the lamp is to be operated
    982           * @param   onTime - the length of time (in 1/10ths second) that the lamp is to remain on, before automatically turning off
    983           * @param   offWaitTime - the length of time (in 1/10ths second) that the lamp shall remain off, and guarded to prevent an on command turning the light back on.
    984           * @param   disableDefaultRsp - whether to disable the Default Response command
    985           * @param   seqNum - sequence number
    986           *
    987           * @return  ZStatus_t
    988           */
    989          ZStatus_t zclGeneral_SendOnOff_CmdOnWithTimedOff ( uint8 srcEP, afAddrType_t *dstAddr,
    990                                                             zclOnOffCtrl_t onOffCtrl, uint16 onTime, uint16 offWaitTime,
    991                                                             uint8 disableDefaultRsp, uint8 seqNum )
    992          {
    993            uint8 buf[5];
    994          
    995            buf[0] = onOffCtrl.byte;
    996            buf[1] = LO_UINT16( onTime );
    997            buf[2] = HI_UINT16( onTime );
    998            buf[3] = LO_UINT16( offWaitTime );
    999            buf[4] = HI_UINT16( offWaitTime );
   1000          
   1001            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
   1002                                    COMMAND_ON_WITH_TIMED_OFF, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1003                                    disableDefaultRsp, 0, seqNum, 5, buf );
   1004          }
   1005          #endif // ZCL_LIGHT_LINK_ENHANCE
   1006          #endif // ZCL_ON_OFF
   1007          
   1008          #ifdef ZCL_LEVEL_CTRL
   1009          /*********************************************************************
   1010           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
   1011           *
   1012           * @brief   Call to send out a Level Control Request. You can also use
   1013           *          the appropriate macro.
   1014           *
   1015           * @param   srcEP - Sending application's endpoint
   1016           * @param   dstAddr - where you want the message to go
   1017           * @param   cmd - one of the following:
   1018           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
   1019           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
   1020           * @param   level - what level to move to
   1021           * @param   transitionTime - how long to take to get to the level (in seconds)
   1022           *
   1023           * @return  ZStatus_t
   1024           */
   1025          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1026                                                                   uint8 cmd, uint8 level, uint16 transTime,
   1027                                                                   uint8 disableDefaultRsp, uint8 seqNum )
   1028          {
   1029            uint8 buf[3];
   1030          
   1031            buf[0] = level;
   1032            buf[1] = LO_UINT16( transTime );
   1033            buf[2] = HI_UINT16( transTime );
   1034          
   1035            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1036                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1037                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1038          }
   1039          
   1040          /*********************************************************************
   1041           * @fn      zclGeneral_SendLevelControlMoveRequest
   1042           *
   1043           * @brief   Call to send out a Level Control Request. You can also use
   1044           *          the appropriate macro.
   1045           *
   1046           * @param   srcEP - Sending application's endpoint
   1047           * @param   dstAddr - where you want the message to go
   1048           * @param   cmd - one of the following:
   1049           *              COMMAND_LEVEL_MOVE or
   1050           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
   1051           * @param   moveMode - LEVEL_MOVE_UP or
   1052           *                     LEVEL_MOVE_DOWN
   1053           * @param   rate - number of steps to take per second
   1054           *
   1055           * @return  ZStatus_t
   1056           */
   1057          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1058                                                            uint8 cmd, uint8 moveMode, uint8 rate,
   1059                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1060          {
   1061            uint8 buf[2];
   1062          
   1063            buf[0] = moveMode;
   1064            buf[1] = rate;
   1065          
   1066            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1067                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1068                                    disableDefaultRsp, 0, seqNum, 2, buf );
   1069          }
   1070          
   1071          /*********************************************************************
   1072           * @fn      zclGeneral_SendLevelControlStepRequest
   1073           *
   1074           * @brief   Call to send out a Level Control Request. You can also use
   1075           *          the appropriate macro.
   1076           *
   1077           * @param   srcEP - Sending application's endpoint
   1078           * @param   dstAddr - where you want the message to go
   1079           * @param   cmd - one of the following:
   1080           *              COMMAND_LEVEL_STEP
   1081           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
   1082           * @param   stepMode - LEVEL_STEP_UP or
   1083           *                     LEVEL_STEP_DOWN
   1084           * @param   amount - number of levels to step
   1085           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
   1086           *
   1087           * @return  ZStatus_t
   1088           */
   1089          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1090                                                            uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
   1091                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1092          {
   1093            uint8 buf[4];
   1094          
   1095            buf[0] = stepMode;
   1096            buf[1] = stepSize;
   1097            buf[2] = LO_UINT16( transTime );
   1098            buf[3] = HI_UINT16( transTime );
   1099          
   1100            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1101                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1102                                    disableDefaultRsp, 0, seqNum, 4, buf );
   1103          }
   1104          
   1105          /*********************************************************************
   1106           * @fn      zclGeneral_SendLevelControlStepRequest
   1107           *
   1108           * @brief   Call to send out a Level Control Request. You can also use
   1109           *          the appropriate macro.
   1110           *
   1111           * @param   srcEP - Sending application's endpoint
   1112           * @param   dstAddr - where you want the message to go
   1113           * @param   cmd - one of the following:
   1114           *              COMMAND_LEVEL_STOP
   1115           *              COMMAND_LEVEL_STOP_WITH_ON_OFF
   1116           *
   1117           * @return  ZStatus_t
   1118           */
   1119          ZStatus_t zclGeneral_SendLevelControlStopRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1120                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1121          {
   1122            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1123                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1124                                    disableDefaultRsp, 0, seqNum, 0, NULL );
   1125          }
   1126          #endif // ZCL_LEVEL_CTRL
   1127          
   1128          #ifdef ZCL_ALARMS
   1129          /*********************************************************************
   1130           * @fn      zclGeneral_SendAlarm
   1131           *
   1132           * @brief   Call to send out an Alarm Request Command
   1133           *
   1134           * @param   srcEP - Sending application's endpoint
   1135           * @param   dstAddr - where you want the message to go
   1136           * @param   cmd - COMMAND_ALARMS_ALARM
   1137           * @param   alarmCode - code for the cause of the alarm
   1138           * @param   clusterID - cluster whose attribute generate the alarm
   1139           *
   1140           * @return  ZStatus_t
   1141           */
   1142          ZStatus_t zclGeneral_SendAlarm( uint8 srcEP, afAddrType_t *dstAddr,
   1143                                          uint8 alarmCode, uint16 clusterID,
   1144                                          uint8 disableDefaultRsp, uint8 seqNum )
   1145          {
   1146            uint8 buf[3];
   1147          
   1148            buf[0] = alarmCode;
   1149            buf[1] = LO_UINT16( clusterID );
   1150            buf[2] = HI_UINT16( clusterID );
   1151          
   1152            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1153                                    COMMAND_ALARMS_ALARM, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1154                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1155          }
   1156          
   1157          /*********************************************************************
   1158           * @fn      zclGeneral_SendAlarmReset
   1159           *
   1160           * @brief   Call to send out an Alarm Reset Command
   1161           *
   1162           * @param   srcEP - Sending application's endpoint
   1163           * @param   dstAddr - where you want the message to go
   1164           * @param   alarmCode - code for the cause of the alarm
   1165           * @param   clusterID - cluster whose attribute generate the alarm
   1166           *
   1167           * @return  ZStatus_t
   1168          */
   1169          ZStatus_t zclGeneral_SendAlarmReset( uint8 srcEP, afAddrType_t *dstAddr,
   1170                                               uint8 alarmCode, uint16 clusterID,
   1171                                               uint8 disableDefaultRsp, uint8 seqNum )
   1172          {
   1173            uint8 buf[3];
   1174          
   1175            buf[0] = alarmCode;
   1176            buf[1] = LO_UINT16( clusterID );
   1177            buf[2] = HI_UINT16( clusterID );
   1178          
   1179            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1180                                    COMMAND_ALARMS_RESET, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1181                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1182          }
   1183          
   1184          /*********************************************************************
   1185           * @fn      zclGeneral_SendAlarmGetResponse
   1186           *
   1187           * @brief   Call to send out an Alarm Get Response Command
   1188           *
   1189           * @param   srcEP - Sending application's endpoint
   1190           * @param   dstAddr - where you want the message to go
   1191           * @param   status - SUCCESS or NOT_FOUND
   1192           * @param   alarmCode - code for the cause of the alarm
   1193           * @param   clusterID - cluster whose attribute generate the alarm
   1194           * @param   timeStamp - time at which the alarm occured
   1195           *
   1196           * @return  ZStatus_t
   1197           */
   1198          ZStatus_t zclGeneral_SendAlarmGetResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1199                                                     uint8 status, uint8 alarmCode, uint16 clusterID,
   1200                                                     uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
   1201          {
   1202            uint8 buf[8];
   1203            uint8 len = 1; // Status
   1204          
   1205            buf[0] = status;
   1206            if ( status == ZCL_STATUS_SUCCESS )
   1207            {
   1208              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
   1209              buf[1] = alarmCode;
   1210              buf[2] = LO_UINT16( clusterID );
   1211              buf[3] = HI_UINT16( clusterID );
   1212              zcl_buffer_uint32( &buf[4], timeStamp );
   1213            }
   1214          
   1215            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1216                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1217                                    disableDefaultRsp, 0, seqNum, len, buf );
   1218          }
   1219          
   1220          #ifdef SE_UK_EXT
   1221          /*********************************************************************
   1222           * @fn      zclGeneral_SendAlarmGetEventLog
   1223           *
   1224           * @brief   Call to send out an Alarm Get Event Log Command
   1225           *
   1226           * @param   srcEP - Sending application's endpoint
   1227           * @param   dstAddr - where you want the message to go
   1228           * @param   pEventLog - pointer to Get Event Log Command
   1229           * @param   disableDefaultRsp - disable default response
   1230           * @param   seqNum - ZCL sequence number
   1231           *
   1232           * @return  ZStatus_t
   1233           */
   1234          ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1235                                                     zclGetEventLog_t *pEventLog,
   1236                                                     uint8 disableDefaultRsp, uint8 seqNum )
   1237          {
   1238            uint8 buf[10];
   1239          
   1240            buf[0] = pEventLog->logID;
   1241            zcl_buffer_uint32( &buf[1], pEventLog->startTime );
   1242            zcl_buffer_uint32( &buf[5], pEventLog->endTime );
   1243            buf[9] = pEventLog->numEvents;
   1244          
   1245            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1246                                    COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1247                                    disableDefaultRsp, 0, seqNum, 10, buf );
   1248          }
   1249          
   1250          /*********************************************************************
   1251           * @fn      zclGeneral_SendAlarmPublishEventLog
   1252           *
   1253           * @brief   Call to send out an Alarm Publish Event Log Command
   1254           *
   1255           * @param   srcEP - Sending application's endpoint
   1256           * @param   dstAddr - where you want the message to go
   1257           * @param   pEventLog - pointer to Publish Event Log Command
   1258           * @param   disableDefaultRsp - disable default response
   1259           * @param   seqNum - ZCL sequence number
   1260           *
   1261           * @return  ZStatus_t
   1262           */
   1263          ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1264                                                         zclPublishEventLog_t *pEventLog,
   1265                                                         uint8 disableDefaultRsp, uint8 seqNum )
   1266          {
   1267            uint8 *buf;
   1268            uint8 *pBuf;
   1269            uint8 bufLen;
   1270          
   1271            // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
   1272            bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
   1273          
   1274            buf = zcl_mem_alloc( bufLen );
   1275            if ( buf == NULL )
   1276            {
   1277              return (ZMemError);
   1278            }
   1279          
   1280            pBuf = buf;
   1281            *pBuf++ = pEventLog->logID;
   1282            *pBuf++ = pEventLog->cmdIndex;
   1283            *pBuf++ = pEventLog->totalCmds;
   1284          
   1285            for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
   1286            {
   1287              zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
   1288          
   1289              *pBuf++ = pLogs->eventId;
   1290              pBuf = zcl_buffer_uint32( pBuf, pLogs->eventTime );
   1291            }
   1292          
   1293            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1294                                    COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1295                                    disableDefaultRsp, 0, seqNum, bufLen, buf );
   1296          }
   1297          #endif // SE_UK_EXT
   1298          #endif // ZCL_ALARMS
   1299          
   1300          #ifdef ZCL_LOCATION
   1301          /*********************************************************************
   1302           * @fn      zclGeneral_SendLocationSetAbsolute
   1303           *
   1304           * @brief   Call to send out a Set Absolute Location Command
   1305           *
   1306           * @param   srcEP - Sending application's endpoint
   1307           * @param   dstAddr - where you want the message to go
   1308           * @param   absLoc - absolute location info
   1309           *
   1310           * @return  ZStatus_t
   1311           */
   1312          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
   1313                                                        zclLocationAbsolute_t *absLoc,
   1314                                                        uint8 disableDefaultRsp, uint8 seqNum )
   1315          {
   1316             uint8 buf[10]; // 5 fields (2 octects each)
   1317          
   1318             buf[0] = LO_UINT16( absLoc->coordinate1 );
   1319             buf[1] = HI_UINT16( absLoc->coordinate1 );
   1320             buf[2] = LO_UINT16( absLoc->coordinate2 );
   1321             buf[3] = HI_UINT16( absLoc->coordinate2 );
   1322             buf[4] = LO_UINT16( absLoc->coordinate3 );
   1323             buf[5] = HI_UINT16( absLoc->coordinate3 );
   1324             buf[6] = LO_UINT16( absLoc->power );
   1325             buf[7] = HI_UINT16( absLoc->power );
   1326             buf[8] = LO_UINT16( absLoc->pathLossExponent );
   1327             buf[9] = HI_UINT16( absLoc->pathLossExponent );
   1328          
   1329             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1330                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
   1331                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
   1332          }
   1333          
   1334          /*********************************************************************
   1335           * @fn      zclGeneral_SendLocationSetDevCfg
   1336           *
   1337           * @brief   Call to send out a Set Device Configuration Command
   1338           *
   1339           * @param   srcEP - Sending application's endpoint
   1340           * @param   dstAddr - where you want the message to go
   1341           * @param   devCfg - device configuration info
   1342           *
   1343           * @return  ZStatus_t
   1344           */
   1345          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1346                                                      zclLocationDevCfg_t *devCfg,
   1347                                                      uint8 disableDefaultRsp, uint8 seqNum )
   1348          {
   1349             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
   1350          
   1351             buf[0] = LO_UINT16( devCfg->power );
   1352             buf[1] = HI_UINT16( devCfg->power );
   1353             buf[2] = LO_UINT16( devCfg->pathLossExponent );
   1354             buf[3] = HI_UINT16( devCfg->pathLossExponent );
   1355             buf[4] = LO_UINT16( devCfg->calcPeriod );
   1356             buf[5] = HI_UINT16( devCfg->calcPeriod );
   1357             buf[6] = devCfg->numMeasurements;
   1358             buf[7] = LO_UINT16( devCfg->reportPeriod );
   1359             buf[8] = HI_UINT16( devCfg->reportPeriod );
   1360          
   1361             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1362                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
   1363                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
   1364          }
   1365          
   1366          /*********************************************************************
   1367           * @fn      zclGeneral_SendLocationGetDevCfg
   1368           *
   1369           * @brief   Call to send out a Get Device Configuration Command
   1370           *
   1371           * @param   srcEP - Sending application's endpoint
   1372           * @param   dstAddr - where you want the message to go
   1373           * @param   targetAddr - device for which location parameters are being requested
   1374           *
   1375           * @return  ZStatus_t
   1376           */
   1377          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1378                                                      uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1379          {
   1380            uint8 buf[8];
   1381          
   1382            zcl_memcpy( buf, targetAddr, 8 );
   1383          
   1384            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1385                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1386                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1387          }
   1388          
   1389          /*********************************************************************
   1390           * @fn      zclGeneral_SendLocationGetData
   1391           *
   1392           * @brief   Call to send out a Get Location Data Command
   1393           *
   1394           * @param   srcEP - Sending application's endpoint
   1395           * @param   dstAddr - where you want the message to go
   1396           * @param   locaData - location information and channel parameters that are requested.
   1397           *
   1398           * @return  ZStatus_t
   1399           */
   1400          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1401                                                    zclLocationGetData_t *locData,
   1402                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1403          {
   1404            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1405            uint8 *pBuf = buf;
   1406            uint8 len = 2; // bitmap + number responses
   1407          
   1408            *pBuf  = locData->absoluteOnly;
   1409            *pBuf |= locData->recalculate << 1;
   1410            *pBuf |= locData->brdcastIndicator << 2;
   1411            *pBuf |= locData->brdcastResponse << 3;
   1412            *pBuf |= locData->compactResponse << 4;
   1413            pBuf++;  // move past the bitmap field
   1414          
   1415            *pBuf++ = locData->numResponses;
   1416          
   1417            if ( locData->brdcastIndicator == 0 )
   1418            {
   1419              zcl_memcpy( pBuf, locData->targetAddr, 8 );
   1420              len += 8; // ieee addr
   1421            }
   1422          
   1423            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1424                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1425                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1426          }
   1427          
   1428          /*********************************************************************
   1429           * @fn      zclGeneral_SendLocationDevCfgResponse
   1430           *
   1431           * @brief   Call to send out a Device Configuration Response Command
   1432           *
   1433           * @param   srcEP - Sending application's endpoint
   1434           * @param   dstAddr - where you want the message to go
   1435           * @param   devCfg - device's location parameters that are requested
   1436           *
   1437           * @return  ZStatus_t
   1438           */
   1439          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1440                                                           zclLocationDevCfgRsp_t *devCfg,
   1441                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1442          {
   1443            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1444            uint8 len = 1; // Status
   1445          
   1446            buf[0] = devCfg->status;
   1447            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1448            {
   1449              buf[1] = LO_UINT16( devCfg->data.power );
   1450              buf[2] = HI_UINT16( devCfg->data.power );
   1451              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1452              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1453              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1454              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1455              buf[7] = devCfg->data.numMeasurements;
   1456              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1457              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1458              len += 9;
   1459            }
   1460          
   1461            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1462                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1463                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1464          }
   1465          
   1466          /*********************************************************************
   1467           * @fn      zclGeneral_SendLocationData
   1468           *
   1469           * @brief   Call to send out location data
   1470           *
   1471           * @param   srcEP - Sending application's endpoint
   1472           * @param   dstAddr - where you want the message to go
   1473           * @param   status - indicates whether response to request was successful or not
   1474           * @param   locData - location information and channel parameters being sent
   1475           *
   1476           * @return  ZStatus_t
   1477           */
   1478          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1479                                                 uint8 status, zclLocationData_t *locData,
   1480                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1481          {
   1482            uint8 buf[16];
   1483            uint8 *pBuf = buf;
   1484            uint8 len = 0;
   1485          
   1486            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1487            {
   1488              // Only response command includes a status field
   1489              *pBuf++ = status;
   1490              len++;
   1491            }
   1492          
   1493            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1494            {
   1495              // Notification or Response with successful status
   1496              *pBuf++ = locData->type;
   1497              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1498              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1499              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1500              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1501              len += 5;
   1502          
   1503              if ( locationType2D(locData->type) == 0 )
   1504              {
   1505                // 2D location doesn't have coordinate 3
   1506                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1507                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1508                len += 2;
   1509              }
   1510          
   1511              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1512              {
   1513                // Compact notification doesn't include these fields
   1514                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1515                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1516                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1517                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1518                len += 4;
   1519              }
   1520          
   1521              if ( locationTypeAbsolute(locData->type) == 0 )
   1522              {
   1523                // Absolute location doesn't include these fields
   1524                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1525                {
   1526                  // Compact notification doesn't include this field
   1527                  *pBuf++ = locData->calcLoc.locationMethod;
   1528                  len++;
   1529                }
   1530          
   1531                *pBuf++ = locData->calcLoc.qualityMeasure;
   1532                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1533                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1534                len += 3;
   1535              }
   1536            }
   1537          
   1538            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1539                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1540                                    disableDefaultRsp, 0, seqNum, len, buf );
   1541          }
   1542          #endif // ZCL_LOCATION
   1543          
   1544          /*********************************************************************
   1545           * @fn      zclGeneral_FindCallbacks
   1546           *
   1547           * @brief   Find the callbacks for an endpoint
   1548           *
   1549           * @param   endpoint - endpoint to find the application callbacks for
   1550           *
   1551           * @return  pointer to the callbacks
   1552           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1553          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   \                     zclGeneral_FindCallbacks:
   1554          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1555            zclGenCBRec_t *pCBs;
   1556          
   1557            pCBs = zclGenCBs;
   \   000004   90....       MOV       DPTR,#zclGenCBs
   \   000007   E0           MOVX      A,@DPTR
   \   000008   FA           MOV       R2,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   FB           MOV       R3,A
   \   00000C   EA           MOV       A,R2
   \   00000D   FC           MOV       R4,A
   \   00000E   EB           MOV       A,R3
   \   00000F   FD           MOV       R5,A
   1558            while ( pCBs )
   \                     ??zclGeneral_FindCallbacks_0:
   \   000010   EC           MOV       A,R4
   \   000011   4D           ORL       A,R5
   \   000012   6027         JZ        ??zclGeneral_FindCallbacks_1
   1559            {
   1560              if ( pCBs->endpoint == endpoint )
   \   000014   8C82         MOV       DPL,R4
   \   000016   8D83         MOV       DPH,R5
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   69           XRL       A,R1
   \   00001C   700E         JNZ       ??zclGeneral_FindCallbacks_2
   1561                return ( pCBs->CBs );
   \   00001E   8C82         MOV       DPL,R4
   \   000020   8D83         MOV       DPH,R5
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   FA           MOV       R2,A
   \   000027   A3           INC       DPTR
   \   000028   E0           MOVX      A,@DPTR
   \   000029   FB           MOV       R3,A
   \   00002A   8013         SJMP      ??zclGeneral_FindCallbacks_3
   1562              pCBs = pCBs->next;
   \                     ??zclGeneral_FindCallbacks_2:
   \   00002C   8C82         MOV       DPL,R4
   \   00002E   8D83         MOV       DPH,R5
   \   000030   E0           MOVX      A,@DPTR
   \   000031   FA           MOV       R2,A
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   FB           MOV       R3,A
   \   000035   EA           MOV       A,R2
   \   000036   FC           MOV       R4,A
   \   000037   EB           MOV       A,R3
   \   000038   FD           MOV       R5,A
   \   000039   80D5         SJMP      ??zclGeneral_FindCallbacks_0
   1563            }
   1564            return ( (zclGeneral_AppCallbacks_t *)NULL );
   \                     ??zclGeneral_FindCallbacks_1:
   \   00003B   7A00         MOV       R2,#0x0
   \   00003D   7B00         MOV       R3,#0x0
   \                     ??zclGeneral_FindCallbacks_3:
   \   00003F   D083         POP       DPH
   \   000041   D082         POP       DPL
   \   000043   02....       LJMP      ?BRET
   1565          }
   1566          
   1567          /*********************************************************************
   1568           * @fn      zclGeneral_HdlIncoming
   1569           *
   1570           * @brief   Callback from ZCL to process incoming Commands specific
   1571           *          to this cluster library or Profile commands for attributes
   1572           *          that aren't in the attribute list
   1573           *
   1574           *
   1575           * @param   pInMsg - pointer to the incoming message
   1576           *
   1577           * @return  ZStatus_t
   1578           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1579          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1580          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   1581            ZStatus_t stat = ZSuccess;
   \   000009   75..00       MOV       ?V0,#0x0
   1582          
   1583          #if defined ( INTER_PAN )
   1584            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   \   00000C                ; Setup parameters for call to function StubAPS_InterPan
   \   00000C   8E82         MOV       DPL,R6
   \   00000E   8F83         MOV       DPH,R7
   \   000010   E0           MOVX      A,@DPTR
   \   000011   F8           MOV       R0,A
   \   000012   A3           INC       DPTR
   \   000013   E0           MOVX      A,@DPTR
   \   000014   C8           XCH       A,R0
   \   000015   240F         ADD       A,#0xf
   \   000017   F582         MOV       DPL,A
   \   000019   C8           XCH       A,R0
   \   00001A   3400         ADDC      A,#0x0
   \   00001C   F583         MOV       DPH,A
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F9           MOV       R1,A
   \   000020   8E82         MOV       DPL,R6
   \   000022   8F83         MOV       DPH,R7
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F8           MOV       R0,A
   \   000026   A3           INC       DPTR
   \   000027   E0           MOVX      A,@DPTR
   \   000028   C8           XCH       A,R0
   \   000029   2410         ADD       A,#0x10
   \   00002B   F582         MOV       DPL,A
   \   00002D   C8           XCH       A,R0
   \   00002E   3400         ADDC      A,#0x0
   \   000030   F583         MOV       DPH,A
   \   000032   E0           MOVX      A,@DPTR
   \   000033   FA           MOV       R2,A
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   FB           MOV       R3,A
   \   000037   12....       LCALL     `??StubAPS_InterPan::?relay`; Banked call to: StubAPS_InterPan
   \   00003A   E9           MOV       A,R1
   \   00003B   6004         JZ        ??zclGeneral_HdlIncoming_0
   1585              return ( stat ); // Cluster not supported thru Inter-PAN
   \   00003D   A9..         MOV       R1,?V0
   \   00003F   8040         SJMP      ??zclGeneral_HdlIncoming_1
   1586          #endif
   1587            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \                     ??zclGeneral_HdlIncoming_0:
   \   000041   8E82         MOV       DPL,R6
   \   000043   8F83         MOV       DPH,R7
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   5403         ANL       A,#0x3
   \   00004A   F8           MOV       R0,A
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   5400         ANL       A,#0x0
   \   00004F   F9           MOV       R1,A
   \   000050   E8           MOV       A,R0
   \   000051   6401         XRL       A,#0x1
   \   000053   7027         JNZ       ??zclGeneral_HdlIncoming_2
   1588            {
   1589              // Is this a manufacturer specific command?
   1590              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   \   000055   8E82         MOV       DPL,R6
   \   000057   8F83         MOV       DPH,R7
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   F8           MOV       R0,A
   \   00005D   A3           INC       DPTR
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F9           MOV       R1,A
   \   000060   E8           MOV       A,R0
   \   000061   13           RRC       A
   \   000062   13           RRC       A
   \   000063   543F         ANL       A,#0x3f
   \   000065   5401         ANL       A,#0x1
   \   000067   A2E0         MOV       C,0xE0 /* A   */.0
   \   000069   400C         JC        ??zclGeneral_HdlIncoming_3
   1591              {
   1592                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   00006B                ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
   \   00006B   EE           MOV       A,R6
   \   00006C   FA           MOV       R2,A
   \   00006D   EF           MOV       A,R7
   \   00006E   FB           MOV       R3,A
   \   00006F   12....       LCALL     `??zclGeneral_HdlInSpecificCommands::?relay`; Banked call to: zclGeneral_HdlInSpecificCommands
   \   000072   E9           MOV       A,R1
   \   000073   F5..         MOV       ?V0,A
   \   000075   8008         SJMP      ??zclGeneral_HdlIncoming_4
   1593              }
   1594              else
   1595              {
   1596                // We don't support any manufacturer specific command.
   1597                stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_3:
   \   000077   75..01       MOV       ?V0,#0x1
   \   00007A   8003         SJMP      ??zclGeneral_HdlIncoming_4
   1598              }
   1599            }
   1600            else
   1601            {
   1602              // Handle all the normal (Read, Write...) commands -- should never get here
   1603              stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_2:
   \   00007C   75..01       MOV       ?V0,#0x1
   1604            }
   1605            return ( stat );
   \                     ??zclGeneral_HdlIncoming_4:
   \   00007F   A9..         MOV       R1,?V0
   \                     ??zclGeneral_HdlIncoming_1:
   \   000081   7F01         MOV       R7,#0x1
   \   000083   02....       LJMP      ?BANKED_LEAVE_XDATA
   1606          }
   1607          
   1608          /*********************************************************************
   1609           * @fn      zclGeneral_HdlInSpecificCommands
   1610           *
   1611           * @brief   Callback from ZCL to process incoming Commands specific
   1612           *          to this cluster library
   1613          
   1614           * @param   pInMsg - pointer to the incoming message
   1615           *
   1616           * @return  ZStatus_t
   1617           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1618          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1619          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   1620            ZStatus_t stat;
   1621            zclGeneral_AppCallbacks_t *pCBs;
   1622          
   1623            // make sure endpoint exists
   1624            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000009                ; Setup parameters for call to function zclGeneral_FindCallbacks
   \   000009   8E82         MOV       DPL,R6
   \   00000B   8F83         MOV       DPH,R7
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   F8           MOV       R0,A
   \   00000F   A3           INC       DPTR
   \   000010   E0           MOVX      A,@DPTR
   \   000011   C8           XCH       A,R0
   \   000012   2414         ADD       A,#0x14
   \   000014   F582         MOV       DPL,A
   \   000016   C8           XCH       A,R0
   \   000017   3400         ADDC      A,#0x0
   \   000019   F583         MOV       DPH,A
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F9           MOV       R1,A
   \   00001D   12....       LCALL     `??zclGeneral_FindCallbacks::?relay`; Banked call to: zclGeneral_FindCallbacks
   \   000020   8A..         MOV       ?V4,R2
   \   000022   8B..         MOV       ?V5,R3
   \   000024   85....       MOV       ?V0,?V4
   \   000027   85....       MOV       ?V1,?V5
   1625            if ( pCBs == NULL )
   \   00002A   E5..         MOV       A,?V0
   \   00002C   45..         ORL       A,?V1
   \   00002E   7005         JNZ       ??zclGeneral_HdlInSpecificCommands_0
   1626              return ( ZFailure );
   \   000030   7901         MOV       R1,#0x1
   \   000032   02....       LJMP      ??zclGeneral_HdlInSpecificCommands_1 & 0xFFFF
   1627          
   1628            switch ( pInMsg->msg->clusterId )
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   000035   8E82         MOV       DPL,R6
   \   000037   8F83         MOV       DPH,R7
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   F8           MOV       R0,A
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F583         MOV       DPH,A
   \   00003F   8882         MOV       DPL,R0
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F5..         MOV       ?V4,A
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   F5..         MOV       ?V5,A
   \   00004C   78..         MOV       R0,#?V4
   \   00004E   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
   \   000051   0000         DW        0
   \   000053   06           DB        6
   \   000054   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   000056   ....         DW        ??zclGeneral_HdlInSpecificCommands_3
   \   000058   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   00005A   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   00005C   ....         DW        ??zclGeneral_HdlInSpecificCommands_4
   \   00005E   ....         DW        ??zclGeneral_HdlInSpecificCommands_5
   \   000060   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   000062   ....         DW        ??zclGeneral_HdlInSpecificCommands_6
   1629            {
   1630          #ifdef ZCL_BASIC
   1631              case ZCL_CLUSTER_ID_GEN_BASIC:
   1632                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   000064                ; Setup parameters for call to function zclGeneral_ProcessInBasic
   \   000064   AC..         MOV       R4,?V0
   \   000066   AD..         MOV       R5,?V1
   \   000068   EE           MOV       A,R6
   \   000069   FA           MOV       R2,A
   \   00006A   EF           MOV       A,R7
   \   00006B   FB           MOV       R3,A
   \   00006C   12....       LCALL     `??zclGeneral_ProcessInBasic::?relay`; Banked call to: zclGeneral_ProcessInBasic
   \   00006F   E9           MOV       A,R1
   \   000070   F5..         MOV       ?V2,A
   1633                break;
   \   000072   8056         SJMP      ??zclGeneral_HdlInSpecificCommands_7
   1634          #endif // ZCL_BASIC
   1635          
   1636          #ifdef ZCL_IDENTIFY
   1637              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1638                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   000074                ; Setup parameters for call to function zclGeneral_ProcessInIdentity
   \   000074   AC..         MOV       R4,?V0
   \   000076   AD..         MOV       R5,?V1
   \   000078   EE           MOV       A,R6
   \   000079   FA           MOV       R2,A
   \   00007A   EF           MOV       A,R7
   \   00007B   FB           MOV       R3,A
   \   00007C   12....       LCALL     `??zclGeneral_ProcessInIdentity::?relay`; Banked call to: zclGeneral_ProcessInIdentity
   \   00007F   E9           MOV       A,R1
   \   000080   F5..         MOV       ?V2,A
   1639                break;
   \   000082   8046         SJMP      ??zclGeneral_HdlInSpecificCommands_7
   1640          #endif // ZCL_IDENTIFY
   1641          
   1642          #ifdef ZCL_GROUPS
   1643              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1644                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   000084   8E82         MOV       DPL,R6
   \   000086   8F83         MOV       DPH,R7
   \   000088   A3           INC       DPTR
   \   000089   A3           INC       DPTR
   \   00008A   E0           MOVX      A,@DPTR
   \   00008B   F8           MOV       R0,A
   \   00008C   A3           INC       DPTR
   \   00008D   E0           MOVX      A,@DPTR
   \   00008E   F9           MOV       R1,A
   \   00008F   E8           MOV       A,R0
   \   000090   13           RRC       A
   \   000091   13           RRC       A
   \   000092   13           RRC       A
   \   000093   541F         ANL       A,#0x1f
   \   000095   5401         ANL       A,#0x1
   \   000097   A2E0         MOV       C,0xE0 /* A   */.0
   \   000099   400C         JC        ??zclGeneral_HdlInSpecificCommands_8
   1645                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   \   00009B                ; Setup parameters for call to function zclGeneral_ProcessInGroupsServer
   \   00009B   EE           MOV       A,R6
   \   00009C   FA           MOV       R2,A
   \   00009D   EF           MOV       A,R7
   \   00009E   FB           MOV       R3,A
   \   00009F   12....       LCALL     `??zclGeneral_ProcessInGroupsServer::?relay`; Banked call to: zclGeneral_ProcessInGroupsServer
   \   0000A2   E9           MOV       A,R1
   \   0000A3   F5..         MOV       ?V2,A
   \   0000A5   8023         SJMP      ??zclGeneral_HdlInSpecificCommands_7
   1646                else
   1647                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   0000A7                ; Setup parameters for call to function zclGeneral_ProcessInGroupsClient
   \   0000A7   AC..         MOV       R4,?V0
   \   0000A9   AD..         MOV       R5,?V1
   \   0000AB   EE           MOV       A,R6
   \   0000AC   FA           MOV       R2,A
   \   0000AD   EF           MOV       A,R7
   \   0000AE   FB           MOV       R3,A
   \   0000AF   12....       LCALL     `??zclGeneral_ProcessInGroupsClient::?relay`; Banked call to: zclGeneral_ProcessInGroupsClient
   \   0000B2   E9           MOV       A,R1
   \   0000B3   F5..         MOV       ?V2,A
   1648                break;
   \   0000B5   8013         SJMP      ??zclGeneral_HdlInSpecificCommands_7
   1649          #endif // ZCL_GROUPS
   1650          
   1651          #ifdef ZCL_SCENES
   1652              case ZCL_CLUSTER_ID_GEN_SCENES:
   1653                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1654                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1655                else
   1656                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1657                break;
   1658          #endif // ZCL_SCENES
   1659          
   1660          #ifdef ZCL_ON_OFF
   1661              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1662                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   0000B7                ; Setup parameters for call to function zclGeneral_ProcessInOnOff
   \   0000B7   AC..         MOV       R4,?V0
   \   0000B9   AD..         MOV       R5,?V1
   \   0000BB   EE           MOV       A,R6
   \   0000BC   FA           MOV       R2,A
   \   0000BD   EF           MOV       A,R7
   \   0000BE   FB           MOV       R3,A
   \   0000BF   12....       LCALL     `??zclGeneral_ProcessInOnOff::?relay`; Banked call to: zclGeneral_ProcessInOnOff
   \   0000C2   E9           MOV       A,R1
   \   0000C3   F5..         MOV       ?V2,A
   1663                //stat = zclGeneral_ProcessInOnOffTest( pInMsg );
   1664                break;
   \   0000C5   8003         SJMP      ??zclGeneral_HdlInSpecificCommands_7
   1665          #endif // ZCL_ON_OFF
   1666          
   1667          #ifdef ZCL_LEVEL_CTRL
   1668              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1669                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1670                break;
   1671          #endif // ZCL_LEVEL_CTRL
   1672          
   1673          #ifdef ZCL_ALARMS
   1674              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1675                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1676                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1677                else
   1678                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1679                break;
   1680          #endif // ZCL_ALARMS
   1681          
   1682          #ifdef ZCL_LOCATION
   1683              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1684                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1685                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1686                else
   1687                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1688                break;
   1689          #endif // ZCL_LOCATION
   1690          
   1691              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1692              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1693              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1694              case ZCL_CLUSTER_ID_GEN_TIME:
   1695              default:
   1696                stat = ZFailure;
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   0000C7   75..01       MOV       ?V2,#0x1
   1697                break;
   1698            }
   1699          
   1700            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   0000CA   A9..         MOV       R1,?V2
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   0000CC   7F06         MOV       R7,#0x6
   \   0000CE   02....       LJMP      ?BANKED_LEAVE_XDATA
   1701          }
   1702          
   1703          #ifdef ZCL_BASIC
   1704          /*********************************************************************
   1705           * @fn      zclGeneral_ProcessInBasic
   1706           *
   1707           * @brief   Process in the received Basic Command.
   1708           *
   1709           * @param   pInMsg - pointer to the incoming message
   1710           *
   1711           * @return  ZStatus_t
   1712           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1713          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInBasic:
   1714                                                      zclGeneral_AppCallbacks_t *pCBs )
   1715          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   1716            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   00000D   8E82         MOV       DPL,R6
   \   00000F   8F83         MOV       DPH,R7
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F8           MOV       R0,A
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F9           MOV       R1,A
   \   000018   E8           MOV       A,R0
   \   000019   13           RRC       A
   \   00001A   13           RRC       A
   \   00001B   13           RRC       A
   \   00001C   541F         ANL       A,#0x1f
   \   00001E   5401         ANL       A,#0x1
   \   000020   A2E0         MOV       C,0xE0 /* A   */.0
   \   000022   4032         JC        ??zclGeneral_ProcessInBasic_0
   1717            {
   1718              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   \   000024   8E82         MOV       DPL,R6
   \   000026   8F83         MOV       DPH,R7
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   6004         JZ        ??zclGeneral_ProcessInBasic_1
   1719                return ( ZFailure );   // Error ignore the command
   \   000032   7901         MOV       R1,#0x1
   \   000034   8022         SJMP      ??zclGeneral_ProcessInBasic_2
   1720          
   1721              if ( pCBs->pfnBasicReset )
   \                     ??zclGeneral_ProcessInBasic_1:
   \   000036   85..82       MOV       DPL,?V0
   \   000039   85..83       MOV       DPH,?V1
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F8           MOV       R0,A
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F9           MOV       R1,A
   \   000041   E8           MOV       A,R0
   \   000042   49           ORL       A,R1
   \   000043   6011         JZ        ??zclGeneral_ProcessInBasic_0
   1722                pCBs->pfnBasicReset();
   \   000045                ; Setup parameters for indirect call
   \   000045   85..82       MOV       DPL,?V0
   \   000048   85..83       MOV       DPH,?V1
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   F8           MOV       R0,A
   \   00004D   A3           INC       DPTR
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   F583         MOV       DPH,A
   \   000051   8882         MOV       DPL,R0
   \   000053   12....       LCALL     ?CALL_IND
   1723            }
   1724            // no Client command
   1725          
   1726            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInBasic_0:
   \   000056   7900         MOV       R1,#0x0
   \                     ??zclGeneral_ProcessInBasic_2:
   \   000058   7F02         MOV       R7,#0x2
   \   00005A   02....       LJMP      ?BANKED_LEAVE_XDATA
   1727          }
   1728          #endif // ZCL_BASIC
   1729          
   1730          #ifdef ZCL_IDENTIFY
   1731          /*********************************************************************
   1732           * @fn      zclGeneral_ProcessInIdentity
   1733           *
   1734           * @brief   Process in the received Identity Command.
   1735           *
   1736           * @param   pInMsg - pointer to the incoming message
   1737           *
   1738           * @return  ZStatus_t
   1739           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1740          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInIdentity:
   1741                                                         zclGeneral_AppCallbacks_t *pCBs )
   1742          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV       A,#-0x6
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
   1743            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   000012   8E82         MOV       DPL,R6
   \   000014   8F83         MOV       DPH,R7
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F8           MOV       R0,A
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F9           MOV       R1,A
   \   00001D   E8           MOV       A,R0
   \   00001E   13           RRC       A
   \   00001F   13           RRC       A
   \   000020   13           RRC       A
   \   000021   541F         ANL       A,#0x1f
   \   000023   5401         ANL       A,#0x1
   \   000025   A2E0         MOV       C,0xE0 /* A   */.0
   \   000027   5003         JNC       $+5
   \   000029   02....       LJMP      ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
   1744            {
   1745              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   \   00002C   8E82         MOV       DPL,R6
   \   00002E   8F83         MOV       DPH,R7
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   E0           MOVX      A,@DPTR
   \   000038   705C         JNZ       ??zclGeneral_ProcessInIdentity_1
   1746              {
   1747                uint16 identifyTime;
   1748                
   1749                identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \   00003A   8E82         MOV       DPL,R6
   \   00003C   8F83         MOV       DPH,R7
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   A3           INC       DPTR
   \   000046   E0           MOVX      A,@DPTR
   \   000047   F8           MOV       R0,A
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   F583         MOV       DPH,A
   \   00004C   8882         MOV       DPL,R0
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   FA           MOV       R2,A
   \   000050   7B00         MOV       R3,#0x0
   \   000052   8E82         MOV       DPL,R6
   \   000054   8F83         MOV       DPH,R7
   \   000056   A3           INC       DPTR
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   A3           INC       DPTR
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F8           MOV       R0,A
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   F583         MOV       DPH,A
   \   000064   8882         MOV       DPL,R0
   \   000066   A3           INC       DPTR
   \   000067   E0           MOVX      A,@DPTR
   \   000068   F8           MOV       R0,A
   \   000069   7900         MOV       R1,#0x0
   \   00006B   E4           CLR       A
   \   00006C   C8           XCH       A,R0
   \   00006D   F9           MOV       R1,A
   \   00006E   EA           MOV       A,R2
   \   00006F   28           ADD       A,R0
   \   000070   F8           MOV       R0,A
   \   000071   EB           MOV       A,R3
   \   000072   39           ADDC      A,R1
   \   000073   F9           MOV       R1,A
   \   000074   88..         MOV       ?V2,R0
   \   000076   89..         MOV       ?V3,R1
   1750                
   1751                bdb_ZclIdentifyCmdInd( identifyTime, pInMsg->msg->endPoint);
   \   000078                ; Setup parameters for call to function bdb_ZclIdentifyCmdInd
   \   000078   8E82         MOV       DPL,R6
   \   00007A   8F83         MOV       DPH,R7
   \   00007C   E0           MOVX      A,@DPTR
   \   00007D   F8           MOV       R0,A
   \   00007E   A3           INC       DPTR
   \   00007F   E0           MOVX      A,@DPTR
   \   000080   C8           XCH       A,R0
   \   000081   2414         ADD       A,#0x14
   \   000083   F582         MOV       DPL,A
   \   000085   C8           XCH       A,R0
   \   000086   3400         ADDC      A,#0x0
   \   000088   F583         MOV       DPH,A
   \   00008A   E0           MOVX      A,@DPTR
   \   00008B   F9           MOV       R1,A
   \   00008C   AA..         MOV       R2,?V2
   \   00008E   AB..         MOV       R3,?V3
   \   000090   12....       LCALL     `??bdb_ZclIdentifyCmdInd::?relay`; Banked call to: bdb_ZclIdentifyCmdInd
   \   000093   02....       LJMP      ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
   1752              }
   1753              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_QUERY )
   \                     ??zclGeneral_ProcessInIdentity_1:
   \   000096   8E82         MOV       DPL,R6
   \   000098   8F83         MOV       DPH,R7
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   A3           INC       DPTR
   \   00009D   A3           INC       DPTR
   \   00009E   A3           INC       DPTR
   \   00009F   A3           INC       DPTR
   \   0000A0   A3           INC       DPTR
   \   0000A1   E0           MOVX      A,@DPTR
   \   0000A2   6401         XRL       A,#0x1
   \   0000A4   6003         JZ        $+5
   \   0000A6   02....       LJMP      ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
   1754              {
   1755                uint16 identifyTime = 0;
   \   0000A9   85..82       MOV       DPL,?XSP + 0
   \   0000AC   85..83       MOV       DPH,?XSP + 1
   \   0000AF   7400         MOV       A,#0x0
   \   0000B1   F0           MOVX      @DPTR,A
   \   0000B2   A3           INC       DPTR
   \   0000B3   7400         MOV       A,#0x0
   \   0000B5   F0           MOVX      @DPTR,A
   1756          
   1757                // Retrieve Identify Time
   1758                zcl_ReadAttrData( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   1759                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   \   0000B6                ; Setup parameters for call to function zcl_ReadAttrData
   \   0000B6   E4           CLR       A
   \   0000B7   F5..         MOV       ?V2,A
   \   0000B9   F5..         MOV       ?V3,A
   \   0000BB   78..         MOV       R0,#?V2
   \   0000BD   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C0   7402         MOV       A,#0x2
   \   0000C2   12....       LCALL     ?XSTACK_DISP100_8
   \   0000C5   88..         MOV       ?V2,R0
   \   0000C7   89..         MOV       ?V3,R1
   \   0000C9   78..         MOV       R0,#?V2
   \   0000CB   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000CE   7C00         MOV       R4,#0x0
   \   0000D0   7D00         MOV       R5,#0x0
   \   0000D2   8E82         MOV       DPL,R6
   \   0000D4   8F83         MOV       DPH,R7
   \   0000D6   E0           MOVX      A,@DPTR
   \   0000D7   F8           MOV       R0,A
   \   0000D8   A3           INC       DPTR
   \   0000D9   E0           MOVX      A,@DPTR
   \   0000DA   F583         MOV       DPH,A
   \   0000DC   8882         MOV       DPL,R0
   \   0000DE   A3           INC       DPTR
   \   0000DF   A3           INC       DPTR
   \   0000E0   A3           INC       DPTR
   \   0000E1   A3           INC       DPTR
   \   0000E2   E0           MOVX      A,@DPTR
   \   0000E3   FA           MOV       R2,A
   \   0000E4   A3           INC       DPTR
   \   0000E5   E0           MOVX      A,@DPTR
   \   0000E6   FB           MOV       R3,A
   \   0000E7   8E82         MOV       DPL,R6
   \   0000E9   8F83         MOV       DPH,R7
   \   0000EB   E0           MOVX      A,@DPTR
   \   0000EC   F8           MOV       R0,A
   \   0000ED   A3           INC       DPTR
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   C8           XCH       A,R0
   \   0000F0   2414         ADD       A,#0x14
   \   0000F2   F582         MOV       DPL,A
   \   0000F4   C8           XCH       A,R0
   \   0000F5   3400         ADDC      A,#0x0
   \   0000F7   F583         MOV       DPH,A
   \   0000F9   E0           MOVX      A,@DPTR
   \   0000FA   F9           MOV       R1,A
   \   0000FB   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   0000FE   7404         MOV       A,#0x4
   \   000100   12....       LCALL     ?DEALLOC_XSTACK8
   \   000103   E9           MOV       A,R1
   1760          
   1761                // Is device identifying itself?
   1762                if ( identifyTime > 0 )
   \   000104   85..82       MOV       DPL,?XSP + 0
   \   000107   85..83       MOV       DPH,?XSP + 1
   \   00010A   E0           MOVX      A,@DPTR
   \   00010B   F8           MOV       R0,A
   \   00010C   A3           INC       DPTR
   \   00010D   E0           MOVX      A,@DPTR
   \   00010E   F9           MOV       R1,A
   \   00010F   E8           MOV       A,R0
   \   000110   49           ORL       A,R1
   \   000111   7003         JNZ       $+5
   \   000113   02....       LJMP      ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
   1763                {
   1764                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1765                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   \   000116                ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
   \   000116   8E82         MOV       DPL,R6
   \   000118   8F83         MOV       DPH,R7
   \   00011A   A3           INC       DPTR
   \   00011B   A3           INC       DPTR
   \   00011C   A3           INC       DPTR
   \   00011D   A3           INC       DPTR
   \   00011E   A3           INC       DPTR
   \   00011F   A3           INC       DPTR
   \   000120   E0           MOVX      A,@DPTR
   \   000121   F5..         MOV       ?V2,A
   \   000123   78..         MOV       R0,#?V2
   \   000125   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000128   75..01       MOV       ?V2,#0x1
   \   00012B   78..         MOV       R0,#?V2
   \   00012D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000130   7402         MOV       A,#0x2
   \   000132   12....       LCALL     ?XSTACK_DISP0_8
   \   000135   E0           MOVX      A,@DPTR
   \   000136   FC           MOV       R4,A
   \   000137   A3           INC       DPTR
   \   000138   E0           MOVX      A,@DPTR
   \   000139   FD           MOV       R5,A
   \   00013A   8E82         MOV       DPL,R6
   \   00013C   8F83         MOV       DPH,R7
   \   00013E   E0           MOVX      A,@DPTR
   \   00013F   2406         ADD       A,#0x6
   \   000141   FA           MOV       R2,A
   \   000142   A3           INC       DPTR
   \   000143   E0           MOVX      A,@DPTR
   \   000144   3400         ADDC      A,#0x0
   \   000146   FB           MOV       R3,A
   \   000147   8E82         MOV       DPL,R6
   \   000149   8F83         MOV       DPH,R7
   \   00014B   E0           MOVX      A,@DPTR
   \   00014C   F8           MOV       R0,A
   \   00014D   A3           INC       DPTR
   \   00014E   E0           MOVX      A,@DPTR
   \   00014F   C8           XCH       A,R0
   \   000150   2414         ADD       A,#0x14
   \   000152   F582         MOV       DPL,A
   \   000154   C8           XCH       A,R0
   \   000155   3400         ADDC      A,#0x0
   \   000157   F583         MOV       DPH,A
   \   000159   E0           MOVX      A,@DPTR
   \   00015A   F9           MOV       R1,A
   \   00015B   12....       LCALL     `??zclGeneral_SendIdentifyQueryResponse::?relay`; Banked call to: zclGeneral_SendIdentifyQueryResponse
   \   00015E   7402         MOV       A,#0x2
   \   000160   12....       LCALL     ?DEALLOC_XSTACK8
   \   000163   E9           MOV       A,R1
   1766                  return ( ZCL_STATUS_CMD_HAS_RSP );
   \   000164   79FF         MOV       R1,#-0x1
   \   000166   807B         SJMP      ??zclGeneral_ProcessInIdentity_4
   1767                }
   1768              }
   1769          
   1770          #ifdef ZCL_LIGHT_LINK_ENHANCE
   1771              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_TRIGGER_EFFECT )
   1772              {
   1773                if ( pCBs->pfnIdentifyTriggerEffect )
   1774                {
   1775                  zclIdentifyTriggerEffect_t cmd;
   1776          
   1777                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1778                  cmd.effectId = pInMsg->pData[0];
   1779                  cmd.effectVariant = pInMsg->pData[1];
   1780          
   1781                  pCBs->pfnIdentifyTriggerEffect( &cmd );
   1782                }
   1783              }
   1784          #endif //ZCL_LIGHT_LINK_ENHANCE
   1785              else
   1786              {
   1787                return ( ZFailure );   // Error ignore the command
   \                     ??zclGeneral_ProcessInIdentity_3:
   \   000168   7901         MOV       R1,#0x1
   \   00016A   8077         SJMP      ??zclGeneral_ProcessInIdentity_4
   1788              }
   1789            }
   1790            else // Client Command
   1791            {
   1792              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   \                     ??zclGeneral_ProcessInIdentity_0:
   \   00016C   8E82         MOV       DPL,R6
   \   00016E   8F83         MOV       DPH,R7
   \   000170   A3           INC       DPTR
   \   000171   A3           INC       DPTR
   \   000172   A3           INC       DPTR
   \   000173   A3           INC       DPTR
   \   000174   A3           INC       DPTR
   \   000175   A3           INC       DPTR
   \   000176   A3           INC       DPTR
   \   000177   E0           MOVX      A,@DPTR
   \   000178   6004         JZ        ??zclGeneral_ProcessInIdentity_5
   1793                return ( ZFailure );   // Error ignore the command
   \   00017A   7901         MOV       R1,#0x1
   \   00017C   8065         SJMP      ??zclGeneral_ProcessInIdentity_4
   1794          
   1795              zclIdentifyQueryRsp_t rsp;
   1796              
   1797              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \                     ??zclGeneral_ProcessInIdentity_5:
   \   00017E   8E82         MOV       DPL,R6
   \   000180   8F83         MOV       DPH,R7
   \   000182   E0           MOVX      A,@DPTR
   \   000183   2406         ADD       A,#0x6
   \   000185   F8           MOV       R0,A
   \   000186   A3           INC       DPTR
   \   000187   E0           MOVX      A,@DPTR
   \   000188   3400         ADDC      A,#0x0
   \   00018A   F9           MOV       R1,A
   \   00018B   7402         MOV       A,#0x2
   \   00018D   12....       LCALL     ?XSTACK_DISP0_8
   \   000190   E8           MOV       A,R0
   \   000191   F0           MOVX      @DPTR,A
   \   000192   A3           INC       DPTR
   \   000193   E9           MOV       A,R1
   \   000194   F0           MOVX      @DPTR,A
   1798              rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \   000195   8E82         MOV       DPL,R6
   \   000197   8F83         MOV       DPH,R7
   \   000199   A3           INC       DPTR
   \   00019A   A3           INC       DPTR
   \   00019B   A3           INC       DPTR
   \   00019C   A3           INC       DPTR
   \   00019D   A3           INC       DPTR
   \   00019E   A3           INC       DPTR
   \   00019F   A3           INC       DPTR
   \   0001A0   A3           INC       DPTR
   \   0001A1   E0           MOVX      A,@DPTR
   \   0001A2   F8           MOV       R0,A
   \   0001A3   A3           INC       DPTR
   \   0001A4   E0           MOVX      A,@DPTR
   \   0001A5   F583         MOV       DPH,A
   \   0001A7   8882         MOV       DPL,R0
   \   0001A9   E0           MOVX      A,@DPTR
   \   0001AA   FA           MOV       R2,A
   \   0001AB   7B00         MOV       R3,#0x0
   \   0001AD   8E82         MOV       DPL,R6
   \   0001AF   8F83         MOV       DPH,R7
   \   0001B1   A3           INC       DPTR
   \   0001B2   A3           INC       DPTR
   \   0001B3   A3           INC       DPTR
   \   0001B4   A3           INC       DPTR
   \   0001B5   A3           INC       DPTR
   \   0001B6   A3           INC       DPTR
   \   0001B7   A3           INC       DPTR
   \   0001B8   A3           INC       DPTR
   \   0001B9   E0           MOVX      A,@DPTR
   \   0001BA   F8           MOV       R0,A
   \   0001BB   A3           INC       DPTR
   \   0001BC   E0           MOVX      A,@DPTR
   \   0001BD   F583         MOV       DPH,A
   \   0001BF   8882         MOV       DPL,R0
   \   0001C1   A3           INC       DPTR
   \   0001C2   E0           MOVX      A,@DPTR
   \   0001C3   F8           MOV       R0,A
   \   0001C4   7900         MOV       R1,#0x0
   \   0001C6   E4           CLR       A
   \   0001C7   C8           XCH       A,R0
   \   0001C8   F9           MOV       R1,A
   \   0001C9   EA           MOV       A,R2
   \   0001CA   28           ADD       A,R0
   \   0001CB   F8           MOV       R0,A
   \   0001CC   EB           MOV       A,R3
   \   0001CD   39           ADDC      A,R1
   \   0001CE   F9           MOV       R1,A
   \   0001CF   7404         MOV       A,#0x4
   \   0001D1   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D4   E8           MOV       A,R0
   \   0001D5   F0           MOVX      @DPTR,A
   \   0001D6   A3           INC       DPTR
   \   0001D7   E9           MOV       A,R1
   \   0001D8   F0           MOVX      @DPTR,A
   1799              
   1800              bdb_ZclIdentifyQueryCmdInd( &rsp );
   \   0001D9                ; Setup parameters for call to function bdb_ZclIdentifyQueryCmdInd
   \   0001D9   7402         MOV       A,#0x2
   \   0001DB   12....       LCALL     ?XSTACK_DISP101_8
   \   0001DE   12....       LCALL     `??bdb_ZclIdentifyQueryCmdInd::?relay`; Banked call to: bdb_ZclIdentifyQueryCmdInd
   1801            }
   1802            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInIdentity_2:
   \   0001E1   7900         MOV       R1,#0x0
   \                     ??zclGeneral_ProcessInIdentity_4:
   \   0001E3   7406         MOV       A,#0x6
   \   0001E5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001E8   7F04         MOV       R7,#0x4
   \   0001EA   02....       LJMP      ?BANKED_LEAVE_XDATA
   1803          }
   1804          #endif // ZCL_IDENTIFY
   1805          
   1806          #ifdef ZCL_GROUPS
   1807          
   1808          /*********************************************************************
   1809           * @fn      zclGeneral_AddGroup
   1810           *
   1811           * @brief   Add a Group.
   1812           *
   1813           * @param   endPoint - application endpoint
   1814           * @param   group - group to be added
   1815           * @param   pData - pointer to the group info
   1816           *
   1817           * @return  ZStatus_t
   1818           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1819          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   \                     zclGeneral_AddGroup:
   1820          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V1,R1
   \   00000C   8A..         MOV       ?V2,R2
   \   00000E   8B..         MOV       ?V3,R3
   \   000010   EC           MOV       A,R4
   \   000011   FE           MOV       R6,A
   \   000012   ED           MOV       A,R5
   \   000013   FF           MOV       R7,A
   1821            uint8 nameLen;
   1822            uint8 nameSupport = FALSE;
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   7400         MOV       A,#0x0
   \   00001C   F0           MOVX      @DPTR,A
   1823          
   1824            pData += 2;   // Move past group ID
   \   00001D   EE           MOV       A,R6
   \   00001E   2402         ADD       A,#0x2
   \   000020   FE           MOV       R6,A
   \   000021   5001         JNC       ??zclGeneral_AddGroup_0
   \   000023   0F           INC       R7
   1825            nameLen = *pData++;
   \                     ??zclGeneral_AddGroup_0:
   \   000024   8E82         MOV       DPL,R6
   \   000026   8F83         MOV       DPH,R7
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F5..         MOV       ?V0,A
   \   00002B   8E82         MOV       DPL,R6
   \   00002D   8F83         MOV       DPH,R7
   \   00002F   A3           INC       DPTR
   \   000030   AE82         MOV       R6,DPL
   \   000032   AF83         MOV       R7,DPH
   1826          
   1827            // Retrieve Name Support attribute
   1828            zcl_ReadAttrData( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS,
   1829                              ATTRID_GROUP_NAME_SUPPORT, &nameSupport, NULL );
   \   000034                ; Setup parameters for call to function zcl_ReadAttrData
   \   000034   E4           CLR       A
   \   000035   F5..         MOV       ?V4,A
   \   000037   F5..         MOV       ?V5,A
   \   000039   78..         MOV       R0,#?V4
   \   00003B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003E   7402         MOV       A,#0x2
   \   000040   12....       LCALL     ?XSTACK_DISP100_8
   \   000043   88..         MOV       ?V4,R0
   \   000045   89..         MOV       ?V5,R1
   \   000047   78..         MOV       R0,#?V4
   \   000049   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004C   7C00         MOV       R4,#0x0
   \   00004E   7D00         MOV       R5,#0x0
   \   000050   7A04         MOV       R2,#0x4
   \   000052   7B00         MOV       R3,#0x0
   \   000054   A9..         MOV       R1,?V1
   \   000056   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   000059   7404         MOV       A,#0x4
   \   00005B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005E   E9           MOV       A,R1
   1830          
   1831            if ( nameSupport )
   \   00005F   85..82       MOV       DPL,?XSP + 0
   \   000062   85..83       MOV       DPH,?XSP + 1
   \   000065   E0           MOVX      A,@DPTR
   \   000066   603B         JZ        ??zclGeneral_AddGroup_1
   1832            {
   1833              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   \   000068   E5..         MOV       A,?V0
   \   00006A   C3           CLR       C
   \   00006B   9410         SUBB      A,#0x10
   \   00006D   4003         JC        ??zclGeneral_AddGroup_2
   1834                 nameLen = (APS_GROUP_NAME_LEN-1);
   \   00006F   75..0F       MOV       ?V0,#0xf
   1835              group->name[0] = nameLen;
   \                     ??zclGeneral_AddGroup_2:
   \   000072   E5..         MOV       A,?V0
   \   000074   C0E0         PUSH      A
   \   000076   85..82       MOV       DPL,?V2
   \   000079   85..83       MOV       DPH,?V3
   \   00007C   A3           INC       DPTR
   \   00007D   A3           INC       DPTR
   \   00007E   D0E0         POP       A
   \   000080   F0           MOVX      @DPTR,A
   1836              zcl_memcpy( &(group->name[1]), pData, nameLen );
   \   000081                ; Setup parameters for call to function osal_memcpy
   \   000081   8E..         MOV       ?V4,R6
   \   000083   8F..         MOV       ?V5,R7
   \   000085   75..00       MOV       ?V6,#0x0
   \   000088   78..         MOV       R0,#?V4
   \   00008A   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00008D   E5..         MOV       A,?V0
   \   00008F   FC           MOV       R4,A
   \   000090   7D00         MOV       R5,#0x0
   \   000092   E5..         MOV       A,?V2
   \   000094   2403         ADD       A,#0x3
   \   000096   FA           MOV       R2,A
   \   000097   E4           CLR       A
   \   000098   35..         ADDC      A,?V3
   \   00009A   FB           MOV       R3,A
   \   00009B   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00009E   7403         MOV       A,#0x3
   \   0000A0   12....       LCALL     ?DEALLOC_XSTACK8
   1837            }
   1838          
   1839            return ( aps_AddGroup( endPoint, group ) );
   \                     ??zclGeneral_AddGroup_1:
   \   0000A3                ; Setup parameters for call to function aps_AddGroup
   \   0000A3   AA..         MOV       R2,?V2
   \   0000A5   AB..         MOV       R3,?V3
   \   0000A7   A9..         MOV       R1,?V1
   \   0000A9   12....       LCALL     `??aps_AddGroup::?relay`; Banked call to: aps_AddGroup
   \   0000AC   7401         MOV       A,#0x1
   \   0000AE   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B1   7F07         MOV       R7,#0x7
   \   0000B3   02....       LJMP      ?BANKED_LEAVE_XDATA
   1840          }
   1841          
   1842          /*********************************************************************
   1843           * @fn      zclGeneral_ProcessInGroupsServer
   1844           *
   1845           * @brief   Process in the received Groups Command.
   1846           *
   1847           * @param   pInMsg - pointer to the incoming message
   1848           *
   1849           * @return  ZStatus_t
   1850           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1851          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   \                     zclGeneral_ProcessInGroupsServer:
   1852          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 54
   \   000005   74CA         MOV       A,#-0x36
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   1853            aps_Group_t group;
   1854            aps_Group_t *pGroup;
   1855            uint8 *pData;
   1856            uint8 status;
   1857            uint8 grpCnt;
   1858            uint8 grpRspCnt = 0;
   \   00000E   75..00       MOV       ?V4,#0x0
   1859            uint16 *grpList;
   1860            uint16 identifyTime = 0;
   \   000011   7402         MOV       A,#0x2
   \   000013   12....       LCALL     ?XSTACK_DISP0_8
   \   000016   7400         MOV       A,#0x0
   \   000018   F0           MOVX      @DPTR,A
   \   000019   A3           INC       DPTR
   \   00001A   7400         MOV       A,#0x0
   \   00001C   F0           MOVX      @DPTR,A
   1861            uint8 i;
   1862            ZStatus_t stat = ZSuccess;
   \   00001D   7F00         MOV       R7,#0x0
   1863          
   1864            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   \   00001F                ; Setup parameters for call to function osal_memset
   \   00001F   7C12         MOV       R4,#0x12
   \   000021   7D00         MOV       R5,#0x0
   \   000023   7900         MOV       R1,#0x0
   \   000025   7404         MOV       A,#0x4
   \   000027   12....       LCALL     ?XSTACK_DISP101_8
   \   00002A   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1865          
   1866            pData = pInMsg->pData;
   \   00002D   85..82       MOV       DPL,?V0
   \   000030   85..83       MOV       DPH,?V1
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   F8           MOV       R0,A
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   F9           MOV       R1,A
   \   000040   88..         MOV       ?V6,R0
   \   000042   89..         MOV       ?V7,R1
   1867            group.ID = BUILD_UINT16( pData[0], pData[1] );
   \   000044   85..82       MOV       DPL,?V6
   \   000047   85..83       MOV       DPH,?V7
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   FA           MOV       R2,A
   \   00004C   7B00         MOV       R3,#0x0
   \   00004E   85..82       MOV       DPL,?V6
   \   000051   85..83       MOV       DPH,?V7
   \   000054   A3           INC       DPTR
   \   000055   E0           MOVX      A,@DPTR
   \   000056   F8           MOV       R0,A
   \   000057   7900         MOV       R1,#0x0
   \   000059   E4           CLR       A
   \   00005A   C8           XCH       A,R0
   \   00005B   F9           MOV       R1,A
   \   00005C   EA           MOV       A,R2
   \   00005D   28           ADD       A,R0
   \   00005E   F8           MOV       R0,A
   \   00005F   EB           MOV       A,R3
   \   000060   39           ADDC      A,R1
   \   000061   F9           MOV       R1,A
   \   000062   7404         MOV       A,#0x4
   \   000064   12....       LCALL     ?XSTACK_DISP0_8
   \   000067   E8           MOV       A,R0
   \   000068   F0           MOVX      @DPTR,A
   \   000069   A3           INC       DPTR
   \   00006A   E9           MOV       A,R1
   \   00006B   F0           MOVX      @DPTR,A
   1868            switch ( pInMsg->hdr.commandID )
   \   00006C   85..82       MOV       DPL,?V0
   \   00006F   85..83       MOV       DPH,?V1
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   A3           INC       DPTR
   \   000078   A3           INC       DPTR
   \   000079   E0           MOVX      A,@DPTR
   \   00007A   6021         JZ        ??zclGeneral_ProcessInGroupsServer_0
   \   00007C   14           DEC       A
   \   00007D   7003         JNZ       $+5
   \   00007F   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_1 & 0xFFFF
   \   000082   14           DEC       A
   \   000083   7003         JNZ       $+5
   \   000085   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_2 & 0xFFFF
   \   000088   14           DEC       A
   \   000089   7003         JNZ       $+5
   \   00008B   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_3 & 0xFFFF
   \   00008E   14           DEC       A
   \   00008F   7003         JNZ       $+5
   \   000091   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_4 & 0xFFFF
   \   000094   14           DEC       A
   \   000095   7003         JNZ       $+5
   \   000097   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_5 & 0xFFFF
   \   00009A   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_6 & 0xFFFF
   1869            {
   1870              case COMMAND_GROUP_ADD:
   1871                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   \                     ??zclGeneral_ProcessInGroupsServer_0:
   \   00009D                ; Setup parameters for call to function zclGeneral_AddGroup
   \   00009D   AC..         MOV       R4,?V6
   \   00009F   AD..         MOV       R5,?V7
   \   0000A1   7404         MOV       A,#0x4
   \   0000A3   12....       LCALL     ?XSTACK_DISP101_8
   \   0000A6   85..82       MOV       DPL,?V0
   \   0000A9   85..83       MOV       DPH,?V1
   \   0000AC   E0           MOVX      A,@DPTR
   \   0000AD   F8           MOV       R0,A
   \   0000AE   A3           INC       DPTR
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   C8           XCH       A,R0
   \   0000B1   2414         ADD       A,#0x14
   \   0000B3   F582         MOV       DPL,A
   \   0000B5   C8           XCH       A,R0
   \   0000B6   3400         ADDC      A,#0x0
   \   0000B8   F583         MOV       DPH,A
   \   0000BA   E0           MOVX      A,@DPTR
   \   0000BB   F9           MOV       R1,A
   \   0000BC   12....       LCALL     `??zclGeneral_AddGroup::?relay`; Banked call to: zclGeneral_AddGroup
   \   0000BF   E9           MOV       A,R1
   \   0000C0   FE           MOV       R6,A
   1872                if ( status != ZSuccess )
   \   0000C1   EE           MOV       A,R6
   \   0000C2   600B         JZ        ??zclGeneral_ProcessInGroupsServer_7
   1873                {
   1874                  if ( status == ZApsDuplicateEntry )
   \   0000C4   74B8         MOV       A,#-0x48
   \   0000C6   6E           XRL       A,R6
   \   0000C7   7004         JNZ       ??zclGeneral_ProcessInGroupsServer_8
   1875                  {
   1876                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   \   0000C9   7E8A         MOV       R6,#-0x76
   \   0000CB   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_7
   1877                  }
   1878                  else
   1879                  {
   1880                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   \                     ??zclGeneral_ProcessInGroupsServer_8:
   \   0000CD   7E89         MOV       R6,#-0x77
   1881                  }
   1882                }
   1883          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1884                if ( UNICAST_MSG( pInMsg->msg ) )
   1885          #endif
   1886                {
   1887                  zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1888                                                   status, group.ID, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_7:
   \   0000CF                ; Setup parameters for call to function zclGeneral_SendGroupResponse
   \   0000CF   85..82       MOV       DPL,?V0
   \   0000D2   85..83       MOV       DPH,?V1
   \   0000D5   A3           INC       DPTR
   \   0000D6   A3           INC       DPTR
   \   0000D7   A3           INC       DPTR
   \   0000D8   A3           INC       DPTR
   \   0000D9   A3           INC       DPTR
   \   0000DA   A3           INC       DPTR
   \   0000DB   E0           MOVX      A,@DPTR
   \   0000DC   F5..         MOV       ?V3,A
   \   0000DE   78..         MOV       R0,#?V3
   \   0000E0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E3   75..01       MOV       ?V3,#0x1
   \   0000E6   78..         MOV       R0,#?V3
   \   0000E8   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000EB   7406         MOV       A,#0x6
   \   0000ED   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F0   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0000F3   EE           MOV       A,R6
   \   0000F4   FD           MOV       R5,A
   \   0000F5   7C00         MOV       R4,#0x0
   \   0000F7   85..82       MOV       DPL,?V0
   \   0000FA   85..83       MOV       DPH,?V1
   \   0000FD   E0           MOVX      A,@DPTR
   \   0000FE   2406         ADD       A,#0x6
   \   000100   FA           MOV       R2,A
   \   000101   A3           INC       DPTR
   \   000102   E0           MOVX      A,@DPTR
   \   000103   3400         ADDC      A,#0x0
   \   000105   FB           MOV       R3,A
   \   000106   85..82       MOV       DPL,?V0
   \   000109   85..83       MOV       DPH,?V1
   \   00010C   E0           MOVX      A,@DPTR
   \   00010D   F8           MOV       R0,A
   \   00010E   A3           INC       DPTR
   \   00010F   E0           MOVX      A,@DPTR
   \   000110   C8           XCH       A,R0
   \   000111   2414         ADD       A,#0x14
   \   000113   F582         MOV       DPL,A
   \   000115   C8           XCH       A,R0
   \   000116   3400         ADDC      A,#0x0
   \   000118   F583         MOV       DPH,A
   \   00011A   E0           MOVX      A,@DPTR
   \   00011B   F9           MOV       R1,A
   \   00011C   12....       LCALL     `??zclGeneral_SendGroupResponse::?relay`; Banked call to: zclGeneral_SendGroupResponse
   \   00011F   7404         MOV       A,#0x4
   \   000121   12....       LCALL     ?DEALLOC_XSTACK8
   \   000124   E9           MOV       A,R1
   1889                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \   000125   7FFF         MOV       R7,#-0x1
   1890                }
   1891                break;
   \   000127   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_9 & 0xFFFF
   1892          
   1893              case COMMAND_GROUP_VIEW:
   1894          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1895                if ( UNICAST_MSG( pInMsg->msg ) )
   1896          #endif
   1897                {
   1898                  pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   \                     ??zclGeneral_ProcessInGroupsServer_1:
   \   00012A                ; Setup parameters for call to function aps_FindGroup
   \   00012A   7404         MOV       A,#0x4
   \   00012C   12....       LCALL     ?XSTACK_DISP0_8
   \   00012F   E0           MOVX      A,@DPTR
   \   000130   FA           MOV       R2,A
   \   000131   A3           INC       DPTR
   \   000132   E0           MOVX      A,@DPTR
   \   000133   FB           MOV       R3,A
   \   000134   85..82       MOV       DPL,?V0
   \   000137   85..83       MOV       DPH,?V1
   \   00013A   E0           MOVX      A,@DPTR
   \   00013B   F8           MOV       R0,A
   \   00013C   A3           INC       DPTR
   \   00013D   E0           MOVX      A,@DPTR
   \   00013E   C8           XCH       A,R0
   \   00013F   2414         ADD       A,#0x14
   \   000141   F582         MOV       DPL,A
   \   000143   C8           XCH       A,R0
   \   000144   3400         ADDC      A,#0x0
   \   000146   F583         MOV       DPH,A
   \   000148   E0           MOVX      A,@DPTR
   \   000149   F9           MOV       R1,A
   \   00014A   12....       LCALL     `??aps_FindGroup::?relay`; Banked call to: aps_FindGroup
   \   00014D   8A..         MOV       ?V8,R2
   \   00014F   8B..         MOV       ?V9,R3
   \   000151   85....       MOV       ?V12,?V8
   \   000154   85....       MOV       ?V13,?V9
   1899                  if ( pGroup )
   \   000157   E5..         MOV       A,?V12
   \   000159   45..         ORL       A,?V13
   \   00015B   6004         JZ        ??zclGeneral_ProcessInGroupsServer_10
   1900                  {
   1901                    status = ZCL_STATUS_SUCCESS;
   \   00015D   7E00         MOV       R6,#0x0
   \   00015F   8011         SJMP      ??zclGeneral_ProcessInGroupsServer_11
   1902                  }
   1903                  else
   1904                  {
   1905                    // Group not found
   1906                    status = ZCL_STATUS_NOT_FOUND;
   \                     ??zclGeneral_ProcessInGroupsServer_10:
   \   000161   7E8B         MOV       R6,#-0x75
   1907                    pGroup = &group;
   \   000163   7404         MOV       A,#0x4
   \   000165   12....       LCALL     ?XSTACK_DISP100_8
   \   000168   88..         MOV       ?V8,R0
   \   00016A   89..         MOV       ?V9,R1
   \   00016C   85....       MOV       ?V12,?V8
   \   00016F   85....       MOV       ?V13,?V9
   1908                  }
   1909                  zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1910                                                    status, pGroup, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_11:
   \   000172                ; Setup parameters for call to function zclGeneral_SendGroupViewResponse
   \   000172   85..82       MOV       DPL,?V0
   \   000175   85..83       MOV       DPH,?V1
   \   000178   A3           INC       DPTR
   \   000179   A3           INC       DPTR
   \   00017A   A3           INC       DPTR
   \   00017B   A3           INC       DPTR
   \   00017C   A3           INC       DPTR
   \   00017D   A3           INC       DPTR
   \   00017E   E0           MOVX      A,@DPTR
   \   00017F   F5..         MOV       ?V3,A
   \   000181   78..         MOV       R0,#?V3
   \   000183   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000186   85....       MOV       ?V8,?V12
   \   000189   85....       MOV       ?V9,?V13
   \   00018C   78..         MOV       R0,#?V8
   \   00018E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000191   7D01         MOV       R5,#0x1
   \   000193   EE           MOV       A,R6
   \   000194   FC           MOV       R4,A
   \   000195   85..82       MOV       DPL,?V0
   \   000198   85..83       MOV       DPH,?V1
   \   00019B   E0           MOVX      A,@DPTR
   \   00019C   2406         ADD       A,#0x6
   \   00019E   FA           MOV       R2,A
   \   00019F   A3           INC       DPTR
   \   0001A0   E0           MOVX      A,@DPTR
   \   0001A1   3400         ADDC      A,#0x0
   \   0001A3   FB           MOV       R3,A
   \   0001A4   85..82       MOV       DPL,?V0
   \   0001A7   85..83       MOV       DPH,?V1
   \   0001AA   E0           MOVX      A,@DPTR
   \   0001AB   F8           MOV       R0,A
   \   0001AC   A3           INC       DPTR
   \   0001AD   E0           MOVX      A,@DPTR
   \   0001AE   C8           XCH       A,R0
   \   0001AF   2414         ADD       A,#0x14
   \   0001B1   F582         MOV       DPL,A
   \   0001B3   C8           XCH       A,R0
   \   0001B4   3400         ADDC      A,#0x0
   \   0001B6   F583         MOV       DPH,A
   \   0001B8   E0           MOVX      A,@DPTR
   \   0001B9   F9           MOV       R1,A
   \   0001BA   12....       LCALL     `??zclGeneral_SendGroupViewResponse::?relay`; Banked call to: zclGeneral_SendGroupViewResponse
   \   0001BD   7403         MOV       A,#0x3
   \   0001BF   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001C2   E9           MOV       A,R1
   1911                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \   0001C3   7FFF         MOV       R7,#-0x1
   1912                }
   1913                break;
   \   0001C5   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_9 & 0xFFFF
   1914          
   1915              case COMMAND_GROUP_GET_MEMBERSHIP:
   1916          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1917                if ( UNICAST_MSG( pInMsg->msg ) )
   1918          #endif
   1919                {
   1920                  grpCnt = *pData++;
   \                     ??zclGeneral_ProcessInGroupsServer_2:
   \   0001C8   85..82       MOV       DPL,?V6
   \   0001CB   85..83       MOV       DPH,?V7
   \   0001CE   E0           MOVX      A,@DPTR
   \   0001CF   F5..         MOV       ?V5,A
   \   0001D1   85..82       MOV       DPL,?V6
   \   0001D4   85..83       MOV       DPH,?V7
   \   0001D7   A3           INC       DPTR
   \   0001D8   8582..       MOV       ?V6,DPL
   \   0001DB   8583..       MOV       ?V7,DPH
   1921          
   1922                  // Allocate space for the group list
   1923                  grpList = zcl_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   \   0001DE                ; Setup parameters for call to function osal_mem_alloc
   \   0001DE   7A20         MOV       R2,#0x20
   \   0001E0   7B00         MOV       R3,#0x0
   \   0001E2   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0001E5   8A..         MOV       ?V8,R2
   \   0001E7   8B..         MOV       ?V9,R3
   \   0001E9   85....       MOV       ?V10,?V8
   \   0001EC   85....       MOV       ?V11,?V9
   1924                  if ( grpList != NULL )
   \   0001EF   E5..         MOV       A,?V10
   \   0001F1   45..         ORL       A,?V11
   \   0001F3   7003         JNZ       $+5
   \   0001F5   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_12 & 0xFFFF
   1925                  {
   1926                    if ( grpCnt == 0 )
   \   0001F8   E5..         MOV       A,?V5
   \   0001FA   7023         JNZ       ??zclGeneral_ProcessInGroupsServer_13
   1927                    {
   1928                      // Find out all the groups of which the endpoint is a member.
   1929                      grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   \   0001FC                ; Setup parameters for call to function aps_FindAllGroupsForEndpoint
   \   0001FC   AA..         MOV       R2,?V10
   \   0001FE   AB..         MOV       R3,?V11
   \   000200   85..82       MOV       DPL,?V0
   \   000203   85..83       MOV       DPH,?V1
   \   000206   E0           MOVX      A,@DPTR
   \   000207   F8           MOV       R0,A
   \   000208   A3           INC       DPTR
   \   000209   E0           MOVX      A,@DPTR
   \   00020A   C8           XCH       A,R0
   \   00020B   2414         ADD       A,#0x14
   \   00020D   F582         MOV       DPL,A
   \   00020F   C8           XCH       A,R0
   \   000210   3400         ADDC      A,#0x0
   \   000212   F583         MOV       DPH,A
   \   000214   E0           MOVX      A,@DPTR
   \   000215   F9           MOV       R1,A
   \   000216   12....       LCALL     `??aps_FindAllGroupsForEndpoint::?relay`; Banked call to: aps_FindAllGroupsForEndpoint
   \   000219   E9           MOV       A,R1
   \   00021A   F5..         MOV       ?V4,A
   \   00021C   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_14 & 0xFFFF
   1930                    }
   1931                    else
   1932                    {
   1933                      // Find out the groups (in the list) of which the endpoint is a member.
   1934                      for ( i = 0; i < grpCnt; i++ )
   \                     ??zclGeneral_ProcessInGroupsServer_13:
   \   00021F   75..00       MOV       ?V2,#0x0
   \                     ??zclGeneral_ProcessInGroupsServer_15:
   \   000222   E5..         MOV       A,?V2
   \   000224   C3           CLR       C
   \   000225   95..         SUBB      A,?V5
   \   000227   4003         JC        $+5
   \   000229   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_14 & 0xFFFF
   1935                      {
   1936                        group.ID = BUILD_UINT16( pData[0], pData[1] );
   \   00022C   85..82       MOV       DPL,?V6
   \   00022F   85..83       MOV       DPH,?V7
   \   000232   E0           MOVX      A,@DPTR
   \   000233   FA           MOV       R2,A
   \   000234   7B00         MOV       R3,#0x0
   \   000236   85..82       MOV       DPL,?V6
   \   000239   85..83       MOV       DPH,?V7
   \   00023C   A3           INC       DPTR
   \   00023D   E0           MOVX      A,@DPTR
   \   00023E   F8           MOV       R0,A
   \   00023F   7900         MOV       R1,#0x0
   \   000241   E4           CLR       A
   \   000242   C8           XCH       A,R0
   \   000243   F9           MOV       R1,A
   \   000244   EA           MOV       A,R2
   \   000245   28           ADD       A,R0
   \   000246   F8           MOV       R0,A
   \   000247   EB           MOV       A,R3
   \   000248   39           ADDC      A,R1
   \   000249   F9           MOV       R1,A
   \   00024A   7404         MOV       A,#0x4
   \   00024C   12....       LCALL     ?XSTACK_DISP0_8
   \   00024F   E8           MOV       A,R0
   \   000250   F0           MOVX      @DPTR,A
   \   000251   A3           INC       DPTR
   \   000252   E9           MOV       A,R1
   \   000253   F0           MOVX      @DPTR,A
   1937                        pData += 2;
   \   000254   E5..         MOV       A,?V6
   \   000256   2402         ADD       A,#0x2
   \   000258   F5..         MOV       ?V6,A
   \   00025A   5002         JNC       ??zclGeneral_ProcessInGroupsServer_16
   \   00025C   05..         INC       ?V7
   1938          
   1939                        if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   \                     ??zclGeneral_ProcessInGroupsServer_16:
   \   00025E                ; Setup parameters for call to function aps_FindGroup
   \   00025E   7404         MOV       A,#0x4
   \   000260   12....       LCALL     ?XSTACK_DISP0_8
   \   000263   E0           MOVX      A,@DPTR
   \   000264   FA           MOV       R2,A
   \   000265   A3           INC       DPTR
   \   000266   E0           MOVX      A,@DPTR
   \   000267   FB           MOV       R3,A
   \   000268   85..82       MOV       DPL,?V0
   \   00026B   85..83       MOV       DPH,?V1
   \   00026E   E0           MOVX      A,@DPTR
   \   00026F   F8           MOV       R0,A
   \   000270   A3           INC       DPTR
   \   000271   E0           MOVX      A,@DPTR
   \   000272   C8           XCH       A,R0
   \   000273   2414         ADD       A,#0x14
   \   000275   F582         MOV       DPL,A
   \   000277   C8           XCH       A,R0
   \   000278   3400         ADDC      A,#0x0
   \   00027A   F583         MOV       DPH,A
   \   00027C   E0           MOVX      A,@DPTR
   \   00027D   F9           MOV       R1,A
   \   00027E   12....       LCALL     `??aps_FindGroup::?relay`; Banked call to: aps_FindGroup
   \   000281   8A..         MOV       ?V8,R2
   \   000283   8B..         MOV       ?V9,R3
   \   000285   E5..         MOV       A,?V8
   \   000287   45..         ORL       A,?V9
   \   000289   6035         JZ        ??zclGeneral_ProcessInGroupsServer_17
   1940                          grpList[grpRspCnt++] = group.ID;
   \   00028B   7404         MOV       A,#0x4
   \   00028D   12....       LCALL     ?XSTACK_DISP0_8
   \   000290   E0           MOVX      A,@DPTR
   \   000291   FA           MOV       R2,A
   \   000292   A3           INC       DPTR
   \   000293   E0           MOVX      A,@DPTR
   \   000294   FB           MOV       R3,A
   \   000295   E5..         MOV       A,?V4
   \   000297   F8           MOV       R0,A
   \   000298   7900         MOV       R1,#0x0
   \   00029A   E8           MOV       A,R0
   \   00029B   75F002       MOV       B,#0x2
   \   00029E   A4           MUL       AB
   \   00029F   C8           XCH       A,R0
   \   0002A0   ACF0         MOV       R4,B
   \   0002A2   75F000       MOV       B,#0x0
   \   0002A5   A4           MUL       AB
   \   0002A6   2C           ADD       A,R4
   \   0002A7   FC           MOV       R4,A
   \   0002A8   75F002       MOV       B,#0x2
   \   0002AB   E9           MOV       A,R1
   \   0002AC   A4           MUL       AB
   \   0002AD   2C           ADD       A,R4
   \   0002AE   F9           MOV       R1,A
   \   0002AF   E5..         MOV       A,?V10
   \   0002B1   28           ADD       A,R0
   \   0002B2   F582         MOV       DPL,A
   \   0002B4   E5..         MOV       A,?V11
   \   0002B6   39           ADDC      A,R1
   \   0002B7   F583         MOV       DPH,A
   \   0002B9   EA           MOV       A,R2
   \   0002BA   F0           MOVX      @DPTR,A
   \   0002BB   A3           INC       DPTR
   \   0002BC   EB           MOV       A,R3
   \   0002BD   F0           MOVX      @DPTR,A
   \   0002BE   05..         INC       ?V4
   1941                      }
   \                     ??zclGeneral_ProcessInGroupsServer_17:
   \   0002C0   05..         INC       ?V2
   \   0002C2   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_15 & 0xFFFF
   1942                    }
   1943          
   1944                    if ( grpCnt == 0 ||  grpRspCnt != 0 )
   \                     ??zclGeneral_ProcessInGroupsServer_14:
   \   0002C5   E5..         MOV       A,?V5
   \   0002C7   6004         JZ        ??zclGeneral_ProcessInGroupsServer_18
   \   0002C9   E5..         MOV       A,?V4
   \   0002CB   6074         JZ        ??zclGeneral_ProcessInGroupsServer_19
   1945                    {
   1946                      zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1947                                                                 aps_GroupsRemaingCapacity(), grpRspCnt,
   1948                                                                 grpList, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_18:
   \   0002CD                ; Setup parameters for call to function aps_CountAllGroups
   \   0002CD   12....       LCALL     `??aps_CountAllGroups::?relay`; Banked call to: aps_CountAllGroups
   \   0002D0   E9           MOV       A,R1
   \   0002D1   F9           MOV       R1,A
   \   0002D2                ; Setup parameters for call to function zclGeneral_SendGroupGetMembershipRequest
   \   0002D2   85..82       MOV       DPL,?V0
   \   0002D5   85..83       MOV       DPH,?V1
   \   0002D8   A3           INC       DPTR
   \   0002D9   A3           INC       DPTR
   \   0002DA   A3           INC       DPTR
   \   0002DB   A3           INC       DPTR
   \   0002DC   A3           INC       DPTR
   \   0002DD   A3           INC       DPTR
   \   0002DE   E0           MOVX      A,@DPTR
   \   0002DF   F5..         MOV       ?V3,A
   \   0002E1   78..         MOV       R0,#?V3
   \   0002E3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002E6   75..01       MOV       ?V3,#0x1
   \   0002E9   78..         MOV       R0,#?V3
   \   0002EB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002EE   78..         MOV       R0,#?V10
   \   0002F0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0002F3   E5..         MOV       A,?V4
   \   0002F5   F5..         MOV       ?V3,A
   \   0002F7   78..         MOV       R0,#?V3
   \   0002F9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002FC   7410         MOV       A,#0x10
   \   0002FE   C3           CLR       C
   \   0002FF   99           SUBB      A,R1
   \   000300   F5..         MOV       ?V3,A
   \   000302   78..         MOV       R0,#?V3
   \   000304   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000307   75..01       MOV       ?V3,#0x1
   \   00030A   78..         MOV       R0,#?V3
   \   00030C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00030F   7D01         MOV       R5,#0x1
   \   000311   7C02         MOV       R4,#0x2
   \   000313   85..82       MOV       DPL,?V0
   \   000316   85..83       MOV       DPH,?V1
   \   000319   E0           MOVX      A,@DPTR
   \   00031A   2406         ADD       A,#0x6
   \   00031C   FA           MOV       R2,A
   \   00031D   A3           INC       DPTR
   \   00031E   E0           MOVX      A,@DPTR
   \   00031F   3400         ADDC      A,#0x0
   \   000321   FB           MOV       R3,A
   \   000322   85..82       MOV       DPL,?V0
   \   000325   85..83       MOV       DPH,?V1
   \   000328   E0           MOVX      A,@DPTR
   \   000329   F8           MOV       R0,A
   \   00032A   A3           INC       DPTR
   \   00032B   E0           MOVX      A,@DPTR
   \   00032C   C8           XCH       A,R0
   \   00032D   2414         ADD       A,#0x14
   \   00032F   F582         MOV       DPL,A
   \   000331   C8           XCH       A,R0
   \   000332   3400         ADDC      A,#0x0
   \   000334   F583         MOV       DPH,A
   \   000336   E0           MOVX      A,@DPTR
   \   000337   F9           MOV       R1,A
   \   000338   12....       LCALL     `??zclGeneral_SendGroupGetMembershipRequest::?re`; Banked call to: zclGeneral_SendGroupGetMembershipRequest
   \   00033B   7407         MOV       A,#0x7
   \   00033D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000340   E9           MOV       A,R1
   1949                    }
   1950          
   1951                    zcl_mem_free( grpList );
   \                     ??zclGeneral_ProcessInGroupsServer_19:
   \   000341                ; Setup parameters for call to function osal_mem_free
   \   000341   AA..         MOV       R2,?V10
   \   000343   AB..         MOV       R3,?V11
   \   000345   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000348   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_20 & 0xFFFF
   1952                  }
   1953                  else
   1954                  {
   1955                    // Couldn't allocate space for the group list -- send a Default Response command back.
   1956                    zclDefaultRspCmd_t defaultRspCmd;
   1957          
   1958                    defaultRspCmd.commandID = pInMsg->hdr.commandID;
   \                     ??zclGeneral_ProcessInGroupsServer_12:
   \   00034B   85..82       MOV       DPL,?V0
   \   00034E   85..83       MOV       DPH,?V1
   \   000351   A3           INC       DPTR
   \   000352   A3           INC       DPTR
   \   000353   A3           INC       DPTR
   \   000354   A3           INC       DPTR
   \   000355   A3           INC       DPTR
   \   000356   A3           INC       DPTR
   \   000357   A3           INC       DPTR
   \   000358   E0           MOVX      A,@DPTR
   \   000359   C0E0         PUSH      A
   \   00035B   85..82       MOV       DPL,?XSP + 0
   \   00035E   85..83       MOV       DPH,?XSP + 1
   \   000361   D0E0         POP       A
   \   000363   F0           MOVX      @DPTR,A
   1959                    defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   \   000364   7401         MOV       A,#0x1
   \   000366   12....       LCALL     ?XSTACK_DISP0_8
   \   000369   7489         MOV       A,#-0x77
   \   00036B   F0           MOVX      @DPTR,A
   1960                    zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1961                                           pInMsg->msg->clusterId, &defaultRspCmd,
   1962                                           ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   \   00036C                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   00036C   85..82       MOV       DPL,?V0
   \   00036F   85..83       MOV       DPH,?V1
   \   000372   A3           INC       DPTR
   \   000373   A3           INC       DPTR
   \   000374   A3           INC       DPTR
   \   000375   A3           INC       DPTR
   \   000376   A3           INC       DPTR
   \   000377   A3           INC       DPTR
   \   000378   E0           MOVX      A,@DPTR
   \   000379   F5..         MOV       ?V3,A
   \   00037B   78..         MOV       R0,#?V3
   \   00037D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000380   E4           CLR       A
   \   000381   F5..         MOV       ?V8,A
   \   000383   F5..         MOV       ?V9,A
   \   000385   78..         MOV       R0,#?V8
   \   000387   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00038A   75..01       MOV       ?V3,#0x1
   \   00038D   78..         MOV       R0,#?V3
   \   00038F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000392   75..01       MOV       ?V3,#0x1
   \   000395   78..         MOV       R0,#?V3
   \   000397   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00039A   7405         MOV       A,#0x5
   \   00039C   12....       LCALL     ?XSTACK_DISP100_8
   \   00039F   88..         MOV       ?V8,R0
   \   0003A1   89..         MOV       ?V9,R1
   \   0003A3   78..         MOV       R0,#?V8
   \   0003A5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0003A8   85..82       MOV       DPL,?V0
   \   0003AB   85..83       MOV       DPH,?V1
   \   0003AE   E0           MOVX      A,@DPTR
   \   0003AF   F8           MOV       R0,A
   \   0003B0   A3           INC       DPTR
   \   0003B1   E0           MOVX      A,@DPTR
   \   0003B2   F583         MOV       DPH,A
   \   0003B4   8882         MOV       DPL,R0
   \   0003B6   A3           INC       DPTR
   \   0003B7   A3           INC       DPTR
   \   0003B8   A3           INC       DPTR
   \   0003B9   A3           INC       DPTR
   \   0003BA   E0           MOVX      A,@DPTR
   \   0003BB   FC           MOV       R4,A
   \   0003BC   A3           INC       DPTR
   \   0003BD   E0           MOVX      A,@DPTR
   \   0003BE   FD           MOV       R5,A
   \   0003BF   85..82       MOV       DPL,?V0
   \   0003C2   85..83       MOV       DPH,?V1
   \   0003C5   E0           MOVX      A,@DPTR
   \   0003C6   2406         ADD       A,#0x6
   \   0003C8   FA           MOV       R2,A
   \   0003C9   A3           INC       DPTR
   \   0003CA   E0           MOVX      A,@DPTR
   \   0003CB   3400         ADDC      A,#0x0
   \   0003CD   FB           MOV       R3,A
   \   0003CE   85..82       MOV       DPL,?V0
   \   0003D1   85..83       MOV       DPH,?V1
   \   0003D4   E0           MOVX      A,@DPTR
   \   0003D5   F8           MOV       R0,A
   \   0003D6   A3           INC       DPTR
   \   0003D7   E0           MOVX      A,@DPTR
   \   0003D8   C8           XCH       A,R0
   \   0003D9   2414         ADD       A,#0x14
   \   0003DB   F582         MOV       DPL,A
   \   0003DD   C8           XCH       A,R0
   \   0003DE   3400         ADDC      A,#0x0
   \   0003E0   F583         MOV       DPH,A
   \   0003E2   E0           MOVX      A,@DPTR
   \   0003E3   F9           MOV       R1,A
   \   0003E4   12....       LCALL     `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   0003E7   7407         MOV       A,#0x7
   \   0003E9   12....       LCALL     ?DEALLOC_XSTACK8
   \   0003EC   E9           MOV       A,R1
   1963                  }
   1964          
   1965                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \                     ??zclGeneral_ProcessInGroupsServer_20:
   \   0003ED   7FFF         MOV       R7,#-0x1
   1966                }
   1967                break;
   \   0003EF   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_9 & 0xFFFF
   1968          
   1969              case COMMAND_GROUP_REMOVE:
   1970          #if defined ( ZCL_SCENES )
   1971                zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, group.ID );
   1972          #endif
   1973                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   \                     ??zclGeneral_ProcessInGroupsServer_3:
   \   0003F2                ; Setup parameters for call to function aps_RemoveGroup
   \   0003F2   7404         MOV       A,#0x4
   \   0003F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0003F7   E0           MOVX      A,@DPTR
   \   0003F8   FA           MOV       R2,A
   \   0003F9   A3           INC       DPTR
   \   0003FA   E0           MOVX      A,@DPTR
   \   0003FB   FB           MOV       R3,A
   \   0003FC   85..82       MOV       DPL,?V0
   \   0003FF   85..83       MOV       DPH,?V1
   \   000402   E0           MOVX      A,@DPTR
   \   000403   F8           MOV       R0,A
   \   000404   A3           INC       DPTR
   \   000405   E0           MOVX      A,@DPTR
   \   000406   C8           XCH       A,R0
   \   000407   2414         ADD       A,#0x14
   \   000409   F582         MOV       DPL,A
   \   00040B   C8           XCH       A,R0
   \   00040C   3400         ADDC      A,#0x0
   \   00040E   F583         MOV       DPH,A
   \   000410   E0           MOVX      A,@DPTR
   \   000411   F9           MOV       R1,A
   \   000412   12....       LCALL     `??aps_RemoveGroup::?relay`; Banked call to: aps_RemoveGroup
   \   000415   E9           MOV       A,R1
   \   000416   6004         JZ        ??zclGeneral_ProcessInGroupsServer_21
   1974                {
   1975                  status = ZCL_STATUS_SUCCESS;
   \   000418   7E00         MOV       R6,#0x0
   \   00041A   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_22
   1976                }
   1977                else
   1978                {
   1979                  status = ZCL_STATUS_NOT_FOUND;
   \                     ??zclGeneral_ProcessInGroupsServer_21:
   \   00041C   7E8B         MOV       R6,#-0x75
   1980                }
   1981          
   1982          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1983                if ( UNICAST_MSG( pInMsg->msg ) )
   1984          #endif
   1985                {
   1986                  zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1987                                                      status, group.ID, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_22:
   \   00041E                ; Setup parameters for call to function zclGeneral_SendGroupResponse
   \   00041E   85..82       MOV       DPL,?V0
   \   000421   85..83       MOV       DPH,?V1
   \   000424   A3           INC       DPTR
   \   000425   A3           INC       DPTR
   \   000426   A3           INC       DPTR
   \   000427   A3           INC       DPTR
   \   000428   A3           INC       DPTR
   \   000429   A3           INC       DPTR
   \   00042A   E0           MOVX      A,@DPTR
   \   00042B   F5..         MOV       ?V3,A
   \   00042D   78..         MOV       R0,#?V3
   \   00042F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000432   75..01       MOV       ?V3,#0x1
   \   000435   78..         MOV       R0,#?V3
   \   000437   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00043A   7406         MOV       A,#0x6
   \   00043C   12....       LCALL     ?XSTACK_DISP0_8
   \   00043F   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000442   EE           MOV       A,R6
   \   000443   FD           MOV       R5,A
   \   000444   7C03         MOV       R4,#0x3
   \   000446   85..82       MOV       DPL,?V0
   \   000449   85..83       MOV       DPH,?V1
   \   00044C   E0           MOVX      A,@DPTR
   \   00044D   2406         ADD       A,#0x6
   \   00044F   FA           MOV       R2,A
   \   000450   A3           INC       DPTR
   \   000451   E0           MOVX      A,@DPTR
   \   000452   3400         ADDC      A,#0x0
   \   000454   FB           MOV       R3,A
   \   000455   85..82       MOV       DPL,?V0
   \   000458   85..83       MOV       DPH,?V1
   \   00045B   E0           MOVX      A,@DPTR
   \   00045C   F8           MOV       R0,A
   \   00045D   A3           INC       DPTR
   \   00045E   E0           MOVX      A,@DPTR
   \   00045F   C8           XCH       A,R0
   \   000460   2414         ADD       A,#0x14
   \   000462   F582         MOV       DPL,A
   \   000464   C8           XCH       A,R0
   \   000465   3400         ADDC      A,#0x0
   \   000467   F583         MOV       DPH,A
   \   000469   E0           MOVX      A,@DPTR
   \   00046A   F9           MOV       R1,A
   \   00046B   12....       LCALL     `??zclGeneral_SendGroupResponse::?relay`; Banked call to: zclGeneral_SendGroupResponse
   \   00046E   7404         MOV       A,#0x4
   \   000470   12....       LCALL     ?DEALLOC_XSTACK8
   \   000473   E9           MOV       A,R1
   1988                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \   000474   7FFF         MOV       R7,#-0x1
   1989                }
   1990                break;
   \   000476   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_9 & 0xFFFF
   1991          
   1992              case COMMAND_GROUP_REMOVE_ALL:
   1993                {
   1994                  uint8 numGroups;
   1995                  uint16 groupList[APS_MAX_GROUPS];
   1996          
   1997                  if ( numGroups = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, groupList ) )
   \                     ??zclGeneral_ProcessInGroupsServer_4:
   \   000479                ; Setup parameters for call to function aps_FindAllGroupsForEndpoint
   \   000479   7416         MOV       A,#0x16
   \   00047B   12....       LCALL     ?XSTACK_DISP101_8
   \   00047E   85..82       MOV       DPL,?V0
   \   000481   85..83       MOV       DPH,?V1
   \   000484   E0           MOVX      A,@DPTR
   \   000485   F8           MOV       R0,A
   \   000486   A3           INC       DPTR
   \   000487   E0           MOVX      A,@DPTR
   \   000488   C8           XCH       A,R0
   \   000489   2414         ADD       A,#0x14
   \   00048B   F582         MOV       DPL,A
   \   00048D   C8           XCH       A,R0
   \   00048E   3400         ADDC      A,#0x0
   \   000490   F583         MOV       DPH,A
   \   000492   E0           MOVX      A,@DPTR
   \   000493   F9           MOV       R1,A
   \   000494   12....       LCALL     `??aps_FindAllGroupsForEndpoint::?relay`; Banked call to: aps_FindAllGroupsForEndpoint
   \   000497   E9           MOV       A,R1
   \   000498   F8           MOV       R0,A
   \   000499   88..         MOV       ?V3,R0
   \   00049B   E8           MOV       A,R0
   \   00049C   6027         JZ        ??zclGeneral_ProcessInGroupsServer_23
   1998                  {
   1999                    for ( i = 0; i < numGroups; i++ )
   \   00049E   75..00       MOV       ?V2,#0x0
   \                     ??zclGeneral_ProcessInGroupsServer_24:
   \   0004A1   E5..         MOV       A,?V2
   \   0004A3   C3           CLR       C
   \   0004A4   95..         SUBB      A,?V3
   \   0004A6   5004         JNC       ??zclGeneral_ProcessInGroupsServer_25
   \   0004A8   05..         INC       ?V2
   \   0004AA   80F5         SJMP      ??zclGeneral_ProcessInGroupsServer_24
   2000                    {
   2001          #if defined ( ZCL_SCENES )
   2002                      zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, groupList[i] );
   2003          #endif
   2004                    }
   2005          
   2006                    aps_RemoveAllGroup( pInMsg->msg->endPoint );
   \                     ??zclGeneral_ProcessInGroupsServer_25:
   \   0004AC                ; Setup parameters for call to function aps_RemoveAllGroup
   \   0004AC   85..82       MOV       DPL,?V0
   \   0004AF   85..83       MOV       DPH,?V1
   \   0004B2   E0           MOVX      A,@DPTR
   \   0004B3   F8           MOV       R0,A
   \   0004B4   A3           INC       DPTR
   \   0004B5   E0           MOVX      A,@DPTR
   \   0004B6   C8           XCH       A,R0
   \   0004B7   2414         ADD       A,#0x14
   \   0004B9   F582         MOV       DPL,A
   \   0004BB   C8           XCH       A,R0
   \   0004BC   3400         ADDC      A,#0x0
   \   0004BE   F583         MOV       DPH,A
   \   0004C0   E0           MOVX      A,@DPTR
   \   0004C1   F9           MOV       R1,A
   \   0004C2   12....       LCALL     `??aps_RemoveAllGroup::?relay`; Banked call to: aps_RemoveAllGroup
   2007                  }
   2008                }
   2009                break;
   \                     ??zclGeneral_ProcessInGroupsServer_23:
   \   0004C5   8074         SJMP      ??zclGeneral_ProcessInGroupsServer_9
   2010          
   2011              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   2012                // Retrieve Identify Time
   2013                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2014                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   \                     ??zclGeneral_ProcessInGroupsServer_5:
   \   0004C7                ; Setup parameters for call to function zcl_ReadAttrData
   \   0004C7   E4           CLR       A
   \   0004C8   F5..         MOV       ?V8,A
   \   0004CA   F5..         MOV       ?V9,A
   \   0004CC   78..         MOV       R0,#?V8
   \   0004CE   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0004D1   7404         MOV       A,#0x4
   \   0004D3   12....       LCALL     ?XSTACK_DISP100_8
   \   0004D6   88..         MOV       ?V8,R0
   \   0004D8   89..         MOV       ?V9,R1
   \   0004DA   78..         MOV       R0,#?V8
   \   0004DC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0004DF   7C00         MOV       R4,#0x0
   \   0004E1   7D00         MOV       R5,#0x0
   \   0004E3   7A03         MOV       R2,#0x3
   \   0004E5   7B00         MOV       R3,#0x0
   \   0004E7   85..82       MOV       DPL,?V0
   \   0004EA   85..83       MOV       DPH,?V1
   \   0004ED   E0           MOVX      A,@DPTR
   \   0004EE   F8           MOV       R0,A
   \   0004EF   A3           INC       DPTR
   \   0004F0   E0           MOVX      A,@DPTR
   \   0004F1   C8           XCH       A,R0
   \   0004F2   2414         ADD       A,#0x14
   \   0004F4   F582         MOV       DPL,A
   \   0004F6   C8           XCH       A,R0
   \   0004F7   3400         ADDC      A,#0x0
   \   0004F9   F583         MOV       DPH,A
   \   0004FB   E0           MOVX      A,@DPTR
   \   0004FC   F9           MOV       R1,A
   \   0004FD   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   000500   7404         MOV       A,#0x4
   \   000502   12....       LCALL     ?DEALLOC_XSTACK8
   \   000505   E9           MOV       A,R1
   2015          
   2016                // Is device identifying itself?
   2017                if ( identifyTime > 0 )
   \   000506   7402         MOV       A,#0x2
   \   000508   12....       LCALL     ?XSTACK_DISP0_8
   \   00050B   E0           MOVX      A,@DPTR
   \   00050C   F8           MOV       R0,A
   \   00050D   A3           INC       DPTR
   \   00050E   E0           MOVX      A,@DPTR
   \   00050F   F9           MOV       R1,A
   \   000510   E8           MOV       A,R0
   \   000511   49           ORL       A,R1
   \   000512   6027         JZ        ??zclGeneral_ProcessInGroupsServer_9
   2018                {
   2019                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   \   000514                ; Setup parameters for call to function zclGeneral_AddGroup
   \   000514   AC..         MOV       R4,?V6
   \   000516   AD..         MOV       R5,?V7
   \   000518   7404         MOV       A,#0x4
   \   00051A   12....       LCALL     ?XSTACK_DISP101_8
   \   00051D   85..82       MOV       DPL,?V0
   \   000520   85..83       MOV       DPH,?V1
   \   000523   E0           MOVX      A,@DPTR
   \   000524   F8           MOV       R0,A
   \   000525   A3           INC       DPTR
   \   000526   E0           MOVX      A,@DPTR
   \   000527   C8           XCH       A,R0
   \   000528   2414         ADD       A,#0x14
   \   00052A   F582         MOV       DPL,A
   \   00052C   C8           XCH       A,R0
   \   00052D   3400         ADDC      A,#0x0
   \   00052F   F583         MOV       DPH,A
   \   000531   E0           MOVX      A,@DPTR
   \   000532   F9           MOV       R1,A
   \   000533   12....       LCALL     `??zclGeneral_AddGroup::?relay`; Banked call to: zclGeneral_AddGroup
   \   000536   E9           MOV       A,R1
   2020                }
   2021                break;
   \   000537   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_9
   2022          
   2023              default:
   2024                stat = ZFailure;
   \                     ??zclGeneral_ProcessInGroupsServer_6:
   \   000539   7F01         MOV       R7,#0x1
   2025                break;
   2026            }
   2027          
   2028            return ( stat );
   \                     ??zclGeneral_ProcessInGroupsServer_9:
   \   00053B   EF           MOV       A,R7
   \   00053C   F9           MOV       R1,A
   \   00053D   7436         MOV       A,#0x36
   \   00053F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000542   7F0E         MOV       R7,#0xe
   \   000544   02....       LJMP      ?BANKED_LEAVE_XDATA
   2029          }
   2030          
   2031          /*********************************************************************
   2032           * @fn      zclGeneral_ProcessInGroupsClient
   2033           *
   2034           * @brief   Process in the received Groups Command.
   2035           *
   2036           * @param   pInMsg - pointer to the incoming message
   2037           *
   2038           * @return  ZStatus_t
   2039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2040          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInGroupsClient:
   2041                                                             zclGeneral_AppCallbacks_t *pCBs )
   2042          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 28
   \   000005   74E4         MOV       A,#-0x1c
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   8C..         MOV       ?V12,R4
   \   000010   8D..         MOV       ?V13,R5
   2043            aps_Group_t group;
   2044            uint8 *pData = pInMsg->pData;
   \   000012   85..82       MOV       DPL,?V0
   \   000015   85..83       MOV       DPH,?V1
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   E0           MOVX      A,@DPTR
   \   000021   FE           MOV       R6,A
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   FF           MOV       R7,A
   2045            uint8 grpCnt;
   2046            uint8 nameLen;
   2047            zclGroupRsp_t rsp;
   2048            uint8 i;
   2049            ZStatus_t stat = ZSuccess;
   \   000025   75..00       MOV       ?V7,#0x0
   2050          
   2051            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   \   000028                ; Setup parameters for call to function osal_memset
   \   000028   7C12         MOV       R4,#0x12
   \   00002A   7D00         MOV       R5,#0x0
   \   00002C   7900         MOV       R1,#0x0
   \   00002E   740A         MOV       A,#0xa
   \   000030   12....       LCALL     ?XSTACK_DISP101_8
   \   000033   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2052            zcl_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   \   000036                ; Setup parameters for call to function osal_memset
   \   000036   7C0A         MOV       R4,#0xa
   \   000038   7D00         MOV       R5,#0x0
   \   00003A   7900         MOV       R1,#0x0
   \   00003C   AA..         MOV       R2,?XSP + 0
   \   00003E   AB..         MOV       R3,?XSP + 1
   \   000040   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2053          
   2054            switch ( pInMsg->hdr.commandID )
   \   000043   85..82       MOV       DPL,?V0
   \   000046   85..83       MOV       DPH,?V1
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   A3           INC       DPTR
   \   00004D   A3           INC       DPTR
   \   00004E   A3           INC       DPTR
   \   00004F   A3           INC       DPTR
   \   000050   E0           MOVX      A,@DPTR
   \   000051   600F         JZ        ??zclGeneral_ProcessInGroupsClient_0
   \   000053   14           DEC       A
   \   000054   600C         JZ        ??zclGeneral_ProcessInGroupsClient_0
   \   000056   14           DEC       A
   \   000057   7003         JNZ       $+5
   \   000059   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_1 & 0xFFFF
   \   00005C   14           DEC       A
   \   00005D   6003         JZ        $+5
   \   00005F   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_2 & 0xFFFF
   2055            {
   2056              case COMMAND_GROUP_ADD_RSP:
   2057              case COMMAND_GROUP_VIEW_RSP:
   2058              case COMMAND_GROUP_REMOVE_RSP:
   2059                rsp.status = *pData++;
   \                     ??zclGeneral_ProcessInGroupsClient_0:
   \   000062   8E82         MOV       DPL,R6
   \   000064   8F83         MOV       DPH,R7
   \   000066   E0           MOVX      A,@DPTR
   \   000067   C0E0         PUSH      A
   \   000069   7403         MOV       A,#0x3
   \   00006B   12....       LCALL     ?XSTACK_DISP0_8
   \   00006E   D0E0         POP       A
   \   000070   F0           MOVX      @DPTR,A
   \   000071   8E82         MOV       DPL,R6
   \   000073   8F83         MOV       DPH,R7
   \   000075   A3           INC       DPTR
   \   000076   AE82         MOV       R6,DPL
   \   000078   AF83         MOV       R7,DPH
   2060                group.ID = BUILD_UINT16( pData[0], pData[1] );
   \   00007A   8E82         MOV       DPL,R6
   \   00007C   8F83         MOV       DPH,R7
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   FA           MOV       R2,A
   \   000080   7B00         MOV       R3,#0x0
   \   000082   8E82         MOV       DPL,R6
   \   000084   8F83         MOV       DPH,R7
   \   000086   A3           INC       DPTR
   \   000087   E0           MOVX      A,@DPTR
   \   000088   F8           MOV       R0,A
   \   000089   7900         MOV       R1,#0x0
   \   00008B   E4           CLR       A
   \   00008C   C8           XCH       A,R0
   \   00008D   F9           MOV       R1,A
   \   00008E   EA           MOV       A,R2
   \   00008F   28           ADD       A,R0
   \   000090   F8           MOV       R0,A
   \   000091   EB           MOV       A,R3
   \   000092   39           ADDC      A,R1
   \   000093   F9           MOV       R1,A
   \   000094   740A         MOV       A,#0xa
   \   000096   12....       LCALL     ?XSTACK_DISP0_8
   \   000099   E8           MOV       A,R0
   \   00009A   F0           MOVX      @DPTR,A
   \   00009B   A3           INC       DPTR
   \   00009C   E9           MOV       A,R1
   \   00009D   F0           MOVX      @DPTR,A
   2061          
   2062                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   \   00009E   7403         MOV       A,#0x3
   \   0000A0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   7074         JNZ       ??zclGeneral_ProcessInGroupsClient_3
   \   0000A6   85..82       MOV       DPL,?V0
   \   0000A9   85..83       MOV       DPH,?V1
   \   0000AC   A3           INC       DPTR
   \   0000AD   A3           INC       DPTR
   \   0000AE   A3           INC       DPTR
   \   0000AF   A3           INC       DPTR
   \   0000B0   A3           INC       DPTR
   \   0000B1   A3           INC       DPTR
   \   0000B2   A3           INC       DPTR
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   6401         XRL       A,#0x1
   \   0000B6   7062         JNZ       ??zclGeneral_ProcessInGroupsClient_3
   2063                {
   2064                  pData += 2;   // Move past ID
   \   0000B8   EE           MOV       A,R6
   \   0000B9   2402         ADD       A,#0x2
   \   0000BB   FE           MOV       R6,A
   \   0000BC   5001         JNC       ??zclGeneral_ProcessInGroupsClient_4
   \   0000BE   0F           INC       R7
   2065                  nameLen = *pData++;
   \                     ??zclGeneral_ProcessInGroupsClient_4:
   \   0000BF   8E82         MOV       DPL,R6
   \   0000C1   8F83         MOV       DPH,R7
   \   0000C3   E0           MOVX      A,@DPTR
   \   0000C4   F5..         MOV       ?V2,A
   \   0000C6   8E82         MOV       DPL,R6
   \   0000C8   8F83         MOV       DPH,R7
   \   0000CA   A3           INC       DPTR
   \   0000CB   AE82         MOV       R6,DPL
   \   0000CD   AF83         MOV       R7,DPH
   2066                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   \   0000CF   E5..         MOV       A,?V2
   \   0000D1   C3           CLR       C
   \   0000D2   9410         SUBB      A,#0x10
   \   0000D4   4003         JC        ??zclGeneral_ProcessInGroupsClient_5
   2067                    nameLen = (APS_GROUP_NAME_LEN-1);
   \   0000D6   75..0F       MOV       ?V2,#0xf
   2068                  group.name[0] = nameLen;
   \                     ??zclGeneral_ProcessInGroupsClient_5:
   \   0000D9   E5..         MOV       A,?V2
   \   0000DB   C0E0         PUSH      A
   \   0000DD   740C         MOV       A,#0xc
   \   0000DF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E2   D0E0         POP       A
   \   0000E4   F0           MOVX      @DPTR,A
   2069                  zcl_memcpy( &(group.name[1]), pData, nameLen );
   \   0000E5                ; Setup parameters for call to function osal_memcpy
   \   0000E5   8E..         MOV       ?V4,R6
   \   0000E7   8F..         MOV       ?V5,R7
   \   0000E9   75..00       MOV       ?V6,#0x0
   \   0000EC   78..         MOV       R0,#?V4
   \   0000EE   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000F1   E5..         MOV       A,?V2
   \   0000F3   FC           MOV       R4,A
   \   0000F4   7D00         MOV       R5,#0x0
   \   0000F6   7410         MOV       A,#0x10
   \   0000F8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000FB   AA82         MOV       R2,DPL
   \   0000FD   AB83         MOV       R3,DPH
   \   0000FF   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000102   7403         MOV       A,#0x3
   \   000104   12....       LCALL     ?DEALLOC_XSTACK8
   2070                  rsp.grpName = group.name;
   \   000107   740C         MOV       A,#0xc
   \   000109   12....       LCALL     ?XSTACK_DISP0_8
   \   00010C   A882         MOV       R0,DPL
   \   00010E   A983         MOV       R1,DPH
   \   000110   7408         MOV       A,#0x8
   \   000112   12....       LCALL     ?XSTACK_DISP0_8
   \   000115   E8           MOV       A,R0
   \   000116   F0           MOVX      @DPTR,A
   \   000117   A3           INC       DPTR
   \   000118   E9           MOV       A,R1
   \   000119   F0           MOVX      @DPTR,A
   2071                }
   2072          
   2073                if ( pCBs->pfnGroupRsp )
   \                     ??zclGeneral_ProcessInGroupsClient_3:
   \   00011A   E5..         MOV       A,?V12
   \   00011C   240C         ADD       A,#0xc
   \   00011E   F582         MOV       DPL,A
   \   000120   E4           CLR       A
   \   000121   35..         ADDC      A,?V13
   \   000123   F583         MOV       DPH,A
   \   000125   E0           MOVX      A,@DPTR
   \   000126   F8           MOV       R0,A
   \   000127   A3           INC       DPTR
   \   000128   E0           MOVX      A,@DPTR
   \   000129   F9           MOV       R1,A
   \   00012A   E8           MOV       A,R0
   \   00012B   49           ORL       A,R1
   \   00012C   606B         JZ        ??zclGeneral_ProcessInGroupsClient_6
   2074                {
   2075                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   00012E   85..82       MOV       DPL,?V0
   \   000131   85..83       MOV       DPH,?V1
   \   000134   E0           MOVX      A,@DPTR
   \   000135   2406         ADD       A,#0x6
   \   000137   F8           MOV       R0,A
   \   000138   A3           INC       DPTR
   \   000139   E0           MOVX      A,@DPTR
   \   00013A   3400         ADDC      A,#0x0
   \   00013C   F9           MOV       R1,A
   \   00013D   85..82       MOV       DPL,?XSP + 0
   \   000140   85..83       MOV       DPH,?XSP + 1
   \   000143   E8           MOV       A,R0
   \   000144   F0           MOVX      @DPTR,A
   \   000145   A3           INC       DPTR
   \   000146   E9           MOV       A,R1
   \   000147   F0           MOVX      @DPTR,A
   2076                  rsp.cmdID = pInMsg->hdr.commandID;
   \   000148   85..82       MOV       DPL,?V0
   \   00014B   85..83       MOV       DPH,?V1
   \   00014E   A3           INC       DPTR
   \   00014F   A3           INC       DPTR
   \   000150   A3           INC       DPTR
   \   000151   A3           INC       DPTR
   \   000152   A3           INC       DPTR
   \   000153   A3           INC       DPTR
   \   000154   A3           INC       DPTR
   \   000155   E0           MOVX      A,@DPTR
   \   000156   C0E0         PUSH      A
   \   000158   7402         MOV       A,#0x2
   \   00015A   12....       LCALL     ?XSTACK_DISP0_8
   \   00015D   D0E0         POP       A
   \   00015F   F0           MOVX      @DPTR,A
   2077                  rsp.grpCnt = 1;
   \   000160   7404         MOV       A,#0x4
   \   000162   12....       LCALL     ?XSTACK_DISP0_8
   \   000165   7401         MOV       A,#0x1
   \   000167   F0           MOVX      @DPTR,A
   2078                  rsp.grpList = &group.ID;
   \   000168   740A         MOV       A,#0xa
   \   00016A   12....       LCALL     ?XSTACK_DISP100_8
   \   00016D   7405         MOV       A,#0x5
   \   00016F   12....       LCALL     ?XSTACK_DISP0_8
   \   000172   E8           MOV       A,R0
   \   000173   F0           MOVX      @DPTR,A
   \   000174   A3           INC       DPTR
   \   000175   E9           MOV       A,R1
   \   000176   F0           MOVX      @DPTR,A
   2079                  rsp.capacity = 0;
   \   000177   7407         MOV       A,#0x7
   \   000179   12....       LCALL     ?XSTACK_DISP0_8
   \   00017C   7400         MOV       A,#0x0
   \   00017E   F0           MOVX      @DPTR,A
   2080          
   2081                  pCBs->pfnGroupRsp( &rsp );
   \   00017F                ; Setup parameters for indirect call
   \   00017F   AA..         MOV       R2,?XSP + 0
   \   000181   AB..         MOV       R3,?XSP + 1
   \   000183   E5..         MOV       A,?V12
   \   000185   240C         ADD       A,#0xc
   \   000187   F582         MOV       DPL,A
   \   000189   E4           CLR       A
   \   00018A   35..         ADDC      A,?V13
   \   00018C   F583         MOV       DPH,A
   \   00018E   E0           MOVX      A,@DPTR
   \   00018F   F8           MOV       R0,A
   \   000190   A3           INC       DPTR
   \   000191   E0           MOVX      A,@DPTR
   \   000192   F583         MOV       DPH,A
   \   000194   8882         MOV       DPL,R0
   \   000196   12....       LCALL     ?CALL_IND
   2082                }
   2083                break;
   \                     ??zclGeneral_ProcessInGroupsClient_6:
   \   000199   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_7 & 0xFFFF
   2084          
   2085              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   2086                {
   2087                  uint16 *grpList = NULL;
   \                     ??zclGeneral_ProcessInGroupsClient_1:
   \   00019C   75..00       MOV       ?V4,#0x0
   \   00019F   75..00       MOV       ?V5,#0x0
   2088                  rsp.capacity = *pData++;
   \   0001A2   8E82         MOV       DPL,R6
   \   0001A4   8F83         MOV       DPH,R7
   \   0001A6   E0           MOVX      A,@DPTR
   \   0001A7   C0E0         PUSH      A
   \   0001A9   7407         MOV       A,#0x7
   \   0001AB   12....       LCALL     ?XSTACK_DISP0_8
   \   0001AE   D0E0         POP       A
   \   0001B0   F0           MOVX      @DPTR,A
   \   0001B1   8E82         MOV       DPL,R6
   \   0001B3   8F83         MOV       DPH,R7
   \   0001B5   A3           INC       DPTR
   \   0001B6   AE82         MOV       R6,DPL
   \   0001B8   AF83         MOV       R7,DPH
   2089                  grpCnt = *pData++;
   \   0001BA   8E82         MOV       DPL,R6
   \   0001BC   8F83         MOV       DPH,R7
   \   0001BE   E0           MOVX      A,@DPTR
   \   0001BF   F5..         MOV       ?V3,A
   \   0001C1   8E82         MOV       DPL,R6
   \   0001C3   8F83         MOV       DPH,R7
   \   0001C5   A3           INC       DPTR
   \   0001C6   AE82         MOV       R6,DPL
   \   0001C8   AF83         MOV       R7,DPH
   2090          
   2091                  if ( grpCnt > 0 )
   \   0001CA   E5..         MOV       A,?V3
   \   0001CC   7003         JNZ       $+5
   \   0001CE   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_8 & 0xFFFF
   2092                  {
   2093                    // Allocate space for the group list
   2094                    grpList = zcl_mem_alloc( sizeof( uint16 ) * grpCnt );
   \   0001D1                ; Setup parameters for call to function osal_mem_alloc
   \   0001D1   E5..         MOV       A,?V3
   \   0001D3   FA           MOV       R2,A
   \   0001D4   7B00         MOV       R3,#0x0
   \   0001D6   EA           MOV       A,R2
   \   0001D7   75F002       MOV       B,#0x2
   \   0001DA   A4           MUL       AB
   \   0001DB   CA           XCH       A,R2
   \   0001DC   A8F0         MOV       R0,B
   \   0001DE   75F000       MOV       B,#0x0
   \   0001E1   A4           MUL       AB
   \   0001E2   28           ADD       A,R0
   \   0001E3   F8           MOV       R0,A
   \   0001E4   75F002       MOV       B,#0x2
   \   0001E7   EB           MOV       A,R3
   \   0001E8   A4           MUL       AB
   \   0001E9   28           ADD       A,R0
   \   0001EA   FB           MOV       R3,A
   \   0001EB   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0001EE   8A..         MOV       ?V10,R2
   \   0001F0   8B..         MOV       ?V11,R3
   \   0001F2   85....       MOV       ?V4,?V10
   \   0001F5   85....       MOV       ?V5,?V11
   2095                    if ( grpList != NULL )
   \   0001F8   E5..         MOV       A,?V4
   \   0001FA   45..         ORL       A,?V5
   \   0001FC   6064         JZ        ??zclGeneral_ProcessInGroupsClient_8
   2096                    {
   2097                      rsp.grpCnt = grpCnt;
   \   0001FE   E5..         MOV       A,?V3
   \   000200   C0E0         PUSH      A
   \   000202   7404         MOV       A,#0x4
   \   000204   12....       LCALL     ?XSTACK_DISP0_8
   \   000207   D0E0         POP       A
   \   000209   F0           MOVX      @DPTR,A
   2098                      for ( i = 0; i < grpCnt; i++ )
   \   00020A   75..00       MOV       ?V8,#0x0
   \                     ??zclGeneral_ProcessInGroupsClient_9:
   \   00020D   E5..         MOV       A,?V8
   \   00020F   C3           CLR       C
   \   000210   95..         SUBB      A,?V3
   \   000212   504E         JNC       ??zclGeneral_ProcessInGroupsClient_8
   2099                      {
   2100                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   \   000214   8E82         MOV       DPL,R6
   \   000216   8F83         MOV       DPH,R7
   \   000218   E0           MOVX      A,@DPTR
   \   000219   FA           MOV       R2,A
   \   00021A   7B00         MOV       R3,#0x0
   \   00021C   8E82         MOV       DPL,R6
   \   00021E   8F83         MOV       DPH,R7
   \   000220   A3           INC       DPTR
   \   000221   E0           MOVX      A,@DPTR
   \   000222   F8           MOV       R0,A
   \   000223   7900         MOV       R1,#0x0
   \   000225   E4           CLR       A
   \   000226   C8           XCH       A,R0
   \   000227   F9           MOV       R1,A
   \   000228   EA           MOV       A,R2
   \   000229   28           ADD       A,R0
   \   00022A   FA           MOV       R2,A
   \   00022B   EB           MOV       A,R3
   \   00022C   39           ADDC      A,R1
   \   00022D   FB           MOV       R3,A
   \   00022E   E5..         MOV       A,?V8
   \   000230   F8           MOV       R0,A
   \   000231   7900         MOV       R1,#0x0
   \   000233   E8           MOV       A,R0
   \   000234   75F002       MOV       B,#0x2
   \   000237   A4           MUL       AB
   \   000238   C8           XCH       A,R0
   \   000239   ACF0         MOV       R4,B
   \   00023B   75F000       MOV       B,#0x0
   \   00023E   A4           MUL       AB
   \   00023F   2C           ADD       A,R4
   \   000240   FC           MOV       R4,A
   \   000241   75F002       MOV       B,#0x2
   \   000244   E9           MOV       A,R1
   \   000245   A4           MUL       AB
   \   000246   2C           ADD       A,R4
   \   000247   F9           MOV       R1,A
   \   000248   E5..         MOV       A,?V4
   \   00024A   28           ADD       A,R0
   \   00024B   F582         MOV       DPL,A
   \   00024D   E5..         MOV       A,?V5
   \   00024F   39           ADDC      A,R1
   \   000250   F583         MOV       DPH,A
   \   000252   EA           MOV       A,R2
   \   000253   F0           MOVX      @DPTR,A
   \   000254   A3           INC       DPTR
   \   000255   EB           MOV       A,R3
   \   000256   F0           MOVX      @DPTR,A
   2101                        pData += 2;
   \   000257   EE           MOV       A,R6
   \   000258   2402         ADD       A,#0x2
   \   00025A   FE           MOV       R6,A
   \   00025B   5001         JNC       ??zclGeneral_ProcessInGroupsClient_10
   \   00025D   0F           INC       R7
   2102                      }
   \                     ??zclGeneral_ProcessInGroupsClient_10:
   \   00025E   05..         INC       ?V8
   \   000260   80AB         SJMP      ??zclGeneral_ProcessInGroupsClient_9
   2103                    }
   2104                  }
   2105          
   2106                  if ( pCBs->pfnGroupRsp )
   \                     ??zclGeneral_ProcessInGroupsClient_8:
   \   000262   E5..         MOV       A,?V12
   \   000264   240C         ADD       A,#0xc
   \   000266   F582         MOV       DPL,A
   \   000268   E4           CLR       A
   \   000269   35..         ADDC      A,?V13
   \   00026B   F583         MOV       DPH,A
   \   00026D   E0           MOVX      A,@DPTR
   \   00026E   F8           MOV       R0,A
   \   00026F   A3           INC       DPTR
   \   000270   E0           MOVX      A,@DPTR
   \   000271   F9           MOV       R1,A
   \   000272   E8           MOV       A,R0
   \   000273   49           ORL       A,R1
   \   000274   6058         JZ        ??zclGeneral_ProcessInGroupsClient_11
   2107                  {
   2108                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   000276   85..82       MOV       DPL,?V0
   \   000279   85..83       MOV       DPH,?V1
   \   00027C   E0           MOVX      A,@DPTR
   \   00027D   2406         ADD       A,#0x6
   \   00027F   F8           MOV       R0,A
   \   000280   A3           INC       DPTR
   \   000281   E0           MOVX      A,@DPTR
   \   000282   3400         ADDC      A,#0x0
   \   000284   F9           MOV       R1,A
   \   000285   85..82       MOV       DPL,?XSP + 0
   \   000288   85..83       MOV       DPH,?XSP + 1
   \   00028B   E8           MOV       A,R0
   \   00028C   F0           MOVX      @DPTR,A
   \   00028D   A3           INC       DPTR
   \   00028E   E9           MOV       A,R1
   \   00028F   F0           MOVX      @DPTR,A
   2109                    rsp.cmdID = pInMsg->hdr.commandID;
   \   000290   85..82       MOV       DPL,?V0
   \   000293   85..83       MOV       DPH,?V1
   \   000296   A3           INC       DPTR
   \   000297   A3           INC       DPTR
   \   000298   A3           INC       DPTR
   \   000299   A3           INC       DPTR
   \   00029A   A3           INC       DPTR
   \   00029B   A3           INC       DPTR
   \   00029C   A3           INC       DPTR
   \   00029D   E0           MOVX      A,@DPTR
   \   00029E   C0E0         PUSH      A
   \   0002A0   7402         MOV       A,#0x2
   \   0002A2   12....       LCALL     ?XSTACK_DISP0_8
   \   0002A5   D0E0         POP       A
   \   0002A7   F0           MOVX      @DPTR,A
   2110                    rsp.grpList = grpList;
   \   0002A8   7405         MOV       A,#0x5
   \   0002AA   12....       LCALL     ?XSTACK_DISP0_8
   \   0002AD   E5..         MOV       A,?V4
   \   0002AF   F0           MOVX      @DPTR,A
   \   0002B0   A3           INC       DPTR
   \   0002B1   E5..         MOV       A,?V5
   \   0002B3   F0           MOVX      @DPTR,A
   2111          
   2112                    pCBs->pfnGroupRsp( &rsp );
   \   0002B4                ; Setup parameters for indirect call
   \   0002B4   AA..         MOV       R2,?XSP + 0
   \   0002B6   AB..         MOV       R3,?XSP + 1
   \   0002B8   E5..         MOV       A,?V12
   \   0002BA   240C         ADD       A,#0xc
   \   0002BC   F582         MOV       DPL,A
   \   0002BE   E4           CLR       A
   \   0002BF   35..         ADDC      A,?V13
   \   0002C1   F583         MOV       DPH,A
   \   0002C3   E0           MOVX      A,@DPTR
   \   0002C4   F8           MOV       R0,A
   \   0002C5   A3           INC       DPTR
   \   0002C6   E0           MOVX      A,@DPTR
   \   0002C7   F583         MOV       DPH,A
   \   0002C9   8882         MOV       DPL,R0
   \   0002CB   12....       LCALL     ?CALL_IND
   2113                  }
   2114          
   2115                  if ( grpList != NULL )
   \                     ??zclGeneral_ProcessInGroupsClient_11:
   \   0002CE   E5..         MOV       A,?V4
   \   0002D0   45..         ORL       A,?V5
   \   0002D2   600C         JZ        ??zclGeneral_ProcessInGroupsClient_7
   2116                  {
   2117                    zcl_mem_free( grpList );
   \   0002D4                ; Setup parameters for call to function osal_mem_free
   \   0002D4   AA..         MOV       R2,?V4
   \   0002D6   AB..         MOV       R3,?V5
   \   0002D8   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2118                  }
   2119                }
   2120                break;
   \   0002DB   8003         SJMP      ??zclGeneral_ProcessInGroupsClient_7
   2121          
   2122              default:
   2123                stat = ZFailure;
   \                     ??zclGeneral_ProcessInGroupsClient_2:
   \   0002DD   75..01       MOV       ?V7,#0x1
   2124                break;
   2125            }
   2126          
   2127            return ( stat );
   \                     ??zclGeneral_ProcessInGroupsClient_7:
   \   0002E0   A9..         MOV       R1,?V7
   \   0002E2   741C         MOV       A,#0x1c
   \   0002E4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002E7   7F0E         MOV       R7,#0xe
   \   0002E9   02....       LJMP      ?BANKED_LEAVE_XDATA
   2128          }
   2129          #endif // ZCL_GROUPS
   2130          
   2131          #if defined( ZCL_SCENES )
   2132          #if !defined ( ZCL_STANDALONE )
   2133          /*********************************************************************
   2134           * @fn      zclGeneral_AddScene
   2135           *
   2136           * @brief   Add a scene for an endpoint
   2137           *
   2138           * @param   endpoint -
   2139           * @param   scene - new scene item
   2140           *
   2141           * @return  ZStatus_t
   2142           */
   2143          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   2144          {
   2145            zclGenSceneItem_t *pNewItem;
   2146            zclGenSceneItem_t *pLoop;
   2147          
   2148            // Fill in the new profile list
   2149            pNewItem = zcl_mem_alloc( sizeof( zclGenSceneItem_t ) );
   2150            if ( pNewItem == NULL )
   2151              return ( ZMemError );
   2152          
   2153            // Fill in the plugin record.
   2154            pNewItem->next = (zclGenSceneItem_t *)NULL;
   2155            pNewItem->endpoint = endpoint;
   2156            zcl_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   2157          
   2158            // Find spot in list
   2159            if (  zclGenSceneTable == NULL )
   2160            {
   2161              zclGenSceneTable = pNewItem;
   2162            }
   2163            else
   2164            {
   2165              // Look for end of list
   2166              pLoop = zclGenSceneTable;
   2167              while ( pLoop->next != NULL )
   2168                pLoop = pLoop->next;
   2169          
   2170              // Put new item at end of list
   2171              pLoop->next = pNewItem;
   2172            }
   2173          
   2174            // Update NV
   2175            zclGeneral_ScenesWriteNV();
   2176          
   2177            return ( ZSuccess );
   2178          }
   2179          #endif // ZCL_STANDALONE
   2180          
   2181          #if !defined ( ZCL_STANDALONE )
   2182          /*********************************************************************
   2183           * @fn      zclGeneral_FindScene
   2184           *
   2185           * @brief   Find a scene with endpoint and sceneID
   2186           *
   2187           * @param   endpoint -
   2188           * @param   groupID - what group the scene belongs to
   2189           * @param   sceneID - ID to look for scene
   2190           *
   2191           * @return  a pointer to the scene information, NULL if not found
   2192           */
   2193          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2194          {
   2195            zclGenSceneItem_t *pLoop;
   2196          
   2197            // Look for end of list
   2198            pLoop = zclGenSceneTable;
   2199            while ( pLoop )
   2200            {
   2201              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   2202                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2203              {
   2204                return ( &(pLoop->scene) );
   2205              }
   2206              pLoop = pLoop->next;
   2207            }
   2208          
   2209            return ( (zclGeneral_Scene_t *)NULL );
   2210          }
   2211          #endif // ZCL_STANDALONE
   2212          
   2213          #if !defined ( ZCL_STANDALONE )
   2214          /*********************************************************************
   2215           * @fn      zclGeneral_FindAllScenesForGroup
   2216           *
   2217           * @brief   Find all the scenes with groupID
   2218           *
   2219           * @param   endpoint - endpoint to look for
   2220           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   2221           *
   2222           * @return  number of scenes copied to sceneList
   2223           */
   2224          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   2225          {
   2226            zclGenSceneItem_t *pLoop;
   2227            uint8 cnt = 0;
   2228          
   2229            // Look for end of list
   2230            pLoop = zclGenSceneTable;
   2231            while ( pLoop )
   2232            {
   2233              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2234                sceneList[cnt++] = pLoop->scene.ID;
   2235              pLoop = pLoop->next;
   2236            }
   2237            return ( cnt );
   2238          }
   2239          #endif // ZCL_STANDALONE
   2240          
   2241          #if !defined ( ZCL_STANDALONE )
   2242          /*********************************************************************
   2243           * @fn      zclGeneral_RemoveScene
   2244           *
   2245           * @brief   Remove a scene with endpoint and sceneID
   2246           *
   2247           * @param   endpoint -
   2248           * @param   groupID - what group the scene belongs to
   2249           * @param   sceneID - ID to look for scene
   2250           *
   2251           * @return  TRUE if removed, FALSE if not found
   2252           */
   2253          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2254          {
   2255            zclGenSceneItem_t *pLoop;
   2256            zclGenSceneItem_t *pPrev;
   2257          
   2258            // Look for end of list
   2259            pLoop = zclGenSceneTable;
   2260            pPrev = NULL;
   2261            while ( pLoop )
   2262            {
   2263              if ( pLoop->endpoint == endpoint
   2264                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2265              {
   2266                if ( pPrev == NULL )
   2267                  zclGenSceneTable = pLoop->next;
   2268                else
   2269                  pPrev->next = pLoop->next;
   2270          
   2271                // Free the memory
   2272                zcl_mem_free( pLoop );
   2273          
   2274                // Update NV
   2275                zclGeneral_ScenesWriteNV();
   2276          
   2277                return ( TRUE );
   2278              }
   2279              pPrev = pLoop;
   2280              pLoop = pLoop->next;
   2281            }
   2282          
   2283            return ( FALSE );
   2284          }
   2285          #endif // ZCL_STANDALONE
   2286          
   2287          #if !defined ( ZCL_STANDALONE )
   2288          /*********************************************************************
   2289           * @fn      zclGeneral_RemoveAllScenes
   2290           *
   2291           * @brief   Remove all scenes with endpoint and group Id
   2292           *
   2293           * @param   endpoint -
   2294           * @param   groupID - ID to look for group
   2295           *
   2296           * @return  none
   2297           */
   2298          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   2299          {
   2300            zclGenSceneItem_t *pLoop;
   2301            zclGenSceneItem_t *pPrev;
   2302            zclGenSceneItem_t *pNext;
   2303          
   2304            // Look for end of list
   2305            pLoop = zclGenSceneTable;
   2306            pPrev = NULL;
   2307            while ( pLoop )
   2308            {
   2309              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2310              {
   2311                if ( pPrev == NULL )
   2312                  zclGenSceneTable = pLoop->next;
   2313                else
   2314                  pPrev->next = pLoop->next;
   2315                pNext = pLoop->next;
   2316          
   2317                // Free the memory
   2318                zcl_mem_free( pLoop );
   2319                pLoop = pNext;
   2320              }
   2321              else
   2322              {
   2323                pPrev = pLoop;
   2324                pLoop = pLoop->next;
   2325              }
   2326            }
   2327          
   2328            // Update NV
   2329            zclGeneral_ScenesWriteNV();
   2330          }
   2331          #endif // ZCL_STANDALONE
   2332          
   2333          #if !defined ( ZCL_STANDALONE )
   2334          /*********************************************************************
   2335           * @fn      zclGeneral_CountScenes
   2336           *
   2337           * @brief   Count the number of scenes for an endpoint
   2338           *
   2339           * @param   endpoint -
   2340           *
   2341           * @return  number of scenes assigned to an endpoint
   2342           */
   2343          uint8 zclGeneral_CountScenes( uint8 endpoint )
   2344          {
   2345            zclGenSceneItem_t *pLoop;
   2346            uint8 cnt = 0;
   2347          
   2348            // Look for end of list
   2349            pLoop = zclGenSceneTable;
   2350            while ( pLoop )
   2351            {
   2352              if ( pLoop->endpoint == endpoint  )
   2353                cnt++;
   2354              pLoop = pLoop->next;
   2355            }
   2356            return ( cnt );
   2357          }
   2358          #endif
   2359          
   2360          #if !defined ( ZCL_STANDALONE )
   2361          /*********************************************************************
   2362           * @fn      zclGeneral_CountAllScenes
   2363           *
   2364           * @brief   Count the total number of scenes
   2365           *
   2366           * @param   none
   2367           *
   2368           * @return  number of scenes
   2369           */
   2370          uint8 zclGeneral_CountAllScenes( void )
   2371          {
   2372            zclGenSceneItem_t *pLoop;
   2373            uint8 cnt = 0;
   2374          
   2375            // Look for end of list
   2376            pLoop = zclGenSceneTable;
   2377            while ( pLoop )
   2378            {
   2379              cnt++;
   2380              pLoop = pLoop->next;
   2381            }
   2382            return ( cnt );
   2383          }
   2384          #endif // ZCL_STANDALONE
   2385          
   2386          /*********************************************************************
   2387           * @fn      zclGeneral_ReadSceneCountCB
   2388           *
   2389           * @brief   Read the number of scenes currently in the device's
   2390           *          scene table (i.e., the Scene Count attribute).
   2391           *
   2392           *          Note: This function gets called only when the pointer
   2393           *                'dataPtr' to the Scene Count attribute value is
   2394           *                NULL in the attribute database registered with
   2395           *                the ZCL.
   2396           *
   2397           * @param   clusterId - cluster that attribute belongs to
   2398           * @param   attrId - attribute to be read or written
   2399           * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ, or ZCL_OPER_WRITE
   2400           * @param   pValue - pointer to attribute value
   2401           * @param   pLen - pointer to length of attribute value read
   2402           *
   2403           * @return  status
   2404           */
   2405          ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
   2406                                                 uint8 oper, uint8 *pValue, uint16 *pLen )
   2407          {
   2408            ZStatus_t status = ZCL_STATUS_SUCCESS;
   2409          
   2410            // This callback function should only be called for the Scene Count attribute
   2411            switch ( oper )
   2412            {
   2413              case ZCL_OPER_LEN:
   2414                *pLen = 1; // uint8
   2415                break;
   2416          
   2417              case ZCL_OPER_READ:
   2418                *pValue = zclGeneral_CountAllScenes();
   2419          
   2420                if ( pLen != NULL )
   2421                {
   2422                  *pLen = 1;
   2423                }
   2424                break;
   2425          
   2426              case ZCL_OPER_WRITE:
   2427                // Fall through
   2428          
   2429              default:
   2430                status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
   2431                break;
   2432            }
   2433          
   2434            return ( status );
   2435          }
   2436          
   2437          /*********************************************************************
   2438           * @fn      zclGeneral_ProcessInScenesServer
   2439           *
   2440           * @brief   Process in the received Scenes Command.
   2441           *
   2442           * @param   pInMsg - pointer to the incoming message
   2443           *
   2444           * @return  ZStatus_t
   2445           */
   2446          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   2447                                                             zclGeneral_AppCallbacks_t *pCBs )
   2448          {
   2449            zclGeneral_Scene_t scene;
   2450            zclGeneral_Scene_t *pScene;
   2451            uint8 *pData = pInMsg->pData;
   2452            uint8 nameLen;
   2453            uint8 status;
   2454            uint8 sceneCnt = 0;
   2455            uint8 *sceneList = NULL;
   2456            uint8 sendRsp = TRUE;
   2457            uint8 nameSupport = FALSE;
   2458            ZStatus_t stat = ZSuccess;
   2459          
   2460            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2461          
   2462            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2463            pData += 2;   // Move past group ID
   2464            scene.ID = *pData++;
   2465          
   2466            switch ( pInMsg->hdr.commandID )
   2467            {
   2468              case COMMAND_SCENE_ADD:
   2469          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2470              case COMMAND_SCENE_ENHANCED_ADD:
   2471          #endif // ZCL_LIGHT_LINK_ENHANCE
   2472                // Parse the rest of the incoming message
   2473                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2474                pData += 2;
   2475          
   2476                if ( pInMsg->hdr.commandID == COMMAND_SCENE_ENHANCED_ADD )
   2477                {
   2478                  // Received transition time is in 1/10 second
   2479                  scene.transTime100ms = scene.transTime % 10;
   2480                  scene.transTime /= 10;
   2481                }
   2482          
   2483                nameLen= *pData++; // Name length
   2484          
   2485                // Retrieve Name Support attribute
   2486                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES,
   2487                                  ATTRID_SCENES_NAME_SUPPORT, &nameSupport, NULL );
   2488          
   2489                if ( nameSupport )
   2490                {
   2491                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2492                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2493                  scene.name[0] = nameLen;
   2494                  zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2495                }
   2496          
   2497                pData += nameLen; // move past name, use original length
   2498          
   2499                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2500                if ( scene.extLen > 0 )
   2501                {
   2502                  // Copy the extention field(s)
   2503                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2504                  {
   2505                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2506                  }
   2507                  zcl_memcpy( scene.extField, pData, scene.extLen );
   2508                }
   2509          
   2510                if ( scene.groupID == 0x0000 ||
   2511                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2512                {
   2513                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2514                  // does and the corresponding Group exits
   2515                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2516                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2517                  {
   2518                    status = ZCL_STATUS_SUCCESS;
   2519                    if ( pScene != NULL )
   2520                    {
   2521                      // The Scene already exists so update it
   2522                      pScene->transTime = scene.transTime;
   2523                      zcl_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2524          
   2525                      // Use the new extention field(s)
   2526                      zcl_memcpy( pScene->extField, scene.extField, scene.extLen );
   2527                      pScene->extLen = scene.extLen;
   2528          
   2529                      // Save Scenes
   2530                      zclGeneral_ScenesSave();
   2531                    }
   2532                    else
   2533                    {
   2534                      // The Scene doesn't exist so add it
   2535                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2536                    }
   2537                  }
   2538                  else
   2539                  {
   2540                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2541                  }
   2542                }
   2543                else
   2544                {
   2545                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2546                }
   2547          
   2548                if ( UNICAST_MSG( pInMsg->msg ) )
   2549                {
   2550                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_ADD )
   2551                  {
   2552                    zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2553                                                    status, scene.groupID, scene.ID,
   2554                                                    true, pInMsg->hdr.transSeqNum );
   2555                  }
   2556          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2557                  else // COMMAND_SCENE_ENHANCED_ADD
   2558                  {
   2559                    zclGeneral_SendSceneEnhancedAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2560                                                            status, scene.groupID, scene.ID,
   2561                                                            true, pInMsg->hdr.transSeqNum );
   2562                  }
   2563          #endif // ZCL_LIGHT_LINK_ENHANCE
   2564                }
   2565                stat = ZCL_STATUS_CMD_HAS_RSP;
   2566          
   2567                break;
   2568          
   2569              case COMMAND_SCENE_VIEW:
   2570          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2571              case COMMAND_SCENE_ENHANCED_VIEW:
   2572          #endif // ZCL_LIGHT_LINK_ENHANCE
   2573                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2574                if ( pScene != NULL )
   2575                {
   2576                  status = ZCL_STATUS_SUCCESS;
   2577                }
   2578                else
   2579                {
   2580                  // Scene not found
   2581                  if ( scene.groupID != 0x0000 &&
   2582                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2583                  {
   2584                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2585                  }
   2586                  else
   2587                  {
   2588                    status = ZCL_STATUS_NOT_FOUND;
   2589                  }
   2590                  pScene = &scene;
   2591                }
   2592          
   2593                if ( UNICAST_MSG( pInMsg->msg ) )
   2594                {
   2595                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_VIEW )
   2596                  {
   2597                    zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2598                                                     status, pScene, true, pInMsg->hdr.transSeqNum );
   2599                  }
   2600          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2601                  else
   2602                  {
   2603                    zclGeneral_SendSceneEnhancedViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2604                                                             status, pScene, true, pInMsg->hdr.transSeqNum );
   2605                  }
   2606          #endif // ZCL_LIGHT_LINK_ENHANCE
   2607                }
   2608                stat = ZCL_STATUS_CMD_HAS_RSP;
   2609                break;
   2610          
   2611              case COMMAND_SCENE_REMOVE:
   2612                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2613                {
   2614                  status = ZCL_STATUS_SUCCESS;
   2615                }
   2616                else
   2617                {
   2618                  // Scene not found
   2619                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2620                  {
   2621                    // The Group is not in the Group Table
   2622                    status = ZCL_STATUS_INVALID_FIELD;
   2623                  }
   2624                  else
   2625                  {
   2626                    status = ZCL_STATUS_NOT_FOUND;
   2627                  }
   2628                }
   2629          
   2630                if ( UNICAST_MSG( pInMsg->msg ) )
   2631                {
   2632                  // Addressed to this device (not to a group) - send a response back
   2633                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2634                                                      status, scene.groupID,
   2635                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2636                }
   2637                stat = ZCL_STATUS_CMD_HAS_RSP;
   2638                break;
   2639          
   2640              case COMMAND_SCENE_REMOVE_ALL:
   2641                if ( scene.groupID == 0x0000 ||
   2642                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2643                {
   2644                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2645                  status = ZCL_STATUS_SUCCESS;
   2646                }
   2647                else
   2648                {
   2649                  status = ZCL_STATUS_INVALID_FIELD;
   2650                }
   2651          
   2652                if ( UNICAST_MSG( pInMsg->msg ) )
   2653                {
   2654                  // Addressed to this device (not to a group) - send a response back
   2655                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2656                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2657                }
   2658                stat = ZCL_STATUS_CMD_HAS_RSP;
   2659                break;
   2660          
   2661              case COMMAND_SCENE_STORE:
   2662                if ( scene.groupID == 0x0000 ||
   2663                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2664                {
   2665                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2666                  // does and the corresponding Group exits
   2667                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2668                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2669                  {
   2670                    uint8 sceneChanged = FALSE;
   2671          
   2672                    status = ZCL_STATUS_SUCCESS;
   2673                    if ( pScene == NULL )
   2674                    {
   2675                      // Haven't been added yet
   2676                      pScene = &scene;
   2677                    }
   2678          
   2679                    if ( pCBs->pfnSceneStoreReq )
   2680                    {
   2681                      zclSceneReq_t req;
   2682          
   2683                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2684                      req.scene = pScene;
   2685          
   2686                      // Get the latest Scene info
   2687                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2688                      {
   2689                        sceneChanged = TRUE;
   2690                      }
   2691                    }
   2692          
   2693                    if ( pScene == &scene )
   2694                    {
   2695                      // The Scene doesn't exist so add it
   2696                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2697                    }
   2698                    else if ( sceneChanged )
   2699                    {
   2700                      // The Scene already exists so update only NV
   2701                      zclGeneral_ScenesSave();
   2702                    }
   2703                  }
   2704                  else
   2705                  {
   2706                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2707                  }
   2708                }
   2709                else
   2710                {
   2711                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2712                }
   2713          
   2714                if ( UNICAST_MSG( pInMsg->msg ) )
   2715                {
   2716                  // Addressed to this device (not to a group) - send a response back
   2717                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2718                                                     status, scene.groupID, scene.ID,
   2719                                                     true, pInMsg->hdr.transSeqNum );
   2720                }
   2721                stat = ZCL_STATUS_CMD_HAS_RSP;
   2722                break;
   2723          
   2724              case COMMAND_SCENE_RECALL:
   2725                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2726                if ( pScene && pCBs->pfnSceneRecallReq )
   2727                {
   2728                  zclSceneReq_t req;
   2729          
   2730                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2731                  req.scene = pScene;
   2732          
   2733                  pCBs->pfnSceneRecallReq( &req );
   2734                }
   2735                // No response
   2736                break;
   2737          
   2738              case COMMAND_SCENE_GET_MEMBERSHIP:
   2739                // Find all the Scenes corresponding to the Group ID
   2740                if ( scene.groupID == 0x0000 ||
   2741                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2742                {
   2743                  // Allocate space for the scene list
   2744                  sceneList = zcl_mem_alloc( ZCL_GEN_MAX_SCENES );
   2745                  if ( sceneList != NULL )
   2746                  {
   2747                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2748                                                                 scene.groupID, sceneList );
   2749                    status = ZCL_STATUS_SUCCESS;
   2750                    if ( ! UNICAST_MSG( pInMsg->msg ) )
   2751                    {
   2752                      // Addressed to the Group - ONLY send a response if an entry within the
   2753                      // Scene Table corresponds to the Group ID
   2754                      if ( sceneCnt == 0 )
   2755                      {
   2756                        sendRsp = FALSE;
   2757                      }
   2758                    }
   2759                  }
   2760                  else
   2761                  {
   2762                    // Couldn't allocate space for the scene list!
   2763                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2764                  }
   2765                }
   2766                else
   2767                {
   2768                  // The Group is not in the Group Table - send a response back
   2769                  status = ZCL_STATUS_INVALID_FIELD;
   2770                }
   2771          
   2772          #ifdef ZCL_LIGHT_LINK_ENHANCE //ZLL allows response to unicast only
   2773                if ( sendRsp && UNICAST_MSG( pInMsg->msg ) )
   2774          #else
   2775                if ( sendRsp )
   2776          #endif //ZCL_LIGHT_LINK_ENHANCE
   2777                {
   2778                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2779                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2780                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2781                }
   2782          
   2783                if ( sceneList != NULL )
   2784                  zcl_mem_free( sceneList );
   2785          
   2786                stat = ZCL_STATUS_CMD_HAS_RSP;
   2787                break;
   2788          
   2789          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2790              case COMMAND_SCENE_COPY:
   2791                {
   2792                  uint8 mode;
   2793                  uint16 groupIDFrom, groupIDTo;
   2794                  uint8 sceneIDFrom, sceneIDTo;
   2795          
   2796                  pData = pInMsg->pData; // different payload format
   2797          
   2798                  mode = *pData++;
   2799                  groupIDFrom = BUILD_UINT16( pData[0], pData[1] ); // from group ID
   2800                  pData += 2;
   2801                  sceneIDFrom = *pData++; // from scene ID
   2802                  groupIDTo = BUILD_UINT16( pData[0], pData[1] ); // to group ID
   2803                  pData += 2;
   2804                  if ( (mode & SCENE_COPY_MODE_ALL_BIT) == 0 )
   2805                  {
   2806                    sceneIDTo = *pData++; // to scene ID
   2807                  }
   2808          
   2809                  // Make sure the groups exist
   2810                  if ( ( aps_FindGroup( pInMsg->msg->endPoint, groupIDFrom ) != NULL ) &&
   2811                       ( aps_FindGroup( pInMsg->msg->endPoint, groupIDTo ) != NULL ) )
   2812                  {
   2813                    // Allocate space for the scene list
   2814                    sceneList = zcl_mem_alloc( (mode & SCENE_COPY_MODE_ALL_BIT) ? ZCL_GEN_MAX_SCENES : 1 );
   2815                    if ( sceneList == NULL )
   2816                    {
   2817                      status = ZCL_STATUS_INSUFFICIENT_SPACE; // Couldn't allocate space for the scene list!
   2818                    }
   2819                    else
   2820                    {
   2821                      status = ZCL_STATUS_SUCCESS;
   2822                      if ( mode & SCENE_COPY_MODE_ALL_BIT ) // Copy all scenes
   2823                      {
   2824                        sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2825                                                                     groupIDFrom, sceneList );
   2826                      }
   2827                      else // Copy single scene
   2828                      {
   2829                        // Make sure the scene exists
   2830                        pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneIDFrom );
   2831                        if ( pScene != NULL )
   2832                        {
   2833                          sceneList[0] = sceneIDFrom;
   2834                          sceneCnt = 1;
   2835                        }
   2836                        else
   2837                        {
   2838                          status = ZCL_STATUS_INVALID_FIELD; // Scene not found
   2839                        }
   2840                      }
   2841                    }
   2842          
   2843                    if ( status == ZCL_STATUS_SUCCESS )
   2844                    {
   2845                      uint8 numScenesToAdd = 0;
   2846                      uint8 i;
   2847                      for ( i = 0; i < sceneCnt; i++ )
   2848                      {
   2849                        if ( zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, sceneList[i] ) == NULL )
   2850                        {
   2851                          numScenesToAdd++;
   2852                        }
   2853                      }
   2854                      if ( zclGeneral_ScenesRemaingCapacity() >= numScenesToAdd )
   2855                      {
   2856                        // Copy the scenes
   2857                        for ( i = 0; i < sceneCnt; i++ )
   2858                        {
   2859                          // Ignore scene ID from and scene ID to fields
   2860                          pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneList[i] );
   2861                          if ( pScene != NULL )
   2862                          {
   2863                            zclGeneral_Scene_t *pToScene;
   2864                            scene = *pScene;
   2865                            scene.groupID = groupIDTo;
   2866                            scene.ID = ( (mode & SCENE_COPY_MODE_ALL_BIT) ? sceneList[i] : sceneIDTo );
   2867          
   2868                            pToScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2869                            if( pToScene != NULL )
   2870                            {
   2871                              zclGeneral_RemoveScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2872                            }
   2873                            // Add the scene
   2874                            zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2875                          }
   2876                        }
   2877                      }
   2878                      else
   2879                      {
   2880                        status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2881                      }
   2882                    }
   2883                  }
   2884                  else
   2885                  {
   2886                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2887                  }
   2888          
   2889                  if ( UNICAST_MSG( pInMsg->msg ) )
   2890                  {
   2891                    if ( pScene == NULL )
   2892                    {
   2893                      pScene = &scene;
   2894                    }
   2895                    // Addressed to this device (not to a group) - send a response back
   2896                    zclGeneral_SendSceneCopyResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2897                                                      status, pScene->groupID, pScene->ID,
   2898                                                      true, pInMsg->hdr.transSeqNum );
   2899                  }
   2900          
   2901                  if ( sceneList != NULL )
   2902                  {
   2903                    zcl_mem_free( sceneList );
   2904                  }
   2905                }
   2906          
   2907                stat = ZCL_STATUS_CMD_HAS_RSP;
   2908                break;
   2909          #endif // ZCL_LIGHT_LINK_ENHANCE
   2910          
   2911              default:
   2912                stat = ZFailure;
   2913              break;
   2914            }
   2915          
   2916            return ( stat );
   2917          }
   2918          
   2919          /*********************************************************************
   2920           * @fn      zclGeneral_ProcessInScenesClient
   2921           *
   2922           * @brief   Process in the received Scenes Command.
   2923           *
   2924           * @param   pInMsg - pointer to the incoming message
   2925           *
   2926           * @return  ZStatus_t
   2927           */
   2928          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2929                                                             zclGeneral_AppCallbacks_t *pCBs )
   2930          {
   2931            zclGeneral_Scene_t scene;
   2932            uint8 *pData = pInMsg->pData;
   2933            uint8 nameLen;
   2934            zclSceneRsp_t rsp;
   2935            uint8 i;
   2936            ZStatus_t stat = ZSuccess;
   2937          
   2938            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2939            zcl_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2940          
   2941            // Get the status field first
   2942            rsp.status = *pData++;
   2943          
   2944            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2945            {
   2946              rsp.capacity = *pData++;
   2947            }
   2948          
   2949            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2950            pData += 2;   // Move past group ID
   2951          
   2952            switch ( pInMsg->hdr.commandID )
   2953            {
   2954              case COMMAND_SCENE_VIEW_RSP:
   2955                // Parse the rest of the incoming message
   2956                scene.ID = *pData++; // Not applicable to Remove All Response command
   2957                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2958                pData += 2;
   2959                nameLen = *pData++; // Name length
   2960                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2961                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2962          
   2963                scene.name[0] = nameLen;
   2964                zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2965          
   2966                pData += nameLen; // move past name, use original length
   2967          
   2968                //*** Do something with the extension field(s)
   2969          
   2970                // Fall through to callback - break is left off intentionally
   2971          
   2972              case COMMAND_SCENE_ADD_RSP:
   2973              case COMMAND_SCENE_REMOVE_RSP:
   2974              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2975              case COMMAND_SCENE_STORE_RSP:
   2976                if ( pCBs->pfnSceneRsp )
   2977                {
   2978                  if ( pInMsg->hdr.commandID != COMMAND_SCENE_REMOVE_ALL_RSP )
   2979                  {
   2980                    scene.ID = *pData++;
   2981                  }
   2982                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2983                  rsp.cmdID = pInMsg->hdr.commandID;
   2984                  rsp.scene = &scene;
   2985          
   2986                  pCBs->pfnSceneRsp( &rsp );
   2987                }
   2988                break;
   2989          
   2990              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2991                {
   2992                  uint8 *sceneList = NULL;
   2993          
   2994                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   2995                  {
   2996                    uint8 sceneCnt = *pData++;
   2997          
   2998                    if ( sceneCnt > 0 )
   2999                    {
   3000                      // Allocate space for the scene list
   3001                      sceneList = zcl_mem_alloc( sceneCnt );
   3002                      if ( sceneList != NULL )
   3003                      {
   3004                        rsp.sceneCnt = sceneCnt;
   3005                        for ( i = 0; i < sceneCnt; i++ )
   3006                          sceneList[i] = *pData++;
   3007                      }
   3008                    }
   3009                  }
   3010          
   3011                  if ( pCBs->pfnSceneRsp )
   3012                  {
   3013                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3014                    rsp.cmdID = pInMsg->hdr.commandID;
   3015                    rsp.sceneList = sceneList;
   3016                    rsp.scene = &scene;
   3017          
   3018                    pCBs->pfnSceneRsp( &rsp);
   3019                  }
   3020          
   3021                  if ( sceneList != NULL )
   3022                  {
   3023                    zcl_mem_free( sceneList );
   3024                  }
   3025                }
   3026                break;
   3027          
   3028              default:
   3029                stat = ZFailure;
   3030                break;
   3031            }
   3032          
   3033            return ( stat );
   3034          }
   3035          #endif // ZCL_SCENES
   3036          
   3037          #ifdef ZCL_ON_OFF
   3038          /*********************************************************************
   3039           * @fn      zclGeneral_ProcessInCmdOnOff
   3040           *
   3041           * @brief   Process in the received On/Off Command.
   3042           *
   3043           * @param   pInMsg - pointer to the incoming message
   3044           *
   3045           * @return  ZStatus_t
   3046           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3047          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInOnOff:
   3048                                                      zclGeneral_AppCallbacks_t *pCBs )
   3049          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   3050            ZStatus_t stat = ZSuccess;
   \   00000D   75..00       MOV       ?V2,#0x0
   3051          
   3052            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   000010   8E82         MOV       DPL,R6
   \   000012   8F83         MOV       DPH,R7
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F8           MOV       R0,A
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F9           MOV       R1,A
   \   00001B   E8           MOV       A,R0
   \   00001C   13           RRC       A
   \   00001D   13           RRC       A
   \   00001E   13           RRC       A
   \   00001F   541F         ANL       A,#0x1f
   \   000021   5401         ANL       A,#0x1
   \   000023   A2E0         MOV       C,0xE0 /* A   */.0
   \   000025   404E         JC        ??zclGeneral_ProcessInOnOff_0
   3053            {
   3054              switch ( pInMsg->hdr.commandID )
   \   000027   8E82         MOV       DPL,R6
   \   000029   8F83         MOV       DPH,R7
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   6006         JZ        ??zclGeneral_ProcessInOnOff_1
   \   000035   14           DEC       A
   \   000036   6003         JZ        ??zclGeneral_ProcessInOnOff_1
   \   000038   14           DEC       A
   \   000039   7037         JNZ       ??zclGeneral_ProcessInOnOff_2
   3055              {
   3056                case COMMAND_OFF:
   3057                case COMMAND_ON:
   3058                case COMMAND_TOGGLE:
   3059                  if ( pCBs->pfnOnOff )
   \                     ??zclGeneral_ProcessInOnOff_1:
   \   00003B   85..82       MOV       DPL,?V0
   \   00003E   85..83       MOV       DPH,?V1
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F8           MOV       R0,A
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   F9           MOV       R1,A
   \   00004A   E8           MOV       A,R0
   \   00004B   49           ORL       A,R1
   \   00004C   6027         JZ        ??zclGeneral_ProcessInOnOff_0
   3060                  {
   3061                    pCBs->pfnOnOff( pInMsg->hdr.commandID );
   \   00004E                ; Setup parameters for indirect call
   \   00004E   8E82         MOV       DPL,R6
   \   000050   8F83         MOV       DPH,R7
   \   000052   A3           INC       DPTR
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   F9           MOV       R1,A
   \   00005B   85..82       MOV       DPL,?V0
   \   00005E   85..83       MOV       DPH,?V1
   \   000061   A3           INC       DPTR
   \   000062   A3           INC       DPTR
   \   000063   A3           INC       DPTR
   \   000064   A3           INC       DPTR
   \   000065   E0           MOVX      A,@DPTR
   \   000066   F8           MOV       R0,A
   \   000067   A3           INC       DPTR
   \   000068   E0           MOVX      A,@DPTR
   \   000069   F583         MOV       DPH,A
   \   00006B   8882         MOV       DPL,R0
   \   00006D   12....       LCALL     ?CALL_IND
   3062                  }
   3063                  break;
   \   000070   8003         SJMP      ??zclGeneral_ProcessInOnOff_0
   3064          
   3065          #ifdef ZCL_LIGHT_LINK_ENHANCE
   3066                case COMMAND_OFF_WITH_EFFECT:
   3067                  if ( pCBs->pfnOnOff_OffWithEffect )
   3068                  {
   3069                    zclOffWithEffect_t cmd;
   3070          
   3071                    cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3072                    cmd.effectId = pInMsg->pData[0];
   3073                    cmd.effectVariant = pInMsg->pData[1];
   3074          
   3075                    pCBs->pfnOnOff_OffWithEffect( &cmd );
   3076                  }
   3077                  break;
   3078          
   3079                case COMMAND_ON_WITH_RECALL_GLOBAL_SCENE:
   3080                  if ( pCBs->pfnOnOff_OnWithRecallGlobalScene )
   3081                  {
   3082                    pCBs->pfnOnOff_OnWithRecallGlobalScene();
   3083                  }
   3084                  break;
   3085          
   3086                case COMMAND_ON_WITH_TIMED_OFF:
   3087                  if ( pCBs->pfnOnOff_OnWithTimedOff )
   3088                  {
   3089                    zclOnWithTimedOff_t cmd;
   3090          
   3091                    cmd.onOffCtrl.byte = pInMsg->pData[0];
   3092                    cmd.onTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3093                    cmd.offWaitTime = BUILD_UINT16( pInMsg->pData[3], pInMsg->pData[4] );
   3094                    pCBs->pfnOnOff_OnWithTimedOff( &cmd );
   3095                  }
   3096                  break;
   3097          #endif // ZCL_LIGHT_LINK_ENHANCE
   3098          
   3099                default:
   3100                  stat = ZFailure;
   \                     ??zclGeneral_ProcessInOnOff_2:
   \   000072   75..01       MOV       ?V2,#0x1
   3101                  break;
   3102              }
   3103            }
   3104            // no Client command
   3105          
   3106            return ( stat );
   \                     ??zclGeneral_ProcessInOnOff_0:
   \   000075   A9..         MOV       R1,?V2
   \   000077   7F03         MOV       R7,#0x3
   \   000079   02....       LJMP      ?BANKED_LEAVE_XDATA
   3107          }
   3108          #endif // ZCL_ON_OFF
   3109          
   3110          #ifdef ZCL_LEVEL_CTRL
   3111          /*********************************************************************
   3112           * @fn      zclGeneral_ProcessInLevelControl
   3113           *
   3114           * @brief   Process in the received Level Control Command.
   3115           *
   3116           * @param   pInMsg - pointer to the incoming message
   3117           *
   3118           * @return  ZStatus_t
   3119           */
   3120          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   3121                                                             zclGeneral_AppCallbacks_t *pCBs )
   3122          {
   3123            uint8 withOnOff = FALSE;
   3124            ZStatus_t stat = ZSuccess;
   3125          
   3126            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3127            {
   3128              switch ( pInMsg->hdr.commandID )
   3129              {
   3130                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   3131                  withOnOff = TRUE;
   3132                  // fall through
   3133                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   3134                  if ( pCBs->pfnLevelControlMoveToLevel )
   3135                  {
   3136                    zclLCMoveToLevel_t cmd;
   3137          
   3138                    cmd.level = pInMsg->pData[0];
   3139          
   3140                    if ( ( cmd.level >= ATTR_LEVEL_MIN_LEVEL ) &&
   3141                         ( cmd.level <= ATTR_LEVEL_MAX_LEVEL ) )
   3142                    {
   3143                      cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3144                      cmd.withOnOff = withOnOff;
   3145          
   3146                      pCBs->pfnLevelControlMoveToLevel( &cmd );
   3147                    }
   3148                    else
   3149                    {
   3150                      // level range requested is invalid
   3151                      stat = ZCL_STATUS_INVALID_VALUE;
   3152                    }
   3153                  }
   3154                  break;
   3155          
   3156                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   3157                  withOnOff = TRUE;
   3158                  // fall through
   3159                case COMMAND_LEVEL_MOVE:
   3160                  if ( pCBs->pfnLevelControlMove )
   3161                  {
   3162                    zclLCMove_t cmd;
   3163          
   3164                    cmd.moveMode = pInMsg->pData[0];
   3165                    cmd.rate = pInMsg->pData[1];
   3166                    cmd.withOnOff = withOnOff;
   3167          
   3168                    pCBs->pfnLevelControlMove( &cmd );
   3169                  }
   3170                  break;
   3171          
   3172                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   3173                  withOnOff = TRUE;
   3174                  // fall through
   3175                case COMMAND_LEVEL_STEP:
   3176                  if ( pCBs->pfnLevelControlStep )
   3177                  {
   3178                    zclLCStep_t cmd;
   3179          
   3180                    cmd.stepMode = pInMsg->pData[0];
   3181                    cmd.amount =  pInMsg->pData[1];
   3182                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   3183                    cmd.withOnOff = withOnOff;
   3184          
   3185                    pCBs->pfnLevelControlStep( &cmd );
   3186                  }
   3187                  break;
   3188          
   3189                case COMMAND_LEVEL_STOP:
   3190                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   3191                  // Both Stop commands are identical
   3192                  if ( pCBs->pfnLevelControlStop )
   3193                  {
   3194                    pCBs->pfnLevelControlStop();
   3195                  }
   3196                  break;
   3197          
   3198                default:
   3199                  stat = ZFailure;
   3200                  break;
   3201              }
   3202            }
   3203            // no Client command
   3204          
   3205            return ( stat );
   3206          }
   3207          #endif // ZCL_LEVEL_CTRL
   3208          
   3209          #ifdef ZCL_ALARMS
   3210          /*********************************************************************
   3211           * @fn      zclGeneral_AddAlarm
   3212           *
   3213           * @brief   Add an alarm for a cluster
   3214           *
   3215           * @param   endpoint -
   3216           * @param   alarm - new alarm item
   3217           *
   3218           * @return  ZStatus_t
   3219           */
   3220          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   3221          {
   3222            zclGenAlarmItem_t *pNewItem;
   3223            zclGenAlarmItem_t *pLoop;
   3224          
   3225            // Fill in the new profile list
   3226            pNewItem = zcl_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   3227            if ( pNewItem == NULL )
   3228              return ( ZMemError );
   3229          
   3230            // Fill in the plugin record.
   3231            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   3232            pNewItem->endpoint =  endpoint;
   3233            zcl_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   3234          
   3235            // Find spot in list
   3236            if (  zclGenAlarmTable == NULL )
   3237            {
   3238              zclGenAlarmTable = pNewItem;
   3239            }
   3240            else
   3241            {
   3242              // Look for end of list
   3243              pLoop = zclGenAlarmTable;
   3244              while ( pLoop->next != NULL )
   3245                pLoop = pLoop->next;
   3246          
   3247              // Put new item at end of list
   3248              pLoop->next = pNewItem;
   3249            }
   3250          
   3251            return ( ZSuccess );
   3252          }
   3253          
   3254          /*********************************************************************
   3255           * @fn      zclGeneral_FindAlarm
   3256           *
   3257           * @brief   Find an alarm with alarmCode and clusterID
   3258           *
   3259           * @param   endpoint -
   3260           * @param   groupID - what group the scene belongs to
   3261           * @param   sceneID - ID to look for scene
   3262           *
   3263           * @return  a pointer to the alarm information, NULL if not found
   3264           */
   3265          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3266          {
   3267            zclGenAlarmItem_t *pLoop;
   3268          
   3269            // Look for the alarm
   3270            pLoop = zclGenAlarmTable;
   3271            while ( pLoop )
   3272            {
   3273              if ( pLoop->endpoint == endpoint &&
   3274                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3275              {
   3276                return ( &(pLoop->alarm) );
   3277              }
   3278              pLoop = pLoop->next;
   3279            }
   3280          
   3281            return ( (zclGeneral_Alarm_t *)NULL );
   3282          }
   3283          
   3284          /*********************************************************************
   3285           * @fn      zclGeneral_FindEarliestAlarm
   3286           *
   3287           * @brief   Find an alarm with the earliest timestamp
   3288           *
   3289           * @param   endpoint -
   3290           *
   3291           * @return  a pointer to the alarm information, NULL if not found
   3292           */
   3293          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   3294          {
   3295            zclGenAlarmItem_t *pLoop;
   3296            zclGenAlarmItem_t earliestAlarm;
   3297            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   3298          
   3299            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   3300          
   3301            // Look for alarm with earliest time
   3302            pLoop = zclGenAlarmTable;
   3303            while ( pLoop )
   3304            {
   3305              if ( pLoop->endpoint == endpoint &&
   3306                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   3307              {
   3308                pEarliestAlarm = pLoop;
   3309              }
   3310              pLoop = pLoop->next;
   3311            }
   3312          
   3313            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   3314              return ( &(pEarliestAlarm->alarm) );
   3315          
   3316            // No alarm
   3317            return ( (zclGeneral_Alarm_t *)NULL );
   3318          }
   3319          
   3320          /*********************************************************************
   3321           * @fn      zclGeneral_ResetAlarm
   3322           *
   3323           * @brief   Remove an alarm with alarmCode and clusterID
   3324           *
   3325           * @param   endpoint -
   3326           * @param   alarmCode -
   3327           * @param   clusterID -
   3328           *
   3329           * @return  TRUE if removed, FALSE if not found
   3330           */
   3331          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3332          {
   3333            zclGenAlarmItem_t *pLoop;
   3334            zclGenAlarmItem_t *pPrev;
   3335          
   3336            // Look for end of list
   3337            pLoop = zclGenAlarmTable;
   3338            pPrev = NULL;
   3339            while ( pLoop )
   3340            {
   3341              if ( pLoop->endpoint == endpoint &&
   3342                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3343              {
   3344                if ( pPrev == NULL )
   3345                  zclGenAlarmTable = pLoop->next;
   3346                else
   3347                  pPrev->next = pLoop->next;
   3348          
   3349                // Free the memory
   3350                zcl_mem_free( pLoop );
   3351          
   3352                // Notify the Application so that if the alarm condition still active then
   3353                // a new notification will be generated, and a new alarm record will be
   3354                // added to the alarm log
   3355                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   3356                return;
   3357              }
   3358              pPrev = pLoop;
   3359              pLoop = pLoop->next;
   3360            }
   3361          }
   3362          
   3363          /*********************************************************************
   3364           * @fn      zclGeneral_ResetAllAlarms
   3365           *
   3366           * @brief   Remove all alarms with endpoint
   3367           *
   3368           * @param   endpoint -
   3369           * @param   notifyApp -
   3370           *
   3371           * @return  none
   3372           */
   3373          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   3374          {
   3375            zclGenAlarmItem_t *pLoop;
   3376            zclGenAlarmItem_t *pPrev;
   3377            zclGenAlarmItem_t *pNext;
   3378          
   3379            // Look for end of list
   3380            pLoop = zclGenAlarmTable;
   3381            pPrev = NULL;
   3382            while ( pLoop )
   3383            {
   3384              if (  pLoop->endpoint == endpoint )
   3385              {
   3386                if ( pPrev == NULL )
   3387                  zclGenAlarmTable = pLoop->next;
   3388                else
   3389                  pPrev->next = pLoop->next;
   3390          
   3391                pNext = pLoop->next;
   3392          
   3393                // Free the memory
   3394                zcl_mem_free( pLoop );
   3395          
   3396                pLoop = pNext;
   3397              }
   3398              else
   3399              {
   3400                pPrev = pLoop;
   3401                pLoop = pLoop->next;
   3402              }
   3403            }
   3404          
   3405            if ( notifyApp )
   3406            {
   3407              // Notify the Application so that if any alarm conditions still active then
   3408              // a new notification will be generated, and a new alarm record will be
   3409              // added to the alarm log
   3410              // zclGeneral_NotifyResetAll(); // callback function?
   3411            }
   3412          }
   3413          
   3414          /*********************************************************************
   3415           * @fn      zclGeneral_ProcessInAlarmsServer
   3416           *
   3417           * @brief   Process in the received Alarms Command.
   3418           *
   3419           * @param   pInMsg - pointer to the incoming message
   3420           *
   3421           * @return  ZStatus_t
   3422           */
   3423          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   3424                                                             zclGeneral_AppCallbacks_t *pCBs )
   3425          {
   3426            zclAlarm_t alarm;
   3427            zclGeneral_Alarm_t *pAlarm;
   3428            uint8 *pData = pInMsg->pData;
   3429            ZStatus_t stat = ZSuccess;
   3430          
   3431            switch ( pInMsg->hdr.commandID )
   3432            {
   3433              case COMMAND_ALARMS_RESET:
   3434                if ( pCBs->pfnAlarm )
   3435                {
   3436                  alarm.cmdID = pInMsg->hdr.commandID;
   3437                  alarm.alarmCode = pData[0];
   3438                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3439          
   3440                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3441                }
   3442                else
   3443                {
   3444                  stat = ZCL_STATUS_FAILURE;
   3445                }
   3446                break;
   3447          
   3448              case COMMAND_ALARMS_RESET_ALL:
   3449                if ( pCBs->pfnAlarm )
   3450                {
   3451                  alarm.cmdID = pInMsg->hdr.commandID;
   3452          
   3453                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3454                }
   3455                else
   3456                {
   3457                  stat = ZCL_STATUS_FAILURE;
   3458                }
   3459                break;
   3460          
   3461              case COMMAND_ALARMS_GET:
   3462                if ( pCBs->pfnAlarm )
   3463                {
   3464                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3465                  alarm.cmdID = pInMsg->hdr.commandID;
   3466          
   3467                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3468          
   3469                  pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   3470                  if ( pAlarm )
   3471                  {
   3472                    // Send a response back
   3473                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3474                                                     ZCL_STATUS_SUCCESS, pAlarm->code,
   3475                                                     pAlarm->clusterID, pAlarm->timeStamp,
   3476                                                     true, pInMsg->hdr.transSeqNum );
   3477                    // Remove the entry from the Alarm table
   3478                    zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   3479                  }
   3480                  else
   3481                  {
   3482                    // Send a response back
   3483                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3484                                                     ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   3485                                                     true, pInMsg->hdr.transSeqNum );
   3486                  }
   3487                  stat = ZCL_STATUS_CMD_HAS_RSP;
   3488                }
   3489                else
   3490                {
   3491                  stat = ZCL_STATUS_FAILURE;
   3492                }
   3493                break;
   3494          
   3495              case COMMAND_ALARMS_RESET_LOG:
   3496                if ( pCBs->pfnAlarm )
   3497                {
   3498                  alarm.cmdID = pInMsg->hdr.commandID;
   3499          
   3500                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3501          
   3502                  zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   3503                }
   3504                else
   3505                {
   3506                  stat = ZCL_STATUS_FAILURE;
   3507                }
   3508                break;
   3509          
   3510          #ifdef SE_UK_EXT
   3511              case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
   3512                if ( pCBs->pfnPublishEventLog )
   3513                {
   3514                  zclPublishEventLog_t eventLog;
   3515          
   3516                  eventLog.logID = *pData++;
   3517                  eventLog.cmdIndex = *pData++;
   3518                  eventLog.totalCmds = *pData++;
   3519          
   3520                  // First try to find out number of Sub Log Payloads
   3521                  eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
   3522                  if ( eventLog.numSubLogs > 0 )
   3523                  {
   3524                    // Try to alloc space for Log Payload
   3525                    eventLog.pLogs = (zclEventLogPayload_t *)zcl_mem_alloc( sizeof( zclEventLogPayload_t ) *
   3526                                                                             eventLog.numSubLogs );
   3527                    if ( eventLog.pLogs != NULL )
   3528                    {
   3529                      // Copy Log Payload
   3530                      for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
   3531                      {
   3532                        eventLog.pLogs[i].eventId = *pData++;
   3533                        eventLog.pLogs[i].eventTime = zcl_build_uint32( pData, 4 );
   3534                        pData += 4;
   3535                      }
   3536                    }
   3537                    else
   3538                    {
   3539                      stat = ZCL_STATUS_SOFTWARE_FAILURE;
   3540                    }
   3541                  }
   3542                  else
   3543                  {
   3544                    eventLog.pLogs = NULL;
   3545                  }
   3546          
   3547                  if ( stat == ZSuccess )
   3548                  {
   3549                    pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
   3550                  }
   3551          
   3552                  if ( eventLog.pLogs != NULL )
   3553                  {
   3554                    zcl_mem_free( eventLog.pLogs );
   3555                  }
   3556                }
   3557                break;
   3558          #endif // SE_UK_EXT
   3559          
   3560              default:
   3561                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3562                break;
   3563            }
   3564          
   3565            return ( stat );
   3566          }
   3567          
   3568          /*********************************************************************
   3569           * @fn      zclGeneral_ProcessInAlarmsClient
   3570           *
   3571           * @brief   Process in the received Alarms Command.
   3572           *
   3573           * @param   pInMsg - pointer to the incoming message
   3574           *
   3575           * @return  ZStatus_t
   3576           */
   3577          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   3578                                                             zclGeneral_AppCallbacks_t *pCBs )
   3579          {
   3580            uint8 *pData = pInMsg->pData;
   3581            zclAlarm_t alarm;
   3582            ZStatus_t stat = ZSuccess;
   3583          
   3584            zcl_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   3585          
   3586            switch ( pInMsg->hdr.commandID )
   3587            {
   3588              case COMMAND_ALARMS_ALARM:
   3589                if ( pCBs->pfnAlarm )
   3590                {
   3591                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3592                  alarm.cmdID = pInMsg->hdr.commandID;
   3593                  alarm.alarmCode = pData[0];
   3594                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3595          
   3596                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3597                }
   3598                else
   3599                {
   3600                  stat = ZCL_STATUS_FAILURE;
   3601                }
   3602                break;
   3603          
   3604              case COMMAND_ALARMS_GET_RSP:
   3605                if ( pCBs->pfnAlarm )
   3606                {
   3607                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3608                  alarm.cmdID = pInMsg->hdr.commandID;
   3609                  alarm.alarmCode = *pData++;
   3610                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   3611          
   3612                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3613                }
   3614                else
   3615                {
   3616                  stat = ZCL_STATUS_FAILURE;
   3617                }
   3618                break;
   3619          
   3620          #ifdef SE_UK_EXT
   3621              case COMMAND_ALARMS_GET_EVENT_LOG:
   3622                if ( pCBs->pfnGetEventLog )
   3623                {
   3624                  zclGetEventLog_t eventLog;
   3625          
   3626                  eventLog.logID = *pData++;
   3627                  eventLog.startTime = zcl_build_uint32( pData, 4 );
   3628                  pData += 4;
   3629                  eventLog.endTime = zcl_build_uint32( pData, 4 );
   3630                  pData += 4;
   3631                  eventLog.numEvents = *pData;
   3632          
   3633                  pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3634                                        &eventLog, pInMsg->hdr.transSeqNum );
   3635                }
   3636                break;
   3637          #endif // SE_UK_EXT
   3638          
   3639              default:
   3640                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3641                break;
   3642            }
   3643          
   3644            return ( stat );
   3645          }
   3646          #endif // ZCL_ALARMS
   3647          
   3648          #ifdef ZCL_LOCATION
   3649          /*********************************************************************
   3650           * @fn      zclGeneral_ProcessInLocationServer
   3651           *
   3652           * @brief   Process in the received Location Command.
   3653           *
   3654           * @param   pInMsg - pointer to the incoming message
   3655           *
   3656           * @return  ZStatus_t
   3657           */
   3658          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   3659                                                               zclGeneral_AppCallbacks_t *pCBs )
   3660          {
   3661            uint8 *pData = pInMsg->pData;
   3662            zclLocation_t cmd;
   3663            ZStatus_t stat = ZSuccess;
   3664          
   3665            zcl_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   3666          
   3667            switch ( pInMsg->hdr.commandID )
   3668            {
   3669              case COMMAND_LOCATION_SET_ABSOLUTE:
   3670                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3671                pData += 2;
   3672                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3673                pData += 2;
   3674                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3675                pData += 2;
   3676                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3677                pData += 2;
   3678                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3679          
   3680                if ( pCBs->pfnLocation )
   3681                {
   3682                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3683                  cmd.cmdID = pInMsg->hdr.commandID;
   3684          
   3685                  // Update the absolute location info
   3686                  pCBs->pfnLocation( &cmd );
   3687                }
   3688                break;
   3689          
   3690              case COMMAND_LOCATION_SET_DEV_CFG:
   3691                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   3692                pData += 2;
   3693                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3694                pData += 2;
   3695                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3696                pData += 2;
   3697                cmd.un.devCfg.numMeasurements = *pData++;
   3698                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3699          
   3700                if ( pCBs->pfnLocation )
   3701                {
   3702                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3703                  cmd.cmdID = pInMsg->hdr.commandID;
   3704          
   3705                  // Update the device configuration info
   3706                  pCBs->pfnLocation( &cmd );
   3707                }
   3708                break;
   3709          
   3710              case COMMAND_LOCATION_GET_DEV_CFG:
   3711                cmd.un.ieeeAddr = pData;
   3712          
   3713                if ( pCBs->pfnLocation )
   3714                {
   3715                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3716                  cmd.cmdID = pInMsg->hdr.commandID;
   3717                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3718          
   3719                  // Retreive the Device Configuration
   3720                  pCBs->pfnLocation( &cmd );
   3721                }
   3722                stat = ZCL_STATUS_CMD_HAS_RSP;
   3723                break;
   3724          
   3725              case COMMAND_LOCATION_GET_DATA:
   3726                cmd.un.loc.bitmap.locByte = *pData++;
   3727                cmd.un.loc.numResponses = *pData++;
   3728          
   3729                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   3730                  zcl_memcpy( cmd.un.loc.targetAddr, pData, 8 );
   3731          
   3732                if ( pCBs->pfnLocation )
   3733                {
   3734                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3735                  cmd.cmdID = pInMsg->hdr.commandID;
   3736                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3737          
   3738                  // Retreive the Location Data
   3739                  pCBs->pfnLocation( &cmd );
   3740                }
   3741                stat = ZCL_STATUS_CMD_HAS_RSP;
   3742                break;
   3743          
   3744              default:
   3745                stat = ZFailure;
   3746                break;
   3747            }
   3748          
   3749            return ( stat );
   3750          }
   3751          
   3752          /*********************************************************************
   3753           * @fn      zclGeneral_ProcessInLocationDataRsp
   3754           *
   3755           * @brief   Process in the received Location Command.
   3756           *
   3757           * @param   pInMsg - pointer to the incoming message
   3758           *
   3759           * @return  ZStatus_t
   3760           */
   3761          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   3762                                                           zclGeneral_AppCallbacks_t *pCBs )
   3763          {
   3764            uint8 *pData = pInMsg->pData;
   3765            zclLocationRsp_t rsp;
   3766          
   3767            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3768          
   3769            if ( pCBs->pfnLocationRsp )
   3770            {
   3771              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   3772                rsp.un.loc.status = *pData++;
   3773          
   3774              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   3775                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   3776              {
   3777                rsp.un.loc.data.type = *pData++;
   3778                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3779                pData += 2;
   3780                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3781                pData += 2;
   3782          
   3783                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   3784                {
   3785                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3786                  pData += 2;
   3787                }
   3788          
   3789                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3790                {
   3791                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3792                  pData += 2;
   3793                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3794                  pData += 2;
   3795                }
   3796          
   3797                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   3798                {
   3799                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3800                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   3801          
   3802                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   3803                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   3804                }
   3805              }
   3806          
   3807              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3808              rsp.cmdID = pInMsg->hdr.commandID;
   3809          
   3810              // Notify the Application
   3811              pCBs->pfnLocationRsp( &rsp );
   3812            }
   3813          }
   3814          
   3815          /*********************************************************************
   3816           * @fn      zclGeneral_ProcessInLocationClient
   3817           *
   3818           * @brief   Process in the received Location Command.
   3819           *
   3820           * @param   pInMsg - pointer to the incoming message
   3821           *
   3822           * @return  ZStatus_t
   3823           */
   3824          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   3825                                                               zclGeneral_AppCallbacks_t *pCBs )
   3826          {
   3827            uint8 *pData = pInMsg->pData;
   3828            zclLocationRsp_t rsp;
   3829            ZStatus_t stat = ZSuccess;
   3830          
   3831            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3832          
   3833            switch ( pInMsg->hdr.commandID )
   3834            {
   3835              case COMMAND_LOCATION_DEV_CFG_RSP:
   3836                if ( pCBs->pfnLocationRsp )
   3837                {
   3838                  rsp.un.devCfg.status = *pData++;
   3839                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   3840                  {
   3841                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   3842                    pData += 2;
   3843                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3844                    pData += 2;
   3845                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3846                    pData += 2;
   3847                    rsp.un.devCfg.data.numMeasurements = *pData++;
   3848                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3849          
   3850                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3851                    rsp.cmdID = pInMsg->hdr.commandID;
   3852          
   3853                    // Notify the Application
   3854                    pCBs->pfnLocationRsp( &rsp );
   3855                  }
   3856                }
   3857                break;
   3858          
   3859              case COMMAND_LOCATION_DATA_RSP:
   3860              case COMMAND_LOCATION_DATA_NOTIF:
   3861              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3862                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3863                break;
   3864          
   3865              case COMMAND_LOCATION_RSSI_PING:
   3866                if ( pCBs->pfnLocationRsp )
   3867                {
   3868                  rsp.un.locationType = *pData;
   3869          
   3870                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3871                  rsp.cmdID = pInMsg->hdr.commandID;
   3872          
   3873                  // Notify the Application
   3874                  pCBs->pfnLocationRsp( &rsp );
   3875                }
   3876                break;
   3877          
   3878              default:
   3879                stat = ZFailure;
   3880                break;
   3881            }
   3882          
   3883            return ( stat );
   3884          }
   3885          #endif // ZCL_LOCATION
   3886          
   3887          #ifdef ZCL_SCENES
   3888          #if !defined ( ZCL_STANDALONE )
   3889          /*********************************************************************
   3890           * @fn      zclGeneral_ScenesInitNV
   3891           *
   3892           * @brief   Initialize the NV Scene Table Items
   3893           *
   3894           * @param   none
   3895           *
   3896           * @return  number of scenes
   3897           */
   3898          static uint8 zclGeneral_ScenesInitNV( void )
   3899          {
   3900            uint8  status;
   3901            uint16 size;
   3902          
   3903            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3904                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3905          
   3906            status = zcl_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3907          
   3908            if ( status != ZSUCCESS )
   3909            {
   3910              zclGeneral_ScenesSetDefaultNV();
   3911            }
   3912          
   3913            return status;
   3914          }
   3915          #endif // ZCL_STANDALONE
   3916          
   3917          #if !defined ( ZCL_STANDALONE )
   3918          /*********************************************************************
   3919           * @fn          zclGeneral_ScenesSetDefaultNV
   3920           *
   3921           * @brief       Write the defaults to NV
   3922           *
   3923           * @param       none
   3924           *
   3925           * @return      none
   3926           */
   3927          static void zclGeneral_ScenesSetDefaultNV( void )
   3928          {
   3929            nvGenScenesHdr_t hdr;
   3930          
   3931            // Initialize the header
   3932            hdr.numRecs = 0;
   3933          
   3934            // Save off the header
   3935            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3936          }
   3937          #endif // ZCL_STANDALONE
   3938          
   3939          #if !defined ( ZCL_STANDALONE )
   3940          /*********************************************************************
   3941           * @fn          zclGeneral_ScenesWriteNV
   3942           *
   3943           * @brief       Save the Scene Table in NV
   3944           *
   3945           * @param       none
   3946           *
   3947           * @return      none
   3948           */
   3949          static void zclGeneral_ScenesWriteNV( void )
   3950          {
   3951            nvGenScenesHdr_t hdr;
   3952            zclGenSceneItem_t *pLoop;
   3953            zclGenSceneNVItem_t item;
   3954          
   3955            hdr.numRecs = 0;
   3956          
   3957            // Look for end of list
   3958            pLoop = zclGenSceneTable;
   3959            while ( pLoop )
   3960            {
   3961              // Build the record
   3962              item.endpoint = pLoop->endpoint;
   3963              zcl_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3964          
   3965              // Save the record to NV
   3966              zcl_nv_write( ZCD_NV_SCENE_TABLE,
   3967                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3968                              sizeof ( zclGenSceneNVItem_t ), &item );
   3969          
   3970              hdr.numRecs++;
   3971          
   3972              pLoop = pLoop->next;
   3973            }
   3974          
   3975            // Save off the header
   3976            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3977          }
   3978          #endif // ZCL_STANDALONE
   3979          
   3980          #if !defined ( ZCL_STANDALONE )
   3981          /*********************************************************************
   3982           * @fn          zclGeneral_ScenesRestoreFromNV
   3983           *
   3984           * @brief       Restore the Scene table from NV
   3985           *
   3986           * @param       none
   3987           *
   3988           * @return      Number of entries restored
   3989           */
   3990          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   3991          {
   3992            uint16 x;
   3993            nvGenScenesHdr_t hdr;
   3994          
   3995            zclGenSceneNVItem_t item;
   3996            uint16 numAdded = 0;
   3997          
   3998            if ( zcl_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   3999            {
   4000              // Read in the device list
   4001              for ( x = 0; x < hdr.numRecs; x++ )
   4002              {
   4003                if ( zcl_nv_read( ZCD_NV_SCENE_TABLE,
   4004                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   4005                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   4006                {
   4007                  // Add the scene
   4008                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   4009                  {
   4010                    numAdded++;
   4011                  }
   4012                }
   4013              }
   4014            }
   4015          
   4016            return ( numAdded );
   4017          }
   4018          #endif // ZCL_STANDALONE
   4019          
   4020          #if !defined ( ZCL_STANDALONE )
   4021          /*********************************************************************
   4022           * @fn          zclGeneral_ScenesInit
   4023           *
   4024           * @brief       Initialize the scenes table
   4025           *
   4026           * @param       none
   4027           *
   4028           * @return      none
   4029           */
   4030          void zclGeneral_ScenesInit( void )
   4031          {
   4032            // Initialize NV items
   4033            zclGeneral_ScenesInitNV();
   4034          
   4035            // Restore the Scene table
   4036            zclGeneral_ScenesRestoreFromNV();
   4037          }
   4038          #endif // ZCL_STANDALONE
   4039          
   4040          #if !defined ( ZCL_STANDALONE )
   4041          /*********************************************************************
   4042           * @fn          zclGeneral_ScenesSave
   4043           *
   4044           * @brief       Save the scenes table
   4045           *
   4046           * @param       none
   4047           *
   4048           * @return      none
   4049           */
   4050          void zclGeneral_ScenesSave( void )
   4051          {
   4052            // Update NV
   4053            zclGeneral_ScenesWriteNV();
   4054          }
   4055          #endif // ZCL_STANDALONE
   4056          
   4057          #endif // ZCL_SCENES
   4058          
   4059          /***************************************************************************
   4060          ****************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     96   zclGeneral_AddGroup
        0     16   -> aps_AddGroup
        0     19   -> osal_memcpy
        0     20   -> zcl_ReadAttrData
      2     14   zclGeneral_FindCallbacks
      0     23   zclGeneral_HdlInSpecificCommands
        0     14   -> zclGeneral_FindCallbacks
        0     14   -> zclGeneral_ProcessInBasic
        0     14   -> zclGeneral_ProcessInGroupsClient
        0     14   -> zclGeneral_ProcessInGroupsServer
        0     14   -> zclGeneral_ProcessInIdentity
        0     14   -> zclGeneral_ProcessInOnOff
      0      9   zclGeneral_HdlIncoming
        0      9   -> StubAPS_InterPan
        0      9   -> zclGeneral_HdlInSpecificCommands
      0     24   zclGeneral_ProcessInBasic
      1     67   zclGeneral_ProcessInGroupsClient
        0     50   -> osal_mem_alloc
        0     50   -> osal_mem_free
        0     53   -> osal_memcpy
        0     50   -> osal_memset
      1     97   zclGeneral_ProcessInGroupsServer
        0     76   -> aps_CountAllGroups
        0     76   -> aps_FindAllGroupsForEndpoint
        0     76   -> aps_FindGroup
        0     76   -> aps_RemoveAllGroup
        0     76   -> aps_RemoveGroup
        0     76   -> osal_mem_alloc
        0     76   -> osal_mem_free
        0     76   -> osal_memset
        0     76   -> zclGeneral_AddGroup
        0     83   -> zclGeneral_SendGroupGetMembershipRequest
        0     80   -> zclGeneral_SendGroupResponse
        0     79   -> zclGeneral_SendGroupViewResponse
        0     80   -> zcl_ReadAttrData
        0     83   -> zcl_SendDefaultRspCmd
      0     36   zclGeneral_ProcessInIdentity
        0     18   -> bdb_ZclIdentifyCmdInd
        0     18   -> bdb_ZclIdentifyQueryCmdInd
        0     20   -> zclGeneral_SendIdentifyQueryResponse
        0     22   -> zcl_ReadAttrData
      0     25   zclGeneral_ProcessInOnOff
      1     18   zclGeneral_RegisterCmdCallbacks
        0     16   -> osal_mem_alloc
        0     18   -> zcl_registerPlugin
      1     41   zclGeneral_SendAddGroupRequest
        0     25   -> osal_mem_alloc
        0     25   -> osal_mem_free
        0     28   -> osal_memcpy
        0     36   -> zcl_SendCommand
      1    119   zclGeneral_SendGroupGetMembershipRequest
        0     25   -> osal_mem_alloc
        0     25   -> osal_mem_free
        0     36   -> zcl_SendCommand
      1     32   zclGeneral_SendGroupRequest
        0     29   -> zcl_SendCommand
      1    112   zclGeneral_SendGroupResponse
        0     32   -> zcl_SendCommand
      1    112   zclGeneral_SendGroupViewResponse
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     25   -> osal_memcpy
        0     33   -> zcl_SendCommand
      1     31   zclGeneral_SendIdentify
        0     29   -> zcl_SendCommand
      1     27   zclGeneral_SendIdentifyEZModeInvoke
        0     26   -> zcl_SendCommand
      1     49   zclGeneral_SendIdentifyQueryResponse
        0     29   -> zcl_SendCommand
      1     31   zclGeneral_SendIdentifyUpdateCommState
        0     29   -> zcl_SendCommand


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  zclGenCBs
       1  zclGenPluginRegisted
     182  zclGeneral_AddGroup
      70  zclGeneral_FindCallbacks
     209  zclGeneral_HdlInSpecificCommands
     134  zclGeneral_HdlIncoming
      93  zclGeneral_ProcessInBasic
     748  zclGeneral_ProcessInGroupsClient
    1351  zclGeneral_ProcessInGroupsServer
     493  zclGeneral_ProcessInIdentity
     124  zclGeneral_ProcessInOnOff
     194  zclGeneral_RegisterCmdCallbacks
     344  zclGeneral_SendAddGroupRequest
     436  zclGeneral_SendGroupGetMembershipRequest
     173  zclGeneral_SendGroupRequest
     193  zclGeneral_SendGroupResponse
     338  zclGeneral_SendGroupViewResponse
     170  zclGeneral_SendIdentify
     145  zclGeneral_SendIdentifyEZModeInvoke
     170  zclGeneral_SendIdentifyQueryResponse
     161  zclGeneral_SendIdentifyUpdateCommState
     114  -- Other

 
 5 728 bytes in segment BANKED_CODE
   114 bytes in segment BANK_RELAYS
     3 bytes in segment XDATA_Z
 
   114 bytes of CODE     memory
 5 728 bytes of HUGECODE memory
     3 bytes of XDATA    memory

Errors: none
Warnings: none
