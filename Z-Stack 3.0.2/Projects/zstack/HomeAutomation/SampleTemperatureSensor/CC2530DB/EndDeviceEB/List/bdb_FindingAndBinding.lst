###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               21/Jul/2020  00:36:32
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack 3.0.2\Components\stack\bdb\bdb_FindingAndBinding.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EW11B6.tmp ("D:\AA\Z-Stack
#        3.0.2\Components\stack\bdb\bdb_FindingAndBinding.c" -D BDB_REPORTING
#        -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D xNV_RESTORE -D
#        xPOWER_SAVING -D NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D
#        xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D
#        ZCL_TEMPERATURE_MEASUREMENT -D ZCL_GROUPS -D ZCL_ON_OFF -D ZCL_REPORT
#        -D ZCL_REPORT_DESTINATION_DEVICE -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Om --require_prototypes --no_unroll --no_inline --no_tbaa
#        --no_cross_call)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\List\bdb_FindingAndBinding.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\Obj\bdb_FindingAndBinding.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Components\stack\bdb\bdb_FindingAndBinding.c
      1          /**************************************************************************************************
      2            Filename:       bdb_FindingAndBinding.c
      3            Revised:        $Date: 2016-02-25 11:51:49 -0700 (Thu, 25 Feb 2016) $
      4            Revision:       $Revision: - $
      5          
      6            Description:    This file contains the Base Device Behavior functions and attributes.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "bdb.h"
     45          #include "ZDObject.h"
     46          #include "bdb_interface.h"
     47          #include "AddrMgr.h"
     48             
     49          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)   
     50             
     51          /*********************************************************************
     52           * MACROS
     53           */
     54          
     55          
     56          
     57             
     58          /*********************************************************************
     59           * CONSTANTS
     60           */
     61          /*********************************************************************
     62           * TYPEDEFS
     63           */
     64           
     65           
     66          /*********************************************************************
     67           * GLOBAL VARIABLES
     68           */
     69          

   \                                 In  segment XDATA_I, align 1, keep-with-next
     70          uint8 grpName[6] = {'G','r','o','u','p','\0'};
   \                     grpName:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for grpName>`
   \   000006                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     71          bdbGCB_IdentifyTimeChange_t      pfnIdentifyTimeChangeCB = NULL; 
   \                     pfnIdentifyTimeChangeCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     72          bdbGCB_BindNotification_t        pfnBindNotificationCB = NULL;
   \                     pfnBindNotificationCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     73          
     74          /*********************************************************************
     75           * EXTERNAL VARIABLES
     76           */
     77          
     78          /*********************************************************************
     79           * EXTERNAL FUNCTIONS
     80           */
     81          
     82          
     83          
     84          /*********************************************************************
     85           * LOCAL VARIABLES
     86           */
     87          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     88          SimpleDescriptionFormat_t  bdb_FindingBindingTargetSimpleDesc;
   \                     bdb_FindingBindingTargetSimpleDesc:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
     89          

   \                                 In  segment XDATA_I, align 1, keep-with-next
     90          uint8 bdbIndentifyActiveEndpoint  = 0xFF;
   \                     bdbIndentifyActiveEndpoint:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for bdbIndentifyActiveEndpoint>`
   \   000001                REQUIRE __INIT_XDATA_I
     91          
     92          //Your JOB:
     93          //Remove the clusters that your application do not use. This will save some flash and processing
     94          //when looking into matching clusters during the finding & binding procedure

   \                                 In  segment XDATA_ROM_C, align 1
     95          const cId_t bdb_ZclType1Clusters[] =
   \                     bdb_ZclType1Clusters:
   \   000000   0500         DW 5
   \   000002   0600         DW 6
   \   000004   0800         DW 8
   \   000006   0900         DW 9
   \   000008   1600         DW 22
   \   00000A   0201         DW 258
   \   00000C   0202         DW 514
   \   00000E   0302         DW 515
   \   000010   0003         DW 768
   \   000012   0103         DW 769
   \   000014   0105         DW 1281
   \   000016   0205         DW 1282
   \   000018   0006         DW 1536
   \   00001A   0106         DW 1537
   \   00001C   040B         DW 2820
   \   00001E   1406         DW 1556
   \   000020   1506         DW 1557
   \   000022   1706         DW 1559
   \   000024   0007         DW 1792
   \   000026   0107         DW 1793
   \   000028   0207         DW 1794
   \   00002A   0307         DW 1795
   \   00002C   0409         DW 2308
   \   00002E   0009         DW 2304
     96          {
     97            ZCL_CLUSTER_ID_GEN_SCENES,
     98            ZCL_CLUSTER_ID_GEN_ON_OFF,
     99            ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    100            ZCL_CLUSTER_ID_GEN_ALARMS,
    101            ZCL_CLUSTER_ID_GEN_PARTITION,
    102            ZCL_CLUSTER_ID_CLOSURES_WINDOW_COVERING,
    103            ZCL_CLUSTER_ID_HVAC_FAN_CONTROL,
    104            ZCL_CLUSTER_ID_HVAC_DIHUMIDIFICATION_CONTROL,
    105            ZCL_CLUSTER_ID_LIGHTING_COLOR_CONTROL,
    106            ZCL_CLUSTER_ID_LIGHTING_BALLAST_CONFIG,
    107            ZCL_CLUSTER_ID_SS_IAS_ACE,
    108            ZCL_CLUSTER_ID_SS_IAS_WD,
    109            ZCL_CLUSTER_ID_PI_GENERIC_TUNNEL,
    110            ZCL_CLUSTER_ID_PI_BACNET_PROTOCOL_TUNNEL,
    111            ZCL_CLUSTER_ID_HA_ELECTRICAL_MEASUREMENT,
    112            ZCL_CLUSTER_ID_PI_11073_PROTOCOL_TUNNEL,
    113            ZCL_CLUSTER_ID_PI_ISO7818_PROTOCOL_TUNNEL,
    114            ZCL_CLUSTER_ID_PI_RETAIL_TUNNEL,
    115            ZCL_CLUSTER_ID_SE_PRICE,
    116            ZCL_CLUSTER_ID_SE_DRLC,
    117            ZCL_CLUSTER_ID_SE_METERING,
    118            ZCL_CLUSTER_ID_SE_MESSAGING,
    119            ZCL_CLUSTER_ID_TELECOMMUNICATIONS_VOICE_OVER_ZIGBEE,
    120            ZCL_CLUSTER_ID_TELECOMMUNICATIONS_INFORMATION,
    121          };
    122          
    123          //Your JOB:
    124          //Remove the clusters that your application do not use. This will save some flash and processing
    125          //when looking into matching clusters during the finding & binding procedure

   \                                 In  segment XDATA_ROM_C, align 1
    126          const cId_t bdb_ZclType2Clusters[] =
   \                     bdb_ZclType2Clusters:
   \   000000   0700         DW 7
   \   000002   0A00         DW 10
   \   000004   0C00         DW 12
   \   000006   0D00         DW 13
   \   000008   0E00         DW 14
   \   00000A   0F00         DW 15
   \   00000C   1000         DW 16
   \   00000E   1100         DW 17
   \   000010   1200         DW 18
   \   000012   1300         DW 19
   \   000014   1400         DW 20
   \   000016   1900         DW 25
   \   000018   1B00         DW 27
   \   00001A   0001         DW 256
   \   00001C   0101         DW 257
   \   00001E   0002         DW 512
   \   000020   0102         DW 513
   \   000022   0204         DW 1026
   \   000024   0004         DW 1024
   \   000026   0104         DW 1025
   \   000028   0304         DW 1027
   \   00002A   0404         DW 1028
   \   00002C   0504         DW 1029
   \   00002E   0604         DW 1030
   \   000030   0005         DW 1280
   \   000032   0206         DW 1538
   \   000034   0306         DW 1539
   \   000036   0406         DW 1540
   \   000038   0506         DW 1541
   \   00003A   0606         DW 1542
   \   00003C   0706         DW 1543
   \   00003E   0806         DW 1544
   \   000040   0906         DW 1545
   \   000042   0A06         DW 1546
   \   000044   0B06         DW 1547
   \   000046   0C06         DW 1548
   \   000048   0D06         DW 1549
   \   00004A   0E06         DW 1550
   \   00004C   0F06         DW 1551
   \   00004E   1006         DW 1552
   \   000050   1106         DW 1553
   \   000052   1206         DW 1554
   \   000054   1306         DW 1555
   \   000056   0407         DW 1796
   \   000058   0009         DW 2304
   \   00005A   000B         DW 2816
   \   00005C   010B         DW 2817
   \   00005E   020B         DW 2818
   \   000060   030B         DW 2819
    127          {
    128            ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG,
    129            ZCL_CLUSTER_ID_GEN_TIME,
    130            ZCL_CLUSTER_ID_GEN_ANALOG_INPUT_BASIC,
    131            ZCL_CLUSTER_ID_GEN_ANALOG_OUTPUT_BASIC,
    132            ZCL_CLUSTER_ID_GEN_ANALOG_VALUE_BASIC,
    133            ZCL_CLUSTER_ID_GEN_BINARY_INPUT_BASIC,
    134            ZCL_CLUSTER_ID_GEN_BINARY_OUTPUT_BASIC,
    135            ZCL_CLUSTER_ID_GEN_BINARY_VALUE_BASIC,
    136            ZCL_CLUSTER_ID_GEN_MULTISTATE_INPUT_BASIC,
    137            ZCL_CLUSTER_ID_GEN_MULTISTATE_OUTPUT_BASIC,
    138            ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    139            ZCL_CLUSTER_ID_OTA,
    140            ZCL_CLUSTER_ID_GEN_APPLIANCE_CONTROL,
    141            ZCL_CLUSTER_ID_CLOSURES_SHADE_CONFIG,
    142            ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
    143            ZCL_CLUSTER_ID_HVAC_PUMP_CONFIG_CONTROL,
    144            ZCL_CLUSTER_ID_HVAC_THERMOSTAT,
    145            ZCL_CLUSTER_ID_MS_TEMPERATURE_MEASUREMENT,
    146            ZCL_CLUSTER_ID_MS_ILLUMINANCE_MEASUREMENT,
    147            ZCL_CLUSTER_ID_MS_ILLUMINANCE_LEVEL_SENSING_CONFIG,
    148            ZCL_CLUSTER_ID_MS_PRESSURE_MEASUREMENT,
    149            ZCL_CLUSTER_ID_MS_FLOW_MEASUREMENT,
    150            ZCL_CLUSTER_ID_MS_RELATIVE_HUMIDITY,
    151            ZCL_CLUSTER_ID_MS_OCCUPANCY_SENSING,
    152            ZCL_CLUSTER_ID_SS_IAS_ZONE,
    153            ZCL_CLUSTER_ID_PI_ANALOG_INPUT_BACNET_REG,
    154            ZCL_CLUSTER_ID_PI_ANALOG_INPUT_BACNET_EXT,
    155            ZCL_CLUSTER_ID_PI_ANALOG_OUTPUT_BACNET_REG,
    156            ZCL_CLUSTER_ID_PI_ANALOG_OUTPUT_BACNET_EXT,
    157            ZCL_CLUSTER_ID_PI_ANALOG_VALUE_BACNET_REG,
    158            ZCL_CLUSTER_ID_PI_ANALOG_VALUE_BACNET_EXT,
    159            ZCL_CLUSTER_ID_PI_BINARY_INPUT_BACNET_REG,
    160            ZCL_CLUSTER_ID_PI_BINARY_INPUT_BACNET_EXT,
    161            ZCL_CLUSTER_ID_PI_BINARY_OUTPUT_BACNET_REG,
    162            ZCL_CLUSTER_ID_PI_BINARY_OUTPUT_BACNET_EXT,
    163            ZCL_CLUSTER_ID_PI_BINARY_VALUE_BACNET_REG,
    164            ZCL_CLUSTER_ID_PI_BINARY_VALUE_BACNET_EXT,
    165            ZCL_CLUSTER_ID_PI_MULTISTATE_INPUT_BACNET_REG,
    166            ZCL_CLUSTER_ID_PI_MULTISTATE_INPUT_BACNET_EXT,
    167            ZCL_CLUSTER_ID_PI_MULTISTATE_OUTPUT_BACNET_REG,
    168            ZCL_CLUSTER_ID_PI_MULTISTATE_OUTPUT_BACNET_EXT,
    169            ZCL_CLUSTER_ID_PI_MULTISTATE_VALUE_BACNET_REG,
    170            ZCL_CLUSTER_ID_PI_MULTISTATE_VALUE_BACNET_EXT,
    171            ZCL_CLUSTER_ID_SE_TUNNELING,
    172            ZCL_CLUSTER_ID_TELECOMMUNICATIONS_INFORMATION,
    173            ZCL_CLUSTER_ID_HA_APPLIANCE_IDENTIFICATION,
    174            ZCL_CLUSTER_ID_HA_METER_IDENTIFICATION,
    175            ZCL_CLUSTER_ID_HA_APPLIANCE_EVENTS_ALERTS,
    176            ZCL_CLUSTER_ID_HA_APPLIANCE_STATISTICS,
    177          };
    178          
    179          #ifdef ZCL_GROUPS

   \                                 In  segment XDATA_I, align 1, keep-with-next
    180          static zclOptionRec_t zcl_Groups_Options[] =
   \                     zcl_Groups_Options:
   \   000000                DS 3
   \   000003                REQUIRE `?<Initializer for zcl_Groups_Options>`
   \   000003                REQUIRE __INIT_XDATA_I
    181          {
    182            {
    183              ZCL_CLUSTER_ID_GEN_GROUPS,
    184              ( AF_ACK_REQUEST ),
    185            },
    186          };
    187          #endif
    188          
    189          
    190           /*********************************************************************
    191           * LOCAL FUNCTIONS
    192           */
    193          static ZStatus_t bdb_zclFindingBindingAddBindEntry( byte SrcEndpInt,
    194                                            uint16 BindClusterId,
    195                                            byte Cnt,                 
    196                                            uint16 * ClusterList,
    197                                            zAddrType_t *DstAddr, byte DstEndpInt, uint8 addBind, uint8 isClusterOutput );
    198          
    199          uint8 bdb_FindIfAppCluster( cId_t ClusterId, uint8 isClusterOutput );
    200          
    201          
    202          static void bdb_zclSimpleDescClusterListClean( SimpleDescriptionFormat_t *pSimpleDesc );
    203          bdbFindingBindingRespondent_t* bdb_findRespondentNode(uint8 endpoint, uint16 shortAddress);
    204          bdbFindingBindingRespondent_t* bdb_getRespondentRetry(bdbFindingBindingRespondent_t* pRespondentHead);
    205          void bdb_checkMatchingEndpoints(uint8 bindIfMatch, uint16 shortAddress, bdbFindingBindingRespondent_t **pCurr);
    206           /*********************************************************************
    207           * PUBLIC FUNCTIONS
    208           *********************************************************************/
    209          
    210          void bdb_ProcessSimpleDesc( zdoIncomingMsg_t *msgPtr );
    211          void bdb_ProcessIEEEAddrRsp(zdoIncomingMsg_t *pMsg);
    212          
    213          /*********************************************************************
    214           * @fn      bdb_SetIdentifyActiveEndpoint
    215           *
    216           * @brief   Set the endpoint which will perform the finding and binding (either Target or Initiator)
    217           *
    218           * @param   Active endpoint with which perform F&B. If set to 0xFF all endpoints with Identify will be attempted. The endpoint must be either Initiator or Target or Both
    219           *
    220           * @return  ZFailure - F&B commissioning mode already requested
    221           *          ZInvalidParameter - Endpoint specified not found or reserved by Zigbee
    222           *          ZSuccess - 
    223           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    224          ZStatus_t bdb_SetIdentifyActiveEndpoint(uint8 activeEndpoint)
   \                     bdb_SetIdentifyActiveEndpoint:
    225          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   FC           MOV       R4,A
    226            epList_t *bdb_EpDescriptorListTemp = NULL;
    227            
    228            //Cannot process the request if no endpoints or F&B is under process
    229            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_FINDING_BINDING)
   \   000006   90....       MOV       DPTR,#bdbAttributes + 11
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   A2E3         MOV       C,0xE0 /* A   */.3
   \   00000C   5004         JNC       ??bdb_SetIdentifyActiveEndpoint_0
    230            {
    231              return ZFailure;
   \   00000E   7901         MOV       R1,#0x1
   \   000010   8048         SJMP      ??bdb_SetIdentifyActiveEndpoint_1
    232            }
    233            
    234            if(activeEndpoint == 0xFF)
   \                     ??bdb_SetIdentifyActiveEndpoint_0:
   \   000012   74FF         MOV       A,#-0x1
   \   000014   6C           XRL       A,R4
   \   000015   6038         JZ        ??bdb_SetIdentifyActiveEndpoint_2
    235            {
    236              bdbIndentifyActiveEndpoint = activeEndpoint;
    237              return ZSuccess;
    238            }
    239            
    240            if((activeEndpoint != 0) && (activeEndpoint < BDB_ZIGBEE_RESERVED_ENDPOINTS_START))
   \   000017   E9           MOV       A,R1
   \   000018   603E         JZ        ??bdb_SetIdentifyActiveEndpoint_3
   \   00001A   C3           CLR       C
   \   00001B   94F1         SUBB      A,#-0xf
   \   00001D   5039         JNC       ??bdb_SetIdentifyActiveEndpoint_3
    241            {
    242              bdb_EpDescriptorListTemp = bdb_HeadEpDescriptorList;
   \   00001F   90....       MOV       DPTR,#bdb_HeadEpDescriptorList
   \   000022   E0           MOVX      A,@DPTR
   \   000023   FA           MOV       R2,A
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   800C         SJMP      ??bdb_SetIdentifyActiveEndpoint_4
    243              
    244              while(bdb_EpDescriptorListTemp != NULL)
    245              {
    246                if(bdb_EpDescriptorListTemp->epDesc->endPoint == activeEndpoint)
    247                {
    248                  if(bdb_EpDescriptorListTemp->epDesc->epType)
    249                  {
    250                    bdbIndentifyActiveEndpoint = activeEndpoint;
    251                    return ZSuccess;
    252                  }
    253                  else
    254                  {
    255                    return ZInvalidParameter;
    256                  }
    257                }
    258                bdb_EpDescriptorListTemp = bdb_EpDescriptorListTemp->nextDesc;
   \                     ??bdb_SetIdentifyActiveEndpoint_5:
   \   000028   8A82         MOV       DPL,R2
   \   00002A   8B83         MOV       DPH,R3
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F8           MOV       R0,A
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   F9           MOV       R1,A
   \   000031   E8           MOV       A,R0
   \   000032   FA           MOV       R2,A
   \   000033   E9           MOV       A,R1
   \                     ??bdb_SetIdentifyActiveEndpoint_4:
   \   000034   FB           MOV       R3,A
   \   000035   EA           MOV       A,R2
   \   000036   4B           ORL       A,R3
   \   000037   601F         JZ        ??bdb_SetIdentifyActiveEndpoint_3
   \   000039   8A82         MOV       DPL,R2
   \   00003B   8B83         MOV       DPH,R3
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F8           MOV       R0,A
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   8882         MOV       DPL,R0
   \   000045   F583         MOV       DPH,A
   \   000047   E0           MOVX      A,@DPTR
   \   000048   6C           XRL       A,R4
   \   000049   70DD         JNZ       ??bdb_SetIdentifyActiveEndpoint_5
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   6009         JZ        ??bdb_SetIdentifyActiveEndpoint_3
   \                     ??bdb_SetIdentifyActiveEndpoint_2:
   \   00004F   EC           MOV       A,R4
   \   000050   90....       MOV       DPTR,#bdbIndentifyActiveEndpoint
   \   000053   F0           MOVX      @DPTR,A
   \   000054   7900         MOV       R1,#0x0
   \   000056   8002         SJMP      ??bdb_SetIdentifyActiveEndpoint_1
    259              }
    260            }
    261            
    262            return ZInvalidParameter;
   \                     ??bdb_SetIdentifyActiveEndpoint_3:
   \   000058   7902         MOV       R1,#0x2
   \                     ??bdb_SetIdentifyActiveEndpoint_1:
   \   00005A   D083         POP       DPH
   \   00005C   D082         POP       DPL
   \   00005E   02....       LJMP      ?BRET
    263          }
    264          
    265          
    266          /*********************************************************************
    267           * @fn      bdb_setEpDescListToActiveEndpoint
    268           *
    269           * @brief   Set the endpoint list to the active endpoint selected by the application for F&B process
    270           *
    271           * @return  Current endpoint descriptor
    272           */
    273          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    274          endPointDesc_t* bdb_setEpDescListToActiveEndpoint(void)
   \                     bdb_setEpDescListToActiveEndpoint:
    275          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    276            bdb_CurrEpDescriptorList = bdb_HeadEpDescriptorList;
   \   000004   90....       MOV       DPTR,#bdb_HeadEpDescriptorList
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F8           MOV       R0,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   F9           MOV       R1,A
   \   00000C   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   00000F   E8           MOV       A,R0
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   E9           MOV       A,R1
   \   000013   F0           MOVX      @DPTR,A
    277           
    278            //Check which active endpoit is being requested
    279            if(bdbIndentifyActiveEndpoint != 0xFF)
   \   000014   90....       MOV       DPTR,#bdbIndentifyActiveEndpoint
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F4           CPL       A
   \   000019   605F         JZ        ??bdb_setEpDescListToActiveEndpoint_0
    280            {
    281              //Search for an specific endpoint
    282              while(bdb_CurrEpDescriptorList != NULL)
   \                     ??bdb_setEpDescListToActiveEndpoint_1:
   \   00001B   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F8           MOV       R0,A
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F9           MOV       R1,A
   \   000023   E8           MOV       A,R0
   \   000024   49           ORL       A,R1
   \   000025   7003         JNZ       $+5
   \   000027   02....       LJMP      ??bdb_setEpDescListToActiveEndpoint_2 & 0xFFFF
    283              {
    284                if(bdb_CurrEpDescriptorList->epDesc->endPoint == bdbIndentifyActiveEndpoint)
   \   00002A   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   F8           MOV       R0,A
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F583         MOV       DPH,A
   \   000033   8882         MOV       DPL,R0
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   E0           MOVX      A,@DPTR
   \   000038   F8           MOV       R0,A
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   F583         MOV       DPH,A
   \   00003D   8882         MOV       DPL,R0
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F8           MOV       R0,A
   \   000041   90....       MOV       DPTR,#bdbIndentifyActiveEndpoint
   \   000044   E0           MOVX      A,@DPTR
   \   000045   68           XRL       A,R0
   \   000046   605F         JZ        ??bdb_setEpDescListToActiveEndpoint_3
    285                {
    286                  return bdb_CurrEpDescriptorList->epDesc;
    287                }
    288                bdb_CurrEpDescriptorList = bdb_CurrEpDescriptorList->nextDesc;
   \   000048   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   F8           MOV       R0,A
   \   00004D   A3           INC       DPTR
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   F583         MOV       DPH,A
   \   000051   8882         MOV       DPL,R0
   \   000053   E0           MOVX      A,@DPTR
   \   000054   F8           MOV       R0,A
   \   000055   A3           INC       DPTR
   \   000056   E0           MOVX      A,@DPTR
   \   000057   F9           MOV       R1,A
   \   000058   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   00005B   E8           MOV       A,R0
   \   00005C   F0           MOVX      @DPTR,A
   \   00005D   A3           INC       DPTR
   \   00005E   E9           MOV       A,R1
   \   00005F   F0           MOVX      @DPTR,A
   \   000060   80B9         SJMP      ??bdb_setEpDescListToActiveEndpoint_1
    289              }
    290            }
    291            else
    292            {
    293              //Look for the first endpoint that is either intiator or target to perform F&B. Is assumed that the endpoint supports Identify
    294              while(bdb_CurrEpDescriptorList != NULL)
    295              {
    296                if((bdb_CurrEpDescriptorList->epDesc->endPoint != 0) && 
    297                   (bdb_CurrEpDescriptorList->epDesc->endPoint < BDB_ZIGBEE_RESERVED_ENDPOINTS_START) && 
    298                   (bdb_CurrEpDescriptorList->epDesc->epType))
    299                {
    300                  return bdb_CurrEpDescriptorList->epDesc;
    301                }
    302                bdb_CurrEpDescriptorList = bdb_CurrEpDescriptorList->nextDesc;
   \                     ??bdb_setEpDescListToActiveEndpoint_4:
   \   000062   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   000065   E0           MOVX      A,@DPTR
   \   000066   F8           MOV       R0,A
   \   000067   A3           INC       DPTR
   \   000068   E0           MOVX      A,@DPTR
   \   000069   F583         MOV       DPH,A
   \   00006B   8882         MOV       DPL,R0
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   F8           MOV       R0,A
   \   00006F   A3           INC       DPTR
   \   000070   E0           MOVX      A,@DPTR
   \   000071   F9           MOV       R1,A
   \   000072   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   000075   E8           MOV       A,R0
   \   000076   F0           MOVX      @DPTR,A
   \   000077   A3           INC       DPTR
   \   000078   E9           MOV       A,R1
   \   000079   F0           MOVX      @DPTR,A
   \                     ??bdb_setEpDescListToActiveEndpoint_0:
   \   00007A   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   F8           MOV       R0,A
   \   00007F   A3           INC       DPTR
   \   000080   E0           MOVX      A,@DPTR
   \   000081   F9           MOV       R1,A
   \   000082   E8           MOV       A,R0
   \   000083   49           ORL       A,R1
   \   000084   6035         JZ        ??bdb_setEpDescListToActiveEndpoint_2
   \   000086   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   F8           MOV       R0,A
   \   00008B   A3           INC       DPTR
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   F583         MOV       DPH,A
   \   00008F   8882         MOV       DPL,R0
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   E0           MOVX      A,@DPTR
   \   000094   F8           MOV       R0,A
   \   000095   A3           INC       DPTR
   \   000096   E0           MOVX      A,@DPTR
   \   000097   8882         MOV       DPL,R0
   \   000099   F583         MOV       DPH,A
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   60C4         JZ        ??bdb_setEpDescListToActiveEndpoint_4
   \   00009E   C3           CLR       C
   \   00009F   94F1         SUBB      A,#-0xf
   \   0000A1   50BF         JNC       ??bdb_setEpDescListToActiveEndpoint_4
   \   0000A3   A3           INC       DPTR
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   60BB         JZ        ??bdb_setEpDescListToActiveEndpoint_4
   \                     ??bdb_setEpDescListToActiveEndpoint_3:
   \   0000A7   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   0000AA   E0           MOVX      A,@DPTR
   \   0000AB   F8           MOV       R0,A
   \   0000AC   A3           INC       DPTR
   \   0000AD   E0           MOVX      A,@DPTR
   \   0000AE   F583         MOV       DPH,A
   \   0000B0   8882         MOV       DPL,R0
   \   0000B2   A3           INC       DPTR
   \   0000B3   A3           INC       DPTR
   \   0000B4   E0           MOVX      A,@DPTR
   \   0000B5   FA           MOV       R2,A
   \   0000B6   A3           INC       DPTR
   \   0000B7   E0           MOVX      A,@DPTR
   \   0000B8   FB           MOV       R3,A
   \   0000B9   8004         SJMP      ??bdb_setEpDescListToActiveEndpoint_5
    303              }
    304            }
    305            //not found
    306            return NULL;
   \                     ??bdb_setEpDescListToActiveEndpoint_2:
   \   0000BB   7A00         MOV       R2,#0x0
   \   0000BD   7B00         MOV       R3,#0x0
   \                     ??bdb_setEpDescListToActiveEndpoint_5:
   \   0000BF   D083         POP       DPH
   \   0000C1   D082         POP       DPL
   \   0000C3   02....       LJMP      ?BRET
    307          }
    308          
    309          
    310          /*********************************************************************
    311           * @fn      bdb_ProcessIEEEAddrRsp
    312           *
    313           * @brief   Process IEEE addr response and mark the entry as done or remove the 
    314           *          bind if not successful.
    315           *
    316           * @param   zdoIncomingMsg_t *pMsg
    317           *
    318           * @return  none
    319           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    320          void bdb_ProcessIEEEAddrRsp(zdoIncomingMsg_t *pMsg)
   \                     bdb_ProcessIEEEAddrRsp:
    321          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV       A,#-0xf
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    322            ZDO_NwkIEEEAddrResp_t *pAddrRsp = NULL;
    323            bdbFindingBindingRespondent_t *pCurr = NULL;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
    324          
    325            pAddrRsp = ZDO_ParseAddrRsp( pMsg );
   \   000014                ; Setup parameters for call to function ZDO_ParseAddrRsp
   \   000014   12....       LCALL     `??ZDO_ParseAddrRsp::?relay`; Banked call to: ZDO_ParseAddrRsp
   \   000017   8A..         MOV       ?V0,R2
   \   000019   8B..         MOV       ?V1,R3
   \   00001B   AE..         MOV       R6,?V0
   \   00001D   AF..         MOV       R7,?V1
    326            
    327            if(pAddrRsp == NULL)
   \   00001F   EA           MOV       A,R2
   \   000020   4F           ORL       A,R7
   \   000021   7003         JNZ       $+5
   \   000023   02....       LJMP      ??bdb_ProcessIEEEAddrRsp_0 & 0xFFFF
    328            {
    329              return;
    330            }
    331            
    332            bdb_setEpDescListToActiveEndpoint();
   \   000026                ; Setup parameters for call to function bdb_setEpDescListToActiveEndpoint
   \   000026   12....       LCALL     `??bdb_setEpDescListToActiveEndpoint::?relay`; Banked call to: bdb_setEpDescListToActiveEndpoint
    333            
    334            pCurr = bdb_findRespondentNode(bdb_FindingBindingTargetSimpleDesc.EndPoint, pAddrRsp->nwkAddr);
   \   000029   8E82         MOV       DPL,R6
   \   00002B   8F83         MOV       DPH,R7
   \   00002D   A3           INC       DPTR
   \   00002E   8582..       MOV       ?V0,DPL
   \   000031   8583..       MOV       ?V1,DPH
   \   000034                ; Setup parameters for call to function bdb_findRespondentNode
   \   000034   E0           MOVX      A,@DPTR
   \   000035   FA           MOV       R2,A
   \   000036   A3           INC       DPTR
   \   000037   E0           MOVX      A,@DPTR
   \   000038   FB           MOV       R3,A
   \   000039   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F9           MOV       R1,A
   \   00003E   12....       LCALL     `??bdb_findRespondentNode::?relay`; Banked call to: bdb_findRespondentNode
   \   000041   85..82       MOV       DPL,?XSP + 0
   \   000044   85..83       MOV       DPH,?XSP + 1
   \   000047   EA           MOV       A,R2
   \   000048   F0           MOVX      @DPTR,A
   \   000049   A3           INC       DPTR
   \   00004A   EB           MOV       A,R3
   \   00004B   F0           MOVX      @DPTR,A
    335            
    336            //Does the entry exist and we were waiting an IEEE addr rsp from this device?
    337            if((pCurr != NULL) && (pCurr->attempts > FINDING_AND_BINDING_MISSING_IEEE_ADDR))
   \   00004C   85..82       MOV       DPL,?XSP + 0
   \   00004F   85..83       MOV       DPH,?XSP + 1
   \   000052   E0           MOVX      A,@DPTR
   \   000053   F8           MOV       R0,A
   \   000054   A3           INC       DPTR
   \   000055   E0           MOVX      A,@DPTR
   \   000056   F9           MOV       R1,A
   \   000057   E8           MOV       A,R0
   \   000058   49           ORL       A,R1
   \   000059   7003         JNZ       $+5
   \   00005B   02....       LJMP      ??bdb_ProcessIEEEAddrRsp_1 & 0xFFFF
   \   00005E   85..82       MOV       DPL,?XSP + 0
   \   000061   85..83       MOV       DPH,?XSP + 1
   \   000064   E0           MOVX      A,@DPTR
   \   000065   F8           MOV       R0,A
   \   000066   A3           INC       DPTR
   \   000067   E0           MOVX      A,@DPTR
   \   000068   C8           XCH       A,R0
   \   000069   240C         ADD       A,#0xc
   \   00006B   F582         MOV       DPL,A
   \   00006D   E4           CLR       A
   \   00006E   38           ADDC      A,R0
   \   00006F   F583         MOV       DPH,A
   \   000071   E0           MOVX      A,@DPTR
   \   000072   C3           CLR       C
   \   000073   9481         SUBB      A,#-0x7f
   \   000075   5003         JNC       $+5
   \   000077   02....       LJMP      ??bdb_ProcessIEEEAddrRsp_1 & 0xFFFF
    338            {
    339              if(pAddrRsp->status == ZSuccess )
   \   00007A   8E82         MOV       DPL,R6
   \   00007C   8F83         MOV       DPH,R7
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   7079         JNZ       ??bdb_ProcessIEEEAddrRsp_2
    340              {
    341                uint8 extAddr[8]; 
    342                AddrMgrEntry_t entry;
    343                
    344                entry.nwkAddr = pAddrRsp->nwkAddr;
   \   000081   85..82       MOV       DPL,?V0
   \   000084   85..83       MOV       DPH,?V1
   \   000087   E0           MOVX      A,@DPTR
   \   000088   F8           MOV       R0,A
   \   000089   A3           INC       DPTR
   \   00008A   E0           MOVX      A,@DPTR
   \   00008B   F9           MOV       R1,A
   \   00008C   7403         MOV       A,#0x3
   \   00008E   12....       LCALL     ?XSTACK_DISP0_8
   \   000091   E8           MOV       A,R0
   \   000092   F0           MOVX      @DPTR,A
   \   000093   A3           INC       DPTR
   \   000094   E9           MOV       A,R1
   \   000095   F0           MOVX      @DPTR,A
    345                entry.user = ADDRMGR_USER_BINDING;
   \   000096   7402         MOV       A,#0x2
   \   000098   12....       LCALL     ?XSTACK_DISP0_8
   \   00009B   7404         MOV       A,#0x4
   \   00009D   F0           MOVX      @DPTR,A
    346                AddrMgrExtAddrSet(entry.extAddr, pAddrRsp->extAddr);
   \   00009E                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00009E   EE           MOV       A,R6
   \   00009F   2403         ADD       A,#0x3
   \   0000A1   FC           MOV       R4,A
   \   0000A2   E4           CLR       A
   \   0000A3   3F           ADDC      A,R7
   \   0000A4   FD           MOV       R5,A
   \   0000A5   7405         MOV       A,#0x5
   \   0000A7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AA   AA82         MOV       R2,DPL
   \   0000AC   AB83         MOV       R3,DPH
   \   0000AE   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    347                
    348                //Add it as bind entry
    349                if(AddrMgrEntryUpdate(&entry) == FALSE)
   \   0000B1                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   0000B1   7402         MOV       A,#0x2
   \   0000B3   12....       LCALL     ?XSTACK_DISP101_8
   \   0000B6   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   0000B9   E9           MOV       A,R1
   \   0000BA   702A         JNZ       ??bdb_ProcessIEEEAddrRsp_3
    350                {
    351                  //No space, then report F&B table full
    352                  //If periodic was triggered, then finish it
    353                  if(FINDING_AND_BINDING_PERIODIC_ENABLE == TRUE)                                  
    354                  {
    355                    bdb_FB_InitiatorCurrentCyclesNumber = 0;
   \   0000BC   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   0000BF   E4           CLR       A
   \   0000C0   F0           MOVX      @DPTR,A
    356                    osal_stop_timerEx(bdb_TaskID, BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT);
   \   0000C1                ; Setup parameters for call to function osal_stop_timerEx
   \   0000C1   7A40         MOV       R2,#0x40
   \   0000C3   FB           MOV       R3,A
   \   0000C4   90....       MOV       DPTR,#bdb_TaskID
   \   0000C7   E0           MOVX      A,@DPTR
   \   0000C8   F9           MOV       R1,A
   \   0000C9   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    357                  }
    358                  
    359                  bdb_zclSimpleDescClusterListClean( &bdb_FindingBindingTargetSimpleDesc );
   \   0000CC                ; Setup parameters for call to function bdb_zclSimpleDescClusterListClean
   \   0000CC   7A..         MOV       R2,#bdb_FindingBindingTargetSimpleDesc & 0xff
   \   0000CE   7B..         MOV       R3,#(bdb_FindingBindingTargetSimpleDesc >> 8) & 0xff
   \   0000D0   12....       LCALL     `??bdb_zclSimpleDescClusterListClean::?relay`; Banked call to: bdb_zclSimpleDescClusterListClean
    360                  osal_stop_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT );
   \   0000D3                ; Setup parameters for call to function osal_stop_timerEx
   \   0000D3   7A00         MOV       R2,#0x0
   \   0000D5   7B40         MOV       R3,#0x40
   \   0000D7   90....       MOV       DPTR,#bdb_TaskID
   \   0000DA   E0           MOVX      A,@DPTR
   \   0000DB   F9           MOV       R1,A
   \   0000DC   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    361                  bdb_exitFindingBindingWStatus( BDB_COMMISSIONING_FB_BINDING_TABLE_FULL );
   \   0000DF                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   0000DF   790C         MOV       R1,#0xc
   \   0000E1   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
    362                  return;
   \   0000E4   8031         SJMP      ??bdb_ProcessIEEEAddrRsp_0
    363                }
    364          
    365                //search for the matching clusters to be added this time as we have the IEEE addrs
    366                bdb_checkMatchingEndpoints(TRUE, pAddrRsp->nwkAddr, &pCurr);
   \                     ??bdb_ProcessIEEEAddrRsp_3:
   \   0000E6                ; Setup parameters for call to function bdb_checkMatchingEndpoints
   \   0000E6   AC..         MOV       R4,?XSP + 0
   \   0000E8   AD..         MOV       R5,?XSP + 1
   \   0000EA   85..82       MOV       DPL,?V0
   \   0000ED   85..83       MOV       DPH,?V1
   \   0000F0   E0           MOVX      A,@DPTR
   \   0000F1   FA           MOV       R2,A
   \   0000F2   A3           INC       DPTR
   \   0000F3   E0           MOVX      A,@DPTR
   \   0000F4   FB           MOV       R3,A
   \   0000F5   7901         MOV       R1,#0x1
   \   0000F7   12....       LCALL     `??bdb_checkMatchingEndpoints::?relay`; Banked call to: bdb_checkMatchingEndpoints
    367                (void)extAddr;  //dummy
    368              }
    369              //Bind cannot be added if the device was not found
    370              pCurr->attempts = FINDING_AND_BINDING_RESPONDENT_COMPLETE;
   \                     ??bdb_ProcessIEEEAddrRsp_2:
   \   0000FA   85..82       MOV       DPL,?XSP + 0
   \   0000FD   85..83       MOV       DPH,?XSP + 1
   \   000100   E0           MOVX      A,@DPTR
   \   000101   F8           MOV       R0,A
   \   000102   A3           INC       DPTR
   \   000103   E0           MOVX      A,@DPTR
   \   000104   C8           XCH       A,R0
   \   000105   240C         ADD       A,#0xc
   \   000107   F582         MOV       DPL,A
   \   000109   E4           CLR       A
   \   00010A   38           ADDC      A,R0
   \   00010B   F583         MOV       DPH,A
   \   00010D   74FF         MOV       A,#-0x1
   \   00010F   F0           MOVX      @DPTR,A
    371            }
    372            
    373            //release the memory
    374            osal_mem_free( pAddrRsp );
   \                     ??bdb_ProcessIEEEAddrRsp_1:
   \   000110                ; Setup parameters for call to function osal_mem_free
   \   000110   EE           MOV       A,R6
   \   000111   FA           MOV       R2,A
   \   000112   EF           MOV       A,R7
   \   000113   FB           MOV       R3,A
   \   000114   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    375          }
   \                     ??bdb_ProcessIEEEAddrRsp_0:
   \   000117   740F         MOV       A,#0xf
   \   000119   12....       LCALL     ?DEALLOC_XSTACK8
   \   00011C   7F02         MOV       R7,#0x2
   \   00011E   02....       LJMP      ?BANKED_LEAVE_XDATA
    376          
    377          
    378          /*********************************************************************
    379           * @fn      bdb_StopInitiatorFindingBinding
    380           *
    381           * @brief   Stops finding and binding for initiator devices.
    382           *
    383           * @param   none
    384           *
    385           * @return  none
    386           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    387          void bdb_StopInitiatorFindingBinding(void)
   \                     bdb_StopInitiatorFindingBinding:
    388          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    389            //If periodic was triggered, then finish it
    390            if(FINDING_AND_BINDING_PERIODIC_ENABLE == TRUE)                                  
    391            {
    392              bdb_FB_InitiatorCurrentCyclesNumber = 0;
   \   000004   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000007   E4           CLR       A
   \   000008   F0           MOVX      @DPTR,A
    393              osal_stop_timerEx(bdb_TaskID, BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT);
   \   000009                ; Setup parameters for call to function osal_stop_timerEx
   \   000009   7A40         MOV       R2,#0x40
   \   00000B   FB           MOV       R3,A
   \   00000C   90....       MOV       DPTR,#bdb_TaskID
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   F9           MOV       R1,A
   \   000011   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    394            }      
    395            //Clean the respondent list and stop its timer
    396            bdb_zclRespondentListClean( &pRespondentHead );
   \   000014                ; Setup parameters for call to function bdb_zclRespondentListClean
   \   000014   7A..         MOV       R2,#pRespondentHead & 0xff
   \   000016   7B..         MOV       R3,#(pRespondentHead >> 8) & 0xff
   \   000018   12....       LCALL     `??bdb_zclRespondentListClean::?relay`; Banked call to: bdb_zclRespondentListClean
    397            osal_stop_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT );
   \   00001B                ; Setup parameters for call to function osal_stop_timerEx
   \   00001B   7A00         MOV       R2,#0x0
   \   00001D   7B40         MOV       R3,#0x40
   \   00001F   90....       MOV       DPTR,#bdb_TaskID
   \   000022   E0           MOVX      A,@DPTR
   \   000023   F9           MOV       R1,A
   \   000024   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    398            
    399            //Notify status
    400            bdb_exitFindingBindingWStatus( BDB_COMMISSIONING_FB_NO_IDENTIFY_QUERY_RESPONSE );
   \   000027                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   000027   790B         MOV       R1,#0xb
   \   000029   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
    401          
    402          }
   \   00002C   D083         POP       DPH
   \   00002E   D082         POP       DPL
   \   000030   02....       LJMP      ?BRET
    403          
    404          
    405          /*********************************************************************
    406           * @fn      bdb_checkMatchingEndpoints
    407           *
    408           * @brief   Check active endpoints for F&B and the respondant simple descriptor 
    409           *          for matching application clusters
    410           *
    411           * @param   pRespondant - Respondant to be process
    412           * @param   bindIfMatch - Flag to indicate that binds for matching cluster must 
    413           *                        be done
    414           *
    415           * @return  status - Result of the operation
    416           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    417          void bdb_checkMatchingEndpoints(uint8 bindIfMatch, uint16 shortAddr, bdbFindingBindingRespondent_t **pCurr)
   \                     bdb_checkMatchingEndpoints:
    418          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV       A,#-0x15
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   8A..         MOV       ?V6,R2
   \   00000E   8B..         MOV       ?V7,R3
   \   000010   8C..         MOV       ?V10,R4
   \   000012   8D..         MOV       ?V11,R5
    419            uint8 matchFound;
    420            endPointDesc_t *bdb_CurrEpDescriptor;
    421            uint8 i, status;
    422            zAddrType_t dstAddr;
    423          #ifdef ZCL_GROUPS
    424            afAddrType_t afDstAddr;
    425          #endif  
    426            
    427            //Check all the endpoints active for F&B
    428            while(bdb_CurrEpDescriptorList != NULL)
   \                     ??bdb_checkMatchingEndpoints_0:
   \   000014   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F9           MOV       R1,A
   \   00001C   E8           MOV       A,R0
   \   00001D   49           ORL       A,R1
   \   00001E   7003         JNZ       $+5
   \   000020   02....       LJMP      ??bdb_checkMatchingEndpoints_1 & 0xFFFF
    429            {
    430              matchFound = FALSE;
   \   000023   7F00         MOV       R7,#0x0
    431          
    432              bdb_CurrEpDescriptor = bdb_CurrEpDescriptorList->epDesc;
   \   000025   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F8           MOV       R0,A
   \   00002A   A3           INC       DPTR
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   F583         MOV       DPH,A
   \   00002E   8882         MOV       DPL,R0
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   F5..         MOV       ?V2,A
   \   000035   A3           INC       DPTR
   \   000036   E0           MOVX      A,@DPTR
   \   000037   F5..         MOV       ?V3,A
    433          
    434          #ifdef ZCL_GROUPS
    435              if ( bdbAttributes.bdbCommissioningGroupID != 0xFFFF )    
   \   000039   90....       MOV       DPTR,#bdbAttributes + 8
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F4           CPL       A
   \   00003E   7003         JNZ       ??bdb_checkMatchingEndpoints_2
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   F4           CPL       A
   \                     ??bdb_checkMatchingEndpoints_2:
   \   000043   602E         JZ        ??bdb_checkMatchingEndpoints_3
    436              {
    437                zcl_registerClusterOptionList(bdb_CurrEpDescriptor->endPoint,1,zcl_Groups_Options);      
   \   000045                ; Setup parameters for call to function zcl_registerClusterOptionList
   \   000045   7C..         MOV       R4,#zcl_Groups_Options & 0xff
   \   000047   7D..         MOV       R5,#(zcl_Groups_Options >> 8) & 0xff
   \   000049   7A01         MOV       R2,#0x1
   \   00004B   85..82       MOV       DPL,?V2
   \   00004E   85..83       MOV       DPH,?V3
   \   000051   E0           MOVX      A,@DPTR
   \   000052   F9           MOV       R1,A
   \   000053   12....       LCALL     `??zcl_registerClusterOptionList::?relay`; Banked call to: zcl_registerClusterOptionList
    438                
    439                dstAddr.addr.shortAddr = bdbAttributes.bdbCommissioningGroupID;
   \   000056   90....       MOV       DPTR,#bdbAttributes + 8
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   F8           MOV       R0,A
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F9           MOV       R1,A
   \   00005E   85..82       MOV       DPL,?XSP + 0
   \   000061   85..83       MOV       DPH,?XSP + 1
   \   000064   E8           MOV       A,R0
   \   000065   F0           MOVX      @DPTR,A
   \   000066   A3           INC       DPTR
   \   000067   E9           MOV       A,R1
   \   000068   F0           MOVX      @DPTR,A
    440                dstAddr.addrMode = AddrGroup;
   \   000069   7408         MOV       A,#0x8
   \   00006B   12....       LCALL     ?XSTACK_DISP0_8
   \   00006E   7401         MOV       A,#0x1
   \   000070   F0           MOVX      @DPTR,A
   \   000071   8016         SJMP      ??bdb_checkMatchingEndpoints_4
    441              }
    442              else
    443          #endif
    444              {
    445                dstAddr.addrMode = Addr64Bit;
   \                     ??bdb_checkMatchingEndpoints_3:
   \   000073   7408         MOV       A,#0x8
   \   000075   12....       LCALL     ?XSTACK_DISP0_8
   \   000078   7403         MOV       A,#0x3
   \   00007A   F0           MOVX      @DPTR,A
    446                if(bindIfMatch)
   \   00007B   EE           MOV       A,R6
   \   00007C   600B         JZ        ??bdb_checkMatchingEndpoints_4
    447                {
    448                  //if bind is to be created, then we should have the ext address in addr mgr
    449                  AddrMgrExtAddrLookup( shortAddr, dstAddr.addr.extAddr );
   \   00007E                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   00007E   AC..         MOV       R4,?XSP + 0
   \   000080   AD..         MOV       R5,?XSP + 1
   \   000082   AA..         MOV       R2,?V6
   \   000084   AB..         MOV       R3,?V7
   \   000086   12....       LCALL     `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
    450                }
    451              }
    452              for(i = 0; i < bdb_CurrEpDescriptor->simpleDesc->AppNumOutClusters; i++)
   \                     ??bdb_checkMatchingEndpoints_4:
   \   000089   75..00       MOV       ?V0,#0x0
   \   00008C   8002         SJMP      ??bdb_checkMatchingEndpoints_5
   \                     ??bdb_checkMatchingEndpoints_6:
   \   00008E   05..         INC       ?V0
   \                     ??bdb_checkMatchingEndpoints_5:
   \   000090   E5..         MOV       A,?V2
   \   000092   2404         ADD       A,#0x4
   \   000094   F5..         MOV       ?V4,A
   \   000096   E4           CLR       A
   \   000097   35..         ADDC      A,?V3
   \   000099   F5..         MOV       ?V5,A
   \   00009B   85..82       MOV       DPL,?V4
   \   00009E   F583         MOV       DPH,A
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   FA           MOV       R2,A
   \   0000A2   A3           INC       DPTR
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   FB           MOV       R3,A
   \   0000A5   8A82         MOV       DPL,R2
   \   0000A7   F583         MOV       DPH,A
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   A3           INC       DPTR
   \   0000AC   A3           INC       DPTR
   \   0000AD   A3           INC       DPTR
   \   0000AE   A3           INC       DPTR
   \   0000AF   A3           INC       DPTR
   \   0000B0   A3           INC       DPTR
   \   0000B1   A3           INC       DPTR
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   F8           MOV       R0,A
   \   0000B4   E5..         MOV       A,?V0
   \   0000B6   C3           CLR       C
   \   0000B7   98           SUBB      A,R0
   \   0000B8   5079         JNC       ??bdb_checkMatchingEndpoints_7
    453              {
    454                //Filter for Application clusters (to bind app clusters only)
    455                status = bdb_zclFindingBindingAddBindEntry( bdb_CurrEpDescriptor->endPoint,
    456                                        bdb_CurrEpDescriptor->simpleDesc->pAppOutClusterList[i],
    457                                        bdb_FindingBindingTargetSimpleDesc.AppNumInClusters,
    458                                        bdb_FindingBindingTargetSimpleDesc.pAppInClusterList,
    459                                        &dstAddr, bdb_FindingBindingTargetSimpleDesc.EndPoint, bindIfMatch, TRUE );
   \   0000BA                ; Setup parameters for call to function bdb_zclFindingBindingAddBindEntry
   \   0000BA   75..01       MOV       ?V1,#0x1
   \   0000BD   78..         MOV       R0,#?V1
   \   0000BF   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C2   EE           MOV       A,R6
   \   0000C3   F5..         MOV       ?V1,A
   \   0000C5   78..         MOV       R0,#?V1
   \   0000C7   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000CA   7402         MOV       A,#0x2
   \   0000CC   12....       LCALL     ?XSTACK_DISP100_8
   \   0000CF   88..         MOV       ?V8,R0
   \   0000D1   89..         MOV       ?V9,R1
   \   0000D3   78..         MOV       R0,#?V8
   \   0000D5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000D8   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc + 7
   \   0000DB   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0000DE   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc
   \   0000E1   E0           MOVX      A,@DPTR
   \   0000E2   FD           MOV       R5,A
   \   0000E3   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc + 6
   \   0000E6   E0           MOVX      A,@DPTR
   \   0000E7   FC           MOV       R4,A
   \   0000E8   A8..         MOV       R0,?V0
   \   0000EA   E8           MOV       A,R0
   \   0000EB   28           ADD       A,R0
   \   0000EC   F8           MOV       R0,A
   \   0000ED   E4           CLR       A
   \   0000EE   33           RLC       A
   \   0000EF   F9           MOV       R1,A
   \   0000F0   8A82         MOV       DPL,R2
   \   0000F2   8B83         MOV       DPH,R3
   \   0000F4   A3           INC       DPTR
   \   0000F5   A3           INC       DPTR
   \   0000F6   A3           INC       DPTR
   \   0000F7   A3           INC       DPTR
   \   0000F8   A3           INC       DPTR
   \   0000F9   A3           INC       DPTR
   \   0000FA   A3           INC       DPTR
   \   0000FB   A3           INC       DPTR
   \   0000FC   A3           INC       DPTR
   \   0000FD   A3           INC       DPTR
   \   0000FE   E0           MOVX      A,@DPTR
   \   0000FF   28           ADD       A,R0
   \   000100   FA           MOV       R2,A
   \   000101   A3           INC       DPTR
   \   000102   E0           MOVX      A,@DPTR
   \   000103   39           ADDC      A,R1
   \   000104   8A82         MOV       DPL,R2
   \   000106   F583         MOV       DPH,A
   \   000108   E0           MOVX      A,@DPTR
   \   000109   FA           MOV       R2,A
   \   00010A   A3           INC       DPTR
   \   00010B   E0           MOVX      A,@DPTR
   \   00010C   FB           MOV       R3,A
   \   00010D   85..82       MOV       DPL,?V2
   \   000110   85..83       MOV       DPH,?V3
   \   000113   E0           MOVX      A,@DPTR
   \   000114   F9           MOV       R1,A
   \   000115   12....       LCALL     `??bdb_zclFindingBindingAddBindEntry::?relay`; Banked call to: bdb_zclFindingBindingAddBindEntry
   \   000118   7406         MOV       A,#0x6
   \   00011A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00011D   E9           MOV       A,R1
   \   00011E   F5..         MOV       ?V1,A
    460                
    461                if ( status == ZApsTableFull )
   \   000120   74B2         MOV       A,#-0x4e
   \   000122   69           XRL       A,R1
   \   000123   600E         JZ        ??bdb_checkMatchingEndpoints_7
    462                {
    463                  break;
    464                }
    465                else if(status == ZSuccess)
   \   000125   E9           MOV       A,R1
   \   000126   6003         JZ        $+5
   \   000128   02....       LJMP      ??bdb_checkMatchingEndpoints_6 & 0xFFFF
    466                {
    467                  matchFound = TRUE;
   \   00012B   7F01         MOV       R7,#0x1
    468                  //If a match is found and we are not adding due to lack of IEEE addrs, then skip looking
    469                  if(!bindIfMatch)
   \   00012D   EE           MOV       A,R6
   \   00012E   6003         JZ        $+5
   \   000130   02....       LJMP      ??bdb_checkMatchingEndpoints_6 & 0xFFFF
    470                  {
    471                    break;
    472                  }
    473                }
    474              }
    475              
    476              //Only search for other matches if the table is not full and we have not 
    477              //found any match or we have to add bind as many as we can
    478              if( (status != ZApsTableFull) && (!matchFound || bindIfMatch) )      
   \                     ??bdb_checkMatchingEndpoints_7:
   \   000133   74B2         MOV       A,#-0x4e
   \   000135   65..         XRL       A,?V1
   \   000137   7003         JNZ       $+5
   \   000139   02....       LJMP      ??bdb_checkMatchingEndpoints_8 & 0xFFFF
   \   00013C   EF           MOV       A,R7
   \   00013D   6006         JZ        ??bdb_checkMatchingEndpoints_9
   \   00013F   EE           MOV       A,R6
   \   000140   7003         JNZ       $+5
   \   000142   02....       LJMP      ??bdb_checkMatchingEndpoints_8 & 0xFFFF
    479              {
    480                for(i = 0; i < bdb_CurrEpDescriptor->simpleDesc->AppNumInClusters; i++)
   \                     ??bdb_checkMatchingEndpoints_9:
   \   000145   75..00       MOV       ?V0,#0x0
   \   000148   8002         SJMP      ??bdb_checkMatchingEndpoints_10
   \                     ??bdb_checkMatchingEndpoints_11:
   \   00014A   05..         INC       ?V0
   \                     ??bdb_checkMatchingEndpoints_10:
   \   00014C   85..82       MOV       DPL,?V4
   \   00014F   85..83       MOV       DPH,?V5
   \   000152   E0           MOVX      A,@DPTR
   \   000153   FA           MOV       R2,A
   \   000154   A3           INC       DPTR
   \   000155   E0           MOVX      A,@DPTR
   \   000156   FB           MOV       R3,A
   \   000157   8A82         MOV       DPL,R2
   \   000159   F583         MOV       DPH,A
   \   00015B   A3           INC       DPTR
   \   00015C   A3           INC       DPTR
   \   00015D   A3           INC       DPTR
   \   00015E   A3           INC       DPTR
   \   00015F   A3           INC       DPTR
   \   000160   A3           INC       DPTR
   \   000161   E0           MOVX      A,@DPTR
   \   000162   F8           MOV       R0,A
   \   000163   E5..         MOV       A,?V0
   \   000165   C3           CLR       C
   \   000166   98           SUBB      A,R0
   \   000167   5076         JNC       ??bdb_checkMatchingEndpoints_8
    481                {
    482                  //Filter for Application clusters (to bind app clusters only)
    483                  status = bdb_zclFindingBindingAddBindEntry( bdb_CurrEpDescriptor->endPoint,
    484                                          bdb_CurrEpDescriptor->simpleDesc->pAppInClusterList[i],
    485                                          bdb_FindingBindingTargetSimpleDesc.AppNumOutClusters,
    486                                          bdb_FindingBindingTargetSimpleDesc.pAppOutClusterList,
    487                                          &dstAddr, bdb_FindingBindingTargetSimpleDesc.EndPoint, bindIfMatch, FALSE );
   \   000169                ; Setup parameters for call to function bdb_zclFindingBindingAddBindEntry
   \   000169   75..00       MOV       ?V1,#0x0
   \   00016C   78..         MOV       R0,#?V1
   \   00016E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000171   EE           MOV       A,R6
   \   000172   F5..         MOV       ?V1,A
   \   000174   78..         MOV       R0,#?V1
   \   000176   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000179   7402         MOV       A,#0x2
   \   00017B   12....       LCALL     ?XSTACK_DISP100_8
   \   00017E   88..         MOV       ?V8,R0
   \   000180   89..         MOV       ?V9,R1
   \   000182   78..         MOV       R0,#?V8
   \   000184   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000187   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc + 10
   \   00018A   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00018D   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc
   \   000190   E0           MOVX      A,@DPTR
   \   000191   FD           MOV       R5,A
   \   000192   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc + 9
   \   000195   E0           MOVX      A,@DPTR
   \   000196   FC           MOV       R4,A
   \   000197   A8..         MOV       R0,?V0
   \   000199   E8           MOV       A,R0
   \   00019A   28           ADD       A,R0
   \   00019B   F8           MOV       R0,A
   \   00019C   E4           CLR       A
   \   00019D   33           RLC       A
   \   00019E   F9           MOV       R1,A
   \   00019F   8A82         MOV       DPL,R2
   \   0001A1   8B83         MOV       DPH,R3
   \   0001A3   A3           INC       DPTR
   \   0001A4   A3           INC       DPTR
   \   0001A5   A3           INC       DPTR
   \   0001A6   A3           INC       DPTR
   \   0001A7   A3           INC       DPTR
   \   0001A8   A3           INC       DPTR
   \   0001A9   A3           INC       DPTR
   \   0001AA   E0           MOVX      A,@DPTR
   \   0001AB   28           ADD       A,R0
   \   0001AC   FA           MOV       R2,A
   \   0001AD   A3           INC       DPTR
   \   0001AE   E0           MOVX      A,@DPTR
   \   0001AF   39           ADDC      A,R1
   \   0001B0   8A82         MOV       DPL,R2
   \   0001B2   F583         MOV       DPH,A
   \   0001B4   E0           MOVX      A,@DPTR
   \   0001B5   FA           MOV       R2,A
   \   0001B6   A3           INC       DPTR
   \   0001B7   E0           MOVX      A,@DPTR
   \   0001B8   FB           MOV       R3,A
   \   0001B9   85..82       MOV       DPL,?V2
   \   0001BC   85..83       MOV       DPH,?V3
   \   0001BF   E0           MOVX      A,@DPTR
   \   0001C0   F9           MOV       R1,A
   \   0001C1   12....       LCALL     `??bdb_zclFindingBindingAddBindEntry::?relay`; Banked call to: bdb_zclFindingBindingAddBindEntry
   \   0001C4   7406         MOV       A,#0x6
   \   0001C6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001C9   E9           MOV       A,R1
   \   0001CA   F5..         MOV       ?V1,A
    488          
    489                  if ( status == ZApsTableFull )
   \   0001CC   74B2         MOV       A,#-0x4e
   \   0001CE   69           XRL       A,R1
   \   0001CF   600E         JZ        ??bdb_checkMatchingEndpoints_8
    490                  {
    491                    break;
    492                  }
    493                  else if(status == ZSuccess)
   \   0001D1   E9           MOV       A,R1
   \   0001D2   6003         JZ        $+5
   \   0001D4   02....       LJMP      ??bdb_checkMatchingEndpoints_11 & 0xFFFF
    494                  {
    495                    matchFound = TRUE;
   \   0001D7   7F01         MOV       R7,#0x1
    496                    
    497                    //If a match is found and we are not adding due to lack of IEEE addrs, then skip looking
    498                    if(!bindIfMatch)
   \   0001D9   EE           MOV       A,R6
   \   0001DA   6003         JZ        $+5
   \   0001DC   02....       LJMP      ??bdb_checkMatchingEndpoints_11 & 0xFFFF
    499                    {
    500                      break;
    501                    }
    502                  }
    503                }
    504              }
    505              
    506              //Check if we have found any match
    507              if( matchFound == TRUE )
   \                     ??bdb_checkMatchingEndpoints_8:
   \   0001DF   85..82       MOV       DPL,?V10
   \   0001E2   85..83       MOV       DPH,?V11
   \   0001E5   E0           MOVX      A,@DPTR
   \   0001E6   240C         ADD       A,#0xc
   \   0001E8   F8           MOV       R0,A
   \   0001E9   A3           INC       DPTR
   \   0001EA   E0           MOVX      A,@DPTR
   \   0001EB   3400         ADDC      A,#0x0
   \   0001ED   8882         MOV       DPL,R0
   \   0001EF   F583         MOV       DPH,A
   \   0001F1   7401         MOV       A,#0x1
   \   0001F3   6F           XRL       A,R7
   \   0001F4   7075         JNZ       ??bdb_checkMatchingEndpoints_12
    508              {
    509                if(bindIfMatch)
   \   0001F6   EE           MOV       A,R6
   \   0001F7   6004         JZ        ??bdb_checkMatchingEndpoints_13
    510                {
    511                  //Mark respondent as complete as simple desc has been process and we do 
    512                  //have IEEE addrs
    513                  (*pCurr)->attempts = FINDING_AND_BINDING_RESPONDENT_COMPLETE;
   \   0001F9   74FF         MOV       A,#-0x1
   \   0001FB   8002         SJMP      ??bdb_checkMatchingEndpoints_14
    514                }
    515                else
    516                {
    517                  //Mark as we need IEEE addrs
    518                  (*pCurr)->attempts = FINDING_AND_BINDING_MISSING_IEEE_ADDR;
   \                     ??bdb_checkMatchingEndpoints_13:
   \   0001FD   7480         MOV       A,#-0x80
   \                     ??bdb_checkMatchingEndpoints_14:
   \   0001FF   F0           MOVX      @DPTR,A
    519                }
    520          
    521          #ifdef ZCL_GROUPS
    522                if ( bdbAttributes.bdbCommissioningGroupID != 0xFFFF )
   \   000200   90....       MOV       DPTR,#bdbAttributes + 8
   \   000203   E0           MOVX      A,@DPTR
   \   000204   F5..         MOV       ?V4,A
   \   000206   A3           INC       DPTR
   \   000207   E0           MOVX      A,@DPTR
   \   000208   F5..         MOV       ?V5,A
   \   00020A   74FF         MOV       A,#-0x1
   \   00020C   65..         XRL       A,?V4
   \   00020E   7004         JNZ       ??bdb_checkMatchingEndpoints_15
   \   000210   74FF         MOV       A,#-0x1
   \   000212   65..         XRL       A,?V5
   \                     ??bdb_checkMatchingEndpoints_15:
   \   000214   6058         JZ        ??bdb_checkMatchingEndpoints_16
    523                {
    524                  afDstAddr.addr.shortAddr = shortAddr;
   \   000216   7409         MOV       A,#0x9
   \   000218   12....       LCALL     ?XSTACK_DISP0_8
   \   00021B   E5..         MOV       A,?V6
   \   00021D   F0           MOVX      @DPTR,A
   \   00021E   A3           INC       DPTR
   \   00021F   E5..         MOV       A,?V7
   \   000221   F0           MOVX      @DPTR,A
    525                  afDstAddr.addrMode = afAddr16Bit;
   \   000222   7411         MOV       A,#0x11
   \   000224   12....       LCALL     ?XSTACK_DISP0_8
   \   000227   7402         MOV       A,#0x2
   \   000229   F0           MOVX      @DPTR,A
    526                  afDstAddr.endPoint = bdb_FindingBindingTargetSimpleDesc.EndPoint;
   \   00022A   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc
   \   00022D   E0           MOVX      A,@DPTR
   \   00022E   C0E0         PUSH      A
   \   000230   7412         MOV       A,#0x12
   \   000232   12....       LCALL     ?XSTACK_DISP0_8
   \   000235   D0E0         POP       A
   \   000237   F0           MOVX      @DPTR,A
    527                      
    528                  zclGeneral_SendAddGroupRequest( bdb_CurrEpDescriptor->endPoint, &afDstAddr,
    529                                              COMMAND_GROUP_ADD, bdbAttributes.bdbCommissioningGroupID, grpName,
    530                                              TRUE, 0x00 );
   \   000238                ; Setup parameters for call to function zclGeneral_SendAddGroupRequest
   \   000238   75..00       MOV       ?V0,#0x0
   \   00023B   78..         MOV       R0,#?V0
   \   00023D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000240   75....       MOV       ?V8,#grpName & 0xff
   \   000243   75....       MOV       ?V9,#(grpName >> 8) & 0xff
   \   000246   78..         MOV       R0,#?V8
   \   000248   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00024B   78..         MOV       R0,#?V4
   \   00024D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000250   7D01         MOV       R5,#0x1
   \   000252   7C00         MOV       R4,#0x0
   \   000254   740E         MOV       A,#0xe
   \   000256   12....       LCALL     ?XSTACK_DISP101_8
   \   000259   85..82       MOV       DPL,?V2
   \   00025C   85..83       MOV       DPH,?V3
   \   00025F   E0           MOVX      A,@DPTR
   \   000260   F9           MOV       R1,A
   \   000261   12....       LCALL     `??zclGeneral_SendAddGroupRequest::?relay`; Banked call to: zclGeneral_SendAddGroupRequest
   \   000264   7405         MOV       A,#0x5
   \   000266   12....       LCALL     ?DEALLOC_XSTACK8
   \   000269   8003         SJMP      ??bdb_checkMatchingEndpoints_16
    531                }
    532          #endif
    533              }
    534              else
    535              {
    536                //No matching cluster, then we are done with this respondent
    537                (*pCurr)->attempts = FINDING_AND_BINDING_RESPONDENT_COMPLETE;
   \                     ??bdb_checkMatchingEndpoints_12:
   \   00026B   74FF         MOV       A,#-0x1
   \   00026D   F0           MOVX      @DPTR,A
    538              }
    539              
    540              if ( status == ZApsTableFull )
   \                     ??bdb_checkMatchingEndpoints_16:
   \   00026E   74B2         MOV       A,#-0x4e
   \   000270   65..         XRL       A,?V1
   \   000272   702A         JNZ       ??bdb_checkMatchingEndpoints_17
    541              {
    542                //If periodic was triggered, then finish it
    543                if(FINDING_AND_BINDING_PERIODIC_ENABLE == TRUE)                                  
    544                {
    545                  bdb_FB_InitiatorCurrentCyclesNumber = 0;
   \   000274   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000277   E4           CLR       A
   \   000278   F0           MOVX      @DPTR,A
    546                  osal_stop_timerEx(bdb_TaskID, BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT);
   \   000279                ; Setup parameters for call to function osal_stop_timerEx
   \   000279   7A40         MOV       R2,#0x40
   \   00027B   FB           MOV       R3,A
   \   00027C   90....       MOV       DPTR,#bdb_TaskID
   \   00027F   E0           MOVX      A,@DPTR
   \   000280   F9           MOV       R1,A
   \   000281   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    547                }      
    548                
    549                bdb_zclSimpleDescClusterListClean( &bdb_FindingBindingTargetSimpleDesc );
   \   000284                ; Setup parameters for call to function bdb_zclSimpleDescClusterListClean
   \   000284   7A..         MOV       R2,#bdb_FindingBindingTargetSimpleDesc & 0xff
   \   000286   7B..         MOV       R3,#(bdb_FindingBindingTargetSimpleDesc >> 8) & 0xff
   \   000288   12....       LCALL     `??bdb_zclSimpleDescClusterListClean::?relay`; Banked call to: bdb_zclSimpleDescClusterListClean
    550                osal_stop_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT );
   \   00028B                ; Setup parameters for call to function osal_stop_timerEx
   \   00028B   7A00         MOV       R2,#0x0
   \   00028D   7B40         MOV       R3,#0x40
   \   00028F   90....       MOV       DPTR,#bdb_TaskID
   \   000292   E0           MOVX      A,@DPTR
   \   000293   F9           MOV       R1,A
   \   000294   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    551                bdb_exitFindingBindingWStatus( BDB_COMMISSIONING_FB_BINDING_TABLE_FULL );
   \   000297                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   000297   790C         MOV       R1,#0xc
   \   000299   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
    552                
    553                return;
   \   00029C   8050         SJMP      ??bdb_checkMatchingEndpoints_1
    554              }
    555              
    556              //If an specific endpoint was requested, then don't go trough the rest of 
    557              //the endpoints
    558              if( bdbIndentifyActiveEndpoint != 0xFF )
   \                     ??bdb_checkMatchingEndpoints_17:
   \   00029E   90....       MOV       DPTR,#bdbIndentifyActiveEndpoint
   \   0002A1   E0           MOVX      A,@DPTR
   \   0002A2   F4           CPL       A
   \   0002A3   7049         JNZ       ??bdb_checkMatchingEndpoints_1
    559              {
    560                break;
    561              }
    562              else
    563              {
    564                //If active endpoints 'all' is attempted, then process the next endpoint in 
    565                //the list
    566                bdb_CurrEpDescriptorList = bdb_CurrEpDescriptorList->nextDesc;
   \                     ??bdb_checkMatchingEndpoints_18:
   \   0002A5   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   0002A8   E0           MOVX      A,@DPTR
   \   0002A9   F8           MOV       R0,A
   \   0002AA   A3           INC       DPTR
   \   0002AB   E0           MOVX      A,@DPTR
   \   0002AC   F583         MOV       DPH,A
   \   0002AE   8882         MOV       DPL,R0
   \   0002B0   E0           MOVX      A,@DPTR
   \   0002B1   F8           MOV       R0,A
   \   0002B2   A3           INC       DPTR
   \   0002B3   E0           MOVX      A,@DPTR
   \   0002B4   F9           MOV       R1,A
   \   0002B5   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   0002B8   E8           MOV       A,R0
   \   0002B9   F0           MOVX      @DPTR,A
   \   0002BA   A3           INC       DPTR
   \   0002BB   E9           MOV       A,R1
   \   0002BC   F0           MOVX      @DPTR,A
    567          
    568                while(bdb_CurrEpDescriptorList != NULL)
   \   0002BD   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   0002C0   E0           MOVX      A,@DPTR
   \   0002C1   F8           MOV       R0,A
   \   0002C2   A3           INC       DPTR
   \   0002C3   E0           MOVX      A,@DPTR
   \   0002C4   F9           MOV       R1,A
   \   0002C5   E8           MOV       A,R0
   \   0002C6   49           ORL       A,R1
   \   0002C7   7003         JNZ       $+5
   \   0002C9   02....       LJMP      ??bdb_checkMatchingEndpoints_0 & 0xFFFF
    569                {
    570                  //It has to be different from 0 or reserved for Zigbee
    571                  if((bdb_CurrEpDescriptorList->epDesc->endPoint != 0) && (bdb_CurrEpDescriptorList->epDesc->endPoint < BDB_ZIGBEE_RESERVED_ENDPOINTS_START))
   \   0002CC   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   0002CF   E0           MOVX      A,@DPTR
   \   0002D0   F8           MOV       R0,A
   \   0002D1   A3           INC       DPTR
   \   0002D2   E0           MOVX      A,@DPTR
   \   0002D3   F583         MOV       DPH,A
   \   0002D5   8882         MOV       DPL,R0
   \   0002D7   A3           INC       DPTR
   \   0002D8   A3           INC       DPTR
   \   0002D9   E0           MOVX      A,@DPTR
   \   0002DA   F8           MOV       R0,A
   \   0002DB   A3           INC       DPTR
   \   0002DC   E0           MOVX      A,@DPTR
   \   0002DD   F583         MOV       DPH,A
   \   0002DF   8882         MOV       DPL,R0
   \   0002E1   E0           MOVX      A,@DPTR
   \   0002E2   60C1         JZ        ??bdb_checkMatchingEndpoints_18
   \   0002E4   C3           CLR       C
   \   0002E5   94F1         SUBB      A,#-0xf
   \   0002E7   5003         JNC       $+5
   \   0002E9   02....       LJMP      ??bdb_checkMatchingEndpoints_0 & 0xFFFF
    572                  {
    573                    break;
    574                  }
    575                  bdb_CurrEpDescriptorList = bdb_CurrEpDescriptorList->nextDesc;
   \   0002EC   80B7         SJMP      ??bdb_checkMatchingEndpoints_18
    576                }
    577              }
    578            }
    579          }
   \                     ??bdb_checkMatchingEndpoints_1:
   \   0002EE   7415         MOV       A,#0x15
   \   0002F0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0002F3   7F0C         MOV       R7,#0xc
   \   0002F5   02....       LJMP      ?BANKED_LEAVE_XDATA
    580          
    581          
    582          
    583          /*********************************************************************
    584           * @fn      bdb_ProcessSimpleDesc
    585           *
    586           * @brief   Process simple descriptor requested by F&B. Binds will be added if 
    587           *          matching cluster is found and if IEEE addrs of the device is already 
    588           *          stored
    589           *
    590           * @param   msgPtr - pointer to simple descriptor response indication message
    591           *
    592           * @return  none
    593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    594          void bdb_ProcessSimpleDesc( zdoIncomingMsg_t *msgPtr )
   \                     bdb_ProcessSimpleDesc:
    595          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 19
   \   000005   74ED         MOV       A,#-0x13
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
    596            zAddrType_t dstAddr;
    597            bdbFindingBindingRespondent_t *pCurr = NULL;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   E4           CLR       A
   \   000015   F0           MOVX      @DPTR,A
   \   000016   A3           INC       DPTR
   \   000017   F0           MOVX      @DPTR,A
    598            uint8 isRespondantReadyToBeAdded = FALSE;
   \   000018   75..00       MOV       ?V0,#0x0
    599          
    600            bdb_setEpDescListToActiveEndpoint();
   \   00001B                ; Setup parameters for call to function bdb_setEpDescListToActiveEndpoint
   \   00001B   12....       LCALL     `??bdb_setEpDescListToActiveEndpoint::?relay`; Banked call to: bdb_setEpDescListToActiveEndpoint
    601            
    602            if ( !(bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_INITIATOR )) 
   \   00001E   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F8           MOV       R0,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F583         MOV       DPH,A
   \   000027   8882         MOV       DPL,R0
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   F8           MOV       R0,A
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   F583         MOV       DPH,A
   \   000031   8882         MOV       DPL,R0
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   A2E0         MOV       C,0xE0 /* A   */.0
   \   000037   4003         JC        $+5
   \   000039   02....       LJMP      ??bdb_ProcessSimpleDesc_0 & 0xFFFF
    603            {  
    604              //We should not be processing these commands as we are not initiator
    605              return;
    606            }
    607            
    608            dstAddr.addr.shortAddr = BUILD_UINT16( msgPtr->asdu[1], msgPtr->asdu[2] );
   \   00003C   EE           MOV       A,R6
   \   00003D   2413         ADD       A,#0x13
   \   00003F   F582         MOV       DPL,A
   \   000041   E4           CLR       A
   \   000042   3F           ADDC      A,R7
   \   000043   F583         MOV       DPH,A
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F8           MOV       R0,A
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   F9           MOV       R1,A
   \   00004A   8882         MOV       DPL,R0
   \   00004C   F583         MOV       DPH,A
   \   00004E   A3           INC       DPTR
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   FC           MOV       R4,A
   \   000051   8882         MOV       DPL,R0
   \   000053   8983         MOV       DPH,R1
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   E0           MOVX      A,@DPTR
   \   000058   FB           MOV       R3,A
   \   000059   7402         MOV       A,#0x2
   \   00005B   12....       LCALL     ?XSTACK_DISP0_8
   \   00005E   EC           MOV       A,R4
   \   00005F   F0           MOVX      @DPTR,A
   \   000060   A3           INC       DPTR
   \   000061   EB           MOV       A,R3
   \   000062   F0           MOVX      @DPTR,A
    609            dstAddr.addrMode = Addr16Bit;
   \   000063   740A         MOV       A,#0xa
   \   000065   12....       LCALL     ?XSTACK_DISP0_8
   \   000068   7402         MOV       A,#0x2
   \   00006A   F0           MOVX      @DPTR,A
    610            
    611            ZDO_ParseSimpleDescBuf( &msgPtr->asdu[4], &bdb_FindingBindingTargetSimpleDesc );
   \   00006B                ; Setup parameters for call to function ZDO_ParseSimpleDescBuf
   \   00006B   7C..         MOV       R4,#bdb_FindingBindingTargetSimpleDesc & 0xff
   \   00006D   7D..         MOV       R5,#(bdb_FindingBindingTargetSimpleDesc >> 8) & 0xff
   \   00006F   E8           MOV       A,R0
   \   000070   2404         ADD       A,#0x4
   \   000072   FA           MOV       R2,A
   \   000073   E4           CLR       A
   \   000074   39           ADDC      A,R1
   \   000075   FB           MOV       R3,A
   \   000076   12....       LCALL     `??ZDO_ParseSimpleDescBuf::?relay`; Banked call to: ZDO_ParseSimpleDescBuf
    612            
    613            pCurr = bdb_findRespondentNode(bdb_FindingBindingTargetSimpleDesc.EndPoint, dstAddr.addr.shortAddr);
   \   000079                ; Setup parameters for call to function bdb_findRespondentNode
   \   000079   7402         MOV       A,#0x2
   \   00007B   12....       LCALL     ?XSTACK_DISP0_8
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   FA           MOV       R2,A
   \   000080   A3           INC       DPTR
   \   000081   E0           MOVX      A,@DPTR
   \   000082   FB           MOV       R3,A
   \   000083   90....       MOV       DPTR,#bdb_FindingBindingTargetSimpleDesc
   \   000086   E0           MOVX      A,@DPTR
   \   000087   F9           MOV       R1,A
   \   000088   12....       LCALL     `??bdb_findRespondentNode::?relay`; Banked call to: bdb_findRespondentNode
   \   00008B   85..82       MOV       DPL,?XSP + 0
   \   00008E   85..83       MOV       DPH,?XSP + 1
   \   000091   EA           MOV       A,R2
   \   000092   F0           MOVX      @DPTR,A
   \   000093   A3           INC       DPTR
   \   000094   EB           MOV       A,R3
   \   000095   F0           MOVX      @DPTR,A
    614            
    615            //Just for safety check this is a valid entry
    616            if(pCurr != NULL) 
   \   000096   85..82       MOV       DPL,?XSP + 0
   \   000099   85..83       MOV       DPH,?XSP + 1
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   F8           MOV       R0,A
   \   00009E   A3           INC       DPTR
   \   00009F   E0           MOVX      A,@DPTR
   \   0000A0   F9           MOV       R1,A
   \   0000A1   E8           MOV       A,R0
   \   0000A2   49           ORL       A,R1
   \   0000A3   606E         JZ        ??bdb_ProcessSimpleDesc_0
    617            {
    618              uint8 extAddr[Z_EXTADDR_LEN]; 
    619              
    620              if(AddrMgrExtAddrLookup( pCurr->data.addr.shortAddr, extAddr ))
   \   0000A5                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   0000A5   740B         MOV       A,#0xb
   \   0000A7   12....       LCALL     ?XSTACK_DISP102_8
   \   0000AA   85..82       MOV       DPL,?XSP + 0
   \   0000AD   85..83       MOV       DPH,?XSP + 1
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   F8           MOV       R0,A
   \   0000B2   A3           INC       DPTR
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   F583         MOV       DPH,A
   \   0000B6   8882         MOV       DPL,R0
   \   0000B8   E0           MOVX      A,@DPTR
   \   0000B9   FA           MOV       R2,A
   \   0000BA   A3           INC       DPTR
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   FB           MOV       R3,A
   \   0000BD   12....       LCALL     `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   0000C0   E9           MOV       A,R1
   \   0000C1   6005         JZ        ??bdb_ProcessSimpleDesc_1
    621              {
    622                isRespondantReadyToBeAdded = TRUE;
   \   0000C3   75..01       MOV       ?V0,#0x1
   \   0000C6   801A         SJMP      ??bdb_ProcessSimpleDesc_2
    623              }
    624              else
    625              {
    626                //Save the simple desc to don't ask for it again
    627                pCurr->SimpleDescriptor = &bdb_FindingBindingTargetSimpleDesc;
   \                     ??bdb_ProcessSimpleDesc_1:
   \   0000C8   85..82       MOV       DPL,?XSP + 0
   \   0000CB   85..83       MOV       DPH,?XSP + 1
   \   0000CE   E0           MOVX      A,@DPTR
   \   0000CF   F8           MOV       R0,A
   \   0000D0   A3           INC       DPTR
   \   0000D1   E0           MOVX      A,@DPTR
   \   0000D2   C8           XCH       A,R0
   \   0000D3   240D         ADD       A,#0xd
   \   0000D5   F582         MOV       DPL,A
   \   0000D7   E4           CLR       A
   \   0000D8   38           ADDC      A,R0
   \   0000D9   F583         MOV       DPH,A
   \   0000DB   74..         MOV       A,#bdb_FindingBindingTargetSimpleDesc & 0xff
   \   0000DD   F0           MOVX      @DPTR,A
   \   0000DE   A3           INC       DPTR
   \   0000DF   74..         MOV       A,#(bdb_FindingBindingTargetSimpleDesc >> 8) & 0xff
   \   0000E1   F0           MOVX      @DPTR,A
    628              }
    629              (void)extAddr;  //dummy
    630            }
    631            else
    632            {
    633              //This simple desc rsp was not requested by BDB F&B
    634              return;
    635            } 
    636            
    637            bdb_checkMatchingEndpoints(isRespondantReadyToBeAdded, dstAddr.addr.shortAddr, &pCurr);
   \                     ??bdb_ProcessSimpleDesc_2:
   \   0000E2                ; Setup parameters for call to function bdb_checkMatchingEndpoints
   \   0000E2   AC..         MOV       R4,?XSP + 0
   \   0000E4   AD..         MOV       R5,?XSP + 1
   \   0000E6   7402         MOV       A,#0x2
   \   0000E8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000EB   E0           MOVX      A,@DPTR
   \   0000EC   FA           MOV       R2,A
   \   0000ED   A3           INC       DPTR
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   FB           MOV       R3,A
   \   0000F0   A9..         MOV       R1,?V0
   \   0000F2   12....       LCALL     `??bdb_checkMatchingEndpoints::?relay`; Banked call to: bdb_checkMatchingEndpoints
    638            
    639            //If the respondent got process complete, then release the entry
    640            if(pCurr->attempts == FINDING_AND_BINDING_RESPONDENT_COMPLETE)
   \   0000F5   85..82       MOV       DPL,?XSP + 0
   \   0000F8   85..83       MOV       DPH,?XSP + 1
   \   0000FB   E0           MOVX      A,@DPTR
   \   0000FC   F8           MOV       R0,A
   \   0000FD   A3           INC       DPTR
   \   0000FE   E0           MOVX      A,@DPTR
   \   0000FF   C8           XCH       A,R0
   \   000100   240C         ADD       A,#0xc
   \   000102   F582         MOV       DPL,A
   \   000104   E4           CLR       A
   \   000105   38           ADDC      A,R0
   \   000106   F583         MOV       DPH,A
   \   000108   E0           MOVX      A,@DPTR
   \   000109   F4           CPL       A
   \   00010A   7007         JNZ       ??bdb_ProcessSimpleDesc_0
    641            {
    642              bdb_zclSimpleDescClusterListClean( &bdb_FindingBindingTargetSimpleDesc );  
   \   00010C                ; Setup parameters for call to function bdb_zclSimpleDescClusterListClean
   \   00010C   7A..         MOV       R2,#bdb_FindingBindingTargetSimpleDesc & 0xff
   \   00010E   7B..         MOV       R3,#(bdb_FindingBindingTargetSimpleDesc >> 8) & 0xff
   \   000110   12....       LCALL     `??bdb_zclSimpleDescClusterListClean::?relay`; Banked call to: bdb_zclSimpleDescClusterListClean
    643            }
    644          }
   \                     ??bdb_ProcessSimpleDesc_0:
   \   000113   7413         MOV       A,#0x13
   \   000115   12....       LCALL     ?DEALLOC_XSTACK8
   \   000118   7F01         MOV       R7,#0x1
   \   00011A   02....       LJMP      ?BANKED_LEAVE_XDATA
    645          
    646          /*********************************************************************
    647           * @fn      bdb_zclFindingBindingEpType
    648           *
    649           * @brief   Gives the Ep Type according to application clusters in
    650           *          simple descriptor
    651           *
    652           * @return  epType - If Target, Initiator or both
    653           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    654          uint8 bdb_zclFindingBindingEpType( endPointDesc_t *epDesc )
   \                     bdb_zclFindingBindingEpType:
    655          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
    656            uint8 epType = 0;
   \   000005   75..00       MOV       ?V0,#0x0
    657            uint8 status;
    658            uint8 type1ClusterCnt;
    659            uint8 type2ClusterCnt;
    660            
    661            type1ClusterCnt = sizeof( bdb_ZclType1Clusters )/sizeof( uint16 );
    662            type2ClusterCnt = sizeof( bdb_ZclType2Clusters )/sizeof( uint16 );
    663            
    664          
    665            // Are there matching type 1 on server side?
    666            status = ZDO_AnyClusterMatches( epDesc->simpleDesc->AppNumInClusters, 
    667                                            epDesc->simpleDesc->pAppInClusterList,
    668                                            type1ClusterCnt,
    669                                            (uint16*)bdb_ZclType1Clusters);
    670            
    671            if( status == TRUE )
   \   000008   EA           MOV       A,R2
   \   000009   2404         ADD       A,#0x4
   \   00000B   FE           MOV       R6,A
   \   00000C   E4           CLR       A
   \   00000D   3B           ADDC      A,R3
   \   00000E   FF           MOV       R7,A
   \   00000F   8E82         MOV       DPL,R6
   \   000011   F583         MOV       DPH,A
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F8           MOV       R0,A
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   88..         MOV       ?V2,R0
   \   000019   F5..         MOV       ?V3,A
   \   00001B   75....       MOV       ?V4,#bdb_ZclType1Clusters & 0xff
   \   00001E   75....       MOV       ?V5,#(bdb_ZclType1Clusters >> 8) & 0xff
   \   000021                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   000021   78..         MOV       R0,#?V4
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000026   7C18         MOV       R4,#0x18
   \   000028   85..82       MOV       DPL,?V2
   \   00002B   85..83       MOV       DPH,?V3
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   FA           MOV       R2,A
   \   000037   A3           INC       DPTR
   \   000038   E0           MOVX      A,@DPTR
   \   000039   FB           MOV       R3,A
   \   00003A   85..82       MOV       DPL,?V2
   \   00003D   85..83       MOV       DPH,?V3
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   A3           INC       DPTR
   \   000046   E0           MOVX      A,@DPTR
   \   000047   F9           MOV       R1,A
   \   000048   12....       LCALL     `??ZDO_AnyClusterMatches::?relay`; Banked call to: ZDO_AnyClusterMatches
   \   00004B   7402         MOV       A,#0x2
   \   00004D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000050   E9           MOV       A,R1
   \   000051   6401         XRL       A,#0x1
   \   000053   7003         JNZ       ??bdb_zclFindingBindingEpType_0
    672            {
    673              epType |= BDB_FINDING_AND_BINDING_TARGET;
   \   000055   75..02       MOV       ?V0,#0x2
    674            }
    675            
    676            // Are there matching type 1 on client side?
    677            status = ZDO_AnyClusterMatches( epDesc->simpleDesc->AppNumOutClusters, 
    678                                            epDesc->simpleDesc->pAppOutClusterList,
    679                                            type1ClusterCnt,
    680                                            (uint16*)bdb_ZclType1Clusters);
    681            
    682            if( status == TRUE )
   \                     ??bdb_zclFindingBindingEpType_0:
   \   000058   8E82         MOV       DPL,R6
   \   00005A   8F83         MOV       DPH,R7
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F8           MOV       R0,A
   \   00005E   A3           INC       DPTR
   \   00005F   E0           MOVX      A,@DPTR
   \   000060   88..         MOV       ?V2,R0
   \   000062   F5..         MOV       ?V3,A
   \   000064                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   000064   78..         MOV       R0,#?V4
   \   000066   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000069   7C18         MOV       R4,#0x18
   \   00006B   85..82       MOV       DPL,?V2
   \   00006E   85..83       MOV       DPH,?V3
   \   000071   A3           INC       DPTR
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   A3           INC       DPTR
   \   000078   A3           INC       DPTR
   \   000079   A3           INC       DPTR
   \   00007A   A3           INC       DPTR
   \   00007B   E0           MOVX      A,@DPTR
   \   00007C   FA           MOV       R2,A
   \   00007D   A3           INC       DPTR
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   FB           MOV       R3,A
   \   000080   85..82       MOV       DPL,?V2
   \   000083   85..83       MOV       DPH,?V3
   \   000086   A3           INC       DPTR
   \   000087   A3           INC       DPTR
   \   000088   A3           INC       DPTR
   \   000089   A3           INC       DPTR
   \   00008A   A3           INC       DPTR
   \   00008B   A3           INC       DPTR
   \   00008C   A3           INC       DPTR
   \   00008D   A3           INC       DPTR
   \   00008E   A3           INC       DPTR
   \   00008F   E0           MOVX      A,@DPTR
   \   000090   F9           MOV       R1,A
   \   000091   12....       LCALL     `??ZDO_AnyClusterMatches::?relay`; Banked call to: ZDO_AnyClusterMatches
   \   000094   7402         MOV       A,#0x2
   \   000096   12....       LCALL     ?DEALLOC_XSTACK8
   \   000099   E9           MOV       A,R1
   \   00009A   6401         XRL       A,#0x1
   \   00009C   7006         JNZ       ??bdb_zclFindingBindingEpType_1
    683            {
    684              epType |= BDB_FINDING_AND_BINDING_INITIATOR;
   \   00009E   E5..         MOV       A,?V0
   \   0000A0   D2E0         SETB      0xE0 /* A   */.0
   \   0000A2   F5..         MOV       ?V0,A
    685            }
    686            
    687            // Are there matching type 2 on server side?
    688            status = ZDO_AnyClusterMatches( epDesc->simpleDesc->AppNumInClusters, 
    689                                            epDesc->simpleDesc->pAppInClusterList,
    690                                            type2ClusterCnt,
    691                                            (uint16*)bdb_ZclType2Clusters);
    692            
    693            if( status == TRUE )
   \                     ??bdb_zclFindingBindingEpType_1:
   \   0000A4   8E82         MOV       DPL,R6
   \   0000A6   8F83         MOV       DPH,R7
   \   0000A8   E0           MOVX      A,@DPTR
   \   0000A9   F8           MOV       R0,A
   \   0000AA   A3           INC       DPTR
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   88..         MOV       ?V2,R0
   \   0000AE   F5..         MOV       ?V3,A
   \   0000B0   75....       MOV       ?V4,#bdb_ZclType2Clusters & 0xff
   \   0000B3   75....       MOV       ?V5,#(bdb_ZclType2Clusters >> 8) & 0xff
   \   0000B6                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   0000B6   78..         MOV       R0,#?V4
   \   0000B8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BB   7C31         MOV       R4,#0x31
   \   0000BD   85..82       MOV       DPL,?V2
   \   0000C0   85..83       MOV       DPH,?V3
   \   0000C3   A3           INC       DPTR
   \   0000C4   A3           INC       DPTR
   \   0000C5   A3           INC       DPTR
   \   0000C6   A3           INC       DPTR
   \   0000C7   A3           INC       DPTR
   \   0000C8   A3           INC       DPTR
   \   0000C9   A3           INC       DPTR
   \   0000CA   E0           MOVX      A,@DPTR
   \   0000CB   FA           MOV       R2,A
   \   0000CC   A3           INC       DPTR
   \   0000CD   E0           MOVX      A,@DPTR
   \   0000CE   FB           MOV       R3,A
   \   0000CF   85..82       MOV       DPL,?V2
   \   0000D2   85..83       MOV       DPH,?V3
   \   0000D5   A3           INC       DPTR
   \   0000D6   A3           INC       DPTR
   \   0000D7   A3           INC       DPTR
   \   0000D8   A3           INC       DPTR
   \   0000D9   A3           INC       DPTR
   \   0000DA   A3           INC       DPTR
   \   0000DB   E0           MOVX      A,@DPTR
   \   0000DC   F9           MOV       R1,A
   \   0000DD   12....       LCALL     `??ZDO_AnyClusterMatches::?relay`; Banked call to: ZDO_AnyClusterMatches
   \   0000E0   7402         MOV       A,#0x2
   \   0000E2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000E5   E9           MOV       A,R1
   \   0000E6   6401         XRL       A,#0x1
   \   0000E8   7006         JNZ       ??bdb_zclFindingBindingEpType_2
    694            {
    695              epType |= BDB_FINDING_AND_BINDING_INITIATOR;
   \   0000EA   E5..         MOV       A,?V0
   \   0000EC   D2E0         SETB      0xE0 /* A   */.0
   \   0000EE   F5..         MOV       ?V0,A
    696            }
    697            
    698            // Are there matching type 2 on client side?
    699            status = ZDO_AnyClusterMatches( epDesc->simpleDesc->AppNumOutClusters, 
    700                                            epDesc->simpleDesc->pAppOutClusterList,
    701                                            type2ClusterCnt,
    702                                            (uint16*)bdb_ZclType2Clusters);
    703            
    704            if( status == TRUE )
   \                     ??bdb_zclFindingBindingEpType_2:
   \   0000F0   8E82         MOV       DPL,R6
   \   0000F2   8F83         MOV       DPH,R7
   \   0000F4   E0           MOVX      A,@DPTR
   \   0000F5   F8           MOV       R0,A
   \   0000F6   A3           INC       DPTR
   \   0000F7   E0           MOVX      A,@DPTR
   \   0000F8   F9           MOV       R1,A
   \   0000F9   E8           MOV       A,R0
   \   0000FA   FE           MOV       R6,A
   \   0000FB                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   0000FB   78..         MOV       R0,#?V4
   \   0000FD   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000100   7C31         MOV       R4,#0x31
   \   000102   8E82         MOV       DPL,R6
   \   000104   8983         MOV       DPH,R1
   \   000106   A3           INC       DPTR
   \   000107   A3           INC       DPTR
   \   000108   A3           INC       DPTR
   \   000109   A3           INC       DPTR
   \   00010A   A3           INC       DPTR
   \   00010B   A3           INC       DPTR
   \   00010C   A3           INC       DPTR
   \   00010D   A3           INC       DPTR
   \   00010E   A3           INC       DPTR
   \   00010F   A3           INC       DPTR
   \   000110   E0           MOVX      A,@DPTR
   \   000111   FA           MOV       R2,A
   \   000112   A3           INC       DPTR
   \   000113   E0           MOVX      A,@DPTR
   \   000114   FB           MOV       R3,A
   \   000115   8E82         MOV       DPL,R6
   \   000117   8983         MOV       DPH,R1
   \   000119   A3           INC       DPTR
   \   00011A   A3           INC       DPTR
   \   00011B   A3           INC       DPTR
   \   00011C   A3           INC       DPTR
   \   00011D   A3           INC       DPTR
   \   00011E   A3           INC       DPTR
   \   00011F   A3           INC       DPTR
   \   000120   A3           INC       DPTR
   \   000121   A3           INC       DPTR
   \   000122   E0           MOVX      A,@DPTR
   \   000123   F9           MOV       R1,A
   \   000124   12....       LCALL     `??ZDO_AnyClusterMatches::?relay`; Banked call to: ZDO_AnyClusterMatches
   \   000127   7402         MOV       A,#0x2
   \   000129   12....       LCALL     ?DEALLOC_XSTACK8
   \   00012C   E9           MOV       A,R1
   \   00012D   6401         XRL       A,#0x1
   \   00012F   7006         JNZ       ??bdb_zclFindingBindingEpType_3
    705            {
    706              epType |= BDB_FINDING_AND_BINDING_TARGET;
   \   000131   E5..         MOV       A,?V0
   \   000133   D2E1         SETB      0xE0 /* A   */.1
   \   000135   F5..         MOV       ?V0,A
    707            }
    708          
    709            return epType;
   \                     ??bdb_zclFindingBindingEpType_3:
   \   000137   A9..         MOV       R1,?V0
   \   000139   7F06         MOV       R7,#0x6
   \   00013B   02....       LJMP      ?BANKED_LEAVE_XDATA
    710          
    711          }
    712          
    713          /*********************************************************************
    714           * @fn      bdb_zclFindingBindingAddBindEntry
    715           *
    716           * @brief   This function is used to Add an entry to the binding table
    717           *
    718           * @param   SrcEndpInt - source endpoint
    719           * @param   BindClusterId - cluster to try bind
    720           * @param   Cnt - list of remote clusters
    721           * @param   ClusterList - pointer to the Object ID list
    722           * @param   DstAddr - Address of remote node
    723           * @param   DstEndpInt - EndPoint of remote node
    724           * @param   addBind - Indicate wheter or not bind must be added or not
    725           * @param   isClusterOutput - True if the bind attempted is output cluster in the local device, false otherwise
    726           *
    727           * @return  status - Success if added
    728           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    729          static ZStatus_t bdb_zclFindingBindingAddBindEntry( byte SrcEndpInt,
   \                     bdb_zclFindingBindingAddBindEntry:
    730                                            uint16 BindClusterId,
    731                                            byte Cnt,                 
    732                                            uint16 * ClusterList,
    733                                            zAddrType_t *DstAddr, byte DstEndpInt, uint8 addBind, uint8 isClusterOutput )
    734          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   \   000015   E9           MOV       A,R1
   \   000016   FE           MOV       R6,A
   \   000017   EC           MOV       A,R4
   \   000018   FF           MOV       R7,A
   \   000019   8D..         MOV       ?V0,R5
    735            uint8 status;
    736          
    737            if ( bdb_FindIfAppCluster ( BindClusterId, isClusterOutput ) != SUCCESS )
   \   00001B                ; Setup parameters for call to function bdb_FindIfAppCluster
   \   00001B   7413         MOV       A,#0x13
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F9           MOV       R1,A
   \   000022   85..82       MOV       DPL,?XSP + 0
   \   000025   85..83       MOV       DPH,?XSP + 1
   \   000028   E0           MOVX      A,@DPTR
   \   000029   FA           MOV       R2,A
   \   00002A   A3           INC       DPTR
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   FB           MOV       R3,A
   \   00002D   12....       LCALL     `??bdb_FindIfAppCluster::?relay`; Banked call to: bdb_FindIfAppCluster
   \   000030   E9           MOV       A,R1
   \   000031   7026         JNZ       ??bdb_zclFindingBindingAddBindEntry_0
    738            {
    739              return ( ZApsFail ); // No App cluster
    740            }
    741          
    742            // Are there matching clusters?
    743            status = ZDO_AnyClusterMatches( Cnt, 
    744                                            ClusterList,
    745                                            1,
    746                                           &BindClusterId);
    747            if ( status == FALSE )
   \   000033                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   000033   A8..         MOV       R0,?XSP + 0
   \   000035   A9..         MOV       R1,?XSP + 1
   \   000037   88..         MOV       ?V2,R0
   \   000039   89..         MOV       ?V3,R1
   \   00003B   78..         MOV       R0,#?V2
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000040   7C01         MOV       R4,#0x1
   \   000042   7410         MOV       A,#0x10
   \   000044   12....       LCALL     ?XSTACK_DISP0_8
   \   000047   E0           MOVX      A,@DPTR
   \   000048   FA           MOV       R2,A
   \   000049   A3           INC       DPTR
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   FB           MOV       R3,A
   \   00004C   EF           MOV       A,R7
   \   00004D   F9           MOV       R1,A
   \   00004E   12....       LCALL     `??ZDO_AnyClusterMatches::?relay`; Banked call to: ZDO_AnyClusterMatches
   \   000051   7402         MOV       A,#0x2
   \   000053   12....       LCALL     ?DEALLOC_XSTACK8
   \   000056   E9           MOV       A,R1
   \   000057   7004         JNZ       ??bdb_zclFindingBindingAddBindEntry_1
    748            {
    749              return ( ZApsFail ); // No matched Cluster
   \                     ??bdb_zclFindingBindingAddBindEntry_0:
   \   000059   79B1         MOV       R1,#-0x4f
   \   00005B   8046         SJMP      ??bdb_zclFindingBindingAddBindEntry_2
    750            }
    751          
    752            if(addBind)  
   \                     ??bdb_zclFindingBindingAddBindEntry_1:
   \   00005D   7412         MOV       A,#0x12
   \   00005F   12....       LCALL     ?XSTACK_DISP0_8
   \   000062   E0           MOVX      A,@DPTR
   \   000063   603C         JZ        ??bdb_zclFindingBindingAddBindEntry_3
    753            {
    754              if ( pbindAddEntry )
   \   000065   90....       MOV       DPTR,#pbindAddEntry
   \   000068   E0           MOVX      A,@DPTR
   \   000069   F8           MOV       R0,A
   \   00006A   A3           INC       DPTR
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   F9           MOV       R1,A
   \   00006D   E8           MOV       A,R0
   \   00006E   49           ORL       A,R1
   \   00006F   6030         JZ        ??bdb_zclFindingBindingAddBindEntry_3
    755              {
    756                // Add the entry into the binding table
    757                if (!pbindAddEntry( SrcEndpInt, DstAddr, DstEndpInt,
    758                                       1, &BindClusterId ) )
   \   000071                ; Setup parameters for indirect call
   \   000071   78..         MOV       R0,#?V2
   \   000073   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000076   7D01         MOV       R5,#0x1
   \   000078   AC..         MOV       R4,?V0
   \   00007A   7412         MOV       A,#0x12
   \   00007C   12....       LCALL     ?XSTACK_DISP0_8
   \   00007F   E0           MOVX      A,@DPTR
   \   000080   FA           MOV       R2,A
   \   000081   A3           INC       DPTR
   \   000082   E0           MOVX      A,@DPTR
   \   000083   FB           MOV       R3,A
   \   000084   EE           MOV       A,R6
   \   000085   F9           MOV       R1,A
   \   000086   90....       MOV       DPTR,#pbindAddEntry
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   F8           MOV       R0,A
   \   00008B   A3           INC       DPTR
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   F583         MOV       DPH,A
   \   00008F   8882         MOV       DPL,R0
   \   000091   12....       LCALL     ?CALL_IND
   \   000094   7402         MOV       A,#0x2
   \   000096   12....       LCALL     ?DEALLOC_XSTACK8
   \   000099   EA           MOV       A,R2
   \   00009A   4B           ORL       A,R3
   \   00009B   7004         JNZ       ??bdb_zclFindingBindingAddBindEntry_3
    759                {
    760                  return ( ZApsTableFull );
   \   00009D   79B2         MOV       R1,#-0x4e
   \   00009F   8002         SJMP      ??bdb_zclFindingBindingAddBindEntry_2
    761                }
    762              }
    763            }
    764            
    765            return ( ZSuccess );
   \                     ??bdb_zclFindingBindingAddBindEntry_3:
   \   0000A1   7900         MOV       R1,#0x0
   \                     ??bdb_zclFindingBindingAddBindEntry_2:
   \   0000A3   7402         MOV       A,#0x2
   \   0000A5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A8   7F04         MOV       R7,#0x4
   \   0000AA   02....       LJMP      ?BANKED_LEAVE_XDATA
    766          }
    767          
    768          /*********************************************************************
    769           * @fn      bdb_exitFindingBindingWStatus
    770           *
    771           * @brief   Clean respondent list and reports the status to bdb state machine
    772           *
    773           * @return  
    774           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    775          void bdb_exitFindingBindingWStatus( uint8 status )
   \                     bdb_exitFindingBindingWStatus:
    776          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
    777            // bdb report status
    778            bdbAttributes.bdbCommissioningStatus = status;
   \   000006   90....       MOV       DPTR,#bdbAttributes + 10
   \   000009   F0           MOVX      @DPTR,A
    779            
    780            bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_FINDING_BINDING, TRUE );
   \   00000A                ; Setup parameters for call to function bdb_reportCommissioningState
   \   00000A   7A01         MOV       R2,#0x1
   \   00000C   7906         MOV       R1,#0x6
   \   00000E   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
    781          }
   \   000011   7F01         MOV       R7,#0x1
   \   000013   02....       LJMP      ?BANKED_LEAVE_XDATA
    782          
    783          /*********************************************************************
    784           * @fn      bdb_zclSimpleDescClusterListClean
    785           *
    786           * @brief   This function free Simple Descriptor cluster lists
    787           *
    788           * @param   pSimpleDesc - pointer to simple descriptor
    789           *
    790           * @return  status
    791           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    792          static void bdb_zclSimpleDescClusterListClean( SimpleDescriptionFormat_t *pSimpleDesc )
   \                     bdb_zclSimpleDescClusterListClean:
    793          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    794            if(pSimpleDesc->pAppInClusterList != NULL)
   \   000009   EA           MOV       A,R2
   \   00000A   2407         ADD       A,#0x7
   \   00000C   F8           MOV       R0,A
   \   00000D   E4           CLR       A
   \   00000E   3F           ADDC      A,R7
   \   00000F   88..         MOV       ?V0,R0
   \   000011   F5..         MOV       ?V1,A
   \   000013   8882         MOV       DPL,R0
   \   000015   F583         MOV       DPH,A
   \   000017   E0           MOVX      A,@DPTR
   \   000018   FA           MOV       R2,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   FB           MOV       R3,A
   \   00001C   EA           MOV       A,R2
   \   00001D   4B           ORL       A,R3
   \   00001E   600D         JZ        ??bdb_zclSimpleDescClusterListClean_0
    795            {
    796              osal_mem_free( pSimpleDesc->pAppInClusterList );
   \   000020                ; Setup parameters for call to function osal_mem_free
   \   000020   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    797              pSimpleDesc->pAppInClusterList = ( cId_t* )NULL;
   \   000023   85..82       MOV       DPL,?V0
   \   000026   85..83       MOV       DPH,?V1
   \   000029   E4           CLR       A
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   F0           MOVX      @DPTR,A
    798            }
    799            if(pSimpleDesc->pAppOutClusterList != NULL)
   \                     ??bdb_zclSimpleDescClusterListClean_0:
   \   00002D   EE           MOV       A,R6
   \   00002E   240A         ADD       A,#0xa
   \   000030   F8           MOV       R0,A
   \   000031   E4           CLR       A
   \   000032   3F           ADDC      A,R7
   \   000033   F9           MOV       R1,A
   \   000034   E8           MOV       A,R0
   \   000035   FE           MOV       R6,A
   \   000036   E9           MOV       A,R1
   \   000037   FF           MOV       R7,A
   \   000038   8882         MOV       DPL,R0
   \   00003A   F583         MOV       DPH,A
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   FA           MOV       R2,A
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   FB           MOV       R3,A
   \   000041   EA           MOV       A,R2
   \   000042   4B           ORL       A,R3
   \   000043   600B         JZ        ??bdb_zclSimpleDescClusterListClean_1
    800            {
    801              osal_mem_free( pSimpleDesc->pAppOutClusterList );
   \   000045                ; Setup parameters for call to function osal_mem_free
   \   000045   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    802              pSimpleDesc->pAppOutClusterList = ( cId_t* )NULL;
   \   000048   8E82         MOV       DPL,R6
   \   00004A   8F83         MOV       DPH,R7
   \   00004C   E4           CLR       A
   \   00004D   F0           MOVX      @DPTR,A
   \   00004E   A3           INC       DPTR
   \   00004F   F0           MOVX      @DPTR,A
    803            }
    804          }
   \                     ??bdb_zclSimpleDescClusterListClean_1:
   \   000050   7F02         MOV       R7,#0x2
   \   000052   02....       LJMP      ?BANKED_LEAVE_XDATA
    805          
    806          /*********************************************************************
    807           * @fn      bdb_RegisterIdentifyTimeChangeCB
    808           *
    809           * @brief   Register an Application's Identify Time change callback function
    810           *          to let know the application when identify is active or not.
    811           *
    812           * @param   pfnIdentify - application callback
    813           *
    814           * @return  none
    815           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    816          void bdb_RegisterIdentifyTimeChangeCB( bdbGCB_IdentifyTimeChange_t pfnIdentifyTimeChange )
   \                     bdb_RegisterIdentifyTimeChangeCB:
    817          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    818            pfnIdentifyTimeChangeCB = pfnIdentifyTimeChange;
   \   000004   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB
   \   000007   EA           MOV       A,R2
   \   000008   F0           MOVX      @DPTR,A
   \   000009   A3           INC       DPTR
   \   00000A   EB           MOV       A,R3
   \   00000B   F0           MOVX      @DPTR,A
    819          }
   \   00000C   D083         POP       DPH
   \   00000E   D082         POP       DPL
   \   000010   02....       LJMP      ?BRET
    820          
    821          #if (FINDING_AND_BINDING_PERIODIC_ENABLE==TRUE)
    822          /*********************************************************************
    823           * @fn      bdb_GetFBInitiatorStatus
    824           *
    825           * @brief   Get the F&B initiator status for periodic requests.
    826           *
    827           * @param   RemainingTime - in seconds
    828           * @param   AttemptsLeft - number of attempts to be done
    829           * @param   MatchesFound - Add the number of matches to this parameter
    830           *                         since the last bdb_GetFBInitiatorStatus call
    831           *
    832           * @return  none
    833           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    834          void bdb_GetFBInitiatorStatus(uint8 *RemainingTime, uint8* AttemptsLeft)
   \                     bdb_GetFBInitiatorStatus:
    835          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
    836            if(RemainingTime != NULL)  
   \   00000D   EA           MOV       A,R2
   \   00000E   4F           ORL       A,R7
   \   00000F   6048         JZ        ??bdb_GetFBInitiatorStatus_0
    837            {
    838              if (bdb_FB_InitiatorCurrentCyclesNumber == 0)
   \   000011   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000014   E0           MOVX      A,@DPTR
   \   000015   7007         JNZ       ??bdb_GetFBInitiatorStatus_1
    839              {
    840                *RemainingTime = 0;
   \   000017   8A82         MOV       DPL,R2
   \   000019   8B83         MOV       DPH,R3
   \   00001B   E4           CLR       A
   \   00001C   803A         SJMP      ??bdb_GetFBInitiatorStatus_2
    841              }
    842              else
    843              {
    844                *RemainingTime = (bdb_FB_InitiatorCurrentCyclesNumber - 1) * FINDING_AND_BINDING_PERIODIC_TIME + ((osal_get_timeoutEx(bdb_TaskID, BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT) + 999) / 1000);
   \                     ??bdb_GetFBInitiatorStatus_1:
   \   00001E                ; Setup parameters for call to function osal_get_timeoutEx
   \   00001E   7A40         MOV       R2,#0x40
   \   000020   7B00         MOV       R3,#0x0
   \   000022   90....       MOV       DPTR,#bdb_TaskID
   \   000025   E0           MOVX      A,@DPTR
   \   000026   F9           MOV       R1,A
   \   000027   12....       LCALL     `??osal_get_timeoutEx::?relay`; Banked call to: osal_get_timeoutEx
   \   00002A   8A..         MOV       ?V4,R2
   \   00002C   8B..         MOV       ?V5,R3
   \   00002E   8C..         MOV       ?V6,R4
   \   000030   8D..         MOV       ?V7,R5
   \   000032   90....       MOV       DPTR,#__Constant_3e7
   \   000035   78..         MOV       R0,#?V4
   \   000037   12....       LCALL     ?L_ADD_X
   \   00003A   90....       MOV       DPTR,#__Constant_3e8
   \   00003D   78..         MOV       R0,#?V8
   \   00003F   12....       LCALL     ?L_MOV_X
   \   000042   78..         MOV       R0,#?V4
   \   000044   79..         MOV       R1,#?V8
   \   000046   12....       LCALL     ?UL_DIV_MOD
   \   000049   75F00F       MOV       B,#0xf
   \   00004C   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   14           DEC       A
   \   000051   A4           MUL       AB
   \   000052   25..         ADD       A,?V4
   \   000054   8E82         MOV       DPL,R6
   \   000056   8F83         MOV       DPH,R7
   \                     ??bdb_GetFBInitiatorStatus_2:
   \   000058   F0           MOVX      @DPTR,A
    845              }
    846            }
    847            
    848            if(AttemptsLeft != NULL)
   \                     ??bdb_GetFBInitiatorStatus_0:
   \   000059   E5..         MOV       A,?V0
   \   00005B   45..         ORL       A,?V1
   \   00005D   600B         JZ        ??bdb_GetFBInitiatorStatus_3
    849            {
    850              *AttemptsLeft = bdb_FB_InitiatorCurrentCyclesNumber;
   \   00005F   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000062   E0           MOVX      A,@DPTR
   \   000063   85..82       MOV       DPL,?V0
   \   000066   85..83       MOV       DPH,?V1
   \   000069   F0           MOVX      @DPTR,A
    851            }
    852          }
   \                     ??bdb_GetFBInitiatorStatus_3:
   \   00006A   7F0C         MOV       R7,#0xc
   \   00006C   02....       LJMP      ?BANKED_LEAVE_XDATA
    853          #endif
    854          
    855          /*********************************************************************
    856           * @fn      bdb_RegisterBindNotificationCB
    857           *
    858           * @brief   Register an Application's notification callback function to let 
    859           *          know the application when a new bind is added to the binding table.
    860           *
    861           * @param   pfnIdentify - application callback
    862           *
    863           * @return  none
    864           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    865          void bdb_RegisterBindNotificationCB( bdbGCB_BindNotification_t pfnBindNotification )
   \                     bdb_RegisterBindNotificationCB:
    866          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    867            pfnBindNotificationCB = pfnBindNotification;
   \   000004   90....       MOV       DPTR,#pfnBindNotificationCB
   \   000007   EA           MOV       A,R2
   \   000008   F0           MOVX      @DPTR,A
   \   000009   A3           INC       DPTR
   \   00000A   EB           MOV       A,R3
   \   00000B   F0           MOVX      @DPTR,A
    868          }
   \   00000C   D083         POP       DPH
   \   00000E   D082         POP       DPL
   \   000010   02....       LJMP      ?BRET
    869          
    870          /*********************************************************************
    871           * @fn      bdb_SendIdentifyQuery
    872           *
    873           * @brief   Sends Identify query from the given endpoint
    874           *
    875           * @param   endpoint
    876           *
    877           * @return  ZStatus_t
    878           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    879          ZStatus_t bdb_SendIdentifyQuery( uint8 endpoint )
   \                     bdb_SendIdentifyQuery:
    880          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV       A,#-0xc
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FF           MOV       R7,A
    881            afAddrType_t dstAddr;
    882            ZStatus_t    status;
    883            
    884            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
   \   00000C   85..82       MOV       DPL,?XSP + 0
   \   00000F   85..83       MOV       DPH,?XSP + 1
   \   000012   74FF         MOV       A,#-0x1
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   F0           MOVX      @DPTR,A
    885            dstAddr.addrMode = afAddr16Bit;
   \   000017   7408         MOV       A,#0x8
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   7402         MOV       A,#0x2
   \   00001E   F0           MOVX      @DPTR,A
    886            dstAddr.endPoint = 0xFF;
   \   00001F   7409         MOV       A,#0x9
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   74FF         MOV       A,#-0x1
   \   000026   F0           MOVX      @DPTR,A
    887          
    888            status = zclGeneral_SendIdentifyQuery( endpoint, &dstAddr, TRUE, bdb_getZCLFrameCounter() ); 
   \   000027                ; Setup parameters for call to function bdb_getZCLFrameCounter
   \   000027   12....       LCALL     `??bdb_getZCLFrameCounter::?relay`; Banked call to: bdb_getZCLFrameCounter
   \   00002A   E9           MOV       A,R1
   \   00002B   F9           MOV       R1,A
   \   00002C                ; Setup parameters for call to function zcl_SendCommand
   \   00002C   E4           CLR       A
   \   00002D   F5..         MOV       ?V0,A
   \   00002F   F5..         MOV       ?V1,A
   \   000031   78..         MOV       R0,#?V0
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000036   78..         MOV       R0,#?V0
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   E9           MOV       A,R1
   \   00003C   F5..         MOV       ?V0,A
   \   00003E   78..         MOV       R0,#?V0
   \   000040   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000043   E4           CLR       A
   \   000044   F5..         MOV       ?V0,A
   \   000046   78..         MOV       R0,#?V0
   \   000048   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004B   75..01       MOV       ?V0,#0x1
   \   00004E   78..         MOV       R0,#?V0
   \   000050   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000053   75..00       MOV       ?V0,#0x0
   \   000056   78..         MOV       R0,#?V0
   \   000058   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005B   75..01       MOV       ?V0,#0x1
   \   00005E   78..         MOV       R0,#?V0
   \   000060   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000063   78..         MOV       R0,#?V0
   \   000065   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000068   7C03         MOV       R4,#0x3
   \   00006A   7D00         MOV       R5,#0x0
   \   00006C   740B         MOV       A,#0xb
   \   00006E   12....       LCALL     ?XSTACK_DISP101_8
   \   000071   EF           MOV       A,R7
   \   000072   F9           MOV       R1,A
   \   000073   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000076   740B         MOV       A,#0xb
   \   000078   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007B   E9           MOV       A,R1
   \   00007C   FE           MOV       R6,A
    889            
    890            if(status == ZSuccess)
   \   00007D   7017         JNZ       ??bdb_SendIdentifyQuery_0
    891            {
    892              osal_start_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT, IDENTIFY_QUERY_RSP_TIMEOUT );
   \   00007F                ; Setup parameters for call to function osal_start_timerEx
   \   00007F   90....       MOV       DPTR,#__Constant_2710
   \   000082   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000085   7A00         MOV       R2,#0x0
   \   000087   7B40         MOV       R3,#0x40
   \   000089   90....       MOV       DPTR,#bdb_TaskID
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   F9           MOV       R1,A
   \   00008E   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000091   7404         MOV       A,#0x4
   \   000093   12....       LCALL     ?DEALLOC_XSTACK8
    893            }
    894            
    895            return status;
   \                     ??bdb_SendIdentifyQuery_0:
   \   000096   EE           MOV       A,R6
   \   000097   F9           MOV       R1,A
   \   000098   740C         MOV       A,#0xc
   \   00009A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00009D   7F02         MOV       R7,#0x2
   \   00009F   02....       LJMP      ?BANKED_LEAVE_XDATA
    896          }
    897          
    898          /*********************************************************************
    899           * @fn      bdb_ZclIdentifyQueryCmdInd
    900           *
    901           * @brief   Callback from the ZCL General Cluster Library when
    902           *          it received an Identity Query Response Command for this 
    903           *          application.
    904           *
    905           * @param   srcAddr - source address and endpoint of the response message
    906           * @param   identifyTime - the number of seconds to identify yourself
    907           *
    908           * @return  none
    909           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    910          void bdb_ZclIdentifyQueryCmdInd( zclIdentifyQueryRsp_t *pCmd )
   \                     bdb_ZclIdentifyQueryCmdInd:
    911          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    912            bdbFindingBindingRespondent_t *pCurr;
    913            
    914            // Stop the timer before refresh
    915            osal_stop_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT );
   \   000009                ; Setup parameters for call to function osal_stop_timerEx
   \   000009   7A00         MOV       R2,#0x0
   \   00000B   7B40         MOV       R3,#0x40
   \   00000D   90....       MOV       DPTR,#bdb_TaskID
   \   000010   E0           MOVX      A,@DPTR
   \   000011   F9           MOV       R1,A
   \   000012   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    916            
    917            // add new node to the list
    918            pCurr = bdb_AddRespondentNode( &pRespondentHead, pCmd );
   \   000015                ; Setup parameters for call to function bdb_AddRespondentNode
   \   000015   EE           MOV       A,R6
   \   000016   FC           MOV       R4,A
   \   000017   EF           MOV       A,R7
   \   000018   FD           MOV       R5,A
   \   000019   7A..         MOV       R2,#pRespondentHead & 0xff
   \   00001B   7B..         MOV       R3,#(pRespondentHead >> 8) & 0xff
   \   00001D   12....       LCALL     `??bdb_AddRespondentNode::?relay`; Banked call to: bdb_AddRespondentNode
   \   000020   8A..         MOV       ?V0,R2
   \   000022   8B..         MOV       ?V1,R3
   \   000024   A8..         MOV       R0,?V0
   \   000026   A9..         MOV       R1,?V1
    919            
    920            if(pCurr != NULL)
   \   000028   EA           MOV       A,R2
   \   000029   49           ORL       A,R1
   \   00002A   7003         JNZ       $+5
   \   00002C   02....       LJMP      ??bdb_ZclIdentifyQueryCmdInd_0 & 0xFFFF
    921            {
    922              pCurr->data.addrMode = pCmd->srcAddr->addrMode;
   \   00002F   8E82         MOV       DPL,R6
   \   000031   8F83         MOV       DPH,R7
   \   000033   E0           MOVX      A,@DPTR
   \   000034   FA           MOV       R2,A
   \   000035   A3           INC       DPTR
   \   000036   E0           MOVX      A,@DPTR
   \   000037   CA           XCH       A,R2
   \   000038   2408         ADD       A,#0x8
   \   00003A   F582         MOV       DPL,A
   \   00003C   E4           CLR       A
   \   00003D   3A           ADDC      A,R2
   \   00003E   F583         MOV       DPH,A
   \   000040   E0           MOVX      A,@DPTR
   \   000041   8882         MOV       DPL,R0
   \   000043   8B83         MOV       DPH,R3
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   A3           INC       DPTR
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   A3           INC       DPTR
   \   00004D   F0           MOVX      @DPTR,A
    923              pCurr->data.addr.shortAddr = pCmd->srcAddr->addr.shortAddr;
   \   00004E   8E82         MOV       DPL,R6
   \   000050   8F83         MOV       DPH,R7
   \   000052   E0           MOVX      A,@DPTR
   \   000053   FA           MOV       R2,A
   \   000054   A3           INC       DPTR
   \   000055   E0           MOVX      A,@DPTR
   \   000056   F583         MOV       DPH,A
   \   000058   8A82         MOV       DPL,R2
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   FA           MOV       R2,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   FB           MOV       R3,A
   \   00005F   8882         MOV       DPL,R0
   \   000061   8983         MOV       DPH,R1
   \   000063   EA           MOV       A,R2
   \   000064   F0           MOVX      @DPTR,A
   \   000065   A3           INC       DPTR
   \   000066   EB           MOV       A,R3
   \   000067   F0           MOVX      @DPTR,A
    924              pCurr->data.endPoint = pCmd->srcAddr->endPoint;
   \   000068   8E82         MOV       DPL,R6
   \   00006A   8F83         MOV       DPH,R7
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   FA           MOV       R2,A
   \   00006E   A3           INC       DPTR
   \   00006F   E0           MOVX      A,@DPTR
   \   000070   CA           XCH       A,R2
   \   000071   2409         ADD       A,#0x9
   \   000073   F582         MOV       DPL,A
   \   000075   E4           CLR       A
   \   000076   3A           ADDC      A,R2
   \   000077   F583         MOV       DPH,A
   \   000079   E0           MOVX      A,@DPTR
   \   00007A   8882         MOV       DPL,R0
   \   00007C   8983         MOV       DPH,R1
   \   00007E   A3           INC       DPTR
   \   00007F   A3           INC       DPTR
   \   000080   A3           INC       DPTR
   \   000081   A3           INC       DPTR
   \   000082   A3           INC       DPTR
   \   000083   A3           INC       DPTR
   \   000084   A3           INC       DPTR
   \   000085   A3           INC       DPTR
   \   000086   A3           INC       DPTR
   \   000087   F0           MOVX      @DPTR,A
    925              pCurr->data.panId = pCmd->srcAddr->panId;
   \   000088   8E82         MOV       DPL,R6
   \   00008A   8F83         MOV       DPH,R7
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   FA           MOV       R2,A
   \   00008E   A3           INC       DPTR
   \   00008F   E0           MOVX      A,@DPTR
   \   000090   CA           XCH       A,R2
   \   000091   240A         ADD       A,#0xa
   \   000093   F582         MOV       DPL,A
   \   000095   E4           CLR       A
   \   000096   3A           ADDC      A,R2
   \   000097   F583         MOV       DPH,A
   \   000099   E0           MOVX      A,@DPTR
   \   00009A   FA           MOV       R2,A
   \   00009B   A3           INC       DPTR
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   FB           MOV       R3,A
   \   00009E   8882         MOV       DPL,R0
   \   0000A0   8983         MOV       DPH,R1
   \   0000A2   A3           INC       DPTR
   \   0000A3   A3           INC       DPTR
   \   0000A4   A3           INC       DPTR
   \   0000A5   A3           INC       DPTR
   \   0000A6   A3           INC       DPTR
   \   0000A7   A3           INC       DPTR
   \   0000A8   A3           INC       DPTR
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   A3           INC       DPTR
   \   0000AC   EA           MOV       A,R2
   \   0000AD   F0           MOVX      @DPTR,A
   \   0000AE   A3           INC       DPTR
   \   0000AF   EB           MOV       A,R3
   \   0000B0   F0           MOVX      @DPTR,A
    926              pCurr->attempts = FINDING_AND_BINDING_NEW_RESPONDENT;
   \   0000B1   E8           MOV       A,R0
   \   0000B2   240C         ADD       A,#0xc
   \   0000B4   F582         MOV       DPL,A
   \   0000B6   E4           CLR       A
   \   0000B7   39           ADDC      A,R1
   \   0000B8   F583         MOV       DPH,A
   \   0000BA   E4           CLR       A
   \   0000BB   F0           MOVX      @DPTR,A
    927              pCurr->SimpleDescriptor = NULL;
   \   0000BC   E8           MOV       A,R0
   \   0000BD   240D         ADD       A,#0xd
   \   0000BF   F582         MOV       DPL,A
   \   0000C1   E4           CLR       A
   \   0000C2   39           ADDC      A,R1
   \   0000C3   F583         MOV       DPH,A
   \   0000C5   E4           CLR       A
   \   0000C6   F0           MOVX      @DPTR,A
   \   0000C7   A3           INC       DPTR
   \   0000C8   F0           MOVX      @DPTR,A
    928            }
    929            
    930            //Process the identify query rsp
    931            osal_set_event(bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT);
   \                     ??bdb_ZclIdentifyQueryCmdInd_0:
   \   0000C9                ; Setup parameters for call to function osal_set_event
   \   0000C9   7A00         MOV       R2,#0x0
   \   0000CB   7B40         MOV       R3,#0x40
   \   0000CD   90....       MOV       DPTR,#bdb_TaskID
   \   0000D0   E0           MOVX      A,@DPTR
   \   0000D1   F9           MOV       R1,A
   \   0000D2   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    932          }
   \   0000D5   7F02         MOV       R7,#0x2
   \   0000D7   02....       LJMP      ?BANKED_LEAVE_XDATA
    933          
    934          /*********************************************************************
    935           * @fn      bdb_ProcessRespondentList
    936           *
    937           * @brief   Process the respondent list by sending Simple Descriptor request to 
    938           *          devices respondent in the list. Also send IEEE Addr Req to those 
    939           *          device for which a bind is created buy IEEE addr is missing.
    940           *
    941           * @param   none
    942           *
    943           * @return  none
    944           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    945          void bdb_ProcessRespondentList( void )
   \                     bdb_ProcessRespondentList:
    946          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    947            zAddrType_t dstAddr = { 0 };
   \   00000A   90....       MOV       DPTR,#`?<Constant {{0}}>`
   \   00000D   AC..         MOV       R4,?XSP + 0
   \   00000F   AD..         MOV       R5,?XSP + 1
   \   000011   7409         MOV       A,#0x9
   \   000013   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
    948            
    949            // Look for the first respondent
    950            if ( pRespondentCurr == NULL )
   \   000016   90....       MOV       DPTR,#pRespondentCurr
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F8           MOV       R0,A
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   F9           MOV       R1,A
   \   00001E   E8           MOV       A,R0
   \   00001F   49           ORL       A,R1
   \   000020   702F         JNZ       ??bdb_ProcessRespondentList_0
    951            {
    952              pRespondentCurr = bdb_getRespondentRetry(pRespondentHead);
   \   000022                ; Setup parameters for call to function bdb_getRespondentRetry
   \   000022   90....       MOV       DPTR,#pRespondentHead
   \   000025   E0           MOVX      A,@DPTR
   \   000026   FA           MOV       R2,A
   \   000027   A3           INC       DPTR
   \   000028   E0           MOVX      A,@DPTR
   \   000029   FB           MOV       R3,A
   \   00002A   12....       LCALL     `??bdb_getRespondentRetry::?relay`; Banked call to: bdb_getRespondentRetry
   \   00002D   90....       MOV       DPTR,#pRespondentCurr
   \   000030   EA           MOV       A,R2
   \   000031   F0           MOVX      @DPTR,A
   \   000032   A3           INC       DPTR
   \   000033   EB           MOV       A,R3
   \   000034   F0           MOVX      @DPTR,A
    953              
    954              // If null, then no responses from Identify query request
    955              if ( (pRespondentCurr == NULL) )
   \   000035   90....       MOV       DPTR,#pRespondentCurr
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F8           MOV       R0,A
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   F9           MOV       R1,A
   \   00003D   E8           MOV       A,R0
   \   00003E   49           ORL       A,R1
   \   00003F   706F         JNZ       ??bdb_ProcessRespondentList_1
    956              {
    957                //No responses, then no responses
    958                if(pRespondentHead == NULL)
   \   000041   90....       MOV       DPTR,#pRespondentHead
   \   000044   E0           MOVX      A,@DPTR
   \   000045   F8           MOV       R0,A
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   F9           MOV       R1,A
   \   000049   E8           MOV       A,R0
   \   00004A   49           ORL       A,R1
   \   00004B   704B         JNZ       ??bdb_ProcessRespondentList_2
    959                {
    960                  bdb_exitFindingBindingWStatus( BDB_COMMISSIONING_FB_NO_IDENTIFY_QUERY_RESPONSE );
   \   00004D                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   00004D   790B         MOV       R1,#0xb
   \   00004F   8049         SJMP      ??bdb_ProcessRespondentList_3
    961                }
    962                //Responses and binded to all clusters possible
    963                else
    964                {
    965                  bdb_exitFindingBindingWStatus( BDB_COMMISSIONING_SUCCESS );
    966                }
    967                return;
    968              }
    969            }
    970            else
    971            {
    972              //Validate that we are not processing a missing IEEE Address before chaning 
    973              //the current respondent to be process
    974              if((pRespondentCurr->attempts & FINDING_AND_BINDING_MISSING_IEEE_ADDR) &&
    975                 ((pRespondentCurr->attempts & (~FINDING_AND_BINDING_MISSING_IEEE_ADDR)) >= FINDING_AND_BINDING_MAX_ATTEMPTS))
   \                     ??bdb_ProcessRespondentList_0:
   \   000051   90....       MOV       DPTR,#pRespondentCurr
   \   000054   E0           MOVX      A,@DPTR
   \   000055   240C         ADD       A,#0xc
   \   000057   F8           MOV       R0,A
   \   000058   A3           INC       DPTR
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   3400         ADDC      A,#0x0
   \   00005C   8882         MOV       DPL,R0
   \   00005E   F583         MOV       DPH,A
   \   000060   E0           MOVX      A,@DPTR
   \   000061   A2E7         MOV       C,0xE0 /* A   */.7
   \   000063   504B         JNC       ??bdb_ProcessRespondentList_1
   \   000065   E0           MOVX      A,@DPTR
   \   000066   547F         ANL       A,#0x7f
   \   000068   C3           CLR       C
   \   000069   9404         SUBB      A,#0x4
   \   00006B   4043         JC        ??bdb_ProcessRespondentList_1
    976              {
    977                if(pRespondentNext == NULL)
   \   00006D   90....       MOV       DPTR,#pRespondentNext
   \   000070   E0           MOVX      A,@DPTR
   \   000071   F8           MOV       R0,A
   \   000072   A3           INC       DPTR
   \   000073   E0           MOVX      A,@DPTR
   \   000074   F9           MOV       R1,A
   \   000075   E8           MOV       A,R0
   \   000076   49           ORL       A,R1
   \   000077   7027         JNZ       ??bdb_ProcessRespondentList_4
    978                {
    979                  //Review the whole list if we have simple desc that we need to attempt.
    980                  pRespondentCurr = bdb_getRespondentRetry(pRespondentHead);
   \   000079                ; Setup parameters for call to function bdb_getRespondentRetry
   \   000079   90....       MOV       DPTR,#pRespondentHead
   \   00007C   E0           MOVX      A,@DPTR
   \   00007D   FA           MOV       R2,A
   \   00007E   A3           INC       DPTR
   \   00007F   E0           MOVX      A,@DPTR
   \   000080   FB           MOV       R3,A
   \   000081   12....       LCALL     `??bdb_getRespondentRetry::?relay`; Banked call to: bdb_getRespondentRetry
   \   000084   90....       MOV       DPTR,#pRespondentCurr
   \   000087   EA           MOV       A,R2
   \   000088   F0           MOVX      @DPTR,A
   \   000089   A3           INC       DPTR
   \   00008A   EB           MOV       A,R3
   \   00008B   F0           MOVX      @DPTR,A
    981                    
    982                  if(pRespondentCurr == NULL)
   \   00008C   90....       MOV       DPTR,#pRespondentCurr
   \   00008F   E0           MOVX      A,@DPTR
   \   000090   F8           MOV       R0,A
   \   000091   A3           INC       DPTR
   \   000092   E0           MOVX      A,@DPTR
   \   000093   F9           MOV       R1,A
   \   000094   E8           MOV       A,R0
   \   000095   49           ORL       A,R1
   \   000096   7018         JNZ       ??bdb_ProcessRespondentList_1
    983                  {
    984                    bdb_exitFindingBindingWStatus( BDB_COMMISSIONING_SUCCESS );
   \   000098                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \                     ??bdb_ProcessRespondentList_2:
   \   000098   7900         MOV       R1,#0x0
   \                     ??bdb_ProcessRespondentList_3:
   \   00009A   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
    985                    return;
   \   00009D   02....       LJMP      ??bdb_ProcessRespondentList_5 & 0xFFFF
    986                  }
    987                }
    988                else
    989                {
    990                  pRespondentCurr = pRespondentNext;
   \                     ??bdb_ProcessRespondentList_4:
   \   0000A0   90....       MOV       DPTR,#pRespondentNext
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   F8           MOV       R0,A
   \   0000A5   A3           INC       DPTR
   \   0000A6   E0           MOVX      A,@DPTR
   \   0000A7   F9           MOV       R1,A
   \   0000A8   90....       MOV       DPTR,#pRespondentCurr
   \   0000AB   E8           MOV       A,R0
   \   0000AC   F0           MOVX      @DPTR,A
   \   0000AD   A3           INC       DPTR
   \   0000AE   E9           MOV       A,R1
   \   0000AF   F0           MOVX      @DPTR,A
    991                }
    992              }
    993            }
    994            
    995            //Start the timer to process the next respondent
    996            osal_start_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT, SIMPLEDESC_RESPONSE_TIMEOUT );
   \                     ??bdb_ProcessRespondentList_1:
   \   0000B0                ; Setup parameters for call to function osal_start_timerEx
   \   0000B0   90....       MOV       DPTR,#zgPollRate
   \   0000B3   78..         MOV       R0,#?V0
   \   0000B5   12....       LCALL     ?L_MOV_X
   \   0000B8   90....       MOV       DPTR,#__Constant_3
   \   0000BB   78..         MOV       R0,#?V4
   \   0000BD   12....       LCALL     ?L_MOV_X
   \   0000C0   78..         MOV       R0,#?V0
   \   0000C2   79..         MOV       R1,#?V4
   \   0000C4   12....       LCALL     ?L_MUL
   \   0000C7   78..         MOV       R0,#?V0
   \   0000C9   12....       LCALL     ?PUSH_XSTACK_I_FOUR
   \   0000CC   7A00         MOV       R2,#0x0
   \   0000CE   7B40         MOV       R3,#0x40
   \   0000D0   90....       MOV       DPTR,#bdb_TaskID
   \   0000D3   E0           MOVX      A,@DPTR
   \   0000D4   F9           MOV       R1,A
   \   0000D5   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   0000D8   7404         MOV       A,#0x4
   \   0000DA   12....       LCALL     ?DEALLOC_XSTACK8
    997            
    998            //If ParentLost is reported, then do not attempt send SimpleDesc, mark those as pending, 
    999            //if Parent Lost is restored, then these simpleDesc attempts will be restored to 0
   1000            if(bdbCommissioningProcedureState.bdbCommissioningState != BDB_PARENT_LOST)
   \   0000DD   90....       MOV       DPTR,#pRespondentCurr
   \   0000E0   E0           MOVX      A,@DPTR
   \   0000E1   240C         ADD       A,#0xc
   \   0000E3   F8           MOV       R0,A
   \   0000E4   A3           INC       DPTR
   \   0000E5   E0           MOVX      A,@DPTR
   \   0000E6   3400         ADDC      A,#0x0
   \   0000E8   F9           MOV       R1,A
   \   0000E9   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0000EC   E0           MOVX      A,@DPTR
   \   0000ED   6408         XRL       A,#0x8
   \   0000EF   7003         JNZ       $+5
   \   0000F1   02....       LJMP      ??bdb_ProcessRespondentList_6 & 0xFFFF
   1001            {
   1002              dstAddr.addr.shortAddr = pRespondentCurr->data.addr.shortAddr;
   \   0000F4   90....       MOV       DPTR,#pRespondentCurr
   \   0000F7   E0           MOVX      A,@DPTR
   \   0000F8   FA           MOV       R2,A
   \   0000F9   A3           INC       DPTR
   \   0000FA   E0           MOVX      A,@DPTR
   \   0000FB   F583         MOV       DPH,A
   \   0000FD   8A82         MOV       DPL,R2
   \   0000FF   E0           MOVX      A,@DPTR
   \   000100   FA           MOV       R2,A
   \   000101   A3           INC       DPTR
   \   000102   E0           MOVX      A,@DPTR
   \   000103   FB           MOV       R3,A
   \   000104   85..82       MOV       DPL,?XSP + 0
   \   000107   85..83       MOV       DPH,?XSP + 1
   \   00010A   EA           MOV       A,R2
   \   00010B   F0           MOVX      @DPTR,A
   \   00010C   A3           INC       DPTR
   \   00010D   EB           MOV       A,R3
   \   00010E   F0           MOVX      @DPTR,A
   1003              dstAddr.addrMode = pRespondentCurr->data.addrMode;
   \   00010F   90....       MOV       DPTR,#pRespondentCurr
   \   000112   E0           MOVX      A,@DPTR
   \   000113   FA           MOV       R2,A
   \   000114   A3           INC       DPTR
   \   000115   E0           MOVX      A,@DPTR
   \   000116   CA           XCH       A,R2
   \   000117   2408         ADD       A,#0x8
   \   000119   F582         MOV       DPL,A
   \   00011B   E4           CLR       A
   \   00011C   3A           ADDC      A,R2
   \   00011D   F583         MOV       DPH,A
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   C0E0         PUSH      A
   \   000122   7408         MOV       A,#0x8
   \   000124   12....       LCALL     ?XSTACK_DISP0_8
   \   000127   D0E0         POP       A
   \   000129   F0           MOVX      @DPTR,A
   1004          
   1005              //Update the attempts, ahead of actually sending the frame, as this is done just below
   1006              pRespondentCurr->attempts++;
   \   00012A   8882         MOV       DPL,R0
   \   00012C   8983         MOV       DPH,R1
   \   00012E   E0           MOVX      A,@DPTR
   \   00012F   04           INC       A
   \   000130   F0           MOVX      @DPTR,A
   1007              
   1008              //Send IEEE addr request or simple desc req
   1009              if(pRespondentCurr->attempts & FINDING_AND_BINDING_MISSING_IEEE_ADDR)
   \   000131   90....       MOV       DPTR,#pRespondentCurr
   \   000134   E0           MOVX      A,@DPTR
   \   000135   F8           MOV       R0,A
   \   000136   A3           INC       DPTR
   \   000137   E0           MOVX      A,@DPTR
   \   000138   F583         MOV       DPH,A
   \   00013A   8882         MOV       DPL,R0
   \   00013C   E0           MOVX      A,@DPTR
   \   00013D   FA           MOV       R2,A
   \   00013E   A3           INC       DPTR
   \   00013F   E0           MOVX      A,@DPTR
   \   000140   FB           MOV       R3,A
   \   000141   90....       MOV       DPTR,#pRespondentCurr
   \   000144   E0           MOVX      A,@DPTR
   \   000145   F8           MOV       R0,A
   \   000146   A3           INC       DPTR
   \   000147   E0           MOVX      A,@DPTR
   \   000148   C8           XCH       A,R0
   \   000149   240C         ADD       A,#0xc
   \   00014B   F582         MOV       DPL,A
   \   00014D   E4           CLR       A
   \   00014E   38           ADDC      A,R0
   \   00014F   F583         MOV       DPH,A
   \   000151   E0           MOVX      A,@DPTR
   \   000152   A2E7         MOV       C,0xE0 /* A   */.7
   \   000154   500B         JNC       ??bdb_ProcessRespondentList_7
   1010              {
   1011                ZDP_IEEEAddrReq(pRespondentCurr->data.addr.shortAddr,0,0,0);
   \   000156                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000156   7D00         MOV       R5,#0x0
   \   000158   7C00         MOV       R4,#0x0
   \   00015A   7900         MOV       R1,#0x0
   \   00015C   12....       LCALL     `??ZDP_IEEEAddrReq::?relay`; Banked call to: ZDP_IEEEAddrReq
   \   00015F   8035         SJMP      ??bdb_ProcessRespondentList_8
   1012              }
   1013              else
   1014              {
   1015                //Send simple descriptor
   1016                ZDP_SimpleDescReq( &dstAddr, pRespondentCurr->data.addr.shortAddr, pRespondentCurr->data.endPoint, 0 );
   \                     ??bdb_ProcessRespondentList_7:
   \   000161                ; Setup parameters for call to function ZDP_SimpleDescReq
   \   000161   75..00       MOV       ?V0,#0x0
   \   000164   78..         MOV       R0,#?V0
   \   000166   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000169   90....       MOV       DPTR,#pRespondentCurr
   \   00016C   E0           MOVX      A,@DPTR
   \   00016D   F8           MOV       R0,A
   \   00016E   A3           INC       DPTR
   \   00016F   E0           MOVX      A,@DPTR
   \   000170   C8           XCH       A,R0
   \   000171   2409         ADD       A,#0x9
   \   000173   F582         MOV       DPL,A
   \   000175   E4           CLR       A
   \   000176   38           ADDC      A,R0
   \   000177   F583         MOV       DPH,A
   \   000179   E0           MOVX      A,@DPTR
   \   00017A   F9           MOV       R1,A
   \   00017B   EA           MOV       A,R2
   \   00017C   FC           MOV       R4,A
   \   00017D   EB           MOV       A,R3
   \   00017E   FD           MOV       R5,A
   \   00017F   7401         MOV       A,#0x1
   \   000181   12....       LCALL     ?XSTACK_DISP101_8
   \   000184   12....       LCALL     `??ZDP_SimpleDescReq::?relay`; Banked call to: ZDP_SimpleDescReq
   \   000187   7401         MOV       A,#0x1
   \   000189   12....       LCALL     ?DEALLOC_XSTACK8
   \   00018C   8008         SJMP      ??bdb_ProcessRespondentList_8
   1017              }
   1018            }
   1019            else
   1020            {
   1021              //Stop any attempt due to parent lost
   1022              pRespondentCurr->attempts |= FINDING_AND_BINDING_PARENT_LOST;
   \                     ??bdb_ProcessRespondentList_6:
   \   00018E   8882         MOV       DPL,R0
   \   000190   8983         MOV       DPH,R1
   \   000192   E0           MOVX      A,@DPTR
   \   000193   D2E6         SETB      0xE0 /* A   */.6
   \   000195   F0           MOVX      @DPTR,A
   1023            }
   1024            
   1025            //Search for the next respondant that has not enough tries in the list
   1026            pRespondentNext = bdb_getRespondentRetry(pRespondentCurr->pNext);
   \                     ??bdb_ProcessRespondentList_8:
   \   000196                ; Setup parameters for call to function bdb_getRespondentRetry
   \   000196   90....       MOV       DPTR,#pRespondentCurr
   \   000199   E0           MOVX      A,@DPTR
   \   00019A   F8           MOV       R0,A
   \   00019B   A3           INC       DPTR
   \   00019C   E0           MOVX      A,@DPTR
   \   00019D   C8           XCH       A,R0
   \   00019E   240F         ADD       A,#0xf
   \   0001A0   F582         MOV       DPL,A
   \   0001A2   E4           CLR       A
   \   0001A3   38           ADDC      A,R0
   \   0001A4   F583         MOV       DPH,A
   \   0001A6   E0           MOVX      A,@DPTR
   \   0001A7   FA           MOV       R2,A
   \   0001A8   A3           INC       DPTR
   \   0001A9   E0           MOVX      A,@DPTR
   \   0001AA   FB           MOV       R3,A
   \   0001AB   12....       LCALL     `??bdb_getRespondentRetry::?relay`; Banked call to: bdb_getRespondentRetry
   \   0001AE   90....       MOV       DPTR,#pRespondentNext
   \   0001B1   EA           MOV       A,R2
   \   0001B2   F0           MOVX      @DPTR,A
   \   0001B3   A3           INC       DPTR
   \   0001B4   EB           MOV       A,R3
   \   0001B5   F0           MOVX      @DPTR,A
   1027          }
   \                     ??bdb_ProcessRespondentList_5:
   \   0001B6   7409         MOV       A,#0x9
   \   0001B8   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001BB   7F08         MOV       R7,#0x8
   \   0001BD   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {{0}}>`:
   \   000000   0000         DW 0
   \   000002   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    
   \   000008   00           DB 0
   1028          
   1029          /*********************************************************************
   1030           * @fn      bdb_FindIfAppCluster
   1031           *
   1032           * @brief   To verify if cluster is application type and should the local device create a bind for it
   1033           *
   1034           * @param   ClusterId - cluster ID to be verified
   1035           * @param   isClusterOutput - True if the bind attempted is output cluster in the local device, false otherwise
   1036           *
   1037           * @return  true if success
   1038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1039          uint8 bdb_FindIfAppCluster( cId_t ClusterId, uint8 isClusterOutput )
   \                     bdb_FindIfAppCluster:
   1040          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   1041            uint8 i;
   1042            uint8 ClusterCnt;
   1043          
   1044            if(isClusterOutput)
   \   000006   7800         MOV       R0,#0x0
   \   000008   6024         JZ        ??bdb_FindIfAppCluster_0
   1045            {
   1046                ClusterCnt = sizeof( bdb_ZclType1Clusters )/sizeof( uint16 );
   1047          
   1048                for ( i = 0; i < ClusterCnt; i++ )
   \                     ??bdb_FindIfAppCluster_1:
   \   00000A   E8           MOV       A,R0
   \   00000B   C3           CLR       C
   \   00000C   9418         SUBB      A,#0x18
   \   00000E   5042         JNC       ??bdb_FindIfAppCluster_2
   1049                {
   1050                  if ( bdb_ZclType1Clusters[i] == ClusterId )
   \   000010   E8           MOV       A,R0
   \   000011   25E0         ADD       A,0xE0 /* A   */
   \   000013   FC           MOV       R4,A
   \   000014   E4           CLR       A
   \   000015   33           RLC       A
   \   000016   FD           MOV       R5,A
   \   000017   74..         MOV       A,#bdb_ZclType1Clusters & 0xff
   \   000019   2C           ADD       A,R4
   \   00001A   F582         MOV       DPL,A
   \   00001C   74..         MOV       A,#(bdb_ZclType1Clusters >> 8) & 0xff
   \   00001E   3D           ADDC      A,R5
   \   00001F   F583         MOV       DPH,A
   \   000021   E0           MOVX      A,@DPTR
   \   000022   6A           XRL       A,R2
   \   000023   7003         JNZ       ??bdb_FindIfAppCluster_3
   \   000025   A3           INC       DPTR
   \   000026   E0           MOVX      A,@DPTR
   \   000027   6B           XRL       A,R3
   \                     ??bdb_FindIfAppCluster_3:
   \   000028   6024         JZ        ??bdb_FindIfAppCluster_4
   1051                  {
   1052                    return ( SUCCESS );
   1053                  }
   1054                }
   \   00002A   08           INC       R0
   \   00002B   80DD         SJMP      ??bdb_FindIfAppCluster_1
   1055            }
   1056            else
   1057            {
   1058                ClusterCnt = sizeof( bdb_ZclType2Clusters )/sizeof( uint16 );
   1059          
   1060                for ( i = 0; i < ClusterCnt; i++ )
   \                     ??bdb_FindIfAppCluster_5:
   \   00002D   08           INC       R0
   \                     ??bdb_FindIfAppCluster_0:
   \   00002E   E8           MOV       A,R0
   \   00002F   C3           CLR       C
   \   000030   9431         SUBB      A,#0x31
   \   000032   501E         JNC       ??bdb_FindIfAppCluster_2
   1061                {
   1062                  if ( bdb_ZclType2Clusters[i] == ClusterId )
   \   000034   E8           MOV       A,R0
   \   000035   25E0         ADD       A,0xE0 /* A   */
   \   000037   FC           MOV       R4,A
   \   000038   E4           CLR       A
   \   000039   33           RLC       A
   \   00003A   FD           MOV       R5,A
   \   00003B   74..         MOV       A,#bdb_ZclType2Clusters & 0xff
   \   00003D   2C           ADD       A,R4
   \   00003E   F582         MOV       DPL,A
   \   000040   74..         MOV       A,#(bdb_ZclType2Clusters >> 8) & 0xff
   \   000042   3D           ADDC      A,R5
   \   000043   F583         MOV       DPH,A
   \   000045   E0           MOVX      A,@DPTR
   \   000046   6A           XRL       A,R2
   \   000047   7003         JNZ       ??bdb_FindIfAppCluster_6
   \   000049   A3           INC       DPTR
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   6B           XRL       A,R3
   \                     ??bdb_FindIfAppCluster_6:
   \   00004C   70DF         JNZ       ??bdb_FindIfAppCluster_5
   1063                  {
   1064                    return ( SUCCESS );
   \                     ??bdb_FindIfAppCluster_4:
   \   00004E   7900         MOV       R1,#0x0
   \   000050   8002         SJMP      ??bdb_FindIfAppCluster_7
   1065                  }
   1066                }
   1067            }
   1068            
   1069            // If not found, take it as application cluster it will be filtered
   1070            // by simple descriptor at some point
   1071            return ( FAILURE );
   \                     ??bdb_FindIfAppCluster_2:
   \   000052   7901         MOV       R1,#0x1
   \                     ??bdb_FindIfAppCluster_7:
   \   000054   7F01         MOV       R7,#0x1
   \   000056   02....       LJMP      ?BANKED_LEAVE_XDATA
   1072          }
   1073          
   1074          
   1075          /*********************************************************************
   1076           * @fn      bdb_getRespondentRetry
   1077           *
   1078           * @brief   Get the next Respondant entry to retry
   1079           *
   1080           * @param   pHead - pointer to a pointer of the list head
   1081           *
   1082           * @return  respondant entry if found, otherwise NULL
   1083           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1084          bdbFindingBindingRespondent_t* bdb_getRespondentRetry(bdbFindingBindingRespondent_t* pRespondentHead)
   \                     bdb_getRespondentRetry:
   1085          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1086            bdbFindingBindingRespondent_t *pTemp;
   1087            
   1088            pTemp = pRespondentHead;
   \   000004   800E         SJMP      ??bdb_getRespondentRetry_0
   1089            
   1090            while(pTemp != NULL)
   1091            {
   1092              //does the next entry requires to perform an attempt on simple desc req or IEEE addr req?
   1093              if((pTemp->attempts & ~FINDING_AND_BINDING_MISSING_IEEE_ADDR) < FINDING_AND_BINDING_MAX_ATTEMPTS)
   1094              {
   1095                return pTemp;
   1096              }
   1097             
   1098              pTemp = pTemp->pNext;
   \                     ??bdb_getRespondentRetry_1:
   \   000006   EA           MOV       A,R2
   \   000007   240F         ADD       A,#0xf
   \   000009   F582         MOV       DPL,A
   \   00000B   E4           CLR       A
   \   00000C   3B           ADDC      A,R3
   \   00000D   F583         MOV       DPH,A
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   FA           MOV       R2,A
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FB           MOV       R3,A
   \                     ??bdb_getRespondentRetry_0:
   \   000014   EA           MOV       A,R2
   \   000015   4B           ORL       A,R3
   \   000016   6013         JZ        ??bdb_getRespondentRetry_2
   \   000018   EA           MOV       A,R2
   \   000019   240C         ADD       A,#0xc
   \   00001B   F582         MOV       DPL,A
   \   00001D   E4           CLR       A
   \   00001E   3B           ADDC      A,R3
   \   00001F   F583         MOV       DPH,A
   \   000021   E0           MOVX      A,@DPTR
   \   000022   547F         ANL       A,#0x7f
   \   000024   C3           CLR       C
   \   000025   9404         SUBB      A,#0x4
   \   000027   50DD         JNC       ??bdb_getRespondentRetry_1
   \   000029   8004         SJMP      ??bdb_getRespondentRetry_3
   1099            }
   1100            return NULL;
   \                     ??bdb_getRespondentRetry_2:
   \   00002B   7A00         MOV       R2,#0x0
   \   00002D   7B00         MOV       R3,#0x0
   \                     ??bdb_getRespondentRetry_3:
   \   00002F   D083         POP       DPH
   \   000031   D082         POP       DPL
   \   000033   02....       LJMP      ?BRET
   1101          }
   1102          
   1103          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1104          bdbFindingBindingRespondent_t* bdb_findRespondentNode(uint8 endpoint, uint16 shortAddress)
   \                     bdb_findRespondentNode:
   1105          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1106            bdbFindingBindingRespondent_t* pTemp = pRespondentHead;
   \   000004   90....       MOV       DPTR,#pRespondentHead
   \   000007   8009         SJMP      ??bdb_findRespondentNode_0
   1107            
   1108            while(pTemp != NULL)  
   1109            {
   1110              if((pTemp->data.addr.shortAddr == shortAddress) && (pTemp->data.endPoint == endpoint))
   1111              {
   1112                return pTemp;
   1113              }
   1114              
   1115              pTemp = pTemp->pNext;
   \                     ??bdb_findRespondentNode_1:
   \   000009   EC           MOV       A,R4
   \   00000A   240F         ADD       A,#0xf
   \   00000C   F582         MOV       DPL,A
   \   00000E   E4           CLR       A
   \   00000F   3D           ADDC      A,R5
   \   000010   F583         MOV       DPH,A
   \                     ??bdb_findRespondentNode_0:
   \   000012   E0           MOVX      A,@DPTR
   \   000013   FC           MOV       R4,A
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FD           MOV       R5,A
   \   000017   EC           MOV       A,R4
   \   000018   4D           ORL       A,R5
   \   000019   6024         JZ        ??bdb_findRespondentNode_2
   \   00001B   8C82         MOV       DPL,R4
   \   00001D   8D83         MOV       DPH,R5
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   6A           XRL       A,R2
   \   000021   7003         JNZ       ??bdb_findRespondentNode_3
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   6B           XRL       A,R3
   \                     ??bdb_findRespondentNode_3:
   \   000026   70E1         JNZ       ??bdb_findRespondentNode_1
   \   000028   8C82         MOV       DPL,R4
   \   00002A   8D83         MOV       DPH,R5
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   69           XRL       A,R1
   \   000037   70D0         JNZ       ??bdb_findRespondentNode_1
   \   000039   EC           MOV       A,R4
   \   00003A   FA           MOV       R2,A
   \   00003B   ED           MOV       A,R5
   \   00003C   FB           MOV       R3,A
   \   00003D   8004         SJMP      ??bdb_findRespondentNode_4
   1116            }
   1117            
   1118            return NULL;
   \                     ??bdb_findRespondentNode_2:
   \   00003F   7A00         MOV       R2,#0x0
   \   000041   7B00         MOV       R3,#0x0
   \                     ??bdb_findRespondentNode_4:
   \   000043   D083         POP       DPH
   \   000045   D082         POP       DPL
   \   000047   02....       LJMP      ?BRET
   1119          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for grpName>`:
   \   000000   47           DB 71
   \   000001   72           DB 114
   \   000002   6F           DB 111
   \   000003   75           DB 117
   \   000004   70           DB 112
   \   000005   00           DB 0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for bdbIndentifyActiveEndpoint>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_Groups_Options>`:
   \   000000   0400         DW 4
   \   000002   10           DB 16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e7:
   \   000000   E7030000     DD 999

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e8:
   \   000000   E8030000     DD 1000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2710:
   \   000000   10270000     DD 10000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3:
   \   000000   03000000     DD 3
   1120          
   1121          #endif  
   1122          
   1123          /*********************************************************************
   1124          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     23   bdb_FindIfAppCluster
      1     20   bdb_GetFBInitiatorStatus
        0     20   -> osal_get_timeoutEx
      0     25   bdb_ProcessIEEEAddrRsp
        0     25   -> AddrMgrEntryUpdate
        0     25   -> AddrMgrExtAddrSet
        0     25   -> ZDO_ParseAddrRsp
        0     25   -> bdb_checkMatchingEndpoints
        0     25   -> bdb_exitFindingBindingWStatus
        0     25   -> bdb_findRespondentNode
        0     25   -> bdb_setEpDescListToActiveEndpoint
        0     25   -> bdb_zclSimpleDescClusterListClean
        0     25   -> osal_mem_free
        0     25   -> osal_stop_timerEx
      1     29   bdb_ProcessRespondentList
        0     25   -> ZDP_IEEEAddrReq
        0     26   -> ZDP_SimpleDescReq
        0     25   -> bdb_exitFindingBindingWStatus
        0     25   -> bdb_getRespondentRetry
        0     29   -> osal_start_timerEx
      0     28   bdb_ProcessSimpleDesc
        0     28   -> AddrMgrExtAddrLookup
        0     28   -> ZDO_ParseSimpleDescBuf
        0     28   -> bdb_checkMatchingEndpoints
        0     28   -> bdb_findRespondentNode
        0     28   -> bdb_setEpDescListToActiveEndpoint
        0     28   -> bdb_zclSimpleDescClusterListClean
      2      0   bdb_RegisterBindNotificationCB
      2      0   bdb_RegisterIdentifyTimeChangeCB
      0     33   bdb_SendIdentifyQuery
        0     22   -> bdb_getZCLFrameCounter
        0     26   -> osal_start_timerEx
        0     33   -> zcl_SendCommand
      2      0   bdb_SetIdentifyActiveEndpoint
      2      0   bdb_StopInitiatorFindingBinding
        2      0   -> bdb_exitFindingBindingWStatus
        2      0   -> bdb_zclRespondentListClean
        2      0   -> osal_stop_timerEx
      1     10   bdb_ZclIdentifyQueryCmdInd
        0     10   -> bdb_AddRespondentNode
        0     10   -> osal_set_event
        0     10   -> osal_stop_timerEx
      1     75   bdb_checkMatchingEndpoints
        0     41   -> AddrMgrExtAddrLookup
        0     41   -> bdb_exitFindingBindingWStatus
        0     47   -> bdb_zclFindingBindingAddBindEntry
        0     41   -> bdb_zclSimpleDescClusterListClean
        0     41   -> osal_stop_timerEx
        0     46   -> zclGeneral_SendAddGroupRequest
        0     41   -> zcl_registerClusterOptionList
      0     50   bdb_exitFindingBindingWStatus
        0      9   -> bdb_reportCommissioningState
      2     28   bdb_findRespondentNode
      2     25   bdb_getRespondentRetry
      2     28   bdb_setEpDescListToActiveEndpoint
      0     63   bdb_zclFindingBindingAddBindEntry
        0     16   -> ZDO_AnyClusterMatches
        0     14   -> bdb_FindIfAppCluster
      0     16   bdb_zclFindingBindingEpType
        0     16   -> ZDO_AnyClusterMatches
      0     51   bdb_zclSimpleDescClusterListClean
        0     10   -> osal_mem_free


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant {{0}}>
       1  ?<Initializer for bdbIndentifyActiveEndpoint>
       6  ?<Initializer for grpName>
       3  ?<Initializer for zcl_Groups_Options>
       4  __Constant_2710
       4  __Constant_3
       4  __Constant_3e7
       4  __Constant_3e8
       1  bdbIndentifyActiveEndpoint
      89  bdb_FindIfAppCluster
      12  bdb_FindingBindingTargetSimpleDesc
     111  bdb_GetFBInitiatorStatus
     289  bdb_ProcessIEEEAddrRsp
     448  bdb_ProcessRespondentList
     285  bdb_ProcessSimpleDesc
      19  bdb_RegisterBindNotificationCB
      19  bdb_RegisterIdentifyTimeChangeCB
     162  bdb_SendIdentifyQuery
      97  bdb_SetIdentifyActiveEndpoint
      51  bdb_StopInitiatorFindingBinding
     218  bdb_ZclIdentifyQueryCmdInd
      48  bdb_ZclType1Clusters
      98  bdb_ZclType2Clusters
     760  bdb_checkMatchingEndpoints
      22  bdb_exitFindingBindingWStatus
      74  bdb_findRespondentNode
      54  bdb_getRespondentRetry
     198  bdb_setEpDescListToActiveEndpoint
     173  bdb_zclFindingBindingAddBindEntry
     318  bdb_zclFindingBindingEpType
      85  bdb_zclSimpleDescClusterListClean
       6  grpName
       2  pfnBindNotificationCB
       2  pfnIdentifyTimeChangeCB
       3  zcl_Groups_Options
     114  -- Other

 
 3 472 bytes in segment BANKED_CODE
   114 bytes in segment BANK_RELAYS
    10 bytes in segment XDATA_I
    10 bytes in segment XDATA_ID
   171 bytes in segment XDATA_ROM_C
    16 bytes in segment XDATA_Z
 
   124 bytes of CODE     memory
   155 bytes of CONST    memory (+ 16 bytes shared)
 3 472 bytes of HUGECODE memory
    26 bytes of XDATA    memory

Errors: none
Warnings: none
