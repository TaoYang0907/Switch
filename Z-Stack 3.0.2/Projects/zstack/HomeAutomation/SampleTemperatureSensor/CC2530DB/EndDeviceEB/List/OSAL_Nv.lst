###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               20/Jul/2020  17:08:06
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack 3.0.2\Components\osal\mcu\cc2530\OSAL_Nv.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EW86BF.tmp ("D:\AA\Z-Stack
#        3.0.2\Components\osal\mcu\cc2530\OSAL_Nv.c" -D BDB_REPORTING -D
#        SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D xNV_RESTORE -D xPOWER_SAVING
#        -D NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D
#        xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D
#        ZCL_TEMPERATURE_MEASUREMENT -D ZCL_GROUPS -D ZCL_ON_OFF -D ZCL_REPORT
#        -D ZCL_REPORT_DESTINATION_DEVICE -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Om --require_prototypes --no_unroll --no_inline --no_tbaa
#        --no_cross_call)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\List\OSAL_Nv.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\EndDeviceEB\Obj\OSAL_Nv.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Components\osal\mcu\cc2530\OSAL_Nv.c
      1          /******************************************************************************
      2            Filename:       OSAL_Nv.c
      3            Revised:        $Date: 2014-12-19 13:07:30 -0800 (Fri, 19 Dec 2014) $
      4            Revision:       $Revision: 41556 $
      5          
      6            Description:    This module contains the OSAL non-volatile memory functions.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          /******************************************************************************
     41            Notes:
     42              - A trick buried deep in initPage() requires that the MSB of the NV Item Id
     43                is to be reserved for use by this module.
     44          ******************************************************************************/
     45          
     46          /*********************************************************************
     47           * INCLUDES
     48           */
     49          
     50          #include "hal_adc.h"
     51          #include "hal_flash.h"
     52          #include "hal_types.h"
     53          #include "OSAL_Nv.h"
     54          #include "ZComDef.h"
     55          #ifdef HAL_MCU_CC2533
     56          #include "hal_batmon.h"
     57          #endif
     58          #include "OnBoard.h"
     59          
     60          /*********************************************************************
     61           * CONSTANTS
     62           */
     63          
     64          #define OSAL_NV_PAGE_SIZE       HAL_FLASH_PAGE_SIZE
     65          #define OSAL_NV_PAGES_USED      HAL_NV_PAGE_CNT
     66          #define OSAL_NV_PAGE_BEG        HAL_NV_PAGE_BEG
     67          #define OSAL_NV_PAGE_END       (OSAL_NV_PAGE_BEG + OSAL_NV_PAGES_USED - 1)
     68          
     69          #define OSAL_NV_ACTIVE          0x00
     70          #define OSAL_NV_ERASED          0xFF
     71          #define OSAL_NV_ERASED_ID       0xFFFF
     72          #define OSAL_NV_ZEROED_ID       0x0000
     73          // Reserve MSB of Id to signal a search for the "old" source copy (new write interrupted/failed.)
     74          #define OSAL_NV_SOURCE_ID       0x8000
     75          
     76          // In case pages 0-1 are ever used, define a null page value.
     77          #define OSAL_NV_PAGE_NULL       0
     78          
     79          // In case item Id 0 is ever used, define a null item value.
     80          #define OSAL_NV_ITEM_NULL       0
     81          
     82          #define OSAL_NV_WORD_SIZE       HAL_FLASH_WORD_SIZE
     83          
     84          #define OSAL_NV_PAGE_HDR_OFFSET 0
     85          
     86          #define OSAL_NV_MAX_HOT         3

   \                                 In  segment XDATA_ROM_C, align 1
     87          static const uint16 hotIds[OSAL_NV_MAX_HOT] = {
   \                     hotIds:
   \   000000   8200         DW 130
   \   000002   3A00         DW 58
   \   000004   3B00         DW 59
     88            ZCD_NV_NWKKEY,
     89            ZCD_NV_NWK_ACTIVE_KEY_INFO,
     90            ZCD_NV_NWK_ALTERN_KEY_INFO,
     91          };
     92          
     93          /*********************************************************************
     94           * MACROS
     95           */
     96          
     97          #if (defined HAL_MCU_CC2530 || defined HAL_MCU_CC2531)
     98          #define OSAL_NV_CHECK_BUS_VOLTAGE  OnBoard_CheckVoltage()
     99          #elif defined HAL_MCU_CC2533
    100          # define  OSAL_NV_CHECK_BUS_VOLTAGE  (HalBatMonRead( HAL_BATMON_MIN_FLASH ))
    101          #else
    102          # warning No implementation of a low Vdd check.
    103          # define  OSAL_NV_CHECK_BUS_VOLTAGE
    104          #endif
    105          
    106          #define OSAL_NV_DATA_SIZE( LEN )                      \
    107            (((LEN) >= ((uint16)(65536UL - OSAL_NV_WORD_SIZE))) ? \
    108                       ((uint16)(65536UL - OSAL_NV_WORD_SIZE))  : \
    109                       ((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE))
    110          
    111          #define OSAL_NV_ITEM_SIZE( LEN )                                         \
    112            (((LEN) >= ((uint16)(65536UL - OSAL_NV_WORD_SIZE - OSAL_NV_HDR_SIZE))) ? \
    113                       ((uint16)(65536UL - OSAL_NV_WORD_SIZE))                     : \
    114            (((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE) + OSAL_NV_HDR_SIZE))
    115          
    116          #define COMPACT_PAGE_CLEANUP( COM_PG ) st ( \
    117            /* In order to recover from a page compaction that is interrupted,\
    118             * the logic in osal_nv_init() depends upon the following order:\
    119             * 1. State of the target of compaction is changed to ePgInUse.\
    120             * 2. Compacted page is erased.\
    121             */\
    122            setPageUse( pgRes, TRUE );  /* Mark the reserve page as being in use. */\
    123            erasePage( (COM_PG) ); \
    124            \
    125            pgRes = (COM_PG);           /* Set the reserve page to be the newly erased page. */\
    126          )
    127          
    128          /*********************************************************************
    129           * TYPEDEFS
    130           */
    131          
    132          typedef struct
    133          {
    134            uint16 id;
    135            uint16 len;   // Enforce Flash-WORD size on len.
    136            uint16 chk;   // Byte-wise checksum of the 'len' data bytes of the item.
    137            uint16 stat;  // Item status.
    138          } osalNvHdr_t;
    139          // Struct member offsets.
    140          #define OSAL_NV_HDR_ID    0
    141          #define OSAL_NV_HDR_LEN   2
    142          #define OSAL_NV_HDR_CHK   4
    143          #define OSAL_NV_HDR_STAT  6
    144          
    145          #define OSAL_NV_HDR_ITEM  2  // Length of any item of a header struct.
    146          #define OSAL_NV_HDR_SIZE  8
    147          #define OSAL_NV_HDR_HALF (OSAL_NV_HDR_SIZE / 2)
    148          
    149          typedef struct
    150          {
    151            uint16 active;
    152            uint16 inUse;
    153            uint16 xfer;
    154            uint16 spare;
    155          } osalNvPgHdr_t;
    156          // Struct member offsets.
    157          #define OSAL_NV_PG_ACTIVE 0
    158          #define OSAL_NV_PG_INUSE  2
    159          #define OSAL_NV_PG_XFER   4
    160          #define OSAL_NV_PG_SPARE  6
    161          
    162          #define OSAL_NV_PAGE_HDR_SIZE  8
    163          #define OSAL_NV_PAGE_HDR_HALF (OSAL_NV_PAGE_HDR_SIZE / 2)
    164          
    165          typedef enum
    166          {
    167            eNvXfer,
    168            eNvZero
    169          } eNvHdrEnum;
    170          
    171          typedef enum
    172          {
    173            ePgActive,
    174            ePgInUse,
    175            ePgXfer,
    176            ePgSpare
    177          } ePgHdrEnum;
    178          
    179          /*********************************************************************
    180           * GLOBAL VARIABLES
    181           */
    182          
    183          #ifndef OAD_KEEP_NV_PAGES
    184          // When NV pages are to remain intact during OAD download,
    185          // the image itself should not include NV pages.
    186          #pragma location="ZIGNV_ADDRESS_SPACE"

   \                                 In  segment ZIGNV_ADDRESS_SPACE, align 1
    187          __no_init uint8 _nvBuf[OSAL_NV_PAGES_USED * OSAL_NV_PAGE_SIZE];
   \                     _nvBuf:
   \   000000                DS 12288
    188          #pragma required=_nvBuf
    189          #endif // OAD_KEEP_NV_PAGES
    190          
    191          /*********************************************************************
    192           * LOCAL VARIABLES
    193           */
    194          
    195          // Offset into the page of the first available erased space.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    196          static uint16 pgOff[OSAL_NV_PAGES_USED];
   \                     pgOff:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
   \   00000C                REQUIRE _nvBuf
    197          
    198          // Count of the bytes lost for the zeroed-out items.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    199          static uint16 pgLost[OSAL_NV_PAGES_USED];
   \                     pgLost:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    200          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    201          static uint8 pgRes;  // Page reserved for item compacting transfer.
   \                     pgRes:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    202          
    203          // Saving ~100 code bytes to move a uint8* parameter/return value from findItem() to a global.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    204          static uint8 findPg;
   \                     findPg:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    205          
    206          // NV page and offsets for hot items.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    207          static uint8 hotPg[OSAL_NV_MAX_HOT];
   \                     hotPg:
   \   000000                DS 3
   \   000003                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    208          static uint16 hotOff[OSAL_NV_MAX_HOT];
   \                     hotOff:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z
    209          
    210          /*********************************************************************
    211           * LOCAL FUNCTIONS
    212           */
    213          
    214          static uint8  initNV( void );
    215          
    216          static void   setPageUse( uint8 pg, uint8 inUse );
    217          static uint16 initPage( uint8 pg, uint16 id, uint8 findDups );
    218          static void   erasePage( uint8 pg );
    219          static uint8  compactPage( uint8 srcPg, uint16 skipId );
    220          
    221          static uint16 findItem( uint16 id );
    222          static uint8  initItem( uint8 flag, uint16 id, uint16 len, void *buf );
    223          static void   setItem( uint8 pg, uint16 offset, eNvHdrEnum stat );
    224          static uint16 setChk( uint8 pg, uint16 offset, uint16 chk );
    225          
    226          static uint16 calcChkB( uint16 len, uint8 *buf );
    227          static uint16 calcChkF( uint8 pg, uint16 offset, uint16 len );
    228          
    229          static void   writeWord( uint8 pg, uint16 offset, uint8 *buf );
    230          static void   writeWordH( uint8 pg, uint16 offset, uint8 *buf );
    231          static void   writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint16 cnt );
    232          static void   writeBuf( uint8 pg, uint16 offset, uint16 len, uint8 *buf );
    233          static void   xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len );
    234          
    235          static uint8  writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag );
    236          static uint8  hotItem(uint16 id);
    237          static void   hotItemUpdate(uint8 pg, uint16 off, uint16 id);
    238          
    239          /*********************************************************************
    240           * @fn      initNV
    241           *
    242           * @brief   Initialize the NV flash pages.
    243           *
    244           * @param   none
    245           *
    246           * @return  TRUE
    247           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    248          static uint8 initNV( void )
   \                     initNV:
    249          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    250            osalNvPgHdr_t pgHdr;
    251            uint8 oldPg = OSAL_NV_PAGE_NULL;
   \   00000A   75..00       MOV       ?V0,#0x0
    252            uint8 findDups = FALSE;
   \   00000D   7F00         MOV       R7,#0x0
    253            uint8 pg;
    254          
    255            pgRes = OSAL_NV_PAGE_NULL;
   \   00000F   90....       MOV       DPTR,#pgRes
   \   000012   E4           CLR       A
   \   000013   F0           MOVX      @DPTR,A
    256          
    257            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   000014   7E79         MOV       R6,#0x79
   \   000016   8011         SJMP      ??initNV_0
    258            {
    259              HalFlashRead(pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr), OSAL_NV_HDR_SIZE);
    260          
    261              if ( pgHdr.active == OSAL_NV_ERASED_ID )
    262              {
    263                if ( pgRes == OSAL_NV_PAGE_NULL )
    264                {
    265                  pgRes = pg;
    266                }
    267                else
    268                {
    269                  setPageUse( pg, TRUE );
    270                }
    271              }
    272              // An Xfer from this page was in progress.
    273              else if ( pgHdr.xfer != OSAL_NV_ERASED_ID )
   \                     ??initNV_1:
   \   000018   7404         MOV       A,#0x4
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   F4           CPL       A
   \   00001F   7003         JNZ       ??initNV_2
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   F4           CPL       A
   \                     ??initNV_2:
   \   000024   6002         JZ        ??initNV_3
    274              {
    275                oldPg = pg;
   \   000026   8E..         MOV       ?V0,R6
    276              }
   \                     ??initNV_3:
   \   000028   0E           INC       R6
   \                     ??initNV_0:
   \   000029   EE           MOV       A,R6
   \   00002A   C3           CLR       C
   \   00002B   947F         SUBB      A,#0x7f
   \   00002D   503F         JNC       ??initNV_4
   \   00002F                ; Setup parameters for call to function HalFlashRead
   \   00002F   75..08       MOV       ?V2,#0x8
   \   000032   8F..         MOV       ?V3,R7
   \   000034   78..         MOV       R0,#?V2
   \   000036   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000039   7402         MOV       A,#0x2
   \   00003B   12....       LCALL     ?XSTACK_DISP102_8
   \   00003E   7A00         MOV       R2,#0x0
   \   000040   7B00         MOV       R3,#0x0
   \   000042   EE           MOV       A,R6
   \   000043   F9           MOV       R1,A
   \   000044   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000047   7402         MOV       A,#0x2
   \   000049   12....       LCALL     ?DEALLOC_XSTACK8
   \   00004C   85..82       MOV       DPL,?XSP + 0
   \   00004F   85..83       MOV       DPH,?XSP + 1
   \   000052   E0           MOVX      A,@DPTR
   \   000053   F4           CPL       A
   \   000054   7003         JNZ       ??initNV_5
   \   000056   A3           INC       DPTR
   \   000057   E0           MOVX      A,@DPTR
   \   000058   F4           CPL       A
   \                     ??initNV_5:
   \   000059   70BD         JNZ       ??initNV_1
   \   00005B   90....       MOV       DPTR,#pgRes
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   7004         JNZ       ??initNV_6
   \   000061   EE           MOV       A,R6
   \   000062   F0           MOVX      @DPTR,A
   \   000063   80C3         SJMP      ??initNV_3
   \                     ??initNV_6:
   \   000065                ; Setup parameters for call to function setPageUse
   \   000065   7A01         MOV       R2,#0x1
   \   000067   EE           MOV       A,R6
   \   000068   F9           MOV       R1,A
   \   000069   12....       LCALL     `??setPageUse::?relay`; Banked call to: setPageUse
   \   00006C   80BA         SJMP      ??initNV_3
    277            }
    278          
    279            // If a page compaction was interrupted before the old page was erased.
    280            if ( oldPg != OSAL_NV_PAGE_NULL )
   \                     ??initNV_4:
   \   00006E   E5..         MOV       A,?V0
   \   000070   90....       MOV       DPTR,#pgRes
   \   000073   6020         JZ        ??initNV_7
    281            {
    282              /* Interrupted compaction before the target of compaction was put in use;
    283               * so erase the target of compaction and start again.
    284               */
    285              if ( pgRes != OSAL_NV_PAGE_NULL )
   \   000075   E0           MOVX      A,@DPTR
   \   000076   6010         JZ        ??initNV_8
    286              {
    287                erasePage( pgRes );
   \   000078                ; Setup parameters for call to function erasePage
   \   000078   E0           MOVX      A,@DPTR
   \   000079   F9           MOV       R1,A
   \   00007A   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
    288                (void)compactPage( oldPg, OSAL_NV_ITEM_NULL );
   \   00007D                ; Setup parameters for call to function compactPage
   \   00007D   7A00         MOV       R2,#0x0
   \   00007F   7B00         MOV       R3,#0x0
   \   000081   A9..         MOV       R1,?V0
   \   000083   12....       LCALL     `??compactPage::?relay`; Banked call to: compactPage
   \   000086   8015         SJMP      ??initNV_9
    289              }
    290              /* Interrupted compaction after the target of compaction was put in use,
    291               * but before the old page was erased; so erase it now and create a new reserve page.
    292               */
    293              else
    294              {
    295                erasePage( oldPg );
   \                     ??initNV_8:
   \   000088                ; Setup parameters for call to function erasePage
   \   000088   A9..         MOV       R1,?V0
   \   00008A   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
    296                pgRes = oldPg;
   \   00008D   E5..         MOV       A,?V0
   \   00008F   90....       MOV       DPTR,#pgRes
   \   000092   F0           MOVX      @DPTR,A
   \   000093   8008         SJMP      ??initNV_9
    297              }
    298            }
    299            else if ( pgRes != OSAL_NV_PAGE_NULL )
   \                     ??initNV_7:
   \   000095   E0           MOVX      A,@DPTR
   \   000096   6005         JZ        ??initNV_9
    300            {
    301              erasePage( pgRes );  // The last page erase could have been interrupted by a power-cycle.
   \   000098                ; Setup parameters for call to function erasePage
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F9           MOV       R1,A
   \   00009A   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
    302            }
    303            /* else if there is no reserve page, COMPACT_PAGE_CLEANUP() must have succeeded to put the old
    304             * reserve page (i.e. the target of the compacted items) into use but got interrupted by a reset
    305             * while trying to erase the page to be compacted. Such a page should only contain duplicate items
    306             * (i.e. all items will be marked 'Xfer') and thus should have the lost count equal to the page
    307             * size less the page header.
    308             */
    309          
    310            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \                     ??initNV_9:
   \   00009D   7E79         MOV       R6,#0x79
   \   00009F   8013         SJMP      ??initNV_10
    311            {
    312              // Calculate page offset and lost bytes - any "old" item triggers an N^2 re-scan from start.
    313              if ( initPage( pg, OSAL_NV_ITEM_NULL, findDups ) != OSAL_NV_ITEM_NULL )
   \                     ??initNV_11:
   \   0000A1                ; Setup parameters for call to function initPage
   \   0000A1   FC           MOV       R4,A
   \   0000A2   7A00         MOV       R2,#0x0
   \   0000A4   7B00         MOV       R3,#0x0
   \   0000A6   EE           MOV       A,R6
   \   0000A7   F9           MOV       R1,A
   \   0000A8   12....       LCALL     `??initPage::?relay`; Banked call to: initPage
   \   0000AB   EA           MOV       A,R2
   \   0000AC   4B           ORL       A,R3
   \   0000AD   6004         JZ        ??initNV_12
    314              {
    315                findDups = TRUE;
   \   0000AF   7F01         MOV       R7,#0x1
    316                pg = (OSAL_NV_PAGE_BEG - 1);  // Pre-decrement so that loop increment will start over at zero.
   \   0000B1   7E78         MOV       R6,#0x78
    317                continue;
    318              }
    319            }
   \                     ??initNV_12:
   \   0000B3   0E           INC       R6
   \                     ??initNV_10:
   \   0000B4   EE           MOV       A,R6
   \   0000B5   C3           CLR       C
   \   0000B6   947F         SUBB      A,#0x7f
   \   0000B8   EF           MOV       A,R7
   \   0000B9   40E6         JC        ??initNV_11
    320          
    321            if (findDups)
   \   0000BB   6016         JZ        ??initNV_13
    322            {
    323              // Final pass to calculate page lost after invalidating duplicate items.
    324              for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   0000BD   7E79         MOV       R6,#0x79
   \   0000BF   800C         SJMP      ??initNV_14
    325              {
    326                (void)initPage( pg, OSAL_NV_ITEM_NULL, FALSE );
   \                     ??initNV_15:
   \   0000C1                ; Setup parameters for call to function initPage
   \   0000C1   7C00         MOV       R4,#0x0
   \   0000C3   7A00         MOV       R2,#0x0
   \   0000C5   7B00         MOV       R3,#0x0
   \   0000C7   EE           MOV       A,R6
   \   0000C8   F9           MOV       R1,A
   \   0000C9   12....       LCALL     `??initPage::?relay`; Banked call to: initPage
    327              }
   \   0000CC   0E           INC       R6
   \                     ??initNV_14:
   \   0000CD   EE           MOV       A,R6
   \   0000CE   C3           CLR       C
   \   0000CF   947F         SUBB      A,#0x7f
   \   0000D1   40EE         JC        ??initNV_15
    328            }
    329          
    330            if ( pgRes == OSAL_NV_PAGE_NULL )
   \                     ??initNV_13:
   \   0000D3   90....       MOV       DPTR,#pgRes
   \   0000D6   E0           MOVX      A,@DPTR
   \   0000D7   7056         JNZ       ??initNV_16
    331            {
    332              uint8 idx, mostLost = 0;
   \   0000D9   7E00         MOV       R6,#0x0
    333          
    334              for ( idx = 0; idx < OSAL_NV_PAGES_USED; idx++ )
   \   0000DB   7C00         MOV       R4,#0x0
   \   0000DD   801C         SJMP      ??initNV_17
    335              {
    336                // Is this the page that was compacted?
    337                if (pgLost[idx] == (OSAL_NV_PAGE_SIZE - OSAL_NV_PAGE_HDR_SIZE))
    338                {
    339                  mostLost = idx;
    340                  break;
    341                }
    342                /* This check is not expected to be necessary because the above test should always succeed
    343                 * with an early loop exit.
    344                 */
    345                else if (pgLost[idx] > pgLost[mostLost])
   \                     ??initNV_18:
   \   0000DF   EE           MOV       A,R6
   \   0000E0   25E0         ADD       A,0xE0 /* A   */
   \   0000E2   F8           MOV       R0,A
   \   0000E3   E4           CLR       A
   \   0000E4   33           RLC       A
   \   0000E5   F9           MOV       R1,A
   \   0000E6   74..         MOV       A,#pgLost & 0xff
   \   0000E8   28           ADD       A,R0
   \   0000E9   F582         MOV       DPL,A
   \   0000EB   74..         MOV       A,#(pgLost >> 8) & 0xff
   \   0000ED   39           ADDC      A,R1
   \   0000EE   F583         MOV       DPH,A
   \   0000F0   C3           CLR       C
   \   0000F1   E0           MOVX      A,@DPTR
   \   0000F2   9A           SUBB      A,R2
   \   0000F3   A3           INC       DPTR
   \   0000F4   E0           MOVX      A,@DPTR
   \   0000F5   9B           SUBB      A,R3
   \   0000F6   5002         JNC       ??initNV_19
    346                {
    347                  mostLost = idx;
   \   0000F8   EC           MOV       A,R4
   \   0000F9   FE           MOV       R6,A
    348                }
   \                     ??initNV_19:
   \   0000FA   0C           INC       R4
   \                     ??initNV_17:
   \   0000FB   EC           MOV       A,R4
   \   0000FC   C3           CLR       C
   \   0000FD   9406         SUBB      A,#0x6
   \   0000FF   5022         JNC       ??initNV_20
   \   000101   EC           MOV       A,R4
   \   000102   25E0         ADD       A,0xE0 /* A   */
   \   000104   F8           MOV       R0,A
   \   000105   E4           CLR       A
   \   000106   33           RLC       A
   \   000107   F9           MOV       R1,A
   \   000108   74..         MOV       A,#pgLost & 0xff
   \   00010A   28           ADD       A,R0
   \   00010B   F582         MOV       DPL,A
   \   00010D   74..         MOV       A,#(pgLost >> 8) & 0xff
   \   00010F   39           ADDC      A,R1
   \   000110   F583         MOV       DPH,A
   \   000112   E0           MOVX      A,@DPTR
   \   000113   FA           MOV       R2,A
   \   000114   A3           INC       DPTR
   \   000115   E0           MOVX      A,@DPTR
   \   000116   FB           MOV       R3,A
   \   000117   74F8         MOV       A,#-0x8
   \   000119   6A           XRL       A,R2
   \   00011A   7003         JNZ       ??initNV_21
   \   00011C   7407         MOV       A,#0x7
   \   00011E   6B           XRL       A,R3
   \                     ??initNV_21:
   \   00011F   70BE         JNZ       ??initNV_18
   \   000121   EC           MOV       A,R4
   \   000122   FE           MOV       R6,A
    349              }
    350          
    351              pgRes = mostLost + OSAL_NV_PAGE_BEG;
   \                     ??initNV_20:
   \   000123   7479         MOV       A,#0x79
   \   000125   2E           ADD       A,R6
   \   000126   90....       MOV       DPTR,#pgRes
   \   000129   F0           MOVX      @DPTR,A
    352              erasePage( pgRes );  // The last page erase had been interrupted by a power-cycle.
   \   00012A                ; Setup parameters for call to function erasePage
   \   00012A   E0           MOVX      A,@DPTR
   \   00012B   F9           MOV       R1,A
   \   00012C   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
    353            }
    354          
    355            return TRUE;
   \                     ??initNV_16:
   \   00012F   7901         MOV       R1,#0x1
   \   000131   7408         MOV       A,#0x8
   \   000133   12....       LCALL     ?DEALLOC_XSTACK8
   \   000136   7F04         MOV       R7,#0x4
   \   000138   02....       LJMP      ?BANKED_LEAVE_XDATA
    356          }
    357          
    358          /*********************************************************************
    359           * @fn      setPageUse
    360           *
    361           * @brief   Set page header active/inUse state according to 'inUse'.
    362           *
    363           * @param   pg - Valid NV page to verify and init.
    364           * @param   inUse - Boolean TRUE if inUse, FALSE if only active.
    365           *
    366           * @return  none
    367           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    368          static void setPageUse( uint8 pg, uint8 inUse )
   \                     setPageUse:
    369          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    370            osalNvPgHdr_t pgHdr;
    371          
    372            pgHdr.active = OSAL_NV_ZEROED_ID;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
    373          
    374            if ( inUse )
   \   000014   EA           MOV       A,R2
   \   000015   6008         JZ        ??setPageUse_0
    375            {
    376              pgHdr.inUse = OSAL_NV_ZEROED_ID;
   \   000017   7402         MOV       A,#0x2
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   E4           CLR       A
   \   00001D   8007         SJMP      ??setPageUse_1
    377            }
    378            else
    379            {
    380              pgHdr.inUse = OSAL_NV_ERASED_ID;
   \                     ??setPageUse_0:
   \   00001F   7402         MOV       A,#0x2
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   74FF         MOV       A,#-0x1
   \                     ??setPageUse_1:
   \   000026   F0           MOVX      @DPTR,A
   \   000027   A3           INC       DPTR
   \   000028   F0           MOVX      @DPTR,A
    381            }
    382          
    383            writeWord( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8*)(&pgHdr) );
   \   000029                ; Setup parameters for call to function writeWord
   \   000029   AC..         MOV       R4,?XSP + 0
   \   00002B   AD..         MOV       R5,?XSP + 1
   \   00002D   7A00         MOV       R2,#0x0
   \   00002F   7B00         MOV       R3,#0x0
   \   000031   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
    384          }
   \   000034   7408         MOV       A,#0x8
   \   000036   12....       LCALL     ?DEALLOC_XSTACK8
   \   000039   7F01         MOV       R7,#0x1
   \   00003B   02....       LJMP      ?BANKED_LEAVE_XDATA
    385          
    386          /*********************************************************************
    387           * @fn      initPage
    388           *
    389           * @brief   Walk the page items; calculate checksums, lost bytes & page offset.
    390           *
    391           * @param   pg - Valid NV page to verify and init.
    392           * @param   id - Valid NV item Id to use function as a "findItem".
    393           *               If set to NULL then just perform the page initialization.
    394           * @param   findDups - TRUE on recursive call from initNV() to find and zero-out duplicate items
    395           *                     left from a write that is interrupted by a reset/power-cycle.
    396           *                     FALSE otherwise.
    397           *
    398           * @return  If 'id' is non-NULL and good checksums are found, return the offset
    399           *          of the data corresponding to item Id; else OSAL_NV_ITEM_NULL.
    400           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    401          static uint16 initPage( uint8 pg, uint16 id, uint8 findDups )
   \                     initPage:
    402          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V4,R1
   \   00000C   8A..         MOV       ?V6,R2
   \   00000E   8B..         MOV       ?V7,R3
   \   000010   8C..         MOV       ?V5,R4
    403            uint16 offset = OSAL_NV_PAGE_HDR_SIZE;
   \   000012   75..08       MOV       ?V0,#0x8
   \   000015   75..00       MOV       ?V1,#0x0
    404            uint16 sz, lost = 0;
   \   000018   75..00       MOV       ?V2,#0x0
   \   00001B   75..00       MOV       ?V3,#0x0
    405            osalNvHdr_t hdr;
    406          
    407            do
    408            {
    409              HalFlashRead(pg, offset, (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
   \                     ??initPage_0:
   \   00001E                ; Setup parameters for call to function HalFlashRead
   \   00001E   75..08       MOV       ?V8,#0x8
   \   000021   75..00       MOV       ?V9,#0x0
   \   000024   78..         MOV       R0,#?V8
   \   000026   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000029   7402         MOV       A,#0x2
   \   00002B   12....       LCALL     ?XSTACK_DISP102_8
   \   00002E   AA..         MOV       R2,?V0
   \   000030   AB..         MOV       R3,?V1
   \   000032   A9..         MOV       R1,?V4
   \   000034   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000037   7402         MOV       A,#0x2
   \   000039   12....       LCALL     ?DEALLOC_XSTACK8
    410          
    411              if ( hdr.id == OSAL_NV_ERASED_ID )
   \   00003C   85..82       MOV       DPL,?XSP + 0
   \   00003F   85..83       MOV       DPH,?XSP + 1
   \   000042   E0           MOVX      A,@DPTR
   \   000043   F4           CPL       A
   \   000044   7003         JNZ       ??initPage_1
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   F4           CPL       A
   \                     ??initPage_1:
   \   000049   7003         JNZ       $+5
   \   00004B   02....       LJMP      ??initPage_2 & 0xFFFF
    412              {
    413                break;
    414              }
    415          
    416              // Get the actual size in bytes which is the ceiling(hdr.len)
    417              sz = OSAL_NV_DATA_SIZE( hdr.len );
   \   00004E   7402         MOV       A,#0x2
   \   000050   12....       LCALL     ?XSTACK_DISP0_8
   \   000053   E0           MOVX      A,@DPTR
   \   000054   FC           MOV       R4,A
   \   000055   A3           INC       DPTR
   \   000056   E0           MOVX      A,@DPTR
   \   000057   FD           MOV       R5,A
   \   000058   C3           CLR       C
   \   000059   EC           MOV       A,R4
   \   00005A   94FC         SUBB      A,#-0x4
   \   00005C   ED           MOV       A,R5
   \   00005D   94FF         SUBB      A,#-0x1
   \   00005F   4006         JC        ??initPage_3
   \   000061   7EFC         MOV       R6,#-0x4
   \   000063   7FFF         MOV       R7,#-0x1
   \   000065   800D         SJMP      ??initPage_4
   \                     ??initPage_3:
   \   000067   EC           MOV       A,R4
   \   000068   2403         ADD       A,#0x3
   \   00006A   F8           MOV       R0,A
   \   00006B   E4           CLR       A
   \   00006C   3D           ADDC      A,R5
   \   00006D   F9           MOV       R1,A
   \   00006E   E8           MOV       A,R0
   \   00006F   54FC         ANL       A,#0xfc
   \   000071   FE           MOV       R6,A
   \   000072   E9           MOV       A,R1
   \   000073   FF           MOV       R7,A
    418          
    419              // A bad 'len' write has blown away the rest of the page.
    420              if (sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - offset))
   \                     ??initPage_4:
   \   000074   74F8         MOV       A,#-0x8
   \   000076   C3           CLR       C
   \   000077   95..         SUBB      A,?V0
   \   000079   F8           MOV       R0,A
   \   00007A   7407         MOV       A,#0x7
   \   00007C   95..         SUBB      A,?V1
   \   00007E   F9           MOV       R1,A
   \   00007F   C3           CLR       C
   \   000080   E8           MOV       A,R0
   \   000081   9E           SUBB      A,R6
   \   000082   E9           MOV       A,R1
   \   000083   9F           SUBB      A,R7
   \   000084   5020         JNC       ??initPage_5
    421              {
    422                lost += (OSAL_NV_PAGE_SIZE - offset);
   \   000086   E5..         MOV       A,?V2
   \   000088   2400         ADD       A,#0x0
   \   00008A   E5..         MOV       A,?V3
   \   00008C   3408         ADDC      A,#0x8
   \   00008E   F5..         MOV       ?V3,A
   \   000090   C3           CLR       C
   \   000091   E5..         MOV       A,?V2
   \   000093   95..         SUBB      A,?V0
   \   000095   F5..         MOV       ?V2,A
   \   000097   E5..         MOV       A,?V3
   \   000099   95..         SUBB      A,?V1
   \   00009B   F5..         MOV       ?V3,A
    423                offset = OSAL_NV_PAGE_SIZE;
   \   00009D   75..00       MOV       ?V0,#0x0
   \   0000A0   75..08       MOV       ?V1,#0x8
    424                break;
   \   0000A3   02....       LJMP      ??initPage_2 & 0xFFFF
    425              }
    426          
    427              offset += OSAL_NV_HDR_SIZE;
   \                     ??initPage_5:
   \   0000A6   E5..         MOV       A,?V0
   \   0000A8   2408         ADD       A,#0x8
   \   0000AA   F5..         MOV       ?V0,A
   \   0000AC   E4           CLR       A
   \   0000AD   35..         ADDC      A,?V1
   \   0000AF   F5..         MOV       ?V1,A
    428          
    429              if ( hdr.id != OSAL_NV_ZEROED_ID )
   \   0000B1   85..82       MOV       DPL,?XSP + 0
   \   0000B4   85..83       MOV       DPH,?XSP + 1
   \   0000B7   E0           MOVX      A,@DPTR
   \   0000B8   F8           MOV       R0,A
   \   0000B9   A3           INC       DPTR
   \   0000BA   E0           MOVX      A,@DPTR
   \   0000BB   F9           MOV       R1,A
   \   0000BC   E8           MOV       A,R0
   \   0000BD   49           ORL       A,R1
   \   0000BE   7003         JNZ       $+5
   \   0000C0   02....       LJMP      ??initPage_6 & 0xFFFF
    430              {
    431                /* This trick allows function to do double duty for findItem() without
    432                 * compromising its essential functionality at powerup initialization.
    433                 */
    434                if ( id != OSAL_NV_ITEM_NULL )
   \   0000C3   E5..         MOV       A,?V6
   \   0000C5   45..         ORL       A,?V7
   \   0000C7   604C         JZ        ??initPage_7
    435                {
    436                  /* This trick allows asking to find the old/transferred item in case
    437                   * of a successful new item write that gets interrupted before the
    438                   * old item can be zeroed out.
    439                   */
    440                  if ( (id & 0x7fff) == hdr.id )
   \   0000C9   A8..         MOV       R0,?V6
   \   0000CB   E5..         MOV       A,?V7
   \   0000CD   547F         ANL       A,#0x7f
   \   0000CF   F9           MOV       R1,A
   \   0000D0   85..82       MOV       DPL,?XSP + 0
   \   0000D3   85..83       MOV       DPH,?XSP + 1
   \   0000D6   E0           MOVX      A,@DPTR
   \   0000D7   68           XRL       A,R0
   \   0000D8   7003         JNZ       ??initPage_8
   \   0000DA   A3           INC       DPTR
   \   0000DB   E0           MOVX      A,@DPTR
   \   0000DC   69           XRL       A,R1
   \                     ??initPage_8:
   \   0000DD   6003         JZ        $+5
   \   0000DF   02....       LJMP      ??initPage_9 & 0xFFFF
    441                  {
    442                    if ( (((id & OSAL_NV_SOURCE_ID) == 0) && (hdr.stat == OSAL_NV_ERASED_ID)) ||
    443                         (((id & OSAL_NV_SOURCE_ID) != 0) && (hdr.stat != OSAL_NV_ERASED_ID)) )
   \   0000E2   E5..         MOV       A,?V7
   \   0000E4   5480         ANL       A,#0x80
   \   0000E6   F9           MOV       R1,A
   \   0000E7   700E         JNZ       ??initPage_10
   \   0000E9   7406         MOV       A,#0x6
   \   0000EB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   F4           CPL       A
   \   0000F0   7003         JNZ       ??initPage_11
   \   0000F2   A3           INC       DPTR
   \   0000F3   E0           MOVX      A,@DPTR
   \   0000F4   F4           CPL       A
   \                     ??initPage_11:
   \   0000F5   6017         JZ        ??initPage_12
   \                     ??initPage_10:
   \   0000F7   E9           MOV       A,R1
   \   0000F8   7003         JNZ       $+5
   \   0000FA   02....       LJMP      ??initPage_9 & 0xFFFF
   \   0000FD   7406         MOV       A,#0x6
   \   0000FF   12....       LCALL     ?XSTACK_DISP0_8
   \   000102   E0           MOVX      A,@DPTR
   \   000103   F4           CPL       A
   \   000104   7003         JNZ       ??initPage_13
   \   000106   A3           INC       DPTR
   \   000107   E0           MOVX      A,@DPTR
   \   000108   F4           CPL       A
   \                     ??initPage_13:
   \   000109   7003         JNZ       $+5
   \   00010B   02....       LJMP      ??initPage_9 & 0xFFFF
    444                    {
    445                      return offset;
   \                     ??initPage_12:
   \   00010E   AA..         MOV       R2,?V0
   \   000110   AB..         MOV       R3,?V1
   \   000112   02....       LJMP      ??initPage_14 & 0xFFFF
    446                    }
    447                  }
    448                }
    449                // When invoked from the osal_nv_init(), verify checksums and find & zero any duplicates.
    450                else
    451                {
    452                  if ( hdr.chk == calcChkF( pg, offset, hdr.len ) )
   \                     ??initPage_7:
   \   000115                ; Setup parameters for call to function calcChkF
   \   000115   AA..         MOV       R2,?V0
   \   000117   AB..         MOV       R3,?V1
   \   000119   A9..         MOV       R1,?V4
   \   00011B   12....       LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
   \   00011E   8A..         MOV       ?V8,R2
   \   000120   8B..         MOV       ?V9,R3
   \   000122   A8..         MOV       R0,?V8
   \   000124   A9..         MOV       R1,?V9
   \   000126   7404         MOV       A,#0x4
   \   000128   12....       LCALL     ?XSTACK_DISP0_8
   \   00012B   E0           MOVX      A,@DPTR
   \   00012C   68           XRL       A,R0
   \   00012D   7003         JNZ       ??initPage_15
   \   00012F   A3           INC       DPTR
   \   000130   E0           MOVX      A,@DPTR
   \   000131   69           XRL       A,R1
   \                     ??initPage_15:
   \   000132   7048         JNZ       ??initPage_16
    453                  {
    454                    if ( findDups )
   \   000134   7406         MOV       A,#0x6
   \   000136   12....       LCALL     ?XSTACK_DISP0_8
   \   000139   E0           MOVX      A,@DPTR
   \   00013A   F8           MOV       R0,A
   \   00013B   A3           INC       DPTR
   \   00013C   E0           MOVX      A,@DPTR
   \   00013D   F9           MOV       R1,A
   \   00013E   E5..         MOV       A,?V5
   \   000140   602A         JZ        ??initPage_17
    455                    {
    456                      if ( hdr.stat == OSAL_NV_ERASED_ID )
   \   000142   74FF         MOV       A,#-0x1
   \   000144   68           XRL       A,R0
   \   000145   7003         JNZ       ??initPage_18
   \   000147   74FF         MOV       A,#-0x1
   \   000149   69           XRL       A,R1
   \                     ??initPage_18:
   \   00014A   704C         JNZ       ??initPage_9
    457                      {
    458                        /* The trick of setting the MSB of the item Id causes the logic
    459                         * immediately above to return a valid page only if the header 'stat'
    460                         * indicates that it was the older item being transferred.
    461                         */
    462                        uint16 off = findItem( (hdr.id | OSAL_NV_SOURCE_ID) );
   \   00014C                ; Setup parameters for call to function findItem
   \   00014C   85..82       MOV       DPL,?XSP + 0
   \   00014F   85..83       MOV       DPH,?XSP + 1
   \   000152   E0           MOVX      A,@DPTR
   \   000153   FA           MOV       R2,A
   \   000154   A3           INC       DPTR
   \   000155   E0           MOVX      A,@DPTR
   \   000156   4480         ORL       A,#0x80
   \   000158   FB           MOV       R3,A
   \   000159   12....       LCALL     `??findItem::?relay`; Banked call to: findItem
    463          
    464                        if ( off != OSAL_NV_ITEM_NULL )
   \   00015C   EA           MOV       A,R2
   \   00015D   4B           ORL       A,R3
   \   00015E   6038         JZ        ??initPage_9
    465                        {
    466                          setItem( findPg, off, eNvZero );  // Mark old duplicate as invalid.
   \   000160                ; Setup parameters for call to function setItem
   \   000160   7C01         MOV       R4,#0x1
   \   000162   90....       MOV       DPTR,#findPg
   \   000165   E0           MOVX      A,@DPTR
   \   000166   F9           MOV       R1,A
   \   000167   12....       LCALL     `??setItem::?relay`; Banked call to: setItem
   \   00016A   802C         SJMP      ??initPage_9
    467                        }
    468                      }
    469                    }
    470                    // Any "old" item immediately exits and triggers the N^2 exhaustive initialization.
    471                    else if ( hdr.stat != OSAL_NV_ERASED_ID )
   \                     ??initPage_17:
   \   00016C   74FF         MOV       A,#-0x1
   \   00016E   68           XRL       A,R0
   \   00016F   7003         JNZ       ??initPage_19
   \   000171   74FF         MOV       A,#-0x1
   \   000173   69           XRL       A,R1
   \                     ??initPage_19:
   \   000174   6022         JZ        ??initPage_9
    472                    {
    473                      return OSAL_NV_ERASED_ID;
   \   000176   7AFF         MOV       R2,#-0x1
   \   000178   7BFF         MOV       R3,#-0x1
   \   00017A   8062         SJMP      ??initPage_14
    474                    }
    475                  }
    476                  else
    477                  {
    478                    setItem( pg, offset, eNvZero );  // Mark bad checksum as invalid.
   \                     ??initPage_16:
   \   00017C                ; Setup parameters for call to function setItem
   \   00017C   7C01         MOV       R4,#0x1
   \   00017E   AA..         MOV       R2,?V0
   \   000180   AB..         MOV       R3,?V1
   \   000182   A9..         MOV       R1,?V4
   \   000184   12....       LCALL     `??setItem::?relay`; Banked call to: setItem
    479                    lost += (OSAL_NV_HDR_SIZE + sz);
    480                  }
    481                }
    482              }
    483              else
    484              {
    485                lost += (OSAL_NV_HDR_SIZE + sz);
   \                     ??initPage_6:
   \   000187   EE           MOV       A,R6
   \   000188   2408         ADD       A,#0x8
   \   00018A   F8           MOV       R0,A
   \   00018B   E4           CLR       A
   \   00018C   3F           ADDC      A,R7
   \   00018D   F9           MOV       R1,A
   \   00018E   E5..         MOV       A,?V2
   \   000190   28           ADD       A,R0
   \   000191   F5..         MOV       ?V2,A
   \   000193   E5..         MOV       A,?V3
   \   000195   39           ADDC      A,R1
   \   000196   F5..         MOV       ?V3,A
    486              }
    487              offset += sz;
   \                     ??initPage_9:
   \   000198   E5..         MOV       A,?V0
   \   00019A   2E           ADD       A,R6
   \   00019B   F5..         MOV       ?V0,A
   \   00019D   E5..         MOV       A,?V1
   \   00019F   3F           ADDC      A,R7
   \   0001A0   F5..         MOV       ?V1,A
    488          
    489            } while (offset < (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE));
   \   0001A2   C3           CLR       C
   \   0001A3   E5..         MOV       A,?V0
   \   0001A5   94F8         SUBB      A,#-0x8
   \   0001A7   E5..         MOV       A,?V1
   \   0001A9   9407         SUBB      A,#0x7
   \   0001AB   5003         JNC       $+5
   \   0001AD   02....       LJMP      ??initPage_0 & 0xFFFF
    490          
    491            pgOff[pg - OSAL_NV_PAGE_BEG] = offset;
   \                     ??initPage_2:
   \   0001B0   A8..         MOV       R0,?V4
   \   0001B2   E8           MOV       A,R0
   \   0001B3   28           ADD       A,R0
   \   0001B4   F8           MOV       R0,A
   \   0001B5   E4           CLR       A
   \   0001B6   33           RLC       A
   \   0001B7   F9           MOV       R1,A
   \   0001B8   74..         MOV       A,#(pgOff + 14) & 0xff
   \   0001BA   28           ADD       A,R0
   \   0001BB   F582         MOV       DPL,A
   \   0001BD   74..         MOV       A,#((pgOff - 242) >> 8) & 0xff
   \   0001BF   39           ADDC      A,R1
   \   0001C0   F583         MOV       DPH,A
   \   0001C2   E5..         MOV       A,?V0
   \   0001C4   F0           MOVX      @DPTR,A
   \   0001C5   A3           INC       DPTR
   \   0001C6   E5..         MOV       A,?V1
   \   0001C8   F0           MOVX      @DPTR,A
    492            pgLost[pg - OSAL_NV_PAGE_BEG] = lost;
   \   0001C9   74..         MOV       A,#(pgLost + 14) & 0xff
   \   0001CB   28           ADD       A,R0
   \   0001CC   F582         MOV       DPL,A
   \   0001CE   74..         MOV       A,#((pgLost - 242) >> 8) & 0xff
   \   0001D0   39           ADDC      A,R1
   \   0001D1   F583         MOV       DPH,A
   \   0001D3   E5..         MOV       A,?V2
   \   0001D5   F0           MOVX      @DPTR,A
   \   0001D6   A3           INC       DPTR
   \   0001D7   E5..         MOV       A,?V3
   \   0001D9   F0           MOVX      @DPTR,A
    493          
    494            return OSAL_NV_ITEM_NULL;
   \   0001DA   7A00         MOV       R2,#0x0
   \   0001DC   7B00         MOV       R3,#0x0
   \                     ??initPage_14:
   \   0001DE   7408         MOV       A,#0x8
   \   0001E0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001E3   7F0A         MOV       R7,#0xa
   \   0001E5   02....       LJMP      ?BANKED_LEAVE_XDATA
    495          }
    496          
    497          /*********************************************************************
    498           * @fn      erasePage
    499           *
    500           * @brief   Erases a page in Flash.
    501           *
    502           * @param   pg - Valid NV page to erase.
    503           *
    504           * @return  none
    505           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    506          static void erasePage( uint8 pg )
   \                     erasePage:
    507          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    508            HalFlashErase(pg);
   \   000007                ; Setup parameters for call to function HalFlashErase
   \   000007   12....       LCALL     `??HalFlashErase::?relay`; Banked call to: HalFlashErase
    509          
    510            pgOff[pg - OSAL_NV_PAGE_BEG] = OSAL_NV_PAGE_HDR_SIZE;
   \   00000A   EE           MOV       A,R6
   \   00000B   2E           ADD       A,R6
   \   00000C   F8           MOV       R0,A
   \   00000D   E4           CLR       A
   \   00000E   33           RLC       A
   \   00000F   F9           MOV       R1,A
   \   000010   74..         MOV       A,#(pgOff + 14) & 0xff
   \   000012   28           ADD       A,R0
   \   000013   F582         MOV       DPL,A
   \   000015   74..         MOV       A,#((pgOff - 242) >> 8) & 0xff
   \   000017   39           ADDC      A,R1
   \   000018   F583         MOV       DPH,A
   \   00001A   7408         MOV       A,#0x8
   \   00001C   F0           MOVX      @DPTR,A
   \   00001D   A3           INC       DPTR
   \   00001E   E4           CLR       A
   \   00001F   F0           MOVX      @DPTR,A
    511            pgLost[pg - OSAL_NV_PAGE_BEG] = 0;
   \   000020   74..         MOV       A,#(pgLost + 14) & 0xff
   \   000022   28           ADD       A,R0
   \   000023   F582         MOV       DPL,A
   \   000025   74..         MOV       A,#((pgLost - 242) >> 8) & 0xff
   \   000027   39           ADDC      A,R1
   \   000028   F583         MOV       DPH,A
   \   00002A   E4           CLR       A
   \   00002B   F0           MOVX      @DPTR,A
   \   00002C   A3           INC       DPTR
   \   00002D   F0           MOVX      @DPTR,A
    512          }
   \   00002E   7F01         MOV       R7,#0x1
   \   000030   02....       LJMP      ?BANKED_LEAVE_XDATA
    513          
    514          /*********************************************************************
    515           * @fn      compactPage
    516           *
    517           * @brief   Compacts the page specified.
    518           *
    519           * @param   srcPg - Valid NV page to erase.
    520           * @param   skipId - Item Id to not compact.
    521           *
    522           * @return  TRUE if valid items from 'srcPg' are successully compacted onto the 'pgRes';
    523           *          FALSE otherwise.
    524           *          Note that on a failure, this could loop, re-erasing the 'pgRes' and re-compacting with
    525           *          the risk of infinitely looping on HAL flash failure.
    526           *          Worst case scenario: HAL flash starts failing in general, perhaps low Vdd?
    527           *          All page compactions will fail which will cause all osal_nv_write() calls to return
    528           *          NV_OPER_FAILED.
    529           *          Eventually, all pages in use may also be in the state of "pending compaction" where
    530           *          the page header member OSAL_NV_PG_XFER is zeroed out.
    531           *          During this "HAL flash brown-out", the code will run and OTA should work (until low Vdd
    532           *          causes an actual chip brown-out, of course.) Although no new NV items will be created
    533           *          or written, the last value written with a return value of SUCCESS can continue to be
    534           *          read successfully.
    535           *          If eventually HAL flash starts working again, all of the pages marked as
    536           *          "pending compaction" may or may not be eventually compacted. But, initNV() will
    537           *          deterministically clean-up one page pending compaction per power-cycle
    538           *          (if HAL flash is working.) Nevertheless, one erased reserve page will be maintained
    539           *          through such a scenario.
    540           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    541          static uint8 compactPage( uint8 srcPg, uint16 skipId )
   \                     compactPage:
    542          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
   \   00000C   8A..         MOV       ?V2,R2
   \   00000E   8B..         MOV       ?V3,R3
    543            uint16 srcOff;
    544            uint8 rtrn;
    545          
    546            // To minimize code size, only check for a clean page here where it's absolutely required.
    547            for (srcOff = 0; srcOff < OSAL_NV_PAGE_SIZE; srcOff++)
   \   000010   7E00         MOV       R6,#0x0
   \   000012   7F00         MOV       R7,#0x0
   \   000014   8005         SJMP      ??compactPage_0
   \                     ??compactPage_1:
   \   000016   0E           INC       R6
   \   000017   EE           MOV       A,R6
   \   000018   7001         JNZ       ??compactPage_0
   \   00001A   0F           INC       R7
   \                     ??compactPage_0:
   \   00001B   C3           CLR       C
   \   00001C   EF           MOV       A,R7
   \   00001D   9408         SUBB      A,#0x8
   \   00001F   5038         JNC       ??compactPage_2
    548            {
    549              HalFlashRead(pgRes, srcOff, &rtrn, 1);
   \   000021                ; Setup parameters for call to function HalFlashRead
   \   000021   75..01       MOV       ?V4,#0x1
   \   000024   75..00       MOV       ?V5,#0x0
   \   000027   78..         MOV       R0,#?V4
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   7402         MOV       A,#0x2
   \   00002E   12....       LCALL     ?XSTACK_DISP102_8
   \   000031   EE           MOV       A,R6
   \   000032   FA           MOV       R2,A
   \   000033   EF           MOV       A,R7
   \   000034   FB           MOV       R3,A
   \   000035   90....       MOV       DPTR,#pgRes
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F9           MOV       R1,A
   \   00003A   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   00003D   7402         MOV       A,#0x2
   \   00003F   12....       LCALL     ?DEALLOC_XSTACK8
    550              if (rtrn != OSAL_NV_ERASED)
   \   000042   85..82       MOV       DPL,?XSP + 0
   \   000045   85..83       MOV       DPH,?XSP + 1
   \   000048   E0           MOVX      A,@DPTR
   \   000049   F4           CPL       A
   \   00004A   60CA         JZ        ??compactPage_1
    551              {
    552                erasePage(pgRes);
   \   00004C                ; Setup parameters for call to function erasePage
   \   00004C   90....       MOV       DPTR,#pgRes
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   F9           MOV       R1,A
   \   000051   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
    553                return FALSE;
   \   000054   7900         MOV       R1,#0x0
   \   000056   02....       LJMP      ??compactPage_3 & 0xFFFF
    554              }
    555            }
    556          
    557            srcOff = OSAL_NV_PAGE_HDR_SIZE;
   \                     ??compactPage_2:
   \   000059   7E08         MOV       R6,#0x8
   \   00005B   7F00         MOV       R7,#0x0
    558            rtrn = TRUE;
   \   00005D   85..82       MOV       DPL,?XSP + 0
   \   000060   85..83       MOV       DPH,?XSP + 1
   \   000063   7401         MOV       A,#0x1
   \   000065   F0           MOVX      @DPTR,A
   \   000066   02....       LJMP      ??compactPage_4 & 0xFFFF
    559          
    560            while ( srcOff < (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE ) )
    561            {
    562              osalNvHdr_t hdr;
    563              uint16 sz, dstOff = pgOff[pgRes-OSAL_NV_PAGE_BEG];
    564          
    565              HalFlashRead(srcPg, srcOff, (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
    566          
    567              if ( hdr.id == OSAL_NV_ERASED_ID )
    568              {
    569                break;
    570              }
    571          
    572              // Get the actual size in bytes which is the ceiling(hdr.len)
    573              sz = OSAL_NV_DATA_SIZE( hdr.len );
   \                     ??compactPage_5:
   \   000069   EC           MOV       A,R4
   \   00006A   2403         ADD       A,#0x3
   \   00006C   F8           MOV       R0,A
   \   00006D   E4           CLR       A
   \   00006E   3D           ADDC      A,R5
   \   00006F   F9           MOV       R1,A
   \   000070   E8           MOV       A,R0
   \   000071   54FC         ANL       A,#0xfc
   \   000073   F5..         MOV       ?V4,A
   \   000075   E9           MOV       A,R1
   \   000076   F5..         MOV       ?V5,A
    574          
    575              if ( sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - srcOff) )
   \                     ??compactPage_6:
   \   000078   74F8         MOV       A,#-0x8
   \   00007A   C3           CLR       C
   \   00007B   9E           SUBB      A,R6
   \   00007C   F8           MOV       R0,A
   \   00007D   7407         MOV       A,#0x7
   \   00007F   9F           SUBB      A,R7
   \   000080   F9           MOV       R1,A
   \   000081   C3           CLR       C
   \   000082   E8           MOV       A,R0
   \   000083   95..         SUBB      A,?V4
   \   000085   E9           MOV       A,R1
   \   000086   95..         SUBB      A,?V5
   \   000088   5003         JNC       $+5
   \   00008A   02....       LJMP      ??compactPage_7 & 0xFFFF
    576              {
    577                break;
    578              }
    579          
    580              if ( sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - dstOff) )
   \   00008D   74F8         MOV       A,#-0x8
   \   00008F   C3           CLR       C
   \   000090   95..         SUBB      A,?V6
   \   000092   F8           MOV       R0,A
   \   000093   7407         MOV       A,#0x7
   \   000095   95..         SUBB      A,?V7
   \   000097   F9           MOV       R1,A
   \   000098   C3           CLR       C
   \   000099   E8           MOV       A,R0
   \   00009A   95..         SUBB      A,?V4
   \   00009C   E9           MOV       A,R1
   \   00009D   95..         SUBB      A,?V5
   \   00009F   5003         JNC       $+5
   \   0000A1   02....       LJMP      ??compactPage_8 & 0xFFFF
    581              {
    582                rtrn = FALSE;
    583                break;
    584              }
    585          
    586              srcOff += OSAL_NV_HDR_SIZE;
   \   0000A4   EE           MOV       A,R6
   \   0000A5   2408         ADD       A,#0x8
   \   0000A7   FE           MOV       R6,A
   \   0000A8   E4           CLR       A
   \   0000A9   3F           ADDC      A,R7
   \   0000AA   FF           MOV       R7,A
    587          
    588              if ( (hdr.id != OSAL_NV_ZEROED_ID) && (hdr.id != skipId) )
   \   0000AB   7401         MOV       A,#0x1
   \   0000AD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   F8           MOV       R0,A
   \   0000B2   A3           INC       DPTR
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   F9           MOV       R1,A
   \   0000B5   E8           MOV       A,R0
   \   0000B6   49           ORL       A,R1
   \   0000B7   7003         JNZ       $+5
   \   0000B9   02....       LJMP      ??compactPage_9 & 0xFFFF
   \   0000BC   7401         MOV       A,#0x1
   \   0000BE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C1   E0           MOVX      A,@DPTR
   \   0000C2   65..         XRL       A,?V2
   \   0000C4   7004         JNZ       ??compactPage_10
   \   0000C6   A3           INC       DPTR
   \   0000C7   E0           MOVX      A,@DPTR
   \   0000C8   65..         XRL       A,?V3
   \                     ??compactPage_10:
   \   0000CA   7003         JNZ       $+5
   \   0000CC   02....       LJMP      ??compactPage_9 & 0xFFFF
    589              {
    590                if ( hdr.chk == calcChkF( srcPg, srcOff, hdr.len ) )
   \   0000CF                ; Setup parameters for call to function calcChkF
   \   0000CF   EE           MOV       A,R6
   \   0000D0   FA           MOV       R2,A
   \   0000D1   EF           MOV       A,R7
   \   0000D2   FB           MOV       R3,A
   \   0000D3   A9..         MOV       R1,?V0
   \   0000D5   12....       LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
   \   0000D8   8A..         MOV       ?V8,R2
   \   0000DA   8B..         MOV       ?V9,R3
   \   0000DC   A8..         MOV       R0,?V8
   \   0000DE   A9..         MOV       R1,?V9
   \   0000E0   7405         MOV       A,#0x5
   \   0000E2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E5   E0           MOVX      A,@DPTR
   \   0000E6   68           XRL       A,R0
   \   0000E7   7003         JNZ       ??compactPage_11
   \   0000E9   A3           INC       DPTR
   \   0000EA   E0           MOVX      A,@DPTR
   \   0000EB   69           XRL       A,R1
   \                     ??compactPage_11:
   \   0000EC   6003         JZ        $+5
   \   0000EE   02....       LJMP      ??compactPage_9 & 0xFFFF
    591                {
    592                  /* Prevent excessive re-writes to item header caused by numerous, rapid, & successive
    593                   * OSAL_Nv interruptions caused by resets.
    594                   */
    595                  if ( hdr.stat == OSAL_NV_ERASED_ID )
   \   0000F1   7407         MOV       A,#0x7
   \   0000F3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F6   E0           MOVX      A,@DPTR
   \   0000F7   F4           CPL       A
   \   0000F8   7003         JNZ       ??compactPage_12
   \   0000FA   A3           INC       DPTR
   \   0000FB   E0           MOVX      A,@DPTR
   \   0000FC   F4           CPL       A
   \                     ??compactPage_12:
   \   0000FD   700B         JNZ       ??compactPage_13
    596                  {
    597                    setItem( srcPg, srcOff, eNvXfer );
   \   0000FF                ; Setup parameters for call to function setItem
   \   0000FF   7C00         MOV       R4,#0x0
   \   000101   EE           MOV       A,R6
   \   000102   FA           MOV       R2,A
   \   000103   EF           MOV       A,R7
   \   000104   FB           MOV       R3,A
   \   000105   A9..         MOV       R1,?V0
   \   000107   12....       LCALL     `??setItem::?relay`; Banked call to: setItem
    598                  }
    599          
    600                  if ( writeItem( pgRes, hdr.id, hdr.len, NULL, FALSE ) )
   \                     ??compactPage_13:
   \   00010A                ; Setup parameters for call to function writeItem
   \   00010A   75..00       MOV       ?V1,#0x0
   \   00010D   78..         MOV       R0,#?V1
   \   00010F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000112   E4           CLR       A
   \   000113   F5..         MOV       ?V8,A
   \   000115   F5..         MOV       ?V9,A
   \   000117   78..         MOV       R0,#?V8
   \   000119   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00011C   7406         MOV       A,#0x6
   \   00011E   12....       LCALL     ?XSTACK_DISP0_8
   \   000121   E0           MOVX      A,@DPTR
   \   000122   FC           MOV       R4,A
   \   000123   A3           INC       DPTR
   \   000124   E0           MOVX      A,@DPTR
   \   000125   FD           MOV       R5,A
   \   000126   7404         MOV       A,#0x4
   \   000128   12....       LCALL     ?XSTACK_DISP0_8
   \   00012B   E0           MOVX      A,@DPTR
   \   00012C   FA           MOV       R2,A
   \   00012D   A3           INC       DPTR
   \   00012E   E0           MOVX      A,@DPTR
   \   00012F   FB           MOV       R3,A
   \   000130   90....       MOV       DPTR,#pgRes
   \   000133   E0           MOVX      A,@DPTR
   \   000134   F9           MOV       R1,A
   \   000135   12....       LCALL     `??writeItem::?relay`; Banked call to: writeItem
   \   000138   7403         MOV       A,#0x3
   \   00013A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00013D   E9           MOV       A,R1
   \   00013E   7003         JNZ       $+5
   \   000140   02....       LJMP      ??compactPage_8 & 0xFFFF
    601                  {
    602                    dstOff += OSAL_NV_HDR_SIZE;
   \   000143   E5..         MOV       A,?V6
   \   000145   2408         ADD       A,#0x8
   \   000147   F5..         MOV       ?V6,A
   \   000149   E4           CLR       A
   \   00014A   35..         ADDC      A,?V7
   \   00014C   F5..         MOV       ?V7,A
    603                    xferBuf( srcPg, srcOff, pgRes, dstOff, sz );
   \   00014E                ; Setup parameters for call to function xferBuf
   \   00014E   78..         MOV       R0,#?V4
   \   000150   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000153   78..         MOV       R0,#?V6
   \   000155   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000158   90....       MOV       DPTR,#pgRes
   \   00015B   E0           MOVX      A,@DPTR
   \   00015C   FC           MOV       R4,A
   \   00015D   EE           MOV       A,R6
   \   00015E   FA           MOV       R2,A
   \   00015F   EF           MOV       A,R7
   \   000160   FB           MOV       R3,A
   \   000161   A9..         MOV       R1,?V0
   \   000163   12....       LCALL     `??xferBuf::?relay`; Banked call to: xferBuf
   \   000166   7404         MOV       A,#0x4
   \   000168   12....       LCALL     ?DEALLOC_XSTACK8
    604                    // Calculate and write the new checksum.
    605                    if (hdr.chk == calcChkF(pgRes, dstOff, hdr.len))
   \   00016B                ; Setup parameters for call to function calcChkF
   \   00016B   7403         MOV       A,#0x3
   \   00016D   12....       LCALL     ?XSTACK_DISP0_8
   \   000170   E0           MOVX      A,@DPTR
   \   000171   FC           MOV       R4,A
   \   000172   A3           INC       DPTR
   \   000173   E0           MOVX      A,@DPTR
   \   000174   FD           MOV       R5,A
   \   000175   AA..         MOV       R2,?V6
   \   000177   AB..         MOV       R3,?V7
   \   000179   90....       MOV       DPTR,#pgRes
   \   00017C   E0           MOVX      A,@DPTR
   \   00017D   F9           MOV       R1,A
   \   00017E   12....       LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
   \   000181   7405         MOV       A,#0x5
   \   000183   12....       LCALL     ?XSTACK_DISP0_8
   \   000186   E0           MOVX      A,@DPTR
   \   000187   FC           MOV       R4,A
   \   000188   A3           INC       DPTR
   \   000189   E0           MOVX      A,@DPTR
   \   00018A   FD           MOV       R5,A
   \   00018B   EA           MOV       A,R2
   \   00018C   6C           XRL       A,R4
   \   00018D   7002         JNZ       ??compactPage_14
   \   00018F   EB           MOV       A,R3
   \   000190   6D           XRL       A,R5
   \                     ??compactPage_14:
   \   000191   6003         JZ        $+5
   \   000193   02....       LJMP      ??compactPage_8 & 0xFFFF
    606                    {
    607                      if ( hdr.chk != setChk( pgRes, dstOff, hdr.chk ) )
   \   000196                ; Setup parameters for call to function setChk
   \   000196   AA..         MOV       R2,?V6
   \   000198   AB..         MOV       R3,?V7
   \   00019A   90....       MOV       DPTR,#pgRes
   \   00019D   E0           MOVX      A,@DPTR
   \   00019E   F9           MOV       R1,A
   \   00019F   12....       LCALL     `??setChk::?relay`; Banked call to: setChk
   \   0001A2   8A..         MOV       ?V8,R2
   \   0001A4   8B..         MOV       ?V9,R3
   \   0001A6   A8..         MOV       R0,?V8
   \   0001A8   A9..         MOV       R1,?V9
   \   0001AA   7405         MOV       A,#0x5
   \   0001AC   12....       LCALL     ?XSTACK_DISP0_8
   \   0001AF   E0           MOVX      A,@DPTR
   \   0001B0   68           XRL       A,R0
   \   0001B1   7003         JNZ       ??compactPage_15
   \   0001B3   A3           INC       DPTR
   \   0001B4   E0           MOVX      A,@DPTR
   \   0001B5   69           XRL       A,R1
   \                     ??compactPage_15:
   \   0001B6   6003         JZ        $+5
   \   0001B8   02....       LJMP      ??compactPage_8 & 0xFFFF
    608                      {
    609                        rtrn = FALSE;
    610                        break;
    611                      }
    612                      else
    613                      {
    614                        hotItemUpdate(pgRes, dstOff, hdr.id);
   \   0001BB                ; Setup parameters for call to function hotItemUpdate
   \   0001BB   7401         MOV       A,#0x1
   \   0001BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0001C0   E0           MOVX      A,@DPTR
   \   0001C1   FC           MOV       R4,A
   \   0001C2   A3           INC       DPTR
   \   0001C3   E0           MOVX      A,@DPTR
   \   0001C4   FD           MOV       R5,A
   \   0001C5   AA..         MOV       R2,?V6
   \   0001C7   AB..         MOV       R3,?V7
   \   0001C9   90....       MOV       DPTR,#pgRes
   \   0001CC   E0           MOVX      A,@DPTR
   \   0001CD   F9           MOV       R1,A
   \   0001CE   12....       LCALL     `??hotItemUpdate::?relay`; Banked call to: hotItemUpdate
    615                      }
    616                    }
    617                    else
    618                    {
    619                      rtrn = FALSE;
    620                      break;
    621                    }
    622                  }
    623                  else
    624                  {
    625                    rtrn = FALSE;
    626                    break;
    627                  }
    628                }
    629              }
    630          
    631              srcOff += sz;
   \                     ??compactPage_9:
   \   0001D1   EE           MOV       A,R6
   \   0001D2   25..         ADD       A,?V4
   \   0001D4   FE           MOV       R6,A
   \   0001D5   EF           MOV       A,R7
   \   0001D6   35..         ADDC      A,?V5
   \   0001D8   FF           MOV       R7,A
   \                     ??compactPage_4:
   \   0001D9   C3           CLR       C
   \   0001DA   EE           MOV       A,R6
   \   0001DB   94F8         SUBB      A,#-0x8
   \   0001DD   EF           MOV       A,R7
   \   0001DE   9407         SUBB      A,#0x7
   \   0001E0   506E         JNC       ??compactPage_7
   \   0001E2   90....       MOV       DPTR,#pgRes
   \   0001E5   E0           MOVX      A,@DPTR
   \   0001E6   25E0         ADD       A,0xE0 /* A   */
   \   0001E8   F8           MOV       R0,A
   \   0001E9   E4           CLR       A
   \   0001EA   33           RLC       A
   \   0001EB   F9           MOV       R1,A
   \   0001EC   74..         MOV       A,#(pgOff + 14) & 0xff
   \   0001EE   28           ADD       A,R0
   \   0001EF   F582         MOV       DPL,A
   \   0001F1   74..         MOV       A,#((pgOff - 242) >> 8) & 0xff
   \   0001F3   39           ADDC      A,R1
   \   0001F4   F583         MOV       DPH,A
   \   0001F6   E0           MOVX      A,@DPTR
   \   0001F7   F5..         MOV       ?V6,A
   \   0001F9   A3           INC       DPTR
   \   0001FA   E0           MOVX      A,@DPTR
   \   0001FB   F5..         MOV       ?V7,A
   \   0001FD                ; Setup parameters for call to function HalFlashRead
   \   0001FD   75..08       MOV       ?V4,#0x8
   \   000200   75..00       MOV       ?V5,#0x0
   \   000203   78..         MOV       R0,#?V4
   \   000205   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000208   7403         MOV       A,#0x3
   \   00020A   12....       LCALL     ?XSTACK_DISP102_8
   \   00020D   EE           MOV       A,R6
   \   00020E   FA           MOV       R2,A
   \   00020F   EF           MOV       A,R7
   \   000210   FB           MOV       R3,A
   \   000211   A9..         MOV       R1,?V0
   \   000213   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000216   7402         MOV       A,#0x2
   \   000218   12....       LCALL     ?DEALLOC_XSTACK8
   \   00021B   7401         MOV       A,#0x1
   \   00021D   12....       LCALL     ?XSTACK_DISP0_8
   \   000220   E0           MOVX      A,@DPTR
   \   000221   F4           CPL       A
   \   000222   7003         JNZ       ??compactPage_16
   \   000224   A3           INC       DPTR
   \   000225   E0           MOVX      A,@DPTR
   \   000226   F4           CPL       A
   \                     ??compactPage_16:
   \   000227   6027         JZ        ??compactPage_7
   \   000229   7403         MOV       A,#0x3
   \   00022B   12....       LCALL     ?XSTACK_DISP0_8
   \   00022E   E0           MOVX      A,@DPTR
   \   00022F   FC           MOV       R4,A
   \   000230   A3           INC       DPTR
   \   000231   E0           MOVX      A,@DPTR
   \   000232   FD           MOV       R5,A
   \   000233   C3           CLR       C
   \   000234   EC           MOV       A,R4
   \   000235   94FC         SUBB      A,#-0x4
   \   000237   ED           MOV       A,R5
   \   000238   94FF         SUBB      A,#-0x1
   \   00023A   5003         JNC       $+5
   \   00023C   02....       LJMP      ??compactPage_5 & 0xFFFF
   \   00023F   75..FC       MOV       ?V4,#-0x4
   \   000242   75..FF       MOV       ?V5,#-0x1
   \   000245   02....       LJMP      ??compactPage_6 & 0xFFFF
   \                     ??compactPage_8:
   \   000248   85..82       MOV       DPL,?XSP + 0
   \   00024B   85..83       MOV       DPH,?XSP + 1
   \   00024E   E4           CLR       A
   \   00024F   F0           MOVX      @DPTR,A
    632            }
    633          
    634            if (rtrn == FALSE)
   \                     ??compactPage_7:
   \   000250   85..82       MOV       DPL,?XSP + 0
   \   000253   85..83       MOV       DPH,?XSP + 1
   \   000256   E0           MOVX      A,@DPTR
   \   000257   700A         JNZ       ??compactPage_17
    635            {
    636              erasePage(pgRes);
   \   000259                ; Setup parameters for call to function erasePage
   \   000259   90....       MOV       DPTR,#pgRes
   \   00025C   E0           MOVX      A,@DPTR
   \   00025D   F9           MOV       R1,A
   \   00025E   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
   \   000261   801B         SJMP      ??compactPage_18
    637            }
    638            else if (skipId == OSAL_NV_ITEM_NULL)
   \                     ??compactPage_17:
   \   000263   E5..         MOV       A,?V2
   \   000265   45..         ORL       A,?V3
   \   000267   7015         JNZ       ??compactPage_18
    639            {
    640              COMPACT_PAGE_CLEANUP(srcPg);
   \   000269                ; Setup parameters for call to function setPageUse
   \   000269   7A01         MOV       R2,#0x1
   \   00026B   90....       MOV       DPTR,#pgRes
   \   00026E   E0           MOVX      A,@DPTR
   \   00026F   F9           MOV       R1,A
   \   000270   12....       LCALL     `??setPageUse::?relay`; Banked call to: setPageUse
   \   000273                ; Setup parameters for call to function erasePage
   \   000273   A9..         MOV       R1,?V0
   \   000275   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
   \   000278   E5..         MOV       A,?V0
   \   00027A   90....       MOV       DPTR,#pgRes
   \   00027D   F0           MOVX      @DPTR,A
    641            }
    642            // else invoking function must cleanup.
    643          
    644            return rtrn;
   \                     ??compactPage_18:
   \   00027E   85..82       MOV       DPL,?XSP + 0
   \   000281   85..83       MOV       DPH,?XSP + 1
   \   000284   E0           MOVX      A,@DPTR
   \   000285   F9           MOV       R1,A
   \                     ??compactPage_3:
   \   000286   7409         MOV       A,#0x9
   \   000288   12....       LCALL     ?DEALLOC_XSTACK8
   \   00028B   7F0A         MOV       R7,#0xa
   \   00028D   02....       LJMP      ?BANKED_LEAVE_XDATA
    645          }
    646          
    647          /*********************************************************************
    648           * @fn      findItem
    649           *
    650           * @brief   Find an item Id in NV and return the page and offset to its data.
    651           *
    652           * @param   id - Valid NV item Id.
    653           *
    654           * @return  Offset of data corresponding to item Id, if found;
    655           *          otherwise OSAL_NV_ITEM_NULL.
    656           *
    657           *          The page containing the item, if found;
    658           *          otherwise no valid assignment made - left equal to item Id.
    659           *
    660           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    661          static uint16 findItem( uint16 id )
   \                     findItem:
    662          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   8003         SJMP      ??findItem_0
    663            uint16 off;
    664            uint8 pg;
    665          
    666            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
    667            {
    668              if ( (off = initPage( pg, id, FALSE )) != OSAL_NV_ITEM_NULL )
    669              {
    670                findPg = pg;
    671                return off;
    672              }
    673            }
    674          
    675            // Now attempt to find the item as the "old" item of a failed/interrupted NV write.
    676            if ( (id & OSAL_NV_SOURCE_ID) == 0 )
    677            {
    678              return findItem( id | OSAL_NV_SOURCE_ID );
   \                     ??findItem_1:
   \   00000A   7480         MOV       A,#-0x80
   \   00000C   4F           ORL       A,R7
   \                     ??findItem_0:
   \   00000D   FF           MOV       R7,A
    679            }
   \   00000E   75..79       MOV       ?V0,#0x79
   \   000011   8002         SJMP      ??findItem_2
   \                     ??findItem_3:
   \   000013   05..         INC       ?V0
   \                     ??findItem_2:
   \   000015   E5..         MOV       A,?V0
   \   000017   C3           CLR       C
   \   000018   947F         SUBB      A,#0x7f
   \   00001A   501B         JNC       ??findItem_4
   \   00001C                ; Setup parameters for call to function initPage
   \   00001C   7C00         MOV       R4,#0x0
   \   00001E   EE           MOV       A,R6
   \   00001F   FA           MOV       R2,A
   \   000020   EF           MOV       A,R7
   \   000021   FB           MOV       R3,A
   \   000022   A9..         MOV       R1,?V0
   \   000024   12....       LCALL     `??initPage::?relay`; Banked call to: initPage
   \   000027   8B..         MOV       ?V3,R3
   \   000029   A9..         MOV       R1,?V3
   \   00002B   EA           MOV       A,R2
   \   00002C   49           ORL       A,R1
   \   00002D   60E4         JZ        ??findItem_3
   \   00002F   E5..         MOV       A,?V0
   \   000031   90....       MOV       DPTR,#findPg
   \   000034   F0           MOVX      @DPTR,A
   \   000035   800C         SJMP      ??findItem_5
   \                     ??findItem_4:
   \   000037   EF           MOV       A,R7
   \   000038   5480         ANL       A,#0x80
   \   00003A   60CE         JZ        ??findItem_1
    680            else
    681            {
    682              findPg = OSAL_NV_PAGE_NULL;
   \   00003C   90....       MOV       DPTR,#findPg
   \   00003F   E4           CLR       A
   \   000040   F0           MOVX      @DPTR,A
    683              return OSAL_NV_ITEM_NULL;
   \   000041   FA           MOV       R2,A
   \   000042   FB           MOV       R3,A
   \                     ??findItem_5:
   \   000043   7F04         MOV       R7,#0x4
   \   000045   02....       LJMP      ?BANKED_LEAVE_XDATA
    684            }
    685          }
    686          
    687          /*********************************************************************
    688           * @fn      initItem
    689           *
    690           * @brief   An NV item is created and initialized with the data passed to the function, if any.
    691           *
    692           * @param   flag - TRUE if the 'buf' parameter contains data for the call to writeItem().
    693           *                 (i.e. if invoked from osal_nv_item_init() ).
    694           *                 FALSE if writeItem() should just write the header and the 'buf' parameter
    695           *                 is ok to use as a return value of the page number to be cleaned with
    696           *                 COMPACT_PAGE_CLEANUP().
    697           *                 (i.e. if invoked from osal_nv_write() ).
    698           * @param   id  - Valid NV item Id.
    699           * @param   len - Item data length.
    700           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
    701           *
    702           * @return  The OSAL Nv page number if item write and read back checksums ok;
    703           *          OSAL_NV_PAGE_NULL otherwise.
    704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    705          static uint8 initItem( uint8 flag, uint16 id, uint16 len, void *buf )
   \                     initItem:
    706          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V2,R1
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   8C..         MOV       ?V0,R4
   \   000012   8D..         MOV       ?V1,R5
    707            uint16 sz = OSAL_NV_ITEM_SIZE( len );
   \   000014   C3           CLR       C
   \   000015   EC           MOV       A,R4
   \   000016   94F4         SUBB      A,#-0xc
   \   000018   ED           MOV       A,R5
   \   000019   94FF         SUBB      A,#-0x1
   \   00001B   400E         JC        ??initItem_0
   \   00001D   85..82       MOV       DPL,?XSP + 0
   \   000020   85..83       MOV       DPH,?XSP + 1
   \   000023   74FC         MOV       A,#-0x4
   \   000025   F0           MOVX      @DPTR,A
   \   000026   A3           INC       DPTR
   \   000027   74FF         MOV       A,#-0x1
   \   000029   8019         SJMP      ??initItem_1
   \                     ??initItem_0:
   \   00002B   EC           MOV       A,R4
   \   00002C   2403         ADD       A,#0x3
   \   00002E   F8           MOV       R0,A
   \   00002F   E4           CLR       A
   \   000030   35..         ADDC      A,?V1
   \   000032   F9           MOV       R1,A
   \   000033   E8           MOV       A,R0
   \   000034   54FC         ANL       A,#0xfc
   \   000036   2408         ADD       A,#0x8
   \   000038   5001         JNC       ??initItem_2
   \   00003A   09           INC       R1
   \                     ??initItem_2:
   \   00003B   85..82       MOV       DPL,?XSP + 0
   \   00003E   85..83       MOV       DPH,?XSP + 1
   \   000041   F0           MOVX      @DPTR,A
   \   000042   A3           INC       DPTR
   \   000043   E9           MOV       A,R1
   \                     ??initItem_1:
   \   000044   F0           MOVX      @DPTR,A
    708            uint8 rtrn = OSAL_NV_PAGE_NULL;
   \   000045   7F00         MOV       R7,#0x0
    709            uint8 cnt = OSAL_NV_PAGES_USED;
   \   000047   7C06         MOV       R4,#0x6
    710            uint8 pg = pgRes+1;  // Set to 1 after the reserve page to even wear across all available pages.
   \   000049   90....       MOV       DPTR,#pgRes
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   04           INC       A
   \   00004E   FE           MOV       R6,A
    711          
    712            do {
    713              if (pg >= OSAL_NV_PAGE_BEG+OSAL_NV_PAGES_USED)
   \                     ??initItem_3:
   \   00004F   EE           MOV       A,R6
   \   000050   C3           CLR       C
   \   000051   947F         SUBB      A,#0x7f
   \   000053   4002         JC        ??initItem_4
    714              {
    715                pg = OSAL_NV_PAGE_BEG;
   \   000055   7E79         MOV       R6,#0x79
    716              }
    717              if ( pg != pgRes )
   \                     ??initItem_4:
   \   000057   90....       MOV       DPTR,#pgRes
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   6E           XRL       A,R6
   \   00005C   6043         JZ        ??initItem_5
    718              {
    719                uint8 idx = pg - OSAL_NV_PAGE_BEG;
   \   00005E   7487         MOV       A,#-0x79
   \   000060   2E           ADD       A,R6
    720                if ( sz <= (OSAL_NV_PAGE_SIZE - pgOff[idx] + pgLost[idx]) )
   \   000061   25E0         ADD       A,0xE0 /* A   */
   \   000063   F8           MOV       R0,A
   \   000064   E4           CLR       A
   \   000065   33           RLC       A
   \   000066   F9           MOV       R1,A
   \   000067   74..         MOV       A,#pgOff & 0xff
   \   000069   28           ADD       A,R0
   \   00006A   F582         MOV       DPL,A
   \   00006C   74..         MOV       A,#(pgOff >> 8) & 0xff
   \   00006E   39           ADDC      A,R1
   \   00006F   F583         MOV       DPH,A
   \   000071   E0           MOVX      A,@DPTR
   \   000072   FA           MOV       R2,A
   \   000073   A3           INC       DPTR
   \   000074   E0           MOVX      A,@DPTR
   \   000075   FB           MOV       R3,A
   \   000076   E4           CLR       A
   \   000077   C3           CLR       C
   \   000078   9A           SUBB      A,R2
   \   000079   FA           MOV       R2,A
   \   00007A   7408         MOV       A,#0x8
   \   00007C   9B           SUBB      A,R3
   \   00007D   FB           MOV       R3,A
   \   00007E   74..         MOV       A,#pgLost & 0xff
   \   000080   28           ADD       A,R0
   \   000081   F582         MOV       DPL,A
   \   000083   74..         MOV       A,#(pgLost >> 8) & 0xff
   \   000085   39           ADDC      A,R1
   \   000086   F583         MOV       DPH,A
   \   000088   E0           MOVX      A,@DPTR
   \   000089   2A           ADD       A,R2
   \   00008A   FA           MOV       R2,A
   \   00008B   A3           INC       DPTR
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   3B           ADDC      A,R3
   \   00008E   FB           MOV       R3,A
   \   00008F   85..82       MOV       DPL,?XSP + 0
   \   000092   85..83       MOV       DPH,?XSP + 1
   \   000095   E0           MOVX      A,@DPTR
   \   000096   F8           MOV       R0,A
   \   000097   A3           INC       DPTR
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F9           MOV       R1,A
   \   00009A   C3           CLR       C
   \   00009B   EA           MOV       A,R2
   \   00009C   98           SUBB      A,R0
   \   00009D   EB           MOV       A,R3
   \   00009E   99           SUBB      A,R1
   \   00009F   5005         JNC       ??initItem_6
    721                {
    722                  break;
    723                }
    724              }
    725              pg++;
   \                     ??initItem_5:
   \   0000A1   0E           INC       R6
    726            } while (--cnt);
   \   0000A2   1C           DEC       R4
   \   0000A3   EC           MOV       A,R4
   \   0000A4   70A9         JNZ       ??initItem_3
    727          
    728            if (cnt)
   \                     ??initItem_6:
   \   0000A6   EC           MOV       A,R4
   \   0000A7   7003         JNZ       $+5
   \   0000A9   02....       LJMP      ??initItem_7 & 0xFFFF
   \   0000AC   741C         MOV       A,#0x1c
   \   0000AE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B1   E0           MOVX      A,@DPTR
   \   0000B2   F5..         MOV       ?V6,A
   \   0000B4   A3           INC       DPTR
   \   0000B5   E0           MOVX      A,@DPTR
   \   0000B6   F5..         MOV       ?V7,A
    729            {
    730              // Item fits if an old page is compacted.
    731              if ( sz > (OSAL_NV_PAGE_SIZE - pgOff[pg - OSAL_NV_PAGE_BEG]) )
   \   0000B8   EE           MOV       A,R6
   \   0000B9   25E0         ADD       A,0xE0 /* A   */
   \   0000BB   F8           MOV       R0,A
   \   0000BC   E4           CLR       A
   \   0000BD   33           RLC       A
   \   0000BE   F9           MOV       R1,A
   \   0000BF   74..         MOV       A,#(pgOff + 14) & 0xff
   \   0000C1   28           ADD       A,R0
   \   0000C2   F582         MOV       DPL,A
   \   0000C4   74..         MOV       A,#((pgOff - 242) >> 8) & 0xff
   \   0000C6   39           ADDC      A,R1
   \   0000C7   F583         MOV       DPH,A
   \   0000C9   E0           MOVX      A,@DPTR
   \   0000CA   F8           MOV       R0,A
   \   0000CB   A3           INC       DPTR
   \   0000CC   E0           MOVX      A,@DPTR
   \   0000CD   F9           MOV       R1,A
   \   0000CE   E4           CLR       A
   \   0000CF   C3           CLR       C
   \   0000D0   98           SUBB      A,R0
   \   0000D1   FA           MOV       R2,A
   \   0000D2   7408         MOV       A,#0x8
   \   0000D4   99           SUBB      A,R1
   \   0000D5   FB           MOV       R3,A
   \   0000D6   85..82       MOV       DPL,?XSP + 0
   \   0000D9   85..83       MOV       DPH,?XSP + 1
   \   0000DC   E0           MOVX      A,@DPTR
   \   0000DD   F8           MOV       R0,A
   \   0000DE   A3           INC       DPTR
   \   0000DF   E0           MOVX      A,@DPTR
   \   0000E0   F9           MOV       R1,A
   \   0000E1   C3           CLR       C
   \   0000E2   EA           MOV       A,R2
   \   0000E3   98           SUBB      A,R0
   \   0000E4   EB           MOV       A,R3
   \   0000E5   99           SUBB      A,R1
   \   0000E6   4003         JC        $+5
   \   0000E8   02....       LJMP      ??initItem_8 & 0xFFFF
    732              {
    733                osalNvPgHdr_t pgHdr;
    734          
    735                /* Prevent excessive re-writes to page header caused by numerous, rapid, & successive
    736                 * OSAL_Nv interruptions caused by resets.
    737                 */
    738                HalFlashRead(pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr), OSAL_NV_PAGE_HDR_SIZE);
   \   0000EB                ; Setup parameters for call to function HalFlashRead
   \   0000EB   75..08       MOV       ?V8,#0x8
   \   0000EE   8F..         MOV       ?V9,R7
   \   0000F0   78..         MOV       R0,#?V8
   \   0000F2   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000F5   7404         MOV       A,#0x4
   \   0000F7   12....       LCALL     ?XSTACK_DISP102_8
   \   0000FA   7A00         MOV       R2,#0x0
   \   0000FC   7B00         MOV       R3,#0x0
   \   0000FE   EE           MOV       A,R6
   \   0000FF   F9           MOV       R1,A
   \   000100   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000103   7402         MOV       A,#0x2
   \   000105   12....       LCALL     ?DEALLOC_XSTACK8
    739                if ( pgHdr.xfer == OSAL_NV_ERASED_ID )
   \   000108   7406         MOV       A,#0x6
   \   00010A   12....       LCALL     ?XSTACK_DISP0_8
   \   00010D   E0           MOVX      A,@DPTR
   \   00010E   F4           CPL       A
   \   00010F   7003         JNZ       ??initItem_9
   \   000111   A3           INC       DPTR
   \   000112   E0           MOVX      A,@DPTR
   \   000113   F4           CPL       A
   \                     ??initItem_9:
   \   000114   7016         JNZ       ??initItem_10
    740                {
    741                  // Mark the old page as being in process of compaction.
    742                  sz = OSAL_NV_ZEROED_ID;
   \   000116   85..82       MOV       DPL,?XSP + 0
   \   000119   85..83       MOV       DPH,?XSP + 1
   \   00011C   E4           CLR       A
   \   00011D   F0           MOVX      @DPTR,A
   \   00011E   A3           INC       DPTR
   \   00011F   F0           MOVX      @DPTR,A
    743                  writeWordH( pg, OSAL_NV_PG_XFER, (uint8*)(&sz) );
   \   000120                ; Setup parameters for call to function writeWordH
   \   000120   AC..         MOV       R4,?XSP + 0
   \   000122   AD..         MOV       R5,?XSP + 1
   \   000124   7A04         MOV       R2,#0x4
   \   000126   FB           MOV       R3,A
   \   000127   EE           MOV       A,R6
   \   000128   F9           MOV       R1,A
   \   000129   12....       LCALL     `??writeWordH::?relay`; Banked call to: writeWordH
    744                }
    745          
    746                /* First the old page is compacted, then the new item will be the last one written to what
    747                 * had been the reserved page.
    748                 */
    749                if (compactPage( pg, id ))
   \                     ??initItem_10:
   \   00012C                ; Setup parameters for call to function compactPage
   \   00012C   AA..         MOV       R2,?V4
   \   00012E   AB..         MOV       R3,?V5
   \   000130   EE           MOV       A,R6
   \   000131   F9           MOV       R1,A
   \   000132   12....       LCALL     `??compactPage::?relay`; Banked call to: compactPage
   \   000135   E9           MOV       A,R1
   \   000136   6071         JZ        ??initItem_7
    750                {
    751                  if ( writeItem( pgRes, id, len, buf, flag ) )
   \   000138                ; Setup parameters for call to function writeItem
   \   000138   E5..         MOV       A,?V2
   \   00013A   F5..         MOV       ?V3,A
   \   00013C   78..         MOV       R0,#?V3
   \   00013E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000141   78..         MOV       R0,#?V6
   \   000143   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000146   AC..         MOV       R4,?V0
   \   000148   AD..         MOV       R5,?V1
   \   00014A   AA..         MOV       R2,?V4
   \   00014C   AB..         MOV       R3,?V5
   \   00014E   90....       MOV       DPTR,#pgRes
   \   000151   E0           MOVX      A,@DPTR
   \   000152   F9           MOV       R1,A
   \   000153   12....       LCALL     `??writeItem::?relay`; Banked call to: writeItem
   \   000156   7403         MOV       A,#0x3
   \   000158   12....       LCALL     ?DEALLOC_XSTACK8
   \   00015B   E9           MOV       A,R1
   \   00015C   6005         JZ        ??initItem_11
    752                  {
    753                    rtrn = pgRes;
   \   00015E   90....       MOV       DPTR,#pgRes
   \   000161   E0           MOVX      A,@DPTR
   \   000162   FF           MOV       R7,A
    754                  }
    755          
    756                  if ( flag == FALSE )
   \                     ??initItem_11:
   \   000163   E5..         MOV       A,?V2
   \   000165   7009         JNZ       ??initItem_12
    757                  {
    758                    /* Overload 'buf' as an OUT parameter to pass back to the calling function
    759                     * the old page to be cleaned up.
    760                     */
    761                    *(uint8 *)buf = pg;
   \   000167   EE           MOV       A,R6
   \   000168   85..82       MOV       DPL,?V6
   \   00016B   85..83       MOV       DPH,?V7
   \   00016E   8013         SJMP      ??initItem_13
    762                  }
    763                  else
    764                  {
    765                    /* Safe to do the compacted page cleanup even if writeItem() above failed because the
    766                     * item does not yet exist since this call with flag==TRUE is from osal_nv_item_init().
    767                     */
    768                    COMPACT_PAGE_CLEANUP( pg );
   \                     ??initItem_12:
   \   000170                ; Setup parameters for call to function setPageUse
   \   000170   7A01         MOV       R2,#0x1
   \   000172   90....       MOV       DPTR,#pgRes
   \   000175   E0           MOVX      A,@DPTR
   \   000176   F9           MOV       R1,A
   \   000177   12....       LCALL     `??setPageUse::?relay`; Banked call to: setPageUse
   \   00017A                ; Setup parameters for call to function erasePage
   \   00017A   EE           MOV       A,R6
   \   00017B   F9           MOV       R1,A
   \   00017C   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
   \   00017F   EE           MOV       A,R6
   \   000180   90....       MOV       DPTR,#pgRes
   \                     ??initItem_13:
   \   000183   F0           MOVX      @DPTR,A
   \   000184   8023         SJMP      ??initItem_7
    769                  }
    770                }
    771              }
    772              else
    773              {
    774                if ( writeItem( pg, id, len, buf, flag ) )
   \                     ??initItem_8:
   \   000186                ; Setup parameters for call to function writeItem
   \   000186   E5..         MOV       A,?V2
   \   000188   F5..         MOV       ?V3,A
   \   00018A   78..         MOV       R0,#?V3
   \   00018C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00018F   78..         MOV       R0,#?V6
   \   000191   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000194   AC..         MOV       R4,?V0
   \   000196   AA..         MOV       R2,?V4
   \   000198   AB..         MOV       R3,?V5
   \   00019A   EE           MOV       A,R6
   \   00019B   F9           MOV       R1,A
   \   00019C   12....       LCALL     `??writeItem::?relay`; Banked call to: writeItem
   \   00019F   7403         MOV       A,#0x3
   \   0001A1   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001A4   E9           MOV       A,R1
   \   0001A5   6002         JZ        ??initItem_7
    775                {
    776                  rtrn = pg;
   \   0001A7   EE           MOV       A,R6
   \   0001A8   FF           MOV       R7,A
    777                }
    778              }
    779            }
    780          
    781            return rtrn;
   \                     ??initItem_7:
   \   0001A9   EF           MOV       A,R7
   \   0001AA   F9           MOV       R1,A
   \   0001AB   740A         MOV       A,#0xa
   \   0001AD   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001B0   7F0A         MOV       R7,#0xa
   \   0001B2   02....       LJMP      ?BANKED_LEAVE_XDATA
    782          }
    783          
    784          /*********************************************************************
    785           * @fn      setItem
    786           *
    787           * @brief   Set an item Id or status to mark its state.
    788           *
    789           * @param   pg - Valid NV page.
    790           * @param   offset - Valid offset into the page of the item data - the header
    791           *                   offset is calculated from this.
    792           * @param   stat - Valid enum value for the item status.
    793           *
    794           * @return  none
    795           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    796          static void setItem( uint8 pg, uint16 offset, eNvHdrEnum stat )
   \                     setItem:
    797          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V1,R1
   \   00000C   8C..         MOV       ?V0,R4
    798            osalNvHdr_t hdr;
    799          
    800            offset -= OSAL_NV_HDR_SIZE;
   \   00000E   EA           MOV       A,R2
   \   00000F   24F8         ADD       A,#-0x8
   \   000011   F5..         MOV       ?V2,A
   \   000013   EB           MOV       A,R3
   \   000014   34FF         ADDC      A,#-0x1
   \   000016   F5..         MOV       ?V3,A
    801            HalFlashRead(pg, offset, (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
   \   000018                ; Setup parameters for call to function HalFlashRead
   \   000018   75..08       MOV       ?V4,#0x8
   \   00001B   75..00       MOV       ?V5,#0x0
   \   00001E   78..         MOV       R0,#?V4
   \   000020   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000023   7402         MOV       A,#0x2
   \   000025   12....       LCALL     ?XSTACK_DISP102_8
   \   000028   AA..         MOV       R2,?V2
   \   00002A   AB..         MOV       R3,?V3
   \   00002C   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   00002F   7402         MOV       A,#0x2
   \   000031   12....       LCALL     ?DEALLOC_XSTACK8
    802          
    803            if ( stat == eNvXfer )
   \   000034   E5..         MOV       A,?V0
   \   000036   7022         JNZ       ??setItem_0
    804            {
    805              hdr.stat = OSAL_NV_ACTIVE;
   \   000038   7406         MOV       A,#0x6
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   E4           CLR       A
   \   00003E   F0           MOVX      @DPTR,A
   \   00003F   A3           INC       DPTR
   \   000040   F0           MOVX      @DPTR,A
    806              /* Write status to flash. Total of 4 bytes written to Flash 
    807               * ( 2 bytes of checksum and 2 bytes of status) 
    808               */
    809              writeWord( pg, offset+OSAL_NV_HDR_CHK, (uint8*)(&(hdr.chk)) );
   \   000041                ; Setup parameters for call to function writeWord
   \   000041   7404         MOV       A,#0x4
   \   000043   12....       LCALL     ?XSTACK_DISP0_8
   \   000046   AC82         MOV       R4,DPL
   \   000048   AD83         MOV       R5,DPH
   \   00004A   E5..         MOV       A,?V2
   \   00004C   2404         ADD       A,#0x4
   \   00004E   FA           MOV       R2,A
   \   00004F   E4           CLR       A
   \   000050   35..         ADDC      A,?V3
   \   000052   FB           MOV       R3,A
   \   000053   A9..         MOV       R1,?V1
   \   000055   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
   \   000058   8047         SJMP      ??setItem_1
    810            }
    811            else // if ( stat == eNvZero )
    812            {
    813              uint16 sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
    814                                                                                    OSAL_NV_HDR_SIZE;
   \                     ??setItem_0:
   \   00005A   7402         MOV       A,#0x2
   \   00005C   12....       LCALL     ?XSTACK_DISP0_8
   \   00005F   E0           MOVX      A,@DPTR
   \   000060   2403         ADD       A,#0x3
   \   000062   F8           MOV       R0,A
   \   000063   A3           INC       DPTR
   \   000064   E0           MOVX      A,@DPTR
   \   000065   3400         ADDC      A,#0x0
   \   000067   F9           MOV       R1,A
   \   000068   E8           MOV       A,R0
   \   000069   54FC         ANL       A,#0xfc
   \   00006B   2408         ADD       A,#0x8
   \   00006D   FE           MOV       R6,A
   \   00006E   E4           CLR       A
   \   00006F   39           ADDC      A,R1
   \   000070   FF           MOV       R7,A
    815              hdr.id = 0;
   \   000071   85..82       MOV       DPL,?XSP + 0
   \   000074   85..83       MOV       DPH,?XSP + 1
   \   000077   E4           CLR       A
   \   000078   F0           MOVX      @DPTR,A
   \   000079   A3           INC       DPTR
   \   00007A   F0           MOVX      @DPTR,A
    816              writeWord( pg, offset, (uint8 *)(&hdr) );
   \   00007B                ; Setup parameters for call to function writeWord
   \   00007B   AC..         MOV       R4,?XSP + 0
   \   00007D   AD..         MOV       R5,?XSP + 1
   \   00007F   AA..         MOV       R2,?V2
   \   000081   AB..         MOV       R3,?V3
   \   000083   A9..         MOV       R1,?V1
   \   000085   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
    817              pgLost[pg-OSAL_NV_PAGE_BEG] += sz;
   \   000088   A8..         MOV       R0,?V1
   \   00008A   E8           MOV       A,R0
   \   00008B   28           ADD       A,R0
   \   00008C   F8           MOV       R0,A
   \   00008D   E4           CLR       A
   \   00008E   33           RLC       A
   \   00008F   F9           MOV       R1,A
   \   000090   74..         MOV       A,#(pgLost + 14) & 0xff
   \   000092   28           ADD       A,R0
   \   000093   F582         MOV       DPL,A
   \   000095   74..         MOV       A,#((pgLost - 242) >> 8) & 0xff
   \   000097   39           ADDC      A,R1
   \   000098   F583         MOV       DPH,A
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   2E           ADD       A,R6
   \   00009C   F0           MOVX      @DPTR,A
   \   00009D   A3           INC       DPTR
   \   00009E   E0           MOVX      A,@DPTR
   \   00009F   3F           ADDC      A,R7
   \   0000A0   F0           MOVX      @DPTR,A
    818            }
    819          }
   \                     ??setItem_1:
   \   0000A1   7408         MOV       A,#0x8
   \   0000A3   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A6   7F06         MOV       R7,#0x6
   \   0000A8   02....       LJMP      ?BANKED_LEAVE_XDATA
    820          
    821          /*********************************************************************
    822           * @fn      setChk
    823           *
    824           * @brief   Set the item header checksum given the data buffer offset.
    825           *
    826           * @param   pg - Valid NV page.
    827           * @param   offset - Valid offset into the page of the item data - the header
    828           *                   offset is calculated from this.
    829           * @param   chk - The checksum to set.
    830           *
    831           * @return  The checksum read back.
    832           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    833          static uint16 setChk( uint8 pg, uint16 offset, uint16 chk )
   \                     setChk:
    834          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EC           MOV       A,R4
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   ED           MOV       A,R5
   \   000014   F0           MOVX      @DPTR,A
   \   000015   89..         MOV       ?V0,R1
    835            offset -= OSAL_NV_WORD_SIZE;
   \   000017   EA           MOV       A,R2
   \   000018   24FC         ADD       A,#-0x4
   \   00001A   FE           MOV       R6,A
   \   00001B   EB           MOV       A,R3
   \   00001C   34FF         ADDC      A,#-0x1
   \   00001E   FF           MOV       R7,A
    836            writeWordH( pg, offset, (uint8 *)&chk );
   \   00001F                ; Setup parameters for call to function writeWordH
   \   00001F   AC..         MOV       R4,?XSP + 0
   \   000021   AD..         MOV       R5,?XSP + 1
   \   000023   EE           MOV       A,R6
   \   000024   FA           MOV       R2,A
   \   000025   EF           MOV       A,R7
   \   000026   FB           MOV       R3,A
   \   000027   12....       LCALL     `??writeWordH::?relay`; Banked call to: writeWordH
    837            HalFlashRead( pg, offset, (uint8 *)(&chk), sizeof( chk ) );
   \   00002A                ; Setup parameters for call to function HalFlashRead
   \   00002A   75..02       MOV       ?V2,#0x2
   \   00002D   75..00       MOV       ?V3,#0x0
   \   000030   78..         MOV       R0,#?V2
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000035   7402         MOV       A,#0x2
   \   000037   12....       LCALL     ?XSTACK_DISP102_8
   \   00003A   EE           MOV       A,R6
   \   00003B   FA           MOV       R2,A
   \   00003C   EF           MOV       A,R7
   \   00003D   FB           MOV       R3,A
   \   00003E   A9..         MOV       R1,?V0
   \   000040   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000043   7402         MOV       A,#0x2
   \   000045   12....       LCALL     ?DEALLOC_XSTACK8
    838          
    839            return chk;
   \   000048   85..82       MOV       DPL,?XSP + 0
   \   00004B   85..83       MOV       DPH,?XSP + 1
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   FA           MOV       R2,A
   \   000050   A3           INC       DPTR
   \   000051   E0           MOVX      A,@DPTR
   \   000052   FB           MOV       R3,A
   \   000053   7402         MOV       A,#0x2
   \   000055   12....       LCALL     ?DEALLOC_XSTACK8
   \   000058   7F04         MOV       R7,#0x4
   \   00005A   02....       LJMP      ?BANKED_LEAVE_XDATA
    840          }
    841          
    842          /*********************************************************************
    843           * @fn      calcChkB
    844           *
    845           * @brief   Calculates the data checksum over the 'buf' parameter.
    846           *
    847           * @param   len - Byte count of the data to be checksummed.
    848           * @param   buf - Data buffer to be checksummed.
    849           *
    850           * @return  Calculated checksum of the data bytes.
    851           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    852          static uint16 calcChkB( uint16 len, uint8 *buf )
   \                     calcChkB:
    853          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   F8           MOV       R0,A
   \   000007   EB           MOV       A,R3
   \   000008   F9           MOV       R1,A
    854            uint8 fill = len % OSAL_NV_WORD_SIZE;
   \   000009   EA           MOV       A,R2
   \   00000A   5403         ANL       A,#0x3
   \   00000C   F5..         MOV       ?V0,A
    855            uint16 chk;
    856          
    857            if ( !buf )
   \   00000E   EC           MOV       A,R4
   \   00000F   4D           ORL       A,R5
   \   000010   7011         JNZ       ??calcChkB_0
    858            {
    859              chk = len * OSAL_NV_ERASED;
   \   000012   EA           MOV       A,R2
   \   000013   75F0FF       MOV       B,#-0x1
   \   000016   A4           MUL       AB
   \   000017   FA           MOV       R2,A
   \   000018   A8F0         MOV       R0,B
   \   00001A   75F0FF       MOV       B,#-0x1
   \   00001D   EB           MOV       A,R3
   \   00001E   A4           MUL       AB
   \   00001F   28           ADD       A,R0
   \   000020   FB           MOV       R3,A
   \   000021   8027         SJMP      ??calcChkB_1
    860            }
    861            else
    862            {
    863              chk = 0;
   \                     ??calcChkB_0:
   \   000023   7A00         MOV       R2,#0x0
   \   000025   7B00         MOV       R3,#0x0
   \   000027   8011         SJMP      ??calcChkB_2
    864              while ( len-- )
    865              {
    866                chk += *buf++;
   \                     ??calcChkB_3:
   \   000029   8C82         MOV       DPL,R4
   \   00002B   8D83         MOV       DPH,R5
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   FE           MOV       R6,A
   \   00002F   EA           MOV       A,R2
   \   000030   2E           ADD       A,R6
   \   000031   FA           MOV       R2,A
   \   000032   E4           CLR       A
   \   000033   3B           ADDC      A,R3
   \   000034   FB           MOV       R3,A
   \   000035   A3           INC       DPTR
   \   000036   AC82         MOV       R4,DPL
   \   000038   AD83         MOV       R5,DPH
    867              }
   \                     ??calcChkB_2:
   \   00003A   E8           MOV       A,R0
   \   00003B   FE           MOV       R6,A
   \   00003C   E9           MOV       A,R1
   \   00003D   FF           MOV       R7,A
   \   00003E   EE           MOV       A,R6
   \   00003F   24FF         ADD       A,#-0x1
   \   000041   18           DEC       R0
   \   000042   EF           MOV       A,R7
   \   000043   34FF         ADDC      A,#-0x1
   \   000045   F9           MOV       R1,A
   \   000046   EE           MOV       A,R6
   \   000047   4F           ORL       A,R7
   \   000048   70DF         JNZ       ??calcChkB_3
    868            }
    869          
    870            // calcChkF() will calculate over OSAL_NV_WORD_SIZE alignment.
    871            if ( fill )
   \                     ??calcChkB_1:
   \   00004A   E5..         MOV       A,?V0
   \   00004C   601E         JZ        ??calcChkB_4
    872            {
    873              chk += (OSAL_NV_WORD_SIZE - fill) * OSAL_NV_ERASED;
   \   00004E   F8           MOV       R0,A
   \   00004F   7404         MOV       A,#0x4
   \   000051   C3           CLR       C
   \   000052   98           SUBB      A,R0
   \   000053   F8           MOV       R0,A
   \   000054   95E0         SUBB      A,0xE0 /* A   */
   \   000056   F9           MOV       R1,A
   \   000057   E8           MOV       A,R0
   \   000058   75F0FF       MOV       B,#-0x1
   \   00005B   A4           MUL       AB
   \   00005C   F8           MOV       R0,A
   \   00005D   ACF0         MOV       R4,B
   \   00005F   75F0FF       MOV       B,#-0x1
   \   000062   E9           MOV       A,R1
   \   000063   A4           MUL       AB
   \   000064   2C           ADD       A,R4
   \   000065   F9           MOV       R1,A
   \   000066   EA           MOV       A,R2
   \   000067   28           ADD       A,R0
   \   000068   FA           MOV       R2,A
   \   000069   EB           MOV       A,R3
   \   00006A   39           ADDC      A,R1
   \   00006B   FB           MOV       R3,A
    874            }
    875          
    876            return chk;
   \                     ??calcChkB_4:
   \   00006C   7F01         MOV       R7,#0x1
   \   00006E   02....       LJMP      ?BANKED_LEAVE_XDATA
    877          }
    878          
    879          /*********************************************************************
    880           * @fn      calcChkF
    881           *
    882           * @brief   Calculates the data checksum by reading the data bytes from NV.
    883           *
    884           * @param   pg - A valid NV Flash page.
    885           * @param   offset - A valid offset into the page.
    886           * @param   len - Byte count of the data to be checksummed.
    887           *
    888           * @return  Calculated checksum of the data bytes.
    889           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    890          static uint16 calcChkF( uint8 pg, uint16 offset, uint16 len )
   \                     calcChkF:
    891          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V4,R1
   \   00000C   8A..         MOV       ?V2,R2
   \   00000E   8B..         MOV       ?V3,R3
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
    892            uint16 chk = 0;
   \   000012   75..00       MOV       ?V0,#0x0
   \   000015   75..00       MOV       ?V1,#0x0
    893          
    894            len = (len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE;
   \   000018   EC           MOV       A,R4
   \   000019   2403         ADD       A,#0x3
   \   00001B   F5..         MOV       ?V6,A
   \   00001D   E4           CLR       A
   \   00001E   3F           ADDC      A,R7
   \   00001F   F5..         MOV       ?V7,A
   \   000021   7402         MOV       A,#0x2
   \   000023   78..         MOV       R0,#?V6
   \   000025   12....       LCALL     ?US_SHR
   \   000028   AE..         MOV       R6,?V6
   \   00002A   AF..         MOV       R7,?V7
    895          
    896            while ( len-- )
   \                     ??calcChkF_0:
   \   00002C   EE           MOV       A,R6
   \   00002D   F8           MOV       R0,A
   \   00002E   EF           MOV       A,R7
   \   00002F   F9           MOV       R1,A
   \   000030   E8           MOV       A,R0
   \   000031   24FF         ADD       A,#-0x1
   \   000033   1E           DEC       R6
   \   000034   E9           MOV       A,R1
   \   000035   34FF         ADDC      A,#-0x1
   \   000037   FF           MOV       R7,A
   \   000038   E8           MOV       A,R0
   \   000039   49           ORL       A,R1
   \   00003A   6052         JZ        ??calcChkF_1
    897            {
    898              uint8 cnt, tmp[OSAL_NV_WORD_SIZE];
    899          
    900              HalFlashRead(pg, offset, tmp, OSAL_NV_WORD_SIZE);
   \   00003C                ; Setup parameters for call to function HalFlashRead
   \   00003C   75..04       MOV       ?V6,#0x4
   \   00003F   75..00       MOV       ?V7,#0x0
   \   000042   78..         MOV       R0,#?V6
   \   000044   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000047   7402         MOV       A,#0x2
   \   000049   12....       LCALL     ?XSTACK_DISP102_8
   \   00004C   AA..         MOV       R2,?V2
   \   00004E   AB..         MOV       R3,?V3
   \   000050   A9..         MOV       R1,?V4
   \   000052   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000055   7402         MOV       A,#0x2
   \   000057   12....       LCALL     ?DEALLOC_XSTACK8
    901              offset += OSAL_NV_WORD_SIZE;
   \   00005A   E5..         MOV       A,?V2
   \   00005C   2404         ADD       A,#0x4
   \   00005E   F5..         MOV       ?V2,A
   \   000060   E4           CLR       A
   \   000061   35..         ADDC      A,?V3
   \   000063   F5..         MOV       ?V3,A
    902          
    903              for ( cnt = 0; cnt < OSAL_NV_WORD_SIZE; cnt++ )
   \   000065   7800         MOV       R0,#0x0
   \                     ??calcChkF_2:
   \   000067   E8           MOV       A,R0
   \   000068   C3           CLR       C
   \   000069   9404         SUBB      A,#0x4
   \   00006B   50BF         JNC       ??calcChkF_0
    904              {
    905                chk += tmp[cnt];
   \   00006D   E8           MOV       A,R0
   \   00006E   FA           MOV       R2,A
   \   00006F   85..82       MOV       DPL,?XSP + 0
   \   000072   85..83       MOV       DPH,?XSP + 1
   \   000075   E582         MOV       A,DPL
   \   000077   2A           ADD       A,R2
   \   000078   F582         MOV       DPL,A
   \   00007A   E4           CLR       A
   \   00007B   3583         ADDC      A,DPH
   \   00007D   F583         MOV       DPH,A
   \   00007F   E0           MOVX      A,@DPTR
   \   000080   FA           MOV       R2,A
   \   000081   E5..         MOV       A,?V0
   \   000083   2A           ADD       A,R2
   \   000084   F5..         MOV       ?V0,A
   \   000086   E4           CLR       A
   \   000087   35..         ADDC      A,?V1
   \   000089   F5..         MOV       ?V1,A
    906              }
   \   00008B   08           INC       R0
   \   00008C   80D9         SJMP      ??calcChkF_2
    907            }
    908          
    909            return chk;
   \                     ??calcChkF_1:
   \   00008E   AA..         MOV       R2,?V0
   \   000090   AB..         MOV       R3,?V1
   \   000092   7404         MOV       A,#0x4
   \   000094   12....       LCALL     ?DEALLOC_XSTACK8
   \   000097   7F08         MOV       R7,#0x8
   \   000099   02....       LJMP      ?BANKED_LEAVE_XDATA
    910          }
    911          
    912          /*********************************************************************
    913           * @fn      writeWord
    914           *
    915           * @brief   Writes a Flash-WORD to NV.
    916           *
    917           * @param   pg - A valid NV Flash page.
    918           * @param   offset - A valid offset into the page.
    919           * @param   buf - Pointer to source buffer.
    920           *
    921           * @return  none
    922           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    923          static void writeWord( uint8 pg, uint16 offset, uint8 *buf )
   \                     writeWord:
    924          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    925            offset = (offset / HAL_FLASH_WORD_SIZE) +
    926                    ((uint16)pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
    927          
    928            HalFlashWrite(offset, buf, 1);
   \   000005                ; Setup parameters for call to function HalFlashWrite
   \   000005   75..01       MOV       ?V0,#0x1
   \   000008   75..00       MOV       ?V1,#0x0
   \   00000B   78..         MOV       R0,#?V0
   \   00000D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000010   8A..         MOV       ?V0,R2
   \   000012   8B..         MOV       ?V1,R3
   \   000014   7402         MOV       A,#0x2
   \   000016   78..         MOV       R0,#?V0
   \   000018   12....       LCALL     ?US_SHR
   \   00001B   E9           MOV       A,R1
   \   00001C   F5..         MOV       ?V2,A
   \   00001E   75..00       MOV       ?V3,#0x0
   \   000021   7409         MOV       A,#0x9
   \   000023   78..         MOV       R0,#?V2
   \   000025   12....       LCALL     ?S_SHL
   \   000028   E5..         MOV       A,?V0
   \   00002A   2400         ADD       A,#0x0
   \   00002C   FA           MOV       R2,A
   \   00002D   E5..         MOV       A,?V1
   \   00002F   35..         ADDC      A,?V3
   \   000031   FB           MOV       R3,A
   \   000032   12....       LCALL     `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
   \   000035   7402         MOV       A,#0x2
   \   000037   12....       LCALL     ?DEALLOC_XSTACK8
    929          }
   \   00003A   7F04         MOV       R7,#0x4
   \   00003C   02....       LJMP      ?BANKED_LEAVE_XDATA
    930          
    931          /*********************************************************************
    932           * @fn      writeWordM
    933           *
    934           * @brief   Writes multiple Flash-WORDs to NV.
    935           *
    936           * @param   pg - A valid NV Flash page.
    937           * @param   offset - A valid offset into the page.
    938           * @param   buf - Pointer to source buffer.
    939           * @param   cnt - Number of 4-byte blocks to write.
    940           *
    941           * @return  none
    942           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    943          static void writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint16 cnt )
   \                     writeWordM:
    944          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    945            offset = (offset / HAL_FLASH_WORD_SIZE) +
    946                    ((uint16)pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
    947            HalFlashWrite(offset, buf, cnt);
   \   000005                ; Setup parameters for call to function HalFlashWrite
   \   000005   740C         MOV       A,#0xc
   \   000007   12....       LCALL     ?XSTACK_DISP0_8
   \   00000A   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00000D   8A..         MOV       ?V0,R2
   \   00000F   8B..         MOV       ?V1,R3
   \   000011   7402         MOV       A,#0x2
   \   000013   78..         MOV       R0,#?V0
   \   000015   12....       LCALL     ?US_SHR
   \   000018   E9           MOV       A,R1
   \   000019   F5..         MOV       ?V2,A
   \   00001B   75..00       MOV       ?V3,#0x0
   \   00001E   7409         MOV       A,#0x9
   \   000020   78..         MOV       R0,#?V2
   \   000022   12....       LCALL     ?S_SHL
   \   000025   E5..         MOV       A,?V0
   \   000027   2400         ADD       A,#0x0
   \   000029   FA           MOV       R2,A
   \   00002A   E5..         MOV       A,?V1
   \   00002C   35..         ADDC      A,?V3
   \   00002E   FB           MOV       R3,A
   \   00002F   12....       LCALL     `??HalFlashWrite::?relay`; Banked call to: HalFlashWrite
   \   000032   7402         MOV       A,#0x2
   \   000034   12....       LCALL     ?DEALLOC_XSTACK8
    948          }
   \   000037   7F04         MOV       R7,#0x4
   \   000039   02....       LJMP      ?BANKED_LEAVE_XDATA
    949          
    950          /*********************************************************************
    951           * @fn      writeWordH
    952           *
    953           * @brief   Writes the 1st half of a Flash-WORD to NV (filling 2nd half with 0xffff).
    954           *
    955           * @param   pg - A valid NV Flash page.
    956           * @param   offset - A valid offset into the page.
    957           * @param   buf - Pointer to source buffer.
    958           *
    959           * @return  none
    960           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    961          static void writeWordH( uint8 pg, uint16 offset, uint8 *buf )
   \                     writeWordH:
    962          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    963            uint8 tmp[4];
    964          
    965            tmp[0] = buf[0];
   \   00000A   8C82         MOV       DPL,R4
   \   00000C   8D83         MOV       DPH,R5
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   85..82       MOV       DPL,?XSP + 0
   \   000012   85..83       MOV       DPH,?XSP + 1
   \   000015   F0           MOVX      @DPTR,A
    966            tmp[1] = buf[1];
   \   000016   8C82         MOV       DPL,R4
   \   000018   8D83         MOV       DPH,R5
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   C0E0         PUSH      A
   \   00001E   7401         MOV       A,#0x1
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   D0E0         POP       A
   \   000025   F0           MOVX      @DPTR,A
    967            tmp[2] = OSAL_NV_ERASED;
   \   000026   7402         MOV       A,#0x2
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   74FF         MOV       A,#-0x1
   \   00002D   F0           MOVX      @DPTR,A
    968            tmp[3] = OSAL_NV_ERASED;
   \   00002E   7403         MOV       A,#0x3
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   74FF         MOV       A,#-0x1
   \   000035   F0           MOVX      @DPTR,A
    969          
    970            writeWord( pg, offset, tmp );
   \   000036                ; Setup parameters for call to function writeWord
   \   000036   AC..         MOV       R4,?XSP + 0
   \   000038   AD..         MOV       R5,?XSP + 1
   \   00003A   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
    971          }
   \   00003D   7404         MOV       A,#0x4
   \   00003F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000042   7F01         MOV       R7,#0x1
   \   000044   02....       LJMP      ?BANKED_LEAVE_XDATA
    972          
    973          /*********************************************************************
    974           * @fn      writeBuf
    975           *
    976           * @brief   Writes a data buffer to NV.
    977           *
    978           * @param   dstPg - A valid NV Flash page.
    979           * @param   offset - A valid offset into the page.
    980           * @param   len  - Byte count of the data to write.
    981           * @param   buf  - The data to write.
    982           *
    983           * @return  TRUE if data buf checksum matches read back checksum, else FALSE.
    984           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    985          static void writeBuf( uint8 dstPg, uint16 dstOff, uint16 len, uint8 *buf )
   \                     writeBuf:
    986          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V1,R1
   \   00000C   EA           MOV       A,R2
   \   00000D   FE           MOV       R6,A
   \   00000E   EB           MOV       A,R3
   \   00000F   FF           MOV       R7,A
   \   000010   8C..         MOV       ?V4,R4
   \   000012   8D..         MOV       ?V5,R5
    987            uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
   \   000014   EA           MOV       A,R2
   \   000015   5403         ANL       A,#0x3
   \   000017   F5..         MOV       ?V0,A
   \   000019   7414         MOV       A,#0x14
   \   00001B   12....       LCALL     ?XSTACK_DISP0_8
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F5..         MOV       ?V2,A
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   F5..         MOV       ?V3,A
    988            uint8 tmp[OSAL_NV_WORD_SIZE];
    989          
    990            if ( rem )
   \   000025   E5..         MOV       A,?V0
   \   000027   607A         JZ        ??writeBuf_0
    991            {
    992              dstOff = (dstOff / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
   \   000029   74FC         MOV       A,#-0x4
   \   00002B   5E           ANL       A,R6
   \   00002C   FE           MOV       R6,A
    993              HalFlashRead(dstPg, dstOff, tmp, OSAL_NV_WORD_SIZE);
   \   00002D                ; Setup parameters for call to function HalFlashRead
   \   00002D   75..04       MOV       ?V6,#0x4
   \   000030   75..00       MOV       ?V7,#0x0
   \   000033   78..         MOV       R0,#?V6
   \   000035   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000038   7402         MOV       A,#0x2
   \   00003A   12....       LCALL     ?XSTACK_DISP102_8
   \   00003D   EE           MOV       A,R6
   \   00003E   FA           MOV       R2,A
   \   00003F   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000042   7402         MOV       A,#0x2
   \   000044   12....       LCALL     ?DEALLOC_XSTACK8
   \   000047   8039         SJMP      ??writeBuf_1
    994          
    995              while ( (rem < OSAL_NV_WORD_SIZE) && len )
    996              {
    997                tmp[rem++] = *buf++;
   \                     ??writeBuf_2:
   \   000049   85..82       MOV       DPL,?V2
   \   00004C   85..83       MOV       DPH,?V3
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   C0E0         PUSH      A
   \   000052   A8..         MOV       R0,?V0
   \   000054   85..82       MOV       DPL,?XSP + 0
   \   000057   85..83       MOV       DPH,?XSP + 1
   \   00005A   E582         MOV       A,DPL
   \   00005C   28           ADD       A,R0
   \   00005D   F582         MOV       DPL,A
   \   00005F   E4           CLR       A
   \   000060   3583         ADDC      A,DPH
   \   000062   F583         MOV       DPH,A
   \   000064   D0E0         POP       A
   \   000066   F0           MOVX      @DPTR,A
   \   000067   85..82       MOV       DPL,?V2
   \   00006A   85..83       MOV       DPH,?V3
   \   00006D   A3           INC       DPTR
   \   00006E   8582..       MOV       ?V2,DPL
   \   000071   8583..       MOV       ?V3,DPH
   \   000074   05..         INC       ?V0
    998                len--;
   \   000076   E5..         MOV       A,?V4
   \   000078   24FF         ADD       A,#-0x1
   \   00007A   F5..         MOV       ?V4,A
   \   00007C   E5..         MOV       A,?V5
   \   00007E   34FF         ADDC      A,#-0x1
   \   000080   F5..         MOV       ?V5,A
    999              }
   \                     ??writeBuf_1:
   \   000082   E5..         MOV       A,?V0
   \   000084   C3           CLR       C
   \   000085   9404         SUBB      A,#0x4
   \   000087   5006         JNC       ??writeBuf_3
   \   000089   E5..         MOV       A,?V4
   \   00008B   45..         ORL       A,?V5
   \   00008D   70BA         JNZ       ??writeBuf_2
   1000          
   1001              writeWord( dstPg, dstOff, tmp );
   \                     ??writeBuf_3:
   \   00008F                ; Setup parameters for call to function writeWord
   \   00008F   AC..         MOV       R4,?XSP + 0
   \   000091   AD..         MOV       R5,?XSP + 1
   \   000093   EE           MOV       A,R6
   \   000094   FA           MOV       R2,A
   \   000095   EF           MOV       A,R7
   \   000096   FB           MOV       R3,A
   \   000097   A9..         MOV       R1,?V1
   \   000099   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
   1002              dstOff += OSAL_NV_WORD_SIZE;
   \   00009C   EE           MOV       A,R6
   \   00009D   2404         ADD       A,#0x4
   \   00009F   FE           MOV       R6,A
   \   0000A0   E4           CLR       A
   \   0000A1   3F           ADDC      A,R7
   \   0000A2   FF           MOV       R7,A
   1003            }
   1004          
   1005            rem = len % OSAL_NV_WORD_SIZE;
   \                     ??writeBuf_0:
   \   0000A3   E5..         MOV       A,?V4
   \   0000A5   5403         ANL       A,#0x3
   \   0000A7   F5..         MOV       ?V0,A
   1006            len /= OSAL_NV_WORD_SIZE;
   \   0000A9   85....       MOV       ?V6,?V4
   \   0000AC   85....       MOV       ?V7,?V5
   \   0000AF   7402         MOV       A,#0x2
   \   0000B1   78..         MOV       R0,#?V6
   \   0000B3   12....       LCALL     ?US_SHR
   \   0000B6   85....       MOV       ?V4,?V6
   \   0000B9   85....       MOV       ?V5,?V7
   1007          
   1008            if ( len )
   \   0000BC   E5..         MOV       A,?V4
   \   0000BE   45..         ORL       A,?V5
   \   0000C0   6032         JZ        ??writeBuf_4
   1009            {
   1010              writeWordM( dstPg, dstOff, buf, len );
   \   0000C2                ; Setup parameters for call to function writeWordM
   \   0000C2   78..         MOV       R0,#?V4
   \   0000C4   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C7   AC..         MOV       R4,?V2
   \   0000C9   AD..         MOV       R5,?V3
   \   0000CB   EE           MOV       A,R6
   \   0000CC   FA           MOV       R2,A
   \   0000CD   EF           MOV       A,R7
   \   0000CE   FB           MOV       R3,A
   \   0000CF   A9..         MOV       R1,?V1
   \   0000D1   12....       LCALL     `??writeWordM::?relay`; Banked call to: writeWordM
   \   0000D4   7402         MOV       A,#0x2
   \   0000D6   12....       LCALL     ?DEALLOC_XSTACK8
   1011              dstOff += OSAL_NV_WORD_SIZE * len;
   \   0000D9   7402         MOV       A,#0x2
   \   0000DB   78..         MOV       R0,#?V4
   \   0000DD   12....       LCALL     ?S_SHL
   \   0000E0   A8..         MOV       R0,?V4
   \   0000E2   A9..         MOV       R1,?V5
   \   0000E4   EE           MOV       A,R6
   \   0000E5   28           ADD       A,R0
   \   0000E6   FE           MOV       R6,A
   \   0000E7   EF           MOV       A,R7
   \   0000E8   39           ADDC      A,R1
   \   0000E9   FF           MOV       R7,A
   1012              buf += OSAL_NV_WORD_SIZE * len;
   \   0000EA   E5..         MOV       A,?V2
   \   0000EC   28           ADD       A,R0
   \   0000ED   F5..         MOV       ?V2,A
   \   0000EF   E5..         MOV       A,?V3
   \   0000F1   39           ADDC      A,R1
   \   0000F2   F5..         MOV       ?V3,A
   1013            }
   1014          
   1015            if ( rem )
   \                     ??writeBuf_4:
   \   0000F4   E5..         MOV       A,?V0
   \   0000F6   6069         JZ        ??writeBuf_5
   1016            {
   1017              uint8 idx = 0;
   \   0000F8   75..00       MOV       ?V4,#0x0
   1018              HalFlashRead(dstPg, dstOff, tmp, OSAL_NV_WORD_SIZE);
   \   0000FB                ; Setup parameters for call to function HalFlashRead
   \   0000FB   75..04       MOV       ?V6,#0x4
   \   0000FE   75..00       MOV       ?V7,#0x0
   \   000101   78..         MOV       R0,#?V6
   \   000103   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000106   7402         MOV       A,#0x2
   \   000108   12....       LCALL     ?XSTACK_DISP102_8
   \   00010B   EE           MOV       A,R6
   \   00010C   FA           MOV       R2,A
   \   00010D   EF           MOV       A,R7
   \   00010E   FB           MOV       R3,A
   \   00010F   A9..         MOV       R1,?V1
   \   000111   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000114   7402         MOV       A,#0x2
   \   000116   12....       LCALL     ?DEALLOC_XSTACK8
   \   000119   802D         SJMP      ??writeBuf_6
   1019              while ( rem-- )
   1020              {
   1021                tmp[idx++] = *buf++;
   \                     ??writeBuf_7:
   \   00011B   85..82       MOV       DPL,?V2
   \   00011E   85..83       MOV       DPH,?V3
   \   000121   E0           MOVX      A,@DPTR
   \   000122   C0E0         PUSH      A
   \   000124   A8..         MOV       R0,?V4
   \   000126   85..82       MOV       DPL,?XSP + 0
   \   000129   85..83       MOV       DPH,?XSP + 1
   \   00012C   E582         MOV       A,DPL
   \   00012E   28           ADD       A,R0
   \   00012F   F582         MOV       DPL,A
   \   000131   E4           CLR       A
   \   000132   3583         ADDC      A,DPH
   \   000134   F583         MOV       DPH,A
   \   000136   D0E0         POP       A
   \   000138   F0           MOVX      @DPTR,A
   \   000139   85..82       MOV       DPL,?V2
   \   00013C   85..83       MOV       DPH,?V3
   \   00013F   A3           INC       DPTR
   \   000140   8582..       MOV       ?V2,DPL
   \   000143   8583..       MOV       ?V3,DPH
   \   000146   05..         INC       ?V4
   1022              }
   \                     ??writeBuf_6:
   \   000148   85....       MOV       ?V5,?V0
   \   00014B   74FF         MOV       A,#-0x1
   \   00014D   25..         ADD       A,?V5
   \   00014F   F5..         MOV       ?V0,A
   \   000151   04           INC       A
   \   000152   70C7         JNZ       ??writeBuf_7
   1023              writeWord( dstPg, dstOff, tmp );
   \   000154                ; Setup parameters for call to function writeWord
   \   000154   AC..         MOV       R4,?XSP + 0
   \   000156   AD..         MOV       R5,?XSP + 1
   \   000158   EE           MOV       A,R6
   \   000159   FA           MOV       R2,A
   \   00015A   EF           MOV       A,R7
   \   00015B   FB           MOV       R3,A
   \   00015C   A9..         MOV       R1,?V1
   \   00015E   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
   1024            }
   1025          }
   \                     ??writeBuf_5:
   \   000161   7404         MOV       A,#0x4
   \   000163   12....       LCALL     ?DEALLOC_XSTACK8
   \   000166   7F08         MOV       R7,#0x8
   \   000168   02....       LJMP      ?BANKED_LEAVE_XDATA
   1026          
   1027          /*********************************************************************
   1028           * @fn      xferBuf
   1029           *
   1030           * @brief   Xfers an NV buffer from one location to another, enforcing OSAL_NV_WORD_SIZE writes.
   1031           *
   1032           * @return  none
   1033           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1034          static void xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len )
   \                     xferBuf:
   1035          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V6,R1
   \   00000C   8A..         MOV       ?V4,R2
   \   00000E   8B..         MOV       ?V5,R3
   \   000010   8C..         MOV       ?V3,R4
   \   000012   7416         MOV       A,#0x16
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F5..         MOV       ?V0,A
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F5..         MOV       ?V1,A
   1036            uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
   \   00001E   E5..         MOV       A,?V0
   \   000020   5403         ANL       A,#0x3
   \   000022   F5..         MOV       ?V2,A
   \   000024   7418         MOV       A,#0x18
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   FE           MOV       R6,A
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   FF           MOV       R7,A
   1037            uint8 tmp[OSAL_NV_WORD_SIZE];
   1038          
   1039            if ( rem )
   \   00002E   E5..         MOV       A,?V2
   \   000030   7003         JNZ       $+5
   \   000032   02....       LJMP      ??xferBuf_0 & 0xFFFF
   1040            {
   1041              dstOff -= rem;
   \   000035   F8           MOV       R0,A
   \   000036   C3           CLR       C
   \   000037   E5..         MOV       A,?V0
   \   000039   98           SUBB      A,R0
   \   00003A   F5..         MOV       ?V0,A
   \   00003C   E5..         MOV       A,?V1
   \   00003E   9400         SUBB      A,#0x0
   \   000040   F5..         MOV       ?V1,A
   1042              HalFlashRead(dstPg, dstOff, tmp, OSAL_NV_WORD_SIZE);
   \   000042                ; Setup parameters for call to function HalFlashRead
   \   000042   75..04       MOV       ?V8,#0x4
   \   000045   75..00       MOV       ?V9,#0x0
   \   000048   78..         MOV       R0,#?V8
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004D   7402         MOV       A,#0x2
   \   00004F   12....       LCALL     ?XSTACK_DISP102_8
   \   000052   AA..         MOV       R2,?V0
   \   000054   AB..         MOV       R3,?V1
   \   000056   A9..         MOV       R1,?V3
   \   000058   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   00005B   7402         MOV       A,#0x2
   \   00005D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000060   8037         SJMP      ??xferBuf_1
   1043          
   1044              while ( (rem < OSAL_NV_WORD_SIZE) && len )
   1045              {
   1046                HalFlashRead(srcPg, srcOff, tmp+rem, 1);
   \                     ??xferBuf_2:
   \   000062                ; Setup parameters for call to function HalFlashRead
   \   000062   75..01       MOV       ?V8,#0x1
   \   000065   78..         MOV       R0,#?V8
   \   000067   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006A   A8..         MOV       R0,?V2
   \   00006C   7402         MOV       A,#0x2
   \   00006E   12....       LCALL     ?XSTACK_DISP0_8
   \   000071   E582         MOV       A,DPL
   \   000073   28           ADD       A,R0
   \   000074   FC           MOV       R4,A
   \   000075   E4           CLR       A
   \   000076   3583         ADDC      A,DPH
   \   000078   FD           MOV       R5,A
   \   000079   AA..         MOV       R2,?V4
   \   00007B   AB..         MOV       R3,?V5
   \   00007D   A9..         MOV       R1,?V6
   \   00007F   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000082   7402         MOV       A,#0x2
   \   000084   12....       LCALL     ?DEALLOC_XSTACK8
   1047                srcOff++;
   \   000087   05..         INC       ?V4
   \   000089   E5..         MOV       A,?V4
   \   00008B   7002         JNZ       ??xferBuf_3
   \   00008D   05..         INC       ?V5
   1048                rem++;
   \                     ??xferBuf_3:
   \   00008F   05..         INC       ?V2
   1049                len--;
   \   000091   EE           MOV       A,R6
   \   000092   24FF         ADD       A,#-0x1
   \   000094   1E           DEC       R6
   \   000095   EF           MOV       A,R7
   \   000096   34FF         ADDC      A,#-0x1
   \   000098   FF           MOV       R7,A
   1050              }
   \                     ??xferBuf_1:
   \   000099   E5..         MOV       A,?V2
   \   00009B   C3           CLR       C
   \   00009C   9404         SUBB      A,#0x4
   \   00009E   5004         JNC       ??xferBuf_4
   \   0000A0   EE           MOV       A,R6
   \   0000A1   4F           ORL       A,R7
   \   0000A2   70BE         JNZ       ??xferBuf_2
   1051          
   1052              writeWord( dstPg, dstOff, tmp );
   \                     ??xferBuf_4:
   \   0000A4                ; Setup parameters for call to function writeWord
   \   0000A4   AC..         MOV       R4,?XSP + 0
   \   0000A6   AD..         MOV       R5,?XSP + 1
   \   0000A8   AA..         MOV       R2,?V0
   \   0000AA   AB..         MOV       R3,?V1
   \   0000AC   A9..         MOV       R1,?V3
   \   0000AE   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
   1053              dstOff += OSAL_NV_WORD_SIZE;
   \   0000B1   E5..         MOV       A,?V0
   \   0000B3   2404         ADD       A,#0x4
   \   0000B5   F5..         MOV       ?V0,A
   \   0000B7   E4           CLR       A
   \   0000B8   35..         ADDC      A,?V1
   \   0000BA   F5..         MOV       ?V1,A
   1054            }
   1055          
   1056            rem = len % OSAL_NV_WORD_SIZE;
   \                     ??xferBuf_0:
   \   0000BC   EE           MOV       A,R6
   \   0000BD   5403         ANL       A,#0x3
   \   0000BF   F5..         MOV       ?V2,A
   1057            len /= OSAL_NV_WORD_SIZE;
   \   0000C1   8E..         MOV       ?V8,R6
   \   0000C3   8F..         MOV       ?V9,R7
   \   0000C5   7402         MOV       A,#0x2
   \   0000C7   78..         MOV       R0,#?V8
   \   0000C9   12....       LCALL     ?US_SHR
   \   0000CC   AE..         MOV       R6,?V8
   \   0000CE   AF..         MOV       R7,?V9
   \   0000D0   8041         SJMP      ??xferBuf_5
   1058          
   1059            while ( len-- )
   1060            {
   1061              HalFlashRead(srcPg, srcOff, tmp, OSAL_NV_WORD_SIZE);
   \                     ??xferBuf_6:
   \   0000D2                ; Setup parameters for call to function HalFlashRead
   \   0000D2   75..04       MOV       ?V8,#0x4
   \   0000D5   75..00       MOV       ?V9,#0x0
   \   0000D8   78..         MOV       R0,#?V8
   \   0000DA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000DD   7402         MOV       A,#0x2
   \   0000DF   12....       LCALL     ?XSTACK_DISP102_8
   \   0000E2   AA..         MOV       R2,?V4
   \   0000E4   AB..         MOV       R3,?V5
   \   0000E6   A9..         MOV       R1,?V6
   \   0000E8   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   0000EB   7402         MOV       A,#0x2
   \   0000ED   12....       LCALL     ?DEALLOC_XSTACK8
   1062              srcOff += OSAL_NV_WORD_SIZE;
   \   0000F0   E5..         MOV       A,?V4
   \   0000F2   2404         ADD       A,#0x4
   \   0000F4   F5..         MOV       ?V4,A
   \   0000F6   E4           CLR       A
   \   0000F7   35..         ADDC      A,?V5
   \   0000F9   F5..         MOV       ?V5,A
   1063              writeWord( dstPg, dstOff, tmp );
   \   0000FB                ; Setup parameters for call to function writeWord
   \   0000FB   AC..         MOV       R4,?XSP + 0
   \   0000FD   AD..         MOV       R5,?XSP + 1
   \   0000FF   AA..         MOV       R2,?V0
   \   000101   AB..         MOV       R3,?V1
   \   000103   A9..         MOV       R1,?V3
   \   000105   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
   1064              dstOff += OSAL_NV_WORD_SIZE;
   \   000108   E5..         MOV       A,?V0
   \   00010A   2404         ADD       A,#0x4
   \   00010C   F5..         MOV       ?V0,A
   \   00010E   E4           CLR       A
   \   00010F   35..         ADDC      A,?V1
   \   000111   F5..         MOV       ?V1,A
   1065            }
   \                     ??xferBuf_5:
   \   000113   EE           MOV       A,R6
   \   000114   F8           MOV       R0,A
   \   000115   EF           MOV       A,R7
   \   000116   F9           MOV       R1,A
   \   000117   E8           MOV       A,R0
   \   000118   24FF         ADD       A,#-0x1
   \   00011A   1E           DEC       R6
   \   00011B   E9           MOV       A,R1
   \   00011C   34FF         ADDC      A,#-0x1
   \   00011E   FF           MOV       R7,A
   \   00011F   E8           MOV       A,R0
   \   000120   49           ORL       A,R1
   \   000121   70AF         JNZ       ??xferBuf_6
   1066          
   1067            if ( rem )
   \   000123   E5..         MOV       A,?V2
   \   000125   6066         JZ        ??xferBuf_7
   1068            {
   1069              uint8 idx = 0;
   \   000127   7E00         MOV       R6,#0x0
   1070              HalFlashRead(dstPg, dstOff, tmp, OSAL_NV_WORD_SIZE);
   \   000129                ; Setup parameters for call to function HalFlashRead
   \   000129   75..04       MOV       ?V8,#0x4
   \   00012C   8E..         MOV       ?V9,R6
   \   00012E   78..         MOV       R0,#?V8
   \   000130   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000133   7402         MOV       A,#0x2
   \   000135   12....       LCALL     ?XSTACK_DISP102_8
   \   000138   AA..         MOV       R2,?V0
   \   00013A   AB..         MOV       R3,?V1
   \   00013C   A9..         MOV       R1,?V3
   \   00013E   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000141   7402         MOV       A,#0x2
   \   000143   12....       LCALL     ?DEALLOC_XSTACK8
   \   000146   802E         SJMP      ??xferBuf_8
   1071              while ( rem-- )
   1072              {
   1073                HalFlashRead(srcPg, srcOff, tmp+idx, 1);
   \                     ??xferBuf_9:
   \   000148                ; Setup parameters for call to function HalFlashRead
   \   000148   75..01       MOV       ?V8,#0x1
   \   00014B   78..         MOV       R0,#?V8
   \   00014D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000150   EE           MOV       A,R6
   \   000151   F8           MOV       R0,A
   \   000152   7402         MOV       A,#0x2
   \   000154   12....       LCALL     ?XSTACK_DISP0_8
   \   000157   E582         MOV       A,DPL
   \   000159   28           ADD       A,R0
   \   00015A   FC           MOV       R4,A
   \   00015B   E4           CLR       A
   \   00015C   3583         ADDC      A,DPH
   \   00015E   FD           MOV       R5,A
   \   00015F   AA..         MOV       R2,?V4
   \   000161   AB..         MOV       R3,?V5
   \   000163   A9..         MOV       R1,?V6
   \   000165   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000168   7402         MOV       A,#0x2
   \   00016A   12....       LCALL     ?DEALLOC_XSTACK8
   1074                srcOff++;
   \   00016D   05..         INC       ?V4
   \   00016F   E5..         MOV       A,?V4
   \   000171   7002         JNZ       ??xferBuf_10
   \   000173   05..         INC       ?V5
   1075                idx++;
   \                     ??xferBuf_10:
   \   000175   0E           INC       R6
   1076              }
   \                     ??xferBuf_8:
   \   000176   AF..         MOV       R7,?V2
   \   000178   74FF         MOV       A,#-0x1
   \   00017A   2F           ADD       A,R7
   \   00017B   F5..         MOV       ?V2,A
   \   00017D   04           INC       A
   \   00017E   70C8         JNZ       ??xferBuf_9
   1077              writeWord( dstPg, dstOff, tmp );
   \   000180                ; Setup parameters for call to function writeWord
   \   000180   AC..         MOV       R4,?XSP + 0
   \   000182   AD..         MOV       R5,?XSP + 1
   \   000184   AA..         MOV       R2,?V0
   \   000186   AB..         MOV       R3,?V1
   \   000188   A9..         MOV       R1,?V3
   \   00018A   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
   1078            }
   1079          }
   \                     ??xferBuf_7:
   \   00018D   7404         MOV       A,#0x4
   \   00018F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000192   7F0A         MOV       R7,#0xa
   \   000194   02....       LJMP      ?BANKED_LEAVE_XDATA
   1080          
   1081          /*********************************************************************
   1082           * @fn      writeItem
   1083           *
   1084           * @brief   Writes an item header/data combo to the specified NV page.
   1085           *
   1086           * @param   pg - Valid NV Flash page.
   1087           * @param   id - Valid NV item Id.
   1088           * @param   len  - Byte count of the data to write.
   1089           * @param   buf  - The data to write. If NULL, no data/checksum write.
   1090           * @param   flag - TRUE if the checksum should be written, FALSE otherwise.
   1091           *
   1092           * @return  TRUE if header/data to write matches header/data read back, else FALSE.
   1093           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1094          static uint8 writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag )
   \                     writeItem:
   1095          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V4,R1
   \   00000C   8A..         MOV       ?V6,R2
   \   00000E   8B..         MOV       ?V7,R3
   \   000010   EC           MOV       A,R4
   \   000011   FE           MOV       R6,A
   \   000012   ED           MOV       A,R5
   \   000013   FF           MOV       R7,A
   1096            uint16 offset = pgOff[pg-OSAL_NV_PAGE_BEG];
   \   000014   E9           MOV       A,R1
   \   000015   29           ADD       A,R1
   \   000016   F5..         MOV       ?V0,A
   \   000018   E4           CLR       A
   \   000019   33           RLC       A
   \   00001A   F5..         MOV       ?V1,A
   \   00001C   74..         MOV       A,#(pgOff + 14) & 0xff
   \   00001E   25..         ADD       A,?V0
   \   000020   F5..         MOV       ?V8,A
   \   000022   74..         MOV       A,#((pgOff - 242) >> 8) & 0xff
   \   000024   35..         ADDC      A,?V1
   \   000026   F5..         MOV       ?V9,A
   \   000028   85..82       MOV       DPL,?V8
   \   00002B   F583         MOV       DPH,A
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   F5..         MOV       ?V2,A
   \   000030   A3           INC       DPTR
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F5..         MOV       ?V3,A
   1097            uint8 rtrn = FALSE;
   \   000034   75..00       MOV       ?V5,#0x0
   1098            osalNvHdr_t hdr;
   1099          
   1100            hdr.id = id;
   \   000037   85..82       MOV       DPL,?XSP + 0
   \   00003A   85..83       MOV       DPH,?XSP + 1
   \   00003D   EA           MOV       A,R2
   \   00003E   F0           MOVX      @DPTR,A
   \   00003F   A3           INC       DPTR
   \   000040   EB           MOV       A,R3
   \   000041   F0           MOVX      @DPTR,A
   1101            hdr.len = len;
   \   000042   7402         MOV       A,#0x2
   \   000044   12....       LCALL     ?XSTACK_DISP0_8
   \   000047   EC           MOV       A,R4
   \   000048   F0           MOVX      @DPTR,A
   \   000049   A3           INC       DPTR
   \   00004A   ED           MOV       A,R5
   \   00004B   F0           MOVX      @DPTR,A
   1102          
   1103            writeWord( pg, offset, (uint8 *)&hdr );
   \   00004C                ; Setup parameters for call to function writeWord
   \   00004C   AC..         MOV       R4,?XSP + 0
   \   00004E   AD..         MOV       R5,?XSP + 1
   \   000050   AA..         MOV       R2,?V2
   \   000052   AB..         MOV       R3,?V3
   \   000054   12....       LCALL     `??writeWord::?relay`; Banked call to: writeWord
   1104            HalFlashRead(pg, offset, (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
   \   000057                ; Setup parameters for call to function HalFlashRead
   \   000057   75..08       MOV       ?V10,#0x8
   \   00005A   75..00       MOV       ?V11,#0x0
   \   00005D   78..         MOV       R0,#?V10
   \   00005F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000062   7402         MOV       A,#0x2
   \   000064   12....       LCALL     ?XSTACK_DISP102_8
   \   000067   AA..         MOV       R2,?V2
   \   000069   AB..         MOV       R3,?V3
   \   00006B   A9..         MOV       R1,?V4
   \   00006D   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000070   7402         MOV       A,#0x2
   \   000072   12....       LCALL     ?DEALLOC_XSTACK8
   1105          
   1106            if ( (hdr.id == id) && (hdr.len == len) )
   \   000075   7402         MOV       A,#0x2
   \   000077   12....       LCALL     ?XSTACK_DISP0_8
   \   00007A   E0           MOVX      A,@DPTR
   \   00007B   F8           MOV       R0,A
   \   00007C   A3           INC       DPTR
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   F9           MOV       R1,A
   \   00007F   85..82       MOV       DPL,?XSP + 0
   \   000082   85..83       MOV       DPH,?XSP + 1
   \   000085   E0           MOVX      A,@DPTR
   \   000086   65..         XRL       A,?V6
   \   000088   7004         JNZ       ??writeItem_0
   \   00008A   A3           INC       DPTR
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   65..         XRL       A,?V7
   \                     ??writeItem_0:
   \   00008E   6003         JZ        $+5
   \   000090   02....       LJMP      ??writeItem_1 & 0xFFFF
   \   000093   EE           MOV       A,R6
   \   000094   68           XRL       A,R0
   \   000095   7002         JNZ       ??writeItem_2
   \   000097   EF           MOV       A,R7
   \   000098   69           XRL       A,R1
   \                     ??writeItem_2:
   \   000099   6003         JZ        $+5
   \   00009B   02....       LJMP      ??writeItem_1 & 0xFFFF
   1107            {
   1108              if ( flag )
   \   00009E   741E         MOV       A,#0x1e
   \   0000A0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   7003         JNZ       $+5
   \   0000A6   02....       LJMP      ??writeItem_3 & 0xFFFF
   \   0000A9   741C         MOV       A,#0x1c
   \   0000AB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AE   E0           MOVX      A,@DPTR
   \   0000AF   F5..         MOV       ?V0,A
   \   0000B1   A3           INC       DPTR
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   F5..         MOV       ?V1,A
   1109              {
   1110                hdr.chk = calcChkB( len, buf );
   \   0000B5                ; Setup parameters for call to function calcChkB
   \   0000B5   AC..         MOV       R4,?V0
   \   0000B7   FD           MOV       R5,A
   \   0000B8   EE           MOV       A,R6
   \   0000B9   FA           MOV       R2,A
   \   0000BA   EF           MOV       A,R7
   \   0000BB   FB           MOV       R3,A
   \   0000BC   12....       LCALL     `??calcChkB::?relay`; Banked call to: calcChkB
   \   0000BF   7404         MOV       A,#0x4
   \   0000C1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C4   EA           MOV       A,R2
   \   0000C5   F0           MOVX      @DPTR,A
   \   0000C6   A3           INC       DPTR
   \   0000C7   EB           MOV       A,R3
   \   0000C8   F0           MOVX      @DPTR,A
   1111          
   1112                offset += OSAL_NV_HDR_SIZE;
   \   0000C9   E5..         MOV       A,?V2
   \   0000CB   2408         ADD       A,#0x8
   \   0000CD   F5..         MOV       ?V2,A
   \   0000CF   E4           CLR       A
   \   0000D0   35..         ADDC      A,?V3
   \   0000D2   F5..         MOV       ?V3,A
   1113                if ( buf != NULL )
   \   0000D4   E5..         MOV       A,?V0
   \   0000D6   45..         ORL       A,?V1
   \   0000D8   6017         JZ        ??writeItem_4
   1114                {
   1115                  writeBuf( pg, offset, len, buf );
   \   0000DA                ; Setup parameters for call to function writeBuf
   \   0000DA   78..         MOV       R0,#?V0
   \   0000DC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000DF   EE           MOV       A,R6
   \   0000E0   FC           MOV       R4,A
   \   0000E1   EF           MOV       A,R7
   \   0000E2   FD           MOV       R5,A
   \   0000E3   AA..         MOV       R2,?V2
   \   0000E5   AB..         MOV       R3,?V3
   \   0000E7   A9..         MOV       R1,?V4
   \   0000E9   12....       LCALL     `??writeBuf::?relay`; Banked call to: writeBuf
   \   0000EC   7402         MOV       A,#0x2
   \   0000EE   12....       LCALL     ?DEALLOC_XSTACK8
   1116                }
   1117          
   1118                if ( hdr.chk == calcChkF( pg, offset, len ) )
   \                     ??writeItem_4:
   \   0000F1                ; Setup parameters for call to function calcChkF
   \   0000F1   EE           MOV       A,R6
   \   0000F2   FC           MOV       R4,A
   \   0000F3   EF           MOV       A,R7
   \   0000F4   FD           MOV       R5,A
   \   0000F5   AA..         MOV       R2,?V2
   \   0000F7   AB..         MOV       R3,?V3
   \   0000F9   A9..         MOV       R1,?V4
   \   0000FB   12....       LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
   \   0000FE   7404         MOV       A,#0x4
   \   000100   12....       LCALL     ?XSTACK_DISP0_8
   \   000103   E0           MOVX      A,@DPTR
   \   000104   FC           MOV       R4,A
   \   000105   A3           INC       DPTR
   \   000106   E0           MOVX      A,@DPTR
   \   000107   FD           MOV       R5,A
   \   000108   EA           MOV       A,R2
   \   000109   6C           XRL       A,R4
   \   00010A   7002         JNZ       ??writeItem_5
   \   00010C   EB           MOV       A,R3
   \   00010D   6D           XRL       A,R5
   \                     ??writeItem_5:
   \   00010E   7036         JNZ       ??writeItem_6
   1119                {
   1120                  if ( hdr.chk == setChk( pg, offset, hdr.chk ) )
   \   000110                ; Setup parameters for call to function setChk
   \   000110   AA..         MOV       R2,?V2
   \   000112   AB..         MOV       R3,?V3
   \   000114   A9..         MOV       R1,?V4
   \   000116   12....       LCALL     `??setChk::?relay`; Banked call to: setChk
   \   000119   8A..         MOV       ?V0,R2
   \   00011B   8B..         MOV       ?V1,R3
   \   00011D   A8..         MOV       R0,?V0
   \   00011F   A9..         MOV       R1,?V1
   \   000121   7404         MOV       A,#0x4
   \   000123   12....       LCALL     ?XSTACK_DISP0_8
   \   000126   E0           MOVX      A,@DPTR
   \   000127   68           XRL       A,R0
   \   000128   7003         JNZ       ??writeItem_7
   \   00012A   A3           INC       DPTR
   \   00012B   E0           MOVX      A,@DPTR
   \   00012C   69           XRL       A,R1
   \                     ??writeItem_7:
   \   00012D   7017         JNZ       ??writeItem_6
   1121                  {
   1122                    hotItemUpdate(pg, offset, hdr.id);
   \   00012F                ; Setup parameters for call to function hotItemUpdate
   \   00012F   85..82       MOV       DPL,?XSP + 0
   \   000132   85..83       MOV       DPH,?XSP + 1
   \   000135   E0           MOVX      A,@DPTR
   \   000136   FC           MOV       R4,A
   \   000137   A3           INC       DPTR
   \   000138   E0           MOVX      A,@DPTR
   \   000139   FD           MOV       R5,A
   \   00013A   AA..         MOV       R2,?V2
   \   00013C   AB..         MOV       R3,?V3
   \   00013E   A9..         MOV       R1,?V4
   \   000140   12....       LCALL     `??hotItemUpdate::?relay`; Banked call to: hotItemUpdate
   1123                    rtrn = TRUE;
   1124                  }
   1125                }
   1126              }
   1127              else
   1128              {
   1129                rtrn = TRUE;
   \                     ??writeItem_3:
   \   000143   75..01       MOV       ?V5,#0x1
   1130              }
   1131          
   1132              len = OSAL_NV_ITEM_SIZE( hdr.len );
   \                     ??writeItem_6:
   \   000146   7402         MOV       A,#0x2
   \   000148   12....       LCALL     ?XSTACK_DISP0_8
   \   00014B   E0           MOVX      A,@DPTR
   \   00014C   F8           MOV       R0,A
   \   00014D   A3           INC       DPTR
   \   00014E   E0           MOVX      A,@DPTR
   \   00014F   F9           MOV       R1,A
   \   000150   C3           CLR       C
   \   000151   E8           MOV       A,R0
   \   000152   94F4         SUBB      A,#-0xc
   \   000154   E9           MOV       A,R1
   \   000155   94FF         SUBB      A,#-0x1
   \   000157   4006         JC        ??writeItem_8
   \   000159   7EFC         MOV       R6,#-0x4
   \   00015B   7FFF         MOV       R7,#-0x1
   \   00015D   805E         SJMP      ??writeItem_9
   \                     ??writeItem_8:
   \   00015F   E8           MOV       A,R0
   \   000160   2403         ADD       A,#0x3
   \   000162   5001         JNC       ??writeItem_10
   \   000164   09           INC       R1
   \                     ??writeItem_10:
   \   000165   54FC         ANL       A,#0xfc
   \   000167   2408         ADD       A,#0x8
   \   000169   FE           MOV       R6,A
   \   00016A   E4           CLR       A
   \   00016B   39           ADDC      A,R1
   \   00016C   FF           MOV       R7,A
   \   00016D   804E         SJMP      ??writeItem_9
   1133            }
   1134            else
   1135            {
   1136              len = OSAL_NV_ITEM_SIZE( hdr.len );
   \                     ??writeItem_1:
   \   00016F   C3           CLR       C
   \   000170   E8           MOV       A,R0
   \   000171   94F4         SUBB      A,#-0xc
   \   000173   E9           MOV       A,R1
   \   000174   94FF         SUBB      A,#-0x1
   \   000176   4006         JC        ??writeItem_11
   \   000178   7EFC         MOV       R6,#-0x4
   \   00017A   7FFF         MOV       R7,#-0x1
   \   00017C   800E         SJMP      ??writeItem_12
   \                     ??writeItem_11:
   \   00017E   E8           MOV       A,R0
   \   00017F   2403         ADD       A,#0x3
   \   000181   5001         JNC       ??writeItem_13
   \   000183   09           INC       R1
   \                     ??writeItem_13:
   \   000184   54FC         ANL       A,#0xfc
   \   000186   2408         ADD       A,#0x8
   \   000188   FE           MOV       R6,A
   \   000189   E4           CLR       A
   \   00018A   39           ADDC      A,R1
   \   00018B   FF           MOV       R7,A
   1137          
   1138              if (len > (OSAL_NV_PAGE_SIZE - pgOff[pg - OSAL_NV_PAGE_BEG]))
   \                     ??writeItem_12:
   \   00018C   85..82       MOV       DPL,?V8
   \   00018F   85..83       MOV       DPH,?V9
   \   000192   E0           MOVX      A,@DPTR
   \   000193   F8           MOV       R0,A
   \   000194   A3           INC       DPTR
   \   000195   E0           MOVX      A,@DPTR
   \   000196   F9           MOV       R1,A
   \   000197   E4           CLR       A
   \   000198   C3           CLR       C
   \   000199   98           SUBB      A,R0
   \   00019A   F8           MOV       R0,A
   \   00019B   7408         MOV       A,#0x8
   \   00019D   99           SUBB      A,R1
   \   00019E   F9           MOV       R1,A
   \   00019F   C3           CLR       C
   \   0001A0   E8           MOV       A,R0
   \   0001A1   9E           SUBB      A,R6
   \   0001A2   E9           MOV       A,R1
   \   0001A3   9F           SUBB      A,R7
   \   0001A4   5004         JNC       ??writeItem_14
   1139              {
   1140                len = (OSAL_NV_PAGE_SIZE - pgOff[pg - OSAL_NV_PAGE_BEG]);
   \   0001A6   E8           MOV       A,R0
   \   0001A7   FE           MOV       R6,A
   \   0001A8   E9           MOV       A,R1
   \   0001A9   FF           MOV       R7,A
   1141              }
   1142          
   1143              pgLost[pg - OSAL_NV_PAGE_BEG] += len;
   \                     ??writeItem_14:
   \   0001AA   74..         MOV       A,#(pgLost + 14) & 0xff
   \   0001AC   25..         ADD       A,?V0
   \   0001AE   F582         MOV       DPL,A
   \   0001B0   74..         MOV       A,#((pgLost - 242) >> 8) & 0xff
   \   0001B2   35..         ADDC      A,?V1
   \   0001B4   F583         MOV       DPH,A
   \   0001B6   E0           MOVX      A,@DPTR
   \   0001B7   2E           ADD       A,R6
   \   0001B8   F0           MOVX      @DPTR,A
   \   0001B9   A3           INC       DPTR
   \   0001BA   E0           MOVX      A,@DPTR
   \   0001BB   3F           ADDC      A,R7
   \   0001BC   F0           MOVX      @DPTR,A
   1144            }
   1145            pgOff[pg - OSAL_NV_PAGE_BEG] += len;
   \                     ??writeItem_9:
   \   0001BD   85..82       MOV       DPL,?V8
   \   0001C0   85..83       MOV       DPH,?V9
   \   0001C3   E0           MOVX      A,@DPTR
   \   0001C4   2E           ADD       A,R6
   \   0001C5   F0           MOVX      @DPTR,A
   \   0001C6   A3           INC       DPTR
   \   0001C7   E0           MOVX      A,@DPTR
   \   0001C8   3F           ADDC      A,R7
   \   0001C9   F0           MOVX      @DPTR,A
   1146          
   1147            return rtrn;
   \   0001CA   A9..         MOV       R1,?V5
   \   0001CC   7408         MOV       A,#0x8
   \   0001CE   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001D1   7F0C         MOV       R7,#0xc
   \   0001D3   02....       LJMP      ?BANKED_LEAVE_XDATA
   1148          }
   1149          
   1150          /*********************************************************************
   1151           * @fn      hotItem
   1152           *
   1153           * @brief   Look for the parameter 'id' in the hot items array.
   1154           *
   1155           * @param   id - A valid NV item Id.
   1156           *
   1157           * @return  A valid index into the hot items if the item is hot; OSAL_NV_MAX_HOT if not.
   1158           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1159          static uint8 hotItem(uint16 id)
   \                     hotItem:
   1160          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1161            uint8 hotIdx;
   1162          
   1163            for (hotIdx = 0; hotIdx < OSAL_NV_MAX_HOT; hotIdx++)
   \   000004   7900         MOV       R1,#0x0
   \   000006   8001         SJMP      ??hotItem_0
   \                     ??hotItem_1:
   \   000008   09           INC       R1
   \                     ??hotItem_0:
   \   000009   E9           MOV       A,R1
   \   00000A   C3           CLR       C
   \   00000B   9403         SUBB      A,#0x3
   \   00000D   501A         JNC       ??hotItem_2
   1164            {
   1165              if (hotIds[hotIdx] == id)
   \   00000F   E9           MOV       A,R1
   \   000010   25E0         ADD       A,0xE0 /* A   */
   \   000012   FC           MOV       R4,A
   \   000013   E4           CLR       A
   \   000014   33           RLC       A
   \   000015   FD           MOV       R5,A
   \   000016   74..         MOV       A,#hotIds & 0xff
   \   000018   2C           ADD       A,R4
   \   000019   F582         MOV       DPL,A
   \   00001B   74..         MOV       A,#(hotIds >> 8) & 0xff
   \   00001D   3D           ADDC      A,R5
   \   00001E   F583         MOV       DPH,A
   \   000020   E0           MOVX      A,@DPTR
   \   000021   6A           XRL       A,R2
   \   000022   7003         JNZ       ??hotItem_3
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   6B           XRL       A,R3
   \                     ??hotItem_3:
   \   000027   70DF         JNZ       ??hotItem_1
   1166              {
   1167                break;
   1168              }
   1169            }
   1170          
   1171            return hotIdx;
   \                     ??hotItem_2:
   \   000029   D083         POP       DPH
   \   00002B   D082         POP       DPL
   \   00002D   02....       LJMP      ?BRET
   1172          }
   1173          
   1174          /*********************************************************************
   1175           * @fn      hotItemUpdate
   1176           *
   1177           * @brief   If the parameter 'id' is a hot item, update the corresponding hot item data.
   1178           *
   1179           * @param   pg - The new NV page corresponding to the hot item.
   1180           * @param   off - The new NV page offset corresponding to the hot item.
   1181           * @param   id - A valid NV item Id.
   1182           *
   1183           * @return  none
   1184           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1185          static void hotItemUpdate(uint8 pg, uint16 off, uint16 id)
   \                     hotItemUpdate:
   1186          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FA           MOV       R2,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FB           MOV       R3,A
   1187            uint8 hotIdx = hotItem(id);
   \   00000F                ; Setup parameters for call to function hotItem
   \   00000F   12....       LCALL     `??hotItem::?relay`; Banked call to: hotItem
   \   000012   E9           MOV       A,R1
   \   000013   F8           MOV       R0,A
   1188          
   1189            if (hotIdx < OSAL_NV_MAX_HOT)
   \   000014   C3           CLR       C
   \   000015   9403         SUBB      A,#0x3
   \   000017   5027         JNC       ??hotItemUpdate_0
   1190            {
   1191              {
   1192                hotPg[hotIdx] = pg;
   \   000019   EE           MOV       A,R6
   \   00001A   C0E0         PUSH      A
   \   00001C   74..         MOV       A,#hotPg & 0xff
   \   00001E   29           ADD       A,R1
   \   00001F   F582         MOV       DPL,A
   \   000021   E4           CLR       A
   \   000022   34..         ADDC      A,#(hotPg >> 8) & 0xff
   \   000024   F583         MOV       DPH,A
   \   000026   D0E0         POP       A
   \   000028   F0           MOVX      @DPTR,A
   1193                hotOff[hotIdx] = off;
   \   000029   E9           MOV       A,R1
   \   00002A   29           ADD       A,R1
   \   00002B   F8           MOV       R0,A
   \   00002C   E4           CLR       A
   \   00002D   33           RLC       A
   \   00002E   F9           MOV       R1,A
   \   00002F   74..         MOV       A,#hotOff & 0xff
   \   000031   28           ADD       A,R0
   \   000032   F582         MOV       DPL,A
   \   000034   74..         MOV       A,#(hotOff >> 8) & 0xff
   \   000036   39           ADDC      A,R1
   \   000037   F583         MOV       DPH,A
   \   000039   E5..         MOV       A,?V0
   \   00003B   F0           MOVX      @DPTR,A
   \   00003C   A3           INC       DPTR
   \   00003D   E5..         MOV       A,?V1
   \   00003F   F0           MOVX      @DPTR,A
   1194              }
   1195            }
   1196          }
   \                     ??hotItemUpdate_0:
   \   000040   7F02         MOV       R7,#0x2
   \   000042   02....       LJMP      ?BANKED_LEAVE_XDATA
   1197          
   1198          /*********************************************************************
   1199           * @fn      osal_nv_init
   1200           *
   1201           * @brief   Initialize NV service.
   1202           *
   1203           * @param   p - Not used.
   1204           *
   1205           * @return  none
   1206           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1207          void osal_nv_init( void *p )
   \                     osal_nv_init:
   1208          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1209            (void)p;  // Suppress Lint warning.
   1210            (void)initNV();  // Always returns TRUE after pages have been erased.
   \   000004                ; Setup parameters for call to function initNV
   \   000004   12....       LCALL     `??initNV::?relay`; Banked call to: initNV
   1211          }
   \   000007   D083         POP       DPH
   \   000009   D082         POP       DPL
   \   00000B   02....       LJMP      ?BRET
   1212          
   1213          /*********************************************************************
   1214           * @fn      osal_nv_item_init
   1215           *
   1216           * @brief   If the NV item does not already exist, it is created and
   1217           *          initialized with the data passed to the function, if any.
   1218           *          This function must be called before calling osal_nv_read() or
   1219           *          osal_nv_write().
   1220           *
   1221           * @param   id  - Valid NV item Id.
   1222           * @param   len - Item length.
   1223           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
   1224           *
   1225           * @return  NV_ITEM_UNINIT - Id did not exist and was created successfully.
   1226           *          SUCCESS        - Id already existed, no action taken.
   1227           *          NV_OPER_FAILED - Failure to find or create Id.
   1228           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1229          uint8 osal_nv_item_init( uint16 id, uint16 len, void *buf )
   \                     osal_nv_item_init:
   1230          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   1231            uint16 offset;
   1232          
   1233            if ( ( hotItem( id ) < OSAL_NV_MAX_HOT ) && ( !OSAL_NV_CHECK_BUS_VOLTAGE ) )
   \   00000D                ; Setup parameters for call to function hotItem
   \   00000D   12....       LCALL     `??hotItem::?relay`; Banked call to: hotItem
   \   000010   E9           MOV       A,R1
   \   000011   C3           CLR       C
   \   000012   9403         SUBB      A,#0x3
   \   000014   5006         JNC       ??osal_nv_item_init_0
   \   000016                ; Setup parameters for call to function OnBoard_CheckVoltage
   \   000016   12....       LCALL     `??OnBoard_CheckVoltage::?relay`; Banked call to: OnBoard_CheckVoltage
   \   000019   E9           MOV       A,R1
   \   00001A   6040         JZ        ??osal_nv_item_init_1
   1234            {
   1235              return NV_OPER_FAILED;
   1236            }
   1237            else if ((offset = findItem(id)) != OSAL_NV_ITEM_NULL)
   \                     ??osal_nv_item_init_0:
   \   00001C                ; Setup parameters for call to function findItem
   \   00001C   EE           MOV       A,R6
   \   00001D   FA           MOV       R2,A
   \   00001E   EF           MOV       A,R7
   \   00001F   FB           MOV       R3,A
   \   000020   12....       LCALL     `??findItem::?relay`; Banked call to: findItem
   \   000023   8B..         MOV       ?V3,R3
   \   000025   A9..         MOV       R1,?V3
   \   000027   EA           MOV       A,R2
   \   000028   49           ORL       A,R1
   \   000029   6010         JZ        ??osal_nv_item_init_2
   1238            {
   1239              // Re-populate the NV hot item data if the corresponding items are already established.
   1240              hotItemUpdate(findPg, offset, id);
   \   00002B                ; Setup parameters for call to function hotItemUpdate
   \   00002B   EE           MOV       A,R6
   \   00002C   FC           MOV       R4,A
   \   00002D   EF           MOV       A,R7
   \   00002E   FD           MOV       R5,A
   \   00002F   90....       MOV       DPTR,#findPg
   \   000032   E0           MOVX      A,@DPTR
   \   000033   F9           MOV       R1,A
   \   000034   12....       LCALL     `??hotItemUpdate::?relay`; Banked call to: hotItemUpdate
   1241          
   1242              return SUCCESS;
   \   000037   7900         MOV       R1,#0x0
   \   000039   8023         SJMP      ??osal_nv_item_init_3
   1243            }
   1244            else if ( initItem( TRUE, id, len, buf ) != OSAL_NV_PAGE_NULL )
   \                     ??osal_nv_item_init_2:
   \   00003B                ; Setup parameters for call to function initItem
   \   00003B   740C         MOV       A,#0xc
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000043   AC..         MOV       R4,?V0
   \   000045   AD..         MOV       R5,?V1
   \   000047   EE           MOV       A,R6
   \   000048   FA           MOV       R2,A
   \   000049   EF           MOV       A,R7
   \   00004A   FB           MOV       R3,A
   \   00004B   7901         MOV       R1,#0x1
   \   00004D   12....       LCALL     `??initItem::?relay`; Banked call to: initItem
   \   000050   7402         MOV       A,#0x2
   \   000052   12....       LCALL     ?DEALLOC_XSTACK8
   \   000055   E9           MOV       A,R1
   \   000056   6004         JZ        ??osal_nv_item_init_1
   1245            {
   1246              return NV_ITEM_UNINIT;
   \   000058   7909         MOV       R1,#0x9
   \   00005A   8002         SJMP      ??osal_nv_item_init_3
   1247            }
   1248            else
   1249            {
   1250              return NV_OPER_FAILED;
   \                     ??osal_nv_item_init_1:
   \   00005C   790A         MOV       R1,#0xa
   \                     ??osal_nv_item_init_3:
   \   00005E   7F04         MOV       R7,#0x4
   \   000060   02....       LJMP      ?BANKED_LEAVE_XDATA
   1251            }
   1252          }
   1253          
   1254          /*********************************************************************
   1255           * @fn      osal_nv_item_len
   1256           *
   1257           * @brief   Get the data length of the item stored in NV memory.
   1258           *
   1259           * @param   id  - Valid NV item Id.
   1260           *
   1261           * @return  Item length, if found; zero otherwise.
   1262           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1263          uint16 osal_nv_item_len( uint16 id )
   \                     osal_nv_item_len:
   1264          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1265            osalNvHdr_t hdr;
   1266            uint16 offset;
   1267            uint8 hotIdx;
   1268          
   1269            if ((hotIdx = hotItem(id)) < OSAL_NV_MAX_HOT)
   \   00000E                ; Setup parameters for call to function hotItem
   \   00000E   12....       LCALL     `??hotItem::?relay`; Banked call to: hotItem
   \   000011   E9           MOV       A,R1
   \   000012   F8           MOV       R0,A
   \   000013   C3           CLR       C
   \   000014   9403         SUBB      A,#0x3
   \   000016   505D         JNC       ??osal_nv_item_len_0
   1270            {
   1271              findPg = hotPg[hotIdx];
   \   000018   74..         MOV       A,#hotPg & 0xff
   \   00001A   29           ADD       A,R1
   \   00001B   F582         MOV       DPL,A
   \   00001D   E4           CLR       A
   \   00001E   34..         ADDC      A,#(hotPg >> 8) & 0xff
   \   000020   F583         MOV       DPH,A
   \   000022   E0           MOVX      A,@DPTR
   \   000023   90....       MOV       DPTR,#findPg
   \   000026   F0           MOVX      @DPTR,A
   1272              offset = hotOff[hotIdx];
   \   000027   E9           MOV       A,R1
   \   000028   29           ADD       A,R1
   \   000029   F8           MOV       R0,A
   \   00002A   E4           CLR       A
   \   00002B   33           RLC       A
   \   00002C   F9           MOV       R1,A
   \   00002D   74..         MOV       A,#hotOff & 0xff
   \   00002F   28           ADD       A,R0
   \   000030   F582         MOV       DPL,A
   \   000032   74..         MOV       A,#(hotOff >> 8) & 0xff
   \   000034   39           ADDC      A,R1
   \   000035   F583         MOV       DPH,A
   \   000037   E0           MOVX      A,@DPTR
   \   000038   FA           MOV       R2,A
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   FB           MOV       R3,A
   1273            }
   1274            else if ((offset = findItem(id)) == OSAL_NV_ITEM_NULL)
   1275            {
   1276              return 0;
   1277            }
   1278          
   1279            HalFlashRead(findPg, (offset - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
   \                     ??osal_nv_item_len_1:
   \   00003C                ; Setup parameters for call to function HalFlashRead
   \   00003C   75..08       MOV       ?V2,#0x8
   \   00003F   75..00       MOV       ?V3,#0x0
   \   000042   78..         MOV       R0,#?V2
   \   000044   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000047   7402         MOV       A,#0x2
   \   000049   12....       LCALL     ?XSTACK_DISP102_8
   \   00004C   EA           MOV       A,R2
   \   00004D   24F8         ADD       A,#-0x8
   \   00004F   FA           MOV       R2,A
   \   000050   EB           MOV       A,R3
   \   000051   34FF         ADDC      A,#-0x1
   \   000053   FB           MOV       R3,A
   \   000054   90....       MOV       DPTR,#findPg
   \   000057   E0           MOVX      A,@DPTR
   \   000058   F9           MOV       R1,A
   \   000059   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   00005C   7402         MOV       A,#0x2
   \   00005E   12....       LCALL     ?DEALLOC_XSTACK8
   1280            return hdr.len;
   \   000061   7402         MOV       A,#0x2
   \   000063   12....       LCALL     ?XSTACK_DISP0_8
   \   000066   E0           MOVX      A,@DPTR
   \   000067   FA           MOV       R2,A
   \   000068   A3           INC       DPTR
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   FB           MOV       R3,A
   \                     ??osal_nv_item_len_2:
   \   00006B   7408         MOV       A,#0x8
   \   00006D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000070   7F04         MOV       R7,#0x4
   \   000072   02....       LJMP      ?BANKED_LEAVE_XDATA
   \                     ??osal_nv_item_len_0:
   \   000075                ; Setup parameters for call to function findItem
   \   000075   EE           MOV       A,R6
   \   000076   FA           MOV       R2,A
   \   000077   EF           MOV       A,R7
   \   000078   FB           MOV       R3,A
   \   000079   12....       LCALL     `??findItem::?relay`; Banked call to: findItem
   \   00007C   8B..         MOV       ?V3,R3
   \   00007E   A9..         MOV       R1,?V3
   \   000080   EA           MOV       A,R2
   \   000081   49           ORL       A,R1
   \   000082   70B8         JNZ       ??osal_nv_item_len_1
   \   000084   7A00         MOV       R2,#0x0
   \   000086   7B00         MOV       R3,#0x0
   \   000088   80E1         SJMP      ??osal_nv_item_len_2
   1281          }
   1282          
   1283          /*********************************************************************
   1284           * @fn      osal_nv_write
   1285           *
   1286           * @brief   Write a data item to NV. Function can write an entire item to NV or
   1287           *          an element of an item by indexing into the item with an offset.
   1288           *
   1289           * @param   id  - Valid NV item Id.
   1290           * @param   ndx - Index offset into item
   1291           * @param   len - Length of data to write.
   1292           * @param  *buf - Data to write.
   1293           *
   1294           * @return  SUCCESS if successful, NV_ITEM_UNINIT if item did not
   1295           *          exist in NV and offset is non-zero, NV_OPER_FAILED if failure.
   1296           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1297          uint8 osal_nv_write( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_write:
   1298          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV       A,#-0xb
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V14,R2
   \   00000C   8B..         MOV       ?V15,R3
   \   00000E   8C..         MOV       ?V4,R4
   \   000010   8D..         MOV       ?V5,R5
   1299            uint8 rtrn = SUCCESS;
   \   000012   75..00       MOV       ?V9,#0x0
   1300          
   1301            if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
   \   000015                ; Setup parameters for call to function OnBoard_CheckVoltage
   \   000015   12....       LCALL     `??OnBoard_CheckVoltage::?relay`; Banked call to: OnBoard_CheckVoltage
   \   000018   E9           MOV       A,R1
   \   000019   6072         JZ        ??osal_nv_write_0
   \   00001B   7423         MOV       A,#0x23
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V10,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F5..         MOV       ?V11,A
   1302            {
   1303              return NV_OPER_FAILED;
   1304            }
   1305            else if ( len != 0 )
   \   000027   E5..         MOV       A,?V10
   \   000029   45..         ORL       A,?V11
   \   00002B   7003         JNZ       $+5
   \   00002D   02....       LJMP      ??osal_nv_write_1 & 0xFFFF
   1306            {
   1307              osalNvHdr_t hdr;
   1308              uint16 origOff, srcOff;
   1309              uint16 cnt, chk;
   1310              uint8 *ptr, srcPg;
   1311          
   1312              origOff = srcOff = findItem( id );
   \   000030                ; Setup parameters for call to function findItem
   \   000030   AA..         MOV       R2,?V14
   \   000032   AB..         MOV       R3,?V15
   \   000034   12....       LCALL     `??findItem::?relay`; Banked call to: findItem
   \   000037   EA           MOV       A,R2
   \   000038   FE           MOV       R6,A
   \   000039   EB           MOV       A,R3
   \   00003A   FF           MOV       R7,A
   \   00003B   7401         MOV       A,#0x1
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   EA           MOV       A,R2
   \   000041   F0           MOVX      @DPTR,A
   \   000042   A3           INC       DPTR
   \   000043   EB           MOV       A,R3
   \   000044   F0           MOVX      @DPTR,A
   1313              srcPg = findPg;
   \   000045   90....       MOV       DPTR,#findPg
   \   000048   E0           MOVX      A,@DPTR
   \   000049   F5..         MOV       ?V8,A
   1314              if ( srcOff == OSAL_NV_ITEM_NULL )
   \   00004B   EA           MOV       A,R2
   \   00004C   4F           ORL       A,R7
   \   00004D   7005         JNZ       ??osal_nv_write_2
   1315              {
   1316                return NV_ITEM_UNINIT;
   \   00004F   7909         MOV       R1,#0x9
   \   000051   02....       LJMP      ??osal_nv_write_3 & 0xFFFF
   1317              }
   1318          
   1319              HalFlashRead(srcPg, (srcOff - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr), OSAL_NV_HDR_SIZE);
   \                     ??osal_nv_write_2:
   \   000054                ; Setup parameters for call to function HalFlashRead
   \   000054   75..08       MOV       ?V0,#0x8
   \   000057   75..00       MOV       ?V1,#0x0
   \   00005A   78..         MOV       R0,#?V0
   \   00005C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005F   7405         MOV       A,#0x5
   \   000061   12....       LCALL     ?XSTACK_DISP102_8
   \   000064   EA           MOV       A,R2
   \   000065   24F8         ADD       A,#-0x8
   \   000067   FA           MOV       R2,A
   \   000068   EB           MOV       A,R3
   \   000069   34FF         ADDC      A,#-0x1
   \   00006B   FB           MOV       R3,A
   \   00006C   A9..         MOV       R1,?V8
   \   00006E   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   000071   7402         MOV       A,#0x2
   \   000073   12....       LCALL     ?DEALLOC_XSTACK8
   1320              if ( hdr.len < (ndx + len) )
   \   000076   7405         MOV       A,#0x5
   \   000078   12....       LCALL     ?XSTACK_DISP0_8
   \   00007B   E5..         MOV       A,?V4
   \   00007D   25..         ADD       A,?V10
   \   00007F   F8           MOV       R0,A
   \   000080   E5..         MOV       A,?V5
   \   000082   35..         ADDC      A,?V11
   \   000084   F9           MOV       R1,A
   \   000085   C3           CLR       C
   \   000086   E0           MOVX      A,@DPTR
   \   000087   98           SUBB      A,R0
   \   000088   A3           INC       DPTR
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   99           SUBB      A,R1
   \   00008B   5005         JNC       ??osal_nv_write_4
   1321              {
   1322                return NV_OPER_FAILED;
   \                     ??osal_nv_write_0:
   \   00008D   790A         MOV       R1,#0xa
   \   00008F   02....       LJMP      ??osal_nv_write_3 & 0xFFFF
   1323              }
   1324          
   1325              srcOff += ndx;
   \                     ??osal_nv_write_4:
   \   000092   EE           MOV       A,R6
   \   000093   25..         ADD       A,?V4
   \   000095   FE           MOV       R6,A
   \   000096   EF           MOV       A,R7
   \   000097   35..         ADDC      A,?V5
   \   000099   FF           MOV       R7,A
   1326              ptr = buf;
   \   00009A   7425         MOV       A,#0x25
   \   00009C   12....       LCALL     ?XSTACK_DISP0_8
   \   00009F   E0           MOVX      A,@DPTR
   \   0000A0   F5..         MOV       ?V2,A
   \   0000A2   A3           INC       DPTR
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   F5..         MOV       ?V3,A
   1327              cnt = len;
   \   0000A6   85....       MOV       ?V0,?V10
   \   0000A9   85....       MOV       ?V1,?V11
   1328              chk = 0;
   \   0000AC   75..00       MOV       ?V6,#0x0
   \   0000AF   8070         SJMP      ??osal_nv_write_5
   1329              while ( cnt-- )
   1330              {
   1331                uint8 tmp;
   1332                HalFlashRead(srcPg, srcOff, &tmp, 1);
   \                     ??osal_nv_write_6:
   \   0000B1                ; Setup parameters for call to function HalFlashRead
   \   0000B1   75..01       MOV       ?V12,#0x1
   \   0000B4   75..00       MOV       ?V13,#0x0
   \   0000B7   78..         MOV       R0,#?V12
   \   0000B9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BC   7402         MOV       A,#0x2
   \   0000BE   12....       LCALL     ?XSTACK_DISP102_8
   \   0000C1   EE           MOV       A,R6
   \   0000C2   FA           MOV       R2,A
   \   0000C3   EF           MOV       A,R7
   \   0000C4   FB           MOV       R3,A
   \   0000C5   A9..         MOV       R1,?V8
   \   0000C7   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   0000CA   7402         MOV       A,#0x2
   \   0000CC   12....       LCALL     ?DEALLOC_XSTACK8
   1333                if ( tmp != *ptr )
   \   0000CF   85..82       MOV       DPL,?XSP + 0
   \   0000D2   85..83       MOV       DPH,?XSP + 1
   \   0000D5   E0           MOVX      A,@DPTR
   \   0000D6   F8           MOV       R0,A
   \   0000D7   85..82       MOV       DPL,?V2
   \   0000DA   85..83       MOV       DPH,?V3
   \   0000DD   E0           MOVX      A,@DPTR
   \   0000DE   68           XRL       A,R0
   \   0000DF   602E         JZ        ??osal_nv_write_7
   1334                {
   1335                  chk = 1;  // Mark that at least one byte is different.
   \   0000E1   75..01       MOV       ?V6,#0x1
   1336                  // Calculate expected checksum after transferring old data and writing new data.
   1337                  hdr.chk -= tmp;
   \   0000E4   85..82       MOV       DPL,?XSP + 0
   \   0000E7   85..83       MOV       DPH,?XSP + 1
   \   0000EA   E0           MOVX      A,@DPTR
   \   0000EB   F8           MOV       R0,A
   \   0000EC   7407         MOV       A,#0x7
   \   0000EE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F1   C3           CLR       C
   \   0000F2   E0           MOVX      A,@DPTR
   \   0000F3   98           SUBB      A,R0
   \   0000F4   F0           MOVX      @DPTR,A
   \   0000F5   A3           INC       DPTR
   \   0000F6   E0           MOVX      A,@DPTR
   \   0000F7   9400         SUBB      A,#0x0
   \   0000F9   F0           MOVX      @DPTR,A
   1338                  hdr.chk += *ptr;
   \   0000FA   85..82       MOV       DPL,?V2
   \   0000FD   85..83       MOV       DPH,?V3
   \   000100   E0           MOVX      A,@DPTR
   \   000101   F8           MOV       R0,A
   \   000102   7407         MOV       A,#0x7
   \   000104   12....       LCALL     ?XSTACK_DISP0_8
   \   000107   E0           MOVX      A,@DPTR
   \   000108   28           ADD       A,R0
   \   000109   F0           MOVX      @DPTR,A
   \   00010A   A3           INC       DPTR
   \   00010B   E0           MOVX      A,@DPTR
   \   00010C   3400         ADDC      A,#0x0
   \   00010E   F0           MOVX      @DPTR,A
   1339                }
   1340                srcOff++;
   \                     ??osal_nv_write_7:
   \   00010F   0E           INC       R6
   \   000110   EE           MOV       A,R6
   \   000111   7001         JNZ       ??osal_nv_write_8
   \   000113   0F           INC       R7
   1341                ptr++;
   \                     ??osal_nv_write_8:
   \   000114   85..82       MOV       DPL,?V2
   \   000117   85..83       MOV       DPH,?V3
   \   00011A   A3           INC       DPTR
   \   00011B   8582..       MOV       ?V2,DPL
   \   00011E   8583..       MOV       ?V3,DPH
   1342              }
   \                     ??osal_nv_write_5:
   \   000121   A8..         MOV       R0,?V0
   \   000123   A9..         MOV       R1,?V1
   \   000125   E8           MOV       A,R0
   \   000126   24FF         ADD       A,#-0x1
   \   000128   F5..         MOV       ?V0,A
   \   00012A   E9           MOV       A,R1
   \   00012B   34FF         ADDC      A,#-0x1
   \   00012D   F5..         MOV       ?V1,A
   \   00012F   E8           MOV       A,R0
   \   000130   49           ORL       A,R1
   \   000131   6003         JZ        $+5
   \   000133   02....       LJMP      ??osal_nv_write_6 & 0xFFFF
   1343          
   1344              if ( chk != 0 )  // If the buffer to write is different in one or more bytes.
   \   000136   E5..         MOV       A,?V6
   \   000138   7003         JNZ       $+5
   \   00013A   02....       LJMP      ??osal_nv_write_1 & 0xFFFF
   1345              {
   1346                uint8 comPg = OSAL_NV_PAGE_NULL;
   \   00013D   85..82       MOV       DPL,?XSP + 0
   \   000140   85..83       MOV       DPH,?XSP + 1
   \   000143   E4           CLR       A
   \   000144   F0           MOVX      @DPTR,A
   1347                uint8 dstPg = initItem( FALSE, id, hdr.len, &comPg );
   \   000145                ; Setup parameters for call to function initItem
   \   000145   A8..         MOV       R0,?XSP + 0
   \   000147   A9..         MOV       R1,?XSP + 1
   \   000149   88..         MOV       ?V0,R0
   \   00014B   89..         MOV       ?V1,R1
   \   00014D   78..         MOV       R0,#?V0
   \   00014F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000152   7407         MOV       A,#0x7
   \   000154   12....       LCALL     ?XSTACK_DISP0_8
   \   000157   E0           MOVX      A,@DPTR
   \   000158   FC           MOV       R4,A
   \   000159   A3           INC       DPTR
   \   00015A   E0           MOVX      A,@DPTR
   \   00015B   FD           MOV       R5,A
   \   00015C   AA..         MOV       R2,?V14
   \   00015E   AB..         MOV       R3,?V15
   \   000160   7900         MOV       R1,#0x0
   \   000162   12....       LCALL     `??initItem::?relay`; Banked call to: initItem
   \   000165   7402         MOV       A,#0x2
   \   000167   12....       LCALL     ?DEALLOC_XSTACK8
   \   00016A   E9           MOV       A,R1
   \   00016B   F5..         MOV       ?V2,A
   1348          
   1349                if ( dstPg != OSAL_NV_PAGE_NULL )
   \   00016D   7003         JNZ       $+5
   \   00016F   02....       LJMP      ??osal_nv_write_9 & 0xFFFF
   1350                {
   1351                  uint16 tmp = OSAL_NV_DATA_SIZE( hdr.len );
   \   000172   7405         MOV       A,#0x5
   \   000174   12....       LCALL     ?XSTACK_DISP0_8
   \   000177   E0           MOVX      A,@DPTR
   \   000178   F8           MOV       R0,A
   \   000179   A3           INC       DPTR
   \   00017A   E0           MOVX      A,@DPTR
   \   00017B   F9           MOV       R1,A
   \   00017C   C3           CLR       C
   \   00017D   E8           MOV       A,R0
   \   00017E   94FC         SUBB      A,#-0x4
   \   000180   E9           MOV       A,R1
   \   000181   94FF         SUBB      A,#-0x1
   \   000183   4008         JC        ??osal_nv_write_10
   \   000185   75..FC       MOV       ?V0,#-0x4
   \   000188   75..FF       MOV       ?V1,#-0x1
   \   00018B   800D         SJMP      ??osal_nv_write_11
   \                     ??osal_nv_write_10:
   \   00018D   E8           MOV       A,R0
   \   00018E   2403         ADD       A,#0x3
   \   000190   5001         JNC       ??osal_nv_write_12
   \   000192   09           INC       R1
   \                     ??osal_nv_write_12:
   \   000193   54FC         ANL       A,#0xfc
   \   000195   F5..         MOV       ?V0,A
   \   000197   E9           MOV       A,R1
   \   000198   F5..         MOV       ?V1,A
   1352                  uint16 dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
   \                     ??osal_nv_write_11:
   \   00019A   A8..         MOV       R0,?V2
   \   00019C   E8           MOV       A,R0
   \   00019D   28           ADD       A,R0
   \   00019E   F8           MOV       R0,A
   \   00019F   E4           CLR       A
   \   0001A0   33           RLC       A
   \   0001A1   F9           MOV       R1,A
   \   0001A2   74..         MOV       A,#(pgOff + 14) & 0xff
   \   0001A4   28           ADD       A,R0
   \   0001A5   F5..         MOV       ?V12,A
   \   0001A7   74..         MOV       A,#((pgOff - 242) >> 8) & 0xff
   \   0001A9   39           ADDC      A,R1
   \   0001AA   F5..         MOV       ?V13,A
   \   0001AC   85..82       MOV       DPL,?V12
   \   0001AF   F583         MOV       DPH,A
   \   0001B1   E0           MOVX      A,@DPTR
   \   0001B2   C3           CLR       C
   \   0001B3   95..         SUBB      A,?V0
   \   0001B5   FE           MOV       R6,A
   \   0001B6   A3           INC       DPTR
   \   0001B7   E0           MOVX      A,@DPTR
   \   0001B8   95..         SUBB      A,?V1
   \   0001BA   FF           MOV       R7,A
   1353                  srcOff = origOff;
   1354          
   1355                  /* Prevent excessive re-writes to item header caused by numerous, rapid, & successive
   1356                   * OSAL_Nv interruptions caused by resets.
   1357                   */
   1358                  if ( hdr.stat == OSAL_NV_ERASED_ID )
   \   0001BB   7409         MOV       A,#0x9
   \   0001BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0001C0   E0           MOVX      A,@DPTR
   \   0001C1   F4           CPL       A
   \   0001C2   7003         JNZ       ??osal_nv_write_13
   \   0001C4   A3           INC       DPTR
   \   0001C5   E0           MOVX      A,@DPTR
   \   0001C6   F4           CPL       A
   \                     ??osal_nv_write_13:
   \   0001C7   7011         JNZ       ??osal_nv_write_14
   1359                  {
   1360                    setItem( srcPg, srcOff, eNvXfer );
   \   0001C9                ; Setup parameters for call to function setItem
   \   0001C9   7C00         MOV       R4,#0x0
   \   0001CB   7401         MOV       A,#0x1
   \   0001CD   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D0   E0           MOVX      A,@DPTR
   \   0001D1   FA           MOV       R2,A
   \   0001D2   A3           INC       DPTR
   \   0001D3   E0           MOVX      A,@DPTR
   \   0001D4   FB           MOV       R3,A
   \   0001D5   A9..         MOV       R1,?V8
   \   0001D7   12....       LCALL     `??setItem::?relay`; Banked call to: setItem
   1361                  }
   1362          
   1363                  xferBuf( srcPg, srcOff, dstPg, dstOff, ndx );
   \                     ??osal_nv_write_14:
   \   0001DA                ; Setup parameters for call to function xferBuf
   \   0001DA   78..         MOV       R0,#?V4
   \   0001DC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001DF   8E..         MOV       ?V6,R6
   \   0001E1   8F..         MOV       ?V7,R7
   \   0001E3   78..         MOV       R0,#?V6
   \   0001E5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001E8   AC..         MOV       R4,?V2
   \   0001EA   7405         MOV       A,#0x5
   \   0001EC   12....       LCALL     ?XSTACK_DISP0_8
   \   0001EF   E0           MOVX      A,@DPTR
   \   0001F0   FA           MOV       R2,A
   \   0001F1   A3           INC       DPTR
   \   0001F2   E0           MOVX      A,@DPTR
   \   0001F3   FB           MOV       R3,A
   \   0001F4   A9..         MOV       R1,?V8
   \   0001F6   12....       LCALL     `??xferBuf::?relay`; Banked call to: xferBuf
   \   0001F9   7404         MOV       A,#0x4
   \   0001FB   12....       LCALL     ?DEALLOC_XSTACK8
   1364                  srcOff += ndx;
   1365                  dstOff += ndx;
   \   0001FE   EE           MOV       A,R6
   \   0001FF   25..         ADD       A,?V4
   \   000201   FE           MOV       R6,A
   \   000202   EF           MOV       A,R7
   \   000203   35..         ADDC      A,?V5
   \   000205   FF           MOV       R7,A
   1366          
   1367                  writeBuf( dstPg, dstOff, len, buf );
   \   000206                ; Setup parameters for call to function writeBuf
   \   000206   7425         MOV       A,#0x25
   \   000208   12....       LCALL     ?XSTACK_DISP0_8
   \   00020B   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00020E   AC..         MOV       R4,?V10
   \   000210   AD..         MOV       R5,?V11
   \   000212   EE           MOV       A,R6
   \   000213   FA           MOV       R2,A
   \   000214   EF           MOV       A,R7
   \   000215   FB           MOV       R3,A
   \   000216   A9..         MOV       R1,?V2
   \   000218   12....       LCALL     `??writeBuf::?relay`; Banked call to: writeBuf
   \   00021B   7402         MOV       A,#0x2
   \   00021D   12....       LCALL     ?DEALLOC_XSTACK8
   1368                  srcOff += len;
   1369                  dstOff += len;
   1370          
   1371                  xferBuf( srcPg, srcOff, dstPg, dstOff, (hdr.len-ndx-len) );
   \   000220                ; Setup parameters for call to function xferBuf
   \   000220   7405         MOV       A,#0x5
   \   000222   12....       LCALL     ?XSTACK_DISP0_8
   \   000225   E0           MOVX      A,@DPTR
   \   000226   C3           CLR       C
   \   000227   95..         SUBB      A,?V4
   \   000229   F8           MOV       R0,A
   \   00022A   A3           INC       DPTR
   \   00022B   E0           MOVX      A,@DPTR
   \   00022C   95..         SUBB      A,?V5
   \   00022E   F9           MOV       R1,A
   \   00022F   E8           MOV       A,R0
   \   000230   C3           CLR       C
   \   000231   95..         SUBB      A,?V10
   \   000233   F5..         MOV       ?V6,A
   \   000235   E9           MOV       A,R1
   \   000236   95..         SUBB      A,?V11
   \   000238   F5..         MOV       ?V7,A
   \   00023A   78..         MOV       R0,#?V6
   \   00023C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00023F   EE           MOV       A,R6
   \   000240   25..         ADD       A,?V10
   \   000242   F5..         MOV       ?V6,A
   \   000244   EF           MOV       A,R7
   \   000245   35..         ADDC      A,?V11
   \   000247   F5..         MOV       ?V7,A
   \   000249   78..         MOV       R0,#?V6
   \   00024B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00024E   AC..         MOV       R4,?V2
   \   000250   7405         MOV       A,#0x5
   \   000252   12....       LCALL     ?XSTACK_DISP0_8
   \   000255   E0           MOVX      A,@DPTR
   \   000256   25..         ADD       A,?V4
   \   000258   F8           MOV       R0,A
   \   000259   A3           INC       DPTR
   \   00025A   E0           MOVX      A,@DPTR
   \   00025B   35..         ADDC      A,?V5
   \   00025D   F9           MOV       R1,A
   \   00025E   E8           MOV       A,R0
   \   00025F   25..         ADD       A,?V10
   \   000261   FA           MOV       R2,A
   \   000262   E9           MOV       A,R1
   \   000263   35..         ADDC      A,?V11
   \   000265   FB           MOV       R3,A
   \   000266   A9..         MOV       R1,?V8
   \   000268   12....       LCALL     `??xferBuf::?relay`; Banked call to: xferBuf
   \   00026B   7404         MOV       A,#0x4
   \   00026D   12....       LCALL     ?DEALLOC_XSTACK8
   1372          
   1373                  // Calculate and write the new checksum.
   1374                  dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
   \   000270   85..82       MOV       DPL,?V12
   \   000273   85..83       MOV       DPH,?V13
   \   000276   E0           MOVX      A,@DPTR
   \   000277   C3           CLR       C
   \   000278   95..         SUBB      A,?V0
   \   00027A   FE           MOV       R6,A
   \   00027B   A3           INC       DPTR
   \   00027C   E0           MOVX      A,@DPTR
   \   00027D   95..         SUBB      A,?V1
   \   00027F   FF           MOV       R7,A
   1375          
   1376                  if ( hdr.chk == calcChkF( dstPg, dstOff, hdr.len ) )
   \   000280                ; Setup parameters for call to function calcChkF
   \   000280   7405         MOV       A,#0x5
   \   000282   12....       LCALL     ?XSTACK_DISP0_8
   \   000285   E0           MOVX      A,@DPTR
   \   000286   FC           MOV       R4,A
   \   000287   A3           INC       DPTR
   \   000288   E0           MOVX      A,@DPTR
   \   000289   FD           MOV       R5,A
   \   00028A   EE           MOV       A,R6
   \   00028B   FA           MOV       R2,A
   \   00028C   EF           MOV       A,R7
   \   00028D   FB           MOV       R3,A
   \   00028E   A9..         MOV       R1,?V2
   \   000290   12....       LCALL     `??calcChkF::?relay`; Banked call to: calcChkF
   \   000293   7407         MOV       A,#0x7
   \   000295   12....       LCALL     ?XSTACK_DISP0_8
   \   000298   E0           MOVX      A,@DPTR
   \   000299   FC           MOV       R4,A
   \   00029A   A3           INC       DPTR
   \   00029B   E0           MOVX      A,@DPTR
   \   00029C   FD           MOV       R5,A
   \   00029D   EA           MOV       A,R2
   \   00029E   6C           XRL       A,R4
   \   00029F   7002         JNZ       ??osal_nv_write_15
   \   0002A1   EB           MOV       A,R3
   \   0002A2   6D           XRL       A,R5
   \                     ??osal_nv_write_15:
   \   0002A3   7034         JNZ       ??osal_nv_write_9
   1377                  {
   1378                    if ( hdr.chk != setChk( dstPg, dstOff, hdr.chk ) )
   \   0002A5                ; Setup parameters for call to function setChk
   \   0002A5   EE           MOV       A,R6
   \   0002A6   FA           MOV       R2,A
   \   0002A7   EF           MOV       A,R7
   \   0002A8   FB           MOV       R3,A
   \   0002A9   A9..         MOV       R1,?V2
   \   0002AB   12....       LCALL     `??setChk::?relay`; Banked call to: setChk
   \   0002AE   8A..         MOV       ?V0,R2
   \   0002B0   8B..         MOV       ?V1,R3
   \   0002B2   A8..         MOV       R0,?V0
   \   0002B4   A9..         MOV       R1,?V1
   \   0002B6   7407         MOV       A,#0x7
   \   0002B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0002BB   E0           MOVX      A,@DPTR
   \   0002BC   68           XRL       A,R0
   \   0002BD   7003         JNZ       ??osal_nv_write_16
   \   0002BF   A3           INC       DPTR
   \   0002C0   E0           MOVX      A,@DPTR
   \   0002C1   69           XRL       A,R1
   \                     ??osal_nv_write_16:
   \   0002C2   7015         JNZ       ??osal_nv_write_9
   1379                    {
   1380                      rtrn = NV_OPER_FAILED;
   1381                    }
   1382                    else
   1383                    {
   1384                      hotItemUpdate(dstPg, dstOff, hdr.id);
   \   0002C4                ; Setup parameters for call to function hotItemUpdate
   \   0002C4   7403         MOV       A,#0x3
   \   0002C6   12....       LCALL     ?XSTACK_DISP0_8
   \   0002C9   E0           MOVX      A,@DPTR
   \   0002CA   FC           MOV       R4,A
   \   0002CB   A3           INC       DPTR
   \   0002CC   E0           MOVX      A,@DPTR
   \   0002CD   FD           MOV       R5,A
   \   0002CE   EE           MOV       A,R6
   \   0002CF   FA           MOV       R2,A
   \   0002D0   EF           MOV       A,R7
   \   0002D1   FB           MOV       R3,A
   \   0002D2   A9..         MOV       R1,?V2
   \   0002D4   12....       LCALL     `??hotItemUpdate::?relay`; Banked call to: hotItemUpdate
   \   0002D7   8003         SJMP      ??osal_nv_write_17
   1385                    }
   1386                  }
   1387                  else
   1388                  {
   1389                    rtrn = NV_OPER_FAILED;
   1390                  }
   1391                }
   1392                else
   1393                {
   1394                  rtrn = NV_OPER_FAILED;
   \                     ??osal_nv_write_9:
   \   0002D9   75..0A       MOV       ?V9,#0xa
   1395                }
   1396          
   1397                if ( comPg != OSAL_NV_PAGE_NULL )
   \                     ??osal_nv_write_17:
   \   0002DC   85..82       MOV       DPL,?XSP + 0
   \   0002DF   85..83       MOV       DPH,?XSP + 1
   \   0002E2   E0           MOVX      A,@DPTR
   \   0002E3   6035         JZ        ??osal_nv_write_18
   1398                {
   1399                  /* Even though the page compaction succeeded, if the new item is coming from the compacted
   1400                   * page and writing the new value failed, then the compaction must be aborted.
   1401                   */
   1402                  if ( (srcPg == comPg) && (rtrn == NV_OPER_FAILED) )
   \   0002E5   E0           MOVX      A,@DPTR
   \   0002E6   65..         XRL       A,?V8
   \   0002E8   7010         JNZ       ??osal_nv_write_19
   \   0002EA   740A         MOV       A,#0xa
   \   0002EC   65..         XRL       A,?V9
   \   0002EE   700A         JNZ       ??osal_nv_write_19
   1403                  {
   1404                    erasePage( pgRes );
   \   0002F0                ; Setup parameters for call to function erasePage
   \   0002F0   90....       MOV       DPTR,#pgRes
   \   0002F3   E0           MOVX      A,@DPTR
   \   0002F4   F9           MOV       R1,A
   \   0002F5   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
   \   0002F8   8020         SJMP      ??osal_nv_write_18
   1405                  }
   1406                  else
   1407                  {
   1408                    COMPACT_PAGE_CLEANUP( comPg );
   \                     ??osal_nv_write_19:
   \   0002FA                ; Setup parameters for call to function setPageUse
   \   0002FA   7A01         MOV       R2,#0x1
   \   0002FC   90....       MOV       DPTR,#pgRes
   \   0002FF   E0           MOVX      A,@DPTR
   \   000300   F9           MOV       R1,A
   \   000301   12....       LCALL     `??setPageUse::?relay`; Banked call to: setPageUse
   \   000304                ; Setup parameters for call to function erasePage
   \   000304   85..82       MOV       DPL,?XSP + 0
   \   000307   85..83       MOV       DPH,?XSP + 1
   \   00030A   E0           MOVX      A,@DPTR
   \   00030B   F9           MOV       R1,A
   \   00030C   12....       LCALL     `??erasePage::?relay`; Banked call to: erasePage
   \   00030F   85..82       MOV       DPL,?XSP + 0
   \   000312   85..83       MOV       DPH,?XSP + 1
   \   000315   E0           MOVX      A,@DPTR
   \   000316   90....       MOV       DPTR,#pgRes
   \   000319   F0           MOVX      @DPTR,A
   1409                  }
   1410                }
   1411          
   1412                /* Zero of the old item must wait until after compact page cleanup has finished - if the item
   1413                 * is zeroed before and cleanup is interrupted by a power-cycle, the new item can be lost.
   1414                 */
   1415                if ( (srcPg != comPg) && (rtrn != NV_OPER_FAILED) )
   \                     ??osal_nv_write_18:
   \   00031A   85..82       MOV       DPL,?XSP + 0
   \   00031D   85..83       MOV       DPH,?XSP + 1
   \   000320   E0           MOVX      A,@DPTR
   \   000321   65..         XRL       A,?V8
   \   000323   6016         JZ        ??osal_nv_write_1
   \   000325   740A         MOV       A,#0xa
   \   000327   65..         XRL       A,?V9
   \   000329   6010         JZ        ??osal_nv_write_1
   1416                {
   1417                  setItem( srcPg, origOff, eNvZero );
   \   00032B                ; Setup parameters for call to function setItem
   \   00032B   7C01         MOV       R4,#0x1
   \   00032D   EC           MOV       A,R4
   \   00032E   12....       LCALL     ?XSTACK_DISP0_8
   \   000331   E0           MOVX      A,@DPTR
   \   000332   FA           MOV       R2,A
   \   000333   A3           INC       DPTR
   \   000334   E0           MOVX      A,@DPTR
   \   000335   FB           MOV       R3,A
   \   000336   A9..         MOV       R1,?V8
   \   000338   12....       LCALL     `??setItem::?relay`; Banked call to: setItem
   1418                }
   1419              }
   1420            }
   1421          
   1422            return rtrn;
   \                     ??osal_nv_write_1:
   \   00033B   A9..         MOV       R1,?V9
   \                     ??osal_nv_write_3:
   \   00033D   740B         MOV       A,#0xb
   \   00033F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000342   7F10         MOV       R7,#0x10
   \   000344   02....       LJMP      ?BANKED_LEAVE_XDATA
   1423          }
   1424          
   1425          /*********************************************************************
   1426           * @fn      osal_nv_read
   1427           *
   1428           * @brief   Read data from NV. This function can be used to read an entire item from NV or
   1429           *          an element of an item by indexing into the item with an offset.
   1430           *          Read data is copied into *buf.
   1431           *
   1432           * @param   id  - Valid NV item Id.
   1433           * @param   ndx - Index offset into item
   1434           * @param   len - Length of data to read.
   1435           * @param  *buf - Data is read into this buffer.
   1436           *
   1437           * @return  SUCCESS if NV data was copied to the parameter 'buf'.
   1438           *          Otherwise, NV_OPER_FAILED for failure.
   1439           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1440          uint8 osal_nv_read( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_read:
   1441          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V2,R4
   \   00000B   8D..         MOV       ?V3,R5
   1442            uint16 offset;
   1443            uint8 hotIdx;
   1444          
   1445            if ((hotIdx = hotItem(id)) < OSAL_NV_MAX_HOT)
   \   00000D                ; Setup parameters for call to function hotItem
   \   00000D   12....       LCALL     `??hotItem::?relay`; Banked call to: hotItem
   \   000010   E9           MOV       A,R1
   \   000011   F8           MOV       R0,A
   \   000012   F5..         MOV       ?V4,A
   \   000014   7412         MOV       A,#0x12
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V6,A
   \   00001C   A3           INC       DPTR
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   F5..         MOV       ?V7,A
   \   000020   7414         MOV       A,#0x14
   \   000022   12....       LCALL     ?XSTACK_DISP0_8
   \   000025   E0           MOVX      A,@DPTR
   \   000026   F5..         MOV       ?V0,A
   \   000028   A3           INC       DPTR
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   F5..         MOV       ?V1,A
   \   00002C   E9           MOV       A,R1
   \   00002D   C3           CLR       C
   \   00002E   9403         SUBB      A,#0x3
   \   000030   5030         JNC       ??osal_nv_read_0
   1446            {
   1447              HalFlashRead(hotPg[hotIdx], hotOff[hotIdx]+ndx, buf, len);
   \   000032   AE..         MOV       R6,?V4
   \   000034                ; Setup parameters for call to function HalFlashRead
   \   000034   78..         MOV       R0,#?V6
   \   000036   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000039   AC..         MOV       R4,?V0
   \   00003B   AD..         MOV       R5,?V1
   \   00003D   E9           MOV       A,R1
   \   00003E   29           ADD       A,R1
   \   00003F   F8           MOV       R0,A
   \   000040   E4           CLR       A
   \   000041   33           RLC       A
   \   000042   F9           MOV       R1,A
   \   000043   74..         MOV       A,#hotOff & 0xff
   \   000045   28           ADD       A,R0
   \   000046   F582         MOV       DPL,A
   \   000048   74..         MOV       A,#(hotOff >> 8) & 0xff
   \   00004A   39           ADDC      A,R1
   \   00004B   F583         MOV       DPH,A
   \   00004D   E0           MOVX      A,@DPTR
   \   00004E   25..         ADD       A,?V2
   \   000050   FA           MOV       R2,A
   \   000051   A3           INC       DPTR
   \   000052   E0           MOVX      A,@DPTR
   \   000053   35..         ADDC      A,?V3
   \   000055   FB           MOV       R3,A
   \   000056   74..         MOV       A,#hotPg & 0xff
   \   000058   2E           ADD       A,R6
   \   000059   F582         MOV       DPL,A
   \   00005B   E4           CLR       A
   \   00005C   34..         ADDC      A,#(hotPg >> 8) & 0xff
   \   00005E   F583         MOV       DPH,A
   \   000060   8027         SJMP      ??osal_nv_read_1
   1448              return SUCCESS;
   1449            }
   1450          
   1451            if ((offset = findItem(id)) == OSAL_NV_ITEM_NULL)
   \                     ??osal_nv_read_0:
   \   000062                ; Setup parameters for call to function findItem
   \   000062   EE           MOV       A,R6
   \   000063   FA           MOV       R2,A
   \   000064   EF           MOV       A,R7
   \   000065   FB           MOV       R3,A
   \   000066   12....       LCALL     `??findItem::?relay`; Banked call to: findItem
   \   000069   8B..         MOV       ?V9,R3
   \   00006B   A9..         MOV       R1,?V9
   \   00006D   EA           MOV       A,R2
   \   00006E   49           ORL       A,R1
   \   00006F   7004         JNZ       ??osal_nv_read_2
   1452            {
   1453              return NV_OPER_FAILED;
   \   000071   790A         MOV       R1,#0xa
   \   000073   8020         SJMP      ??osal_nv_read_3
   1454            }
   1455            else
   1456            {
   1457              HalFlashRead(findPg, offset+ndx, buf, len);
   \                     ??osal_nv_read_2:
   \   000075                ; Setup parameters for call to function HalFlashRead
   \   000075   78..         MOV       R0,#?V6
   \   000077   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007A   AC..         MOV       R4,?V0
   \   00007C   AD..         MOV       R5,?V1
   \   00007E   EA           MOV       A,R2
   \   00007F   25..         ADD       A,?V2
   \   000081   FA           MOV       R2,A
   \   000082   EB           MOV       A,R3
   \   000083   35..         ADDC      A,?V3
   \   000085   FB           MOV       R3,A
   \   000086   90....       MOV       DPTR,#findPg
   \                     ??osal_nv_read_1:
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   F9           MOV       R1,A
   \   00008B   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   00008E   7402         MOV       A,#0x2
   \   000090   12....       LCALL     ?DEALLOC_XSTACK8
   1458              return SUCCESS;
   \   000093   7900         MOV       R1,#0x0
   \                     ??osal_nv_read_3:
   \   000095   7F0A         MOV       R7,#0xa
   \   000097   02....       LJMP      ?BANKED_LEAVE_XDATA
   1459            }
   1460          }
   1461          
   1462          /*********************************************************************
   1463           * @fn      osal_nv_delete
   1464           *
   1465           * @brief   Delete item from NV. This function will fail if the length
   1466           *          parameter does not match the length of the item in NV.
   1467           *
   1468           * @param   id  - Valid NV item Id.
   1469           * @param   len - Length of item to delete.
   1470           *
   1471           * @return  SUCCESS if item was deleted,
   1472           *          NV_ITEM_UNINIT if item did not exist in NV,
   1473           *          NV_BAD_ITEM_LEN if length parameter not correct,
   1474           *          NV_OPER_FAILED if attempted deletion failed.
   1475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1476          uint8 osal_nv_delete( uint16 id, uint16 len )
   \                     osal_nv_delete:
   1477          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V2,R4
   \   00000B   8D..         MOV       ?V3,R5
   1478            uint16 length;
   1479            uint16 offset;
   1480          
   1481            offset = findItem( id );
   \   00000D                ; Setup parameters for call to function findItem
   \   00000D   12....       LCALL     `??findItem::?relay`; Banked call to: findItem
   \   000010   8A..         MOV       ?V0,R2
   \   000012   8B..         MOV       ?V1,R3
   1482            if ( offset == OSAL_NV_ITEM_NULL )
   \   000014   EA           MOV       A,R2
   \   000015   4B           ORL       A,R3
   \   000016   7004         JNZ       ??osal_nv_delete_0
   1483            {
   1484              // NV item does not exist
   1485              return NV_ITEM_UNINIT;
   \   000018   7909         MOV       R1,#0x9
   \   00001A   8034         SJMP      ??osal_nv_delete_1
   1486            }
   1487          
   1488            length = osal_nv_item_len( id );
   1489            if ( length != len )
   \                     ??osal_nv_delete_0:
   \   00001C                ; Setup parameters for call to function osal_nv_item_len
   \   00001C   EE           MOV       A,R6
   \   00001D   FA           MOV       R2,A
   \   00001E   EF           MOV       A,R7
   \   00001F   FB           MOV       R3,A
   \   000020   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000023   E5..         MOV       A,?V2
   \   000025   6A           XRL       A,R2
   \   000026   7003         JNZ       ??osal_nv_delete_2
   \   000028   E5..         MOV       A,?V3
   \   00002A   6B           XRL       A,R3
   \                     ??osal_nv_delete_2:
   \   00002B   6004         JZ        ??osal_nv_delete_3
   1490            {
   1491              // NV item has different length
   1492              return NV_BAD_ITEM_LEN;
   \   00002D   790C         MOV       R1,#0xc
   \   00002F   801F         SJMP      ??osal_nv_delete_1
   1493            }
   1494          
   1495            // Set item header ID to zero to 'delete' the item
   1496            setItem( findPg, offset, eNvZero );
   \                     ??osal_nv_delete_3:
   \   000031                ; Setup parameters for call to function setItem
   \   000031   7C01         MOV       R4,#0x1
   \   000033   AA..         MOV       R2,?V0
   \   000035   AB..         MOV       R3,?V1
   \   000037   90....       MOV       DPTR,#findPg
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   F9           MOV       R1,A
   \   00003C   12....       LCALL     `??setItem::?relay`; Banked call to: setItem
   1497          
   1498            // Verify that item has been removed
   1499            offset = findItem( id );
   1500            if ( offset != OSAL_NV_ITEM_NULL )
   \   00003F                ; Setup parameters for call to function findItem
   \   00003F   EE           MOV       A,R6
   \   000040   FA           MOV       R2,A
   \   000041   EF           MOV       A,R7
   \   000042   FB           MOV       R3,A
   \   000043   12....       LCALL     `??findItem::?relay`; Banked call to: findItem
   \   000046   EA           MOV       A,R2
   \   000047   4B           ORL       A,R3
   \   000048   6004         JZ        ??osal_nv_delete_4
   1501            {
   1502              // Still there
   1503              return NV_OPER_FAILED;
   \   00004A   790A         MOV       R1,#0xa
   \   00004C   8002         SJMP      ??osal_nv_delete_1
   1504            }
   1505            else
   1506            {
   1507              // Yes, it's gone
   1508              return SUCCESS;
   \                     ??osal_nv_delete_4:
   \   00004E   7900         MOV       R1,#0x0
   \                     ??osal_nv_delete_1:
   \   000050   7F06         MOV       R7,#0x6
   \   000052   02....       LJMP      ?BANKED_LEAVE_XDATA
   1509            }
   1510          }
   1511          
   1512          /*********************************************************************
   1513           */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     37   calcChkB
      0     57   calcChkF
        0     22   -> HalFlashRead
      0     59   compactPage
        0     29   -> HalFlashRead
        0     27   -> calcChkF
        0     27   -> erasePage
        0     27   -> hotItemUpdate
        0     27   -> setChk
        0     27   -> setItem
        0     27   -> setPageUse
        0     30   -> writeItem
        0     31   -> xferBuf
      0     44   erasePage
        0      9   -> HalFlashErase
      0     47   findItem
        0     12   -> initPage
      2     20   hotItem
      1     45   hotItemUpdate
        0     10   -> hotItem
      1     68   initItem
        0     30   -> HalFlashRead
        0     28   -> compactPage
        0     28   -> erasePage
        0     28   -> setPageUse
        0     31   -> writeItem
        0     28   -> writeWordH
      0     22   initNV
        0     22   -> HalFlashRead
        0     20   -> compactPage
        0     20   -> erasePage
        0     20   -> initPage
        0     20   -> setPageUse
      0     48   initPage
        0     28   -> HalFlashRead
        0     26   -> calcChkF
        0     26   -> findItem
        0     26   -> setItem
      0     14   osal_nv_delete
        0     14   -> findItem
        0     14   -> osal_nv_item_len
        0     14   -> setItem
      2      0   osal_nv_init
        2      0   -> initNV
      0     16   osal_nv_item_init
        0     12   -> OnBoard_CheckVoltage
        0     12   -> findItem
        0     12   -> hotItem
        0     12   -> hotItemUpdate
        0     14   -> initItem
      0     36   osal_nv_item_len
        0     22   -> HalFlashRead
        0     20   -> findItem
        0     20   -> hotItem
      0     24   osal_nv_read
        0     20   -> HalFlashRead
        0     18   -> findItem
        0     18   -> hotItem
      0     43   osal_nv_write
        0     37   -> HalFlashRead
        0     35   -> OnBoard_CheckVoltage
        0     35   -> calcChkF
        0     35   -> erasePage
        0     35   -> findItem
        0     35   -> hotItemUpdate
        0     37   -> initItem
        0     35   -> setChk
        0     35   -> setItem
        0     35   -> setPageUse
        0     37   -> writeBuf
        0     39   -> xferBuf
      0     51   setChk
        0     16   -> HalFlashRead
        0     14   -> writeWordH
      0     59   setItem
        0     24   -> HalFlashRead
        0     22   -> writeWord
      0     52   setPageUse
        0     17   -> writeWord
      1     59   writeBuf
        0     22   -> HalFlashRead
        0     20   -> writeWord
        0     22   -> writeWordM
      0     61   writeItem
        0     30   -> HalFlashRead
        0     28   -> calcChkB
        0     28   -> calcChkF
        0     28   -> hotItemUpdate
        0     28   -> setChk
        0     30   -> writeBuf
        0     28   -> writeWord
      0     42   writeWord
        0     14   -> HalFlashWrite
      1     41   writeWordH
        0     13   -> writeWord
      0     36   writeWordM
        0     14   -> HalFlashWrite
      0     63   xferBuf
        0     24   -> HalFlashRead
        0     22   -> writeWord


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
   12288  _nvBuf
     113  calcChkB
     156  calcChkF
     656  compactPage
      51  erasePage
      72  findItem
       1  findPg
       6  hotIds
      48  hotItem
      69  hotItemUpdate
       6  hotOff
       3  hotPg
     437  initItem
     315  initNV
     488  initPage
      85  osal_nv_delete
      14  osal_nv_init
      99  osal_nv_item_init
     138  osal_nv_item_len
     154  osal_nv_read
     839  osal_nv_write
      12  pgLost
      12  pgOff
       1  pgRes
      93  setChk
     171  setItem
      62  setPageUse
     363  writeBuf
     470  writeItem
      63  writeWord
      71  writeWordH
      60  writeWordM
     407  xferBuf
     150  -- Other

 
  5 494 bytes in segment BANKED_CODE
    150 bytes in segment BANK_RELAYS
      6 bytes in segment XDATA_ROM_C
     35 bytes in segment XDATA_Z
 12 288 bytes in segment ZIGNV_ADDRESS_SPACE
 
    150 bytes of CODE     memory
      6 bytes of CONST    memory
  5 494 bytes of HUGECODE memory
 12 323 bytes of XDATA    memory

Errors: none
Warnings: none
