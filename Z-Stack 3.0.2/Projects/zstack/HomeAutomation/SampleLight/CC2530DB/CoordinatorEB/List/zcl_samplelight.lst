###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               20/Jul/2020  22:28:23
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\Source\zcl_samplelight.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EWC221.tmp ("D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\Source\zcl_samplelight.c"
#        -D BDB_REPORTING -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D
#        NV_RESTORE -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D
#        xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_SCENES -D ZCL_GROUPS -D ZCL_LEVEL_CTRL -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
#        "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List\zcl_samplelight.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\Obj\zcl_samplelight.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Projects\zstack\HomeAutomation\SampleLight\Source\zcl_samplelight.c
      1          /**************************************************************************************************
      2            Filename:       zcl_sampleLight.c
      3            Revised:        $Date: 2014-10-24 16:04:46 -0700 (Fri, 24 Oct 2014) $
      4            Revision:       $Revision: 40796 $
      5          
      6          
      7            Description:    Zigbee Cluster Library - sample light application.
      8          
      9          
     10            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42            This application implements a ZigBee Light, based on Z-Stack 3.0. It can be configured as an
     43            On/Off light or as a dimmable light, by undefining or defining ZCL_LEVEL_CTRL, respectively.
     44          
     45            This application is based on the common sample-application user interface. Please see the main
     46            comment in zcl_sampleapp_ui.c. The rest of this comment describes only the content specific for
     47            this sample applicetion.
     48            
     49            Application-specific UI peripherals being used:
     50          
     51            - LEDs:
     52              LED1 reflect the current light state (On / Off accordingly).
     53          
     54            Application-specific menu system:
     55          
     56              <TOGGLE LIGHT> Toggle the local light and display its status and level
     57                Press OK to toggle the local light on and off.
     58                This screen shows the following information
     59                  Line1: (only populated if ZCL_LEVEL_CTRL is defined)
     60                    LEVEL XXX - xxx is the current level of the light if the light state is ON, or the target level
     61                      of the light when the light state is off. The target level is the level that the light will be
     62                      set to when it is switched from off to on using the on or the toggle commands.
     63                  Line2:
     64                    LIGHT OFF / ON: shows the current state of the light.
     65                Note when ZCL_LEVEL_CTRL is enabled:
     66                  - If the light state is ON and the light level is X, and then the light receives the OFF or TOGGLE 
     67                    commands: The level will decrease gradually until it reaches 1, and only then the light state will
     68                    be changed to OFF. The level then will be restored to X, with the state staying OFF. At this stage
     69                    the light is not lighting, and the level represent the target level for the next ON or TOGGLE 
     70                    commands.
     71                  - If the light state is OFF and the light level is X, and then the light receives the ON or TOGGLE
     72                    commands; The level will be set to 1, the light state will be set to ON, and then the level will
     73                    increase gradually until it reaches level X.
     74                  - Any level-setting command will affect the level directly, and may also affect the on/off state,
     75                    depending on the command's arguments.       
     76          
     77          *********************************************************************/
     78          
     79          /*********************************************************************
     80           * INCLUDES
     81           */
     82          #include "ZComDef.h"
     83          #include "OSAL.h"
     84          #include "AF.h"
     85          #include "ZDApp.h"
     86          #include "ZDObject.h"
     87          #include "MT_SYS.h"
     88          
     89          #include "nwk_util.h"
     90          
     91          #include "zcl.h"
     92          #include "zcl_general.h"
     93          #include "zcl_ha.h"
     94          #include "zcl_diagnostic.h"
     95          
     96          #include "zcl_samplelight.h"
     97             
     98          #include "bdb.h"
     99          #include "bdb_interface.h"
    100          
    101           //GP_UPDATE
    102          #include "gp_interface.h"
    103             
    104          #include "onboard.h"
    105          
    106          /* HAL */
    107          #include "hal_lcd.h"
    108          #include "hal_led.h"
    109          #include "hal_key.h"
    110          
    111          #include "NLMEDE.h"
    112          
    113          // Added to include TouchLink initiator functionality 
    114          #if defined ( BDB_TL_INITIATOR )
    115            #include "bdb_touchlink_initiator.h"
    116          #endif // BDB_TL_INITIATOR
    117          
    118          #if defined ( BDB_TL_TARGET )
    119            #include "bdb_touchlink_target.h"
    120          #endif // BDB_TL_TARGET
    121          
    122          #if defined ( BDB_TL_INITIATOR ) || defined ( BDB_TL_TARGET )
    123            #include "bdb_touchlink.h"
    124          #endif
    125          
    126          
    127          /*********************************************************************
    128           * MACROS
    129           */
    130          #define APP_TITLE "TI Sample Light"
    131          
    132          /*********************************************************************
    133           * TYPEDEFS
    134           */
    135          
    136          /*********************************************************************
    137           * GLOBAL VARIABLES
    138           */
    139          byte zclSampleLight_TaskID;
    140          uint8 zclSampleLightSeqNum;
    141          
    142          /*********************************************************************
    143           * GLOBAL FUNCTIONS
    144           */
    145          
    146          /*********************************************************************
    147           * LOCAL VARIABLES
    148           */
    149          afAddrType_t zclSampleLight_DstAddr;
    150          
    151          // Test Endpoint to allow SYS_APP_MSGs
    152          static endPointDesc_t sampleLight_TestEp =
    153          {
    154            SAMPLELIGHT_ENDPOINT,
    155            0,
    156            &zclSampleLight_TaskID,
    157            (SimpleDescriptionFormat_t *)NULL,  // No Simple description for this test endpoint
    158            (afNetworkLatencyReq_t)0            // No Network Latency req
    159          };
    160          
    161          #ifdef ZCL_LEVEL_CTRL
    162          uint8 zclSampleLight_WithOnOff;       // set to TRUE if state machine should set light on/off
    163          uint8 zclSampleLight_NewLevel;        // new level when done moving
    164          uint8 zclSampleLight_LevelChangeCmd; // current level change was triggered by an on/off command
    165          bool  zclSampleLight_NewLevelUp;      // is direction to new level up or down?
    166          int32 zclSampleLight_CurrentLevel32;  // current level, fixed point (e.g. 192.456)
    167          int32 zclSampleLight_Rate32;          // rate in units, fixed point (e.g. 16.123)
    168          uint8 zclSampleLight_LevelLastLevel;  // to save the Current Level before the light was turned OFF
    169          #endif
    170          
    171          /*********************************************************************
    172           * LOCAL FUNCTIONS
    173           */
    174          static void zclSampleLight_HandleKeys( byte shift, byte keys );
    175          static void zclSampleLight_BasicResetCB( void );
    176          static void zclSampleLight_OnOffCB( uint8 cmd );
    177          //GP_UPDATE
    178          #if (ZG_BUILD_RTR_TYPE)
    179          static void gp_CommissioningMode(bool isEntering);
    180          static uint8 gp_ChangeChannelReq(void);
    181          #endif
    182          
    183          
    184          static void zclSampleLight_ProcessCommissioningStatus(bdbCommissioningModeMsg_t *bdbCommissioningModeMsg);
    185          
    186          
    187          #ifdef ZCL_LEVEL_CTRL
    188          static void zclSampleLight_LevelControlMoveToLevelCB( zclLCMoveToLevel_t *pCmd );
    189          static void zclSampleLight_LevelControlMoveCB( zclLCMove_t *pCmd );
    190          static void zclSampleLight_LevelControlStepCB( zclLCStep_t *pCmd );
    191          static void zclSampleLight_LevelControlStopCB( void );
    192          static void zclSampleLight_DefaultMove( uint8 OnOff );
    193          static uint32 zclSampleLight_TimeRateHelper( uint8 newLevel );
    194          static uint16 zclSampleLight_GetTime ( uint8 level, uint16 time );
    195          static void zclSampleLight_MoveBasedOnRate( uint8 newLevel, uint32 rate );
    196          static void zclSampleLight_MoveBasedOnTime( uint8 newLevel, uint16 time );
    197          static void zclSampleLight_AdjustLightLevel( void );
    198          #endif
    199          
    200          // Functions to process ZCL Foundation incoming Command/Response messages
    201          static void zclSampleLight_ProcessIncomingMsg( zclIncomingMsg_t *msg );
    202          #ifdef ZCL_READ
    203          static uint8 zclSampleLight_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg );
    204          #endif
    205          #ifdef ZCL_WRITE
    206          static uint8 zclSampleLight_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg );
    207          #endif
    208          static uint8 zclSampleLight_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg );
    209          #ifdef ZCL_DISCOVER
    210          static uint8 zclSampleLight_ProcessInDiscCmdsRspCmd( zclIncomingMsg_t *pInMsg );
    211          static uint8 zclSampleLight_ProcessInDiscAttrsRspCmd( zclIncomingMsg_t *pInMsg );
    212          static uint8 zclSampleLight_ProcessInDiscAttrsExtRspCmd( zclIncomingMsg_t *pInMsg );
    213          #endif
    214          
    215          static void zclSampleApp_BatteryWarningCB( uint8 voltLevel);
    216          
    217          void zclSampleLight_UpdateLedState(void);
    218          
    219          /*********************************************************************
    220           * CONSTANTS
    221           */
    222          
    223          #define LEVEL_CHANGED_BY_LEVEL_CMD  0
    224          #define LEVEL_CHANGED_BY_ON_CMD     1
    225          #define LEVEL_CHANGED_BY_OFF_CMD    2
    226          
    227          /*********************************************************************
    228           * STATUS STRINGS
    229           */
    230          #ifdef LCD_SUPPORTED
    231            const char sLightOn[]      = "   LIGHT ON     ";
    232            const char sLightOff[]     = "   LIGHT OFF    ";
    233            #ifdef ZCL_LEVEL_CTRL
    234              char sLightLevel[]        = "   LEVEL ###    "; // displays level 1-254
    235            #endif
    236          #endif
    237          
    238          /*********************************************************************
    239           * REFERENCED EXTERNALS
    240           */
    241          extern int16 zdpExternalStateTaskID;
    242          
    243          /*********************************************************************
    244           * ZCL General Profile Callback table
    245           */
    246          static zclGeneral_AppCallbacks_t zclSampleLight_CmdCallbacks =
    247          {
    248            zclSampleLight_BasicResetCB,            // Basic Cluster Reset command
    249            NULL,                                   // Identify Trigger Effect command
    250            zclSampleLight_OnOffCB,                 // On/Off cluster commands
    251            NULL,                                   // On/Off cluster enhanced command Off with Effect
    252            NULL,                                   // On/Off cluster enhanced command On with Recall Global Scene
    253            NULL,                                   // On/Off cluster enhanced command On with Timed Off
    254          #ifdef ZCL_LEVEL_CTRL
    255            zclSampleLight_LevelControlMoveToLevelCB, // Level Control Move to Level command
    256            zclSampleLight_LevelControlMoveCB,        // Level Control Move command
    257            zclSampleLight_LevelControlStepCB,        // Level Control Step command
    258            zclSampleLight_LevelControlStopCB,        // Level Control Stop command
    259          #endif
    260          #ifdef ZCL_GROUPS
    261            NULL,                                   // Group Response commands
    262          #endif
    263          #ifdef ZCL_SCENES
    264            NULL,                                  // Scene Store Request command
    265            NULL,                                  // Scene Recall Request command
    266            NULL,                                  // Scene Response command
    267          #endif
    268          #ifdef ZCL_ALARMS
    269            NULL,                                  // Alarm (Response) commands
    270          #endif
    271          #ifdef SE_UK_EXT
    272            NULL,                                  // Get Event Log command
    273            NULL,                                  // Publish Event Log command
    274          #endif
    275            NULL,                                  // RSSI Location command
    276            NULL                                   // RSSI Location Response command
    277          };
    278          
    279          /*********************************************************************
    280           * @fn          zclSampleLight_Init
    281           *
    282           * @brief       Initialization function for the zclGeneral layer.
    283           *
    284           * @param       none
    285           *
    286           * @return      none
    287           */
    288          void zclSampleLight_Init( byte task_id )
    289          {
    290            zclSampleLight_TaskID = task_id;
    291          
    292            // Set destination address to indirect
    293            zclSampleLight_DstAddr.addrMode = (afAddrMode_t)AddrNotPresent;
    294            zclSampleLight_DstAddr.endPoint = 0;
    295            zclSampleLight_DstAddr.addr.shortAddr = 0;
    296          
    297            // Register the Simple Descriptor for this application
    298            bdb_RegisterSimpleDescriptor( &zclSampleLight_SimpleDesc );
    299          
    300            // Register the ZCL General Cluster Library callback functions
    301            zclGeneral_RegisterCmdCallbacks( SAMPLELIGHT_ENDPOINT, &zclSampleLight_CmdCallbacks );
    302          
    303            // Register the application's attribute list
    304            zclSampleLight_ResetAttributesToDefaultValues();
    305            zcl_registerAttrList( SAMPLELIGHT_ENDPOINT, zclSampleLight_NumAttributes, zclSampleLight_Attrs );
    306          
    307          #ifdef ZCL_LEVEL_CTRL
    308            zclSampleLight_LevelLastLevel = zclSampleLight_LevelCurrentLevel;
    309          #endif
    310          
    311            // Register the Application to receive the unprocessed Foundation command/response messages
    312            zcl_registerForMsg( zclSampleLight_TaskID );
    313          
    314          #ifdef ZCL_DISCOVER
    315            // Register the application's command list
    316            zcl_registerCmdList( SAMPLELIGHT_ENDPOINT, zclCmdsArraySize, zclSampleLight_Cmds );
    317          #endif
    318          
    319            // Register low voltage NV memory protection application callback
    320            RegisterVoltageWarningCB( zclSampleApp_BatteryWarningCB );
    321          
    322            // Register for all key events - This app will handle all key events
    323            RegisterForKeys( zclSampleLight_TaskID );
    324            
    325            bdb_RegisterCommissioningStatusCB( zclSampleLight_ProcessCommissioningStatus );
    326            
    327            // Register for a test endpoint
    328            afRegister( &sampleLight_TestEp );
    329          
    330          #ifdef ZCL_DIAGNOSTIC
    331            // Register the application's callback function to read/write attribute data.
    332            // This is only required when the attribute data format is unknown to ZCL.
    333            zcl_registerReadWriteCB( SAMPLELIGHT_ENDPOINT, zclDiagnostic_ReadWriteAttrCB, NULL );
    334          
    335            if ( zclDiagnostic_InitStats() == ZSuccess )
    336            {
    337              // Here the user could start the timer to save Diagnostics to NV
    338            }
    339          #endif
    340            
    341          //GP_UPDATE  
    342          #if (ZG_BUILD_RTR_TYPE)  
    343            gp_RegisterCommissioningModeCB(gp_CommissioningMode);
    344            gp_RegisterGPChangeChannelReqCB(gp_ChangeChannelReq);
    345          #endif
    346            
    347            zdpExternalStateTaskID = zclSampleLight_TaskID;
    348          }
    349          
    350          /*********************************************************************
    351           * @fn          zclSample_event_loop
    352           *
    353           * @brief       Event Loop Processor for zclGeneral.
    354           *
    355           * @param       none
    356           *
    357           * @return      none
    358           */
    359          uint16 zclSampleLight_event_loop( uint8 task_id, uint16 events )
    360          {
    361            afIncomingMSGPacket_t *MSGpkt;
    362          
    363            (void)task_id;  // Intentionally unreferenced parameter
    364          
    365            if ( events & SYS_EVENT_MSG )
    366            {
    367              while ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( zclSampleLight_TaskID )) )
    368              {
    369                switch ( MSGpkt->hdr.event )
    370                {
    371                  case ZCL_INCOMING_MSG:
    372                    // Incoming ZCL Foundation command/response messages
    373                    zclSampleLight_ProcessIncomingMsg( (zclIncomingMsg_t *)MSGpkt );
    374                    break;
    375          
    376                  case KEY_CHANGE:
    377                    zclSampleLight_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    378                    break;
    379          
    380                  case ZDO_STATE_CHANGE:
    381                    break;
    382          
    383                  default:
    384                    break;
    385                }
    386          
    387                // Release the memory
    388                osal_msg_deallocate( (uint8 *)MSGpkt );
    389              }
    390          
    391              // return unprocessed events
    392              return (events ^ SYS_EVENT_MSG);
    393            }
    394          
    395          #ifdef ZCL_LEVEL_CTRL
    396            if ( events & SAMPLELIGHT_LEVEL_CTRL_EVT )
    397            {
    398              zclSampleLight_AdjustLightLevel();
    399              return ( events ^ SAMPLELIGHT_LEVEL_CTRL_EVT );
    400            }
    401          #endif
    402          
    403          #if ZG_BUILD_ENDDEVICE_TYPE    
    404            if ( events & SAMPLEAPP_END_DEVICE_REJOIN_EVT )
    405            {
    406              bdb_ZedAttemptRecoverNwk();
    407              return ( events ^ SAMPLEAPP_END_DEVICE_REJOIN_EVT );
    408            }
    409          #endif
    410          
    411            if ( events & SAMPLEAPP_LCD_AUTO_UPDATE_EVT )
    412            {
    413              return ( events ^ SAMPLEAPP_LCD_AUTO_UPDATE_EVT );
    414            }
    415          
    416            if ( events & SAMPLEAPP_KEY_AUTO_REPEAT_EVT )
    417            {
    418              return ( events ^ SAMPLEAPP_KEY_AUTO_REPEAT_EVT );
    419            }
    420          
    421            // Discard unknown events
    422            return 0;
    423          }
    424          
    425          
    426          /*********************************************************************
    427           * @fn      zclSampleLight_HandleKeys
    428           *
    429           * @brief   Handles all key events for this device.
    430           *
    431           * @param   shift - true if in shift/alt.
    432           * @param   keys - bit field for key events. Valid entries:
    433           *                 HAL_KEY_SW_5
    434           *                 HAL_KEY_SW_4
    435           *                 HAL_KEY_SW_2
    436           *                 HAL_KEY_SW_1
    437           *
    438           * @return  none
    439           */
    440          static void zclSampleLight_HandleKeys( byte shift, byte keys )
    441          {
    442          }
    443          
    444          //GP_UPDATE
    445          #if (ZG_BUILD_RTR_TYPE)
    446          /*********************************************************************
    447           * @fn      gp_CommissioningMode
    448           *
    449           * @brief   Callback that notifies the application that gp Proxy is entering 
    450           *          into commissioning mode
    451           *
    452           * @param   isEntering - 
    453           *
    454           * @return  
    455           */
    456          static void gp_CommissioningMode(bool isEntering)
    457          {
    458            if(isEntering)
    459            {
    460              //Led on indicating enter commissioning mode
    461            }
    462            else
    463            {
    464              //Led off indicating enter commissioning mode
    465            }
    466          }
    467          
    468          
    469          
    470          //GP_UPDATE
    471          /*********************************************************************
    472           * @fn      gp_ChangeChannelReq
    473           *
    474           * @brief   Callback function to notify the application about a GP commissioning 
    475           * request that will change the current channel for at most 
    476           * gpBirectionalCommissioningChangeChannelTimeout ms
    477           *
    478           * @param   channel - Channel in which the commissioning will take place
    479           *
    480           * @return  TRUE to allow change channel, FALSE to do not allow
    481           */
    482          static uint8 gp_ChangeChannelReq(void)
    483          {
    484            bool allowChangeChannel = TRUE;
    485            
    486            //Check application state to decide if allow change channel or not
    487            
    488            return allowChangeChannel;
    489          }
    490          
    491          #endif
    492          
    493          
    494          /*********************************************************************
    495           * @fn      zclSampleLight_ProcessCommissioningStatus
    496           *
    497           * @brief   Callback in which the status of the commissioning process are reported
    498           *
    499           * @param   bdbCommissioningModeMsg - Context message of the status of a commissioning process
    500           *
    501           * @return  none
    502           */
    503          static void zclSampleLight_ProcessCommissioningStatus(bdbCommissioningModeMsg_t *bdbCommissioningModeMsg)
    504          {
    505            switch(bdbCommissioningModeMsg->bdbCommissioningMode)
    506            {
    507              case BDB_COMMISSIONING_FORMATION:
    508                if(bdbCommissioningModeMsg->bdbCommissioningStatus == BDB_COMMISSIONING_SUCCESS)
    509                {
    510                  //After formation, perform nwk steering again plus the remaining commissioning modes that has not been process yet
    511                  bdb_StartCommissioning(BDB_COMMISSIONING_MODE_NWK_STEERING | bdbCommissioningModeMsg->bdbRemainingCommissioningModes);
    512                }
    513                else
    514                {
    515                  //Want to try other channels?
    516                  //try with bdb_setChannelAttribute
    517                }
    518              break;
    519              case BDB_COMMISSIONING_NWK_STEERING:
    520                if(bdbCommissioningModeMsg->bdbCommissioningStatus == BDB_COMMISSIONING_SUCCESS)
    521                {
    522                  //YOUR JOB:
    523                  //We are on the nwk, what now?
    524                }
    525                else
    526                {
    527                  //See the possible errors for nwk steering procedure
    528                  //No suitable networks found
    529                  //Want to try other channels?
    530                  //try with bdb_setChannelAttribute
    531                }
    532              break;
    533              case BDB_COMMISSIONING_FINDING_BINDING:
    534                if(bdbCommissioningModeMsg->bdbCommissioningStatus == BDB_COMMISSIONING_SUCCESS)
    535                {
    536                  //YOUR JOB:
    537                }
    538                else
    539                {
    540                  //YOUR JOB:
    541                  //retry?, wait for user interaction?
    542                }
    543              break;
    544              case BDB_COMMISSIONING_INITIALIZATION:
    545                //Initialization notification can only be successful. Failure on initialization 
    546                //only happens for ZED and is notified as BDB_COMMISSIONING_PARENT_LOST notification
    547                
    548                //YOUR JOB:
    549                //We are on a network, what now?
    550                
    551              break;
    552          #if ZG_BUILD_ENDDEVICE_TYPE    
    553              case BDB_COMMISSIONING_PARENT_LOST:
    554                if(bdbCommissioningModeMsg->bdbCommissioningStatus == BDB_COMMISSIONING_NETWORK_RESTORED)
    555                {
    556                  //We did recover from losing parent
    557                }
    558                else
    559                {
    560                  //Parent not found, attempt to rejoin again after a fixed delay
    561                  osal_start_timerEx(zclSampleLight_TaskID, SAMPLEAPP_END_DEVICE_REJOIN_EVT, SAMPLEAPP_END_DEVICE_REJOIN_DELAY);
    562                }
    563              break;
    564          #endif 
    565            }
    566          
    567          }
    568          
    569          /*********************************************************************
    570           * @fn      zclSampleLight_BasicResetCB
    571           *
    572           * @brief   Callback from the ZCL General Cluster Library
    573           *          to set all the Basic Cluster attributes to default values.
    574           *
    575           * @param   none
    576           *
    577           * @return  none
    578           */
    579          static void zclSampleLight_BasicResetCB( void )
    580          {
    581            //Reset every attribute in all supported cluster to their default value.
    582          
    583            zclSampleLight_ResetAttributesToDefaultValues();
    584          
    585            zclSampleLight_UpdateLedState();
    586          }
    587          
    588          /*********************************************************************
    589           * @fn      zclSampleLight_OnOffCB
    590           *
    591           * @brief   Callback from the ZCL General Cluster Library when
    592           *          it received an On/Off Command for this application.
    593           *
    594           * @param   cmd - COMMAND_ON, COMMAND_OFF or COMMAND_TOGGLE
    595           *
    596           * @return  none
    597           */
    598          static void zclSampleLight_OnOffCB( uint8 cmd )
    599          {
    600            afIncomingMSGPacket_t *pPtr = zcl_getRawAFMsg();
    601          
    602            uint8 OnOff;
    603          
    604            zclSampleLight_DstAddr.addr.shortAddr = pPtr->srcAddr.addr.shortAddr;
    605          
    606          
    607            // Turn on the light
    608            if ( cmd == COMMAND_ON )
    609            {
    610              OnOff = LIGHT_ON;
    611            }
    612            // Turn off the light
    613            else if ( cmd == COMMAND_OFF )
    614            {
    615              OnOff = LIGHT_OFF;
    616            }
    617            // Toggle the light
    618            else if ( cmd == COMMAND_TOGGLE )
    619            {
    620          #ifdef ZCL_LEVEL_CTRL
    621              if (zclSampleLight_LevelRemainingTime > 0) 
    622              {
    623                if (zclSampleLight_NewLevelUp)
    624                {
    625                  OnOff = LIGHT_OFF;
    626                }
    627                else
    628                {
    629                  OnOff = LIGHT_ON;
    630                }
    631              }
    632              else
    633              {
    634                if (zclSampleLight_OnOff == LIGHT_ON)
    635                {
    636                  OnOff = LIGHT_OFF;
    637                }
    638                else
    639                {
    640                  OnOff = LIGHT_ON;
    641                }
    642              }
    643          #else
    644              if (zclSampleLight_OnOff == LIGHT_ON)
    645              {
    646                OnOff = LIGHT_OFF;
    647              }
    648              else
    649              {
    650                OnOff = LIGHT_ON;
    651              }
    652          #endif
    653            }
    654          
    655          #ifdef ZCL_LEVEL_CTRL
    656            zclSampleLight_LevelChangeCmd = (OnOff == LIGHT_ON ? LEVEL_CHANGED_BY_ON_CMD : LEVEL_CHANGED_BY_OFF_CMD);
    657          
    658            zclSampleLight_DefaultMove(OnOff);
    659          #else
    660            zclSampleLight_OnOff = OnOff;
    661          #endif
    662          
    663            zclSampleLight_UpdateLedState();
    664          }
    665          
    666          #ifdef ZCL_LEVEL_CTRL
    667          /*********************************************************************
    668           * @fn      zclSampleLight_TimeRateHelper
    669           *
    670           * @brief   Calculate time based on rate, and startup level state machine
    671           *
    672           * @param   newLevel - new level for current level
    673           *
    674           * @return  diff (directly), zclSampleLight_CurrentLevel32 and zclSampleLight_NewLevel, zclSampleLight_NewLevelUp
    675           */
    676          static uint32 zclSampleLight_TimeRateHelper( uint8 newLevel )
    677          {
    678            uint32 diff;
    679            uint32 newLevel32;
    680          
    681            // remember current and new level
    682            zclSampleLight_NewLevel = newLevel;
    683            zclSampleLight_CurrentLevel32 = (uint32)1000 * zclSampleLight_LevelCurrentLevel;
    684          
    685            // calculate diff
    686            newLevel32 = (uint32)1000 * newLevel;
    687            if ( zclSampleLight_LevelCurrentLevel > newLevel )
    688            {
    689              diff = zclSampleLight_CurrentLevel32 - newLevel32;
    690              zclSampleLight_NewLevelUp = FALSE;  // moving down
    691            }
    692            else
    693            {
    694              diff = newLevel32 - zclSampleLight_CurrentLevel32;
    695              zclSampleLight_NewLevelUp = TRUE;   // moving up
    696            }
    697          
    698            return ( diff );
    699          }
    700          
    701          /*********************************************************************
    702           * @fn      zclSampleLight_MoveBasedOnRate
    703           *
    704           * @brief   Calculate time based on rate, and startup level state machine
    705           *
    706           * @param   newLevel - new level for current level
    707           * @param   rate16   - fixed point rate (e.g. 16.123)
    708           *
    709           * @return  none
    710           */
    711          static void zclSampleLight_MoveBasedOnRate( uint8 newLevel, uint32 rate )
    712          {
    713            uint32 diff;
    714          
    715            // determine how much time (in 10ths of seconds) based on the difference and rate
    716            zclSampleLight_Rate32 = rate;
    717            diff = zclSampleLight_TimeRateHelper( newLevel );
    718            zclSampleLight_LevelRemainingTime = diff / rate;
    719            if ( !zclSampleLight_LevelRemainingTime )
    720            {
    721              zclSampleLight_LevelRemainingTime = 1;
    722            }
    723          
    724            osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
    725          }
    726          
    727          /*********************************************************************
    728           * @fn      zclSampleLight_MoveBasedOnTime
    729           *
    730           * @brief   Calculate rate based on time, and startup level state machine
    731           *
    732           * @param   newLevel  - new level for current level
    733           * @param   time      - in 10ths of seconds
    734           *
    735           * @return  none
    736           */
    737          static void zclSampleLight_MoveBasedOnTime( uint8 newLevel, uint16 time )
    738          {
    739            uint16 diff;
    740          
    741            // determine rate (in units) based on difference and time
    742            diff = zclSampleLight_TimeRateHelper( newLevel );
    743            zclSampleLight_LevelRemainingTime = zclSampleLight_GetTime( newLevel, time );
    744            zclSampleLight_Rate32 = diff / time;
    745          
    746            osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
    747          }
    748          
    749          /*********************************************************************
    750           * @fn      zclSampleLight_GetTime
    751           *
    752           * @brief   Determine amount of time that MoveXXX will take to complete.
    753           *
    754           * @param   level = new level to move to
    755           *          time  = 0xffff=default, or 0x0000-n amount of time in tenths of seconds.
    756           *
    757           * @return  none
    758           */
    759          static uint16 zclSampleLight_GetTime( uint8 newLevel, uint16 time )
    760          {
    761            // there is a hiearchy of the amount of time to use for transistioning
    762            // check each one in turn. If none of defaults are set, then use fastest
    763            // time possible.
    764            if ( time == 0xFFFF )
    765            {
    766              // use On or Off Transition Time if set (not 0xffff)
    767              if ( zclSampleLight_LevelCurrentLevel > newLevel )
    768              {
    769                time = zclSampleLight_LevelOffTransitionTime;
    770              }
    771              else
    772              {
    773                time = zclSampleLight_LevelOnTransitionTime;
    774              }
    775          
    776              // else use OnOffTransitionTime if set (not 0xffff)
    777              if ( time == 0xFFFF )
    778              {
    779                time = zclSampleLight_LevelOnOffTransitionTime;
    780              }
    781          
    782              // else as fast as possible
    783              if ( time == 0xFFFF )
    784              {
    785                time = 1;
    786              }
    787            }
    788          
    789            if ( time == 0 )
    790            {
    791              time = 1; // as fast as possible
    792            }
    793          
    794            return ( time );
    795          }
    796          
    797          /*********************************************************************
    798           * @fn      zclSampleLight_DefaultMove
    799           *
    800           * @brief   We were turned on/off. Use default time to move to on or off.
    801           *
    802           * @param   zclSampleLight_OnOff - must be set prior to calling this function.
    803           *
    804           * @return  none
    805           */
    806          static void zclSampleLight_DefaultMove( uint8 OnOff )
    807          {
    808            uint8  newLevel;
    809            uint32 rate;      // fixed point decimal (3 places, eg. 16.345)
    810            uint16 time;
    811          
    812            // if moving to on position, move to on level
    813            if ( OnOff )
    814            {
    815              if (zclSampleLight_OnOff == LIGHT_OFF)
    816              {
    817                zclSampleLight_LevelCurrentLevel = ATTR_LEVEL_MIN_LEVEL;
    818              }
    819              
    820              if ( zclSampleLight_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT )
    821              {
    822                // The last Level (before going OFF) should be used)
    823                newLevel = zclSampleLight_LevelLastLevel;
    824              }
    825              else
    826              {
    827                newLevel = zclSampleLight_LevelOnLevel;
    828              }
    829          
    830              time = zclSampleLight_LevelOnTransitionTime;
    831          
    832            }
    833            else
    834            {
    835              newLevel = ATTR_LEVEL_MIN_LEVEL;
    836          
    837              time = zclSampleLight_LevelOffTransitionTime;
    838            }
    839          
    840            // else use OnOffTransitionTime if set (not 0xffff)
    841            if ( time == 0xFFFF )
    842            {
    843              time = zclSampleLight_LevelOnOffTransitionTime;
    844            }
    845          
    846            // else as fast as possible
    847            if ( time == 0xFFFF )
    848            {
    849              time = 1;
    850            }
    851          
    852            // calculate rate based on time (int 10ths) for full transition (1-254)
    853            rate = 255000 / time;    // units per tick, fixed point, 3 decimal places (e.g. 8500 = 8.5 units per tick)
    854          
    855            // start up state machine.
    856            zclSampleLight_WithOnOff = TRUE;
    857            zclSampleLight_MoveBasedOnRate( newLevel, rate );
    858          }
    859          
    860          /*********************************************************************
    861           * @fn      zclSampleLight_AdjustLightLevel
    862           *
    863           * @brief   Called each 10th of a second while state machine running
    864           *
    865           * @param   none
    866           *
    867           * @return  none
    868           */
    869          static void zclSampleLight_AdjustLightLevel( void )
    870          {
    871            // one tick (10th of a second) less
    872            if ( zclSampleLight_LevelRemainingTime )
    873            {
    874              --zclSampleLight_LevelRemainingTime;
    875            }
    876          
    877            // no time left, done
    878            if ( zclSampleLight_LevelRemainingTime == 0)
    879            {
    880              zclSampleLight_LevelCurrentLevel = zclSampleLight_NewLevel;
    881            }
    882          
    883            // still time left, keep increment/decrementing
    884            else
    885            {
    886              if ( zclSampleLight_NewLevelUp )
    887              {
    888                zclSampleLight_CurrentLevel32 += zclSampleLight_Rate32;
    889              }
    890              else
    891              {
    892                zclSampleLight_CurrentLevel32 -= zclSampleLight_Rate32;
    893              }
    894              zclSampleLight_LevelCurrentLevel = (uint8)( zclSampleLight_CurrentLevel32 / 1000 );
    895            }
    896          
    897            if (( zclSampleLight_LevelChangeCmd == LEVEL_CHANGED_BY_LEVEL_CMD ) && ( zclSampleLight_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT ))
    898            {
    899              zclSampleLight_LevelLastLevel = zclSampleLight_LevelCurrentLevel;
    900            }
    901          
    902            // also affect on/off
    903            if ( zclSampleLight_WithOnOff )
    904            {
    905              if ( zclSampleLight_LevelCurrentLevel > ATTR_LEVEL_MIN_LEVEL )
    906              {
    907                zclSampleLight_OnOff = LIGHT_ON;
    908              }
    909              else
    910              {
    911                if (zclSampleLight_LevelChangeCmd != LEVEL_CHANGED_BY_ON_CMD)
    912                {
    913                  zclSampleLight_OnOff = LIGHT_OFF;
    914                }
    915                else
    916                {
    917                  zclSampleLight_OnOff = LIGHT_ON;
    918                }
    919                
    920                if (( zclSampleLight_LevelChangeCmd != LEVEL_CHANGED_BY_LEVEL_CMD ) && ( zclSampleLight_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT ))
    921                {
    922                  zclSampleLight_LevelCurrentLevel = zclSampleLight_LevelLastLevel;
    923                }
    924              }
    925            }
    926          
    927            zclSampleLight_UpdateLedState();
    928          
    929            // keep ticking away
    930            if ( zclSampleLight_LevelRemainingTime )
    931            {
    932              osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
    933            }
    934          }
    935          
    936          /*********************************************************************
    937           * @fn      zclSampleLight_LevelControlMoveToLevelCB
    938           *
    939           * @brief   Callback from the ZCL General Cluster Library when
    940           *          it received a LevelControlMoveToLevel Command for this application.
    941           *
    942           * @param   pCmd - ZigBee command parameters
    943           *
    944           * @return  none
    945           */
    946          static void zclSampleLight_LevelControlMoveToLevelCB( zclLCMoveToLevel_t *pCmd )
    947          {
    948            zclSampleLight_LevelChangeCmd = LEVEL_CHANGED_BY_LEVEL_CMD;
    949          
    950            zclSampleLight_WithOnOff = pCmd->withOnOff;
    951            zclSampleLight_MoveBasedOnTime( pCmd->level, pCmd->transitionTime );
    952          }
    953          
    954          /*********************************************************************
    955           * @fn      zclSampleLight_LevelControlMoveCB
    956           *
    957           * @brief   Callback from the ZCL General Cluster Library when
    958           *          it received a LevelControlMove Command for this application.
    959           *
    960           * @param   pCmd - ZigBee command parameters
    961           *
    962           * @return  none
    963           */
    964          static void zclSampleLight_LevelControlMoveCB( zclLCMove_t *pCmd )
    965          {
    966            uint8 newLevel;
    967            uint32 rate;
    968          
    969            // convert rate from units per second to units per tick (10ths of seconds)
    970            // and move at that right up or down
    971            zclSampleLight_WithOnOff = pCmd->withOnOff;
    972          
    973            if ( pCmd->moveMode == LEVEL_MOVE_UP )
    974            {
    975              newLevel = ATTR_LEVEL_MAX_LEVEL;  // fully on
    976            }
    977            else
    978            {
    979              newLevel = ATTR_LEVEL_MIN_LEVEL; // fully off
    980            }
    981          
    982            zclSampleLight_LevelChangeCmd = LEVEL_CHANGED_BY_LEVEL_CMD;
    983          
    984            rate = (uint32)100 * pCmd->rate;
    985            zclSampleLight_MoveBasedOnRate( newLevel, rate );
    986          }
    987          
    988          /*********************************************************************
    989           * @fn      zclSampleLight_LevelControlStepCB
    990           *
    991           * @brief   Callback from the ZCL General Cluster Library when
    992           *          it received an On/Off Command for this application.
    993           *
    994           * @param   pCmd - ZigBee command parameters
    995           *
    996           * @return  none
    997           */
    998          static void zclSampleLight_LevelControlStepCB( zclLCStep_t *pCmd )
    999          {
   1000            uint8 newLevel;
   1001          
   1002            // determine new level, but don't exceed boundaries
   1003            if ( pCmd->stepMode == LEVEL_MOVE_UP )
   1004            {
   1005              if ( (uint16)zclSampleLight_LevelCurrentLevel + pCmd->amount > ATTR_LEVEL_MAX_LEVEL )
   1006              {
   1007                newLevel = ATTR_LEVEL_MAX_LEVEL;
   1008              }
   1009              else
   1010              {
   1011                newLevel = zclSampleLight_LevelCurrentLevel + pCmd->amount;
   1012              }
   1013            }
   1014            else
   1015            {
   1016              if ( pCmd->amount >= zclSampleLight_LevelCurrentLevel )
   1017              {
   1018                newLevel = ATTR_LEVEL_MIN_LEVEL;
   1019              }
   1020              else
   1021              {
   1022                newLevel = zclSampleLight_LevelCurrentLevel - pCmd->amount;
   1023              }
   1024            }
   1025            
   1026            zclSampleLight_LevelChangeCmd = LEVEL_CHANGED_BY_LEVEL_CMD;
   1027          
   1028            // move to the new level
   1029            zclSampleLight_WithOnOff = pCmd->withOnOff;
   1030            zclSampleLight_MoveBasedOnTime( newLevel, pCmd->transitionTime );
   1031          }
   1032          
   1033          /*********************************************************************
   1034           * @fn      zclSampleLight_LevelControlStopCB
   1035           *
   1036           * @brief   Callback from the ZCL General Cluster Library when
   1037           *          it received an Level Control Stop Command for this application.
   1038           *
   1039           * @param   pCmd - ZigBee command parameters
   1040           *
   1041           * @return  none
   1042           */
   1043          static void zclSampleLight_LevelControlStopCB( void )
   1044          {
   1045            // stop immediately
   1046            osal_stop_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT );
   1047            zclSampleLight_LevelRemainingTime = 0;
   1048          }
   1049          #endif
   1050          
   1051          /*********************************************************************
   1052           * @fn      zclSampleApp_BatteryWarningCB
   1053           *
   1054           * @brief   Called to handle battery-low situation.
   1055           *
   1056           * @param   voltLevel - level of severity
   1057           *
   1058           * @return  none
   1059           */
   1060          void zclSampleApp_BatteryWarningCB( uint8 voltLevel )
   1061          {
   1062            if ( voltLevel == VOLT_LEVEL_CAUTIOUS )
   1063            {
   1064              // Send warning message to the gateway and blink LED
   1065            }
   1066            else if ( voltLevel == VOLT_LEVEL_BAD )
   1067            {
   1068              // Shut down the system
   1069            }
   1070          }
   1071          
   1072          /******************************************************************************
   1073           *
   1074           *  Functions for processing ZCL Foundation incoming Command/Response messages
   1075           *
   1076           *****************************************************************************/
   1077          
   1078          /*********************************************************************
   1079           * @fn      zclSampleLight_ProcessIncomingMsg
   1080           *
   1081           * @brief   Process ZCL Foundation incoming message
   1082           *
   1083           * @param   pInMsg - pointer to the received message
   1084           *
   1085           * @return  none
   1086           */
   1087          static void zclSampleLight_ProcessIncomingMsg( zclIncomingMsg_t *pInMsg )
   1088          {
   1089            switch ( pInMsg->zclHdr.commandID )
   1090            {
   1091          #ifdef ZCL_READ
   1092              case ZCL_CMD_READ_RSP:
   1093                zclSampleLight_ProcessInReadRspCmd( pInMsg );
   1094                break;
   1095          #endif
   1096          #ifdef ZCL_WRITE
   1097              case ZCL_CMD_WRITE_RSP:
   1098                zclSampleLight_ProcessInWriteRspCmd( pInMsg );
   1099                break;
   1100          #endif
   1101              case ZCL_CMD_CONFIG_REPORT:
   1102              case ZCL_CMD_CONFIG_REPORT_RSP:
   1103              case ZCL_CMD_READ_REPORT_CFG:
   1104              case ZCL_CMD_READ_REPORT_CFG_RSP:
   1105              case ZCL_CMD_REPORT:
   1106                //bdb_ProcessIncomingReportingMsg( pInMsg );
   1107                break;
   1108          
   1109              case ZCL_CMD_DEFAULT_RSP:
   1110                zclSampleLight_ProcessInDefaultRspCmd( pInMsg );
   1111                break;
   1112          #ifdef ZCL_DISCOVER
   1113              case ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP:
   1114                zclSampleLight_ProcessInDiscCmdsRspCmd( pInMsg );
   1115                break;
   1116          
   1117              case ZCL_CMD_DISCOVER_CMDS_GEN_RSP:
   1118                zclSampleLight_ProcessInDiscCmdsRspCmd( pInMsg );
   1119                break;
   1120          
   1121              case ZCL_CMD_DISCOVER_ATTRS_RSP:
   1122                zclSampleLight_ProcessInDiscAttrsRspCmd( pInMsg );
   1123                break;
   1124          
   1125              case ZCL_CMD_DISCOVER_ATTRS_EXT_RSP:
   1126                zclSampleLight_ProcessInDiscAttrsExtRspCmd( pInMsg );
   1127                break;
   1128          #endif
   1129              default:
   1130                break;
   1131            }
   1132          
   1133            if ( pInMsg->attrCmd )
   1134              osal_mem_free( pInMsg->attrCmd );
   1135          }
   1136          
   1137          #ifdef ZCL_READ
   1138          /*********************************************************************
   1139           * @fn      zclSampleLight_ProcessInReadRspCmd
   1140           *
   1141           * @brief   Process the "Profile" Read Response Command
   1142           *
   1143           * @param   pInMsg - incoming message to process
   1144           *
   1145           * @return  none
   1146           */
   1147          static uint8 zclSampleLight_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg )
   1148          {
   1149            zclReadRspCmd_t *readRspCmd;
   1150            uint8 i;
   1151          
   1152            readRspCmd = (zclReadRspCmd_t *)pInMsg->attrCmd;
   1153            for (i = 0; i < readRspCmd->numAttr; i++)
   1154            {
   1155              // Notify the originator of the results of the original read attributes
   1156              // attempt and, for each successfull request, the value of the requested
   1157              // attribute
   1158            }
   1159          
   1160            return ( TRUE );
   1161          }
   1162          #endif // ZCL_READ
   1163          
   1164          #ifdef ZCL_WRITE
   1165          /*********************************************************************
   1166           * @fn      zclSampleLight_ProcessInWriteRspCmd
   1167           *
   1168           * @brief   Process the "Profile" Write Response Command
   1169           *
   1170           * @param   pInMsg - incoming message to process
   1171           *
   1172           * @return  none
   1173           */
   1174          static uint8 zclSampleLight_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg )
   1175          {
   1176            zclWriteRspCmd_t *writeRspCmd;
   1177            uint8 i;
   1178          
   1179            writeRspCmd = (zclWriteRspCmd_t *)pInMsg->attrCmd;
   1180            for ( i = 0; i < writeRspCmd->numAttr; i++ )
   1181            {
   1182              // Notify the device of the results of the its original write attributes
   1183              // command.
   1184            }
   1185          
   1186            return ( TRUE );
   1187          }
   1188          #endif // ZCL_WRITE
   1189          
   1190          /*********************************************************************
   1191           * @fn      zclSampleLight_ProcessInDefaultRspCmd
   1192           *
   1193           * @brief   Process the "Profile" Default Response Command
   1194           *
   1195           * @param   pInMsg - incoming message to process
   1196           *
   1197           * @return  none
   1198           */
   1199          static uint8 zclSampleLight_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg )
   1200          {
   1201            // zclDefaultRspCmd_t *defaultRspCmd = (zclDefaultRspCmd_t *)pInMsg->attrCmd;
   1202          
   1203            // Device is notified of the Default Response command.
   1204            (void)pInMsg;
   1205          
   1206            return ( TRUE );
   1207          }
   1208          
   1209          #ifdef ZCL_DISCOVER
   1210          /*********************************************************************
   1211           * @fn      zclSampleLight_ProcessInDiscCmdsRspCmd
   1212           *
   1213           * @brief   Process the Discover Commands Response Command
   1214           *
   1215           * @param   pInMsg - incoming message to process
   1216           *
   1217           * @return  none
   1218           */
   1219          static uint8 zclSampleLight_ProcessInDiscCmdsRspCmd( zclIncomingMsg_t *pInMsg )
   1220          {
   1221            zclDiscoverCmdsCmdRsp_t *discoverRspCmd;
   1222            uint8 i;
   1223          
   1224            discoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)pInMsg->attrCmd;
   1225            for ( i = 0; i < discoverRspCmd->numCmd; i++ )
   1226            {
   1227              // Device is notified of the result of its attribute discovery command.
   1228            }
   1229          
   1230            return ( TRUE );
   1231          }
   1232          
   1233          /*********************************************************************
   1234           * @fn      zclSampleLight_ProcessInDiscAttrsRspCmd
   1235           *
   1236           * @brief   Process the "Profile" Discover Attributes Response Command
   1237           *
   1238           * @param   pInMsg - incoming message to process
   1239           *
   1240           * @return  none
   1241           */
   1242          static uint8 zclSampleLight_ProcessInDiscAttrsRspCmd( zclIncomingMsg_t *pInMsg )
   1243          {
   1244            zclDiscoverAttrsRspCmd_t *discoverRspCmd;
   1245            uint8 i;
   1246          
   1247            discoverRspCmd = (zclDiscoverAttrsRspCmd_t *)pInMsg->attrCmd;
   1248            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1249            {
   1250              // Device is notified of the result of its attribute discovery command.
   1251            }
   1252          
   1253            return ( TRUE );
   1254          }
   1255          
   1256          /*********************************************************************
   1257           * @fn      zclSampleLight_ProcessInDiscAttrsExtRspCmd
   1258           *
   1259           * @brief   Process the "Profile" Discover Attributes Extended Response Command
   1260           *
   1261           * @param   pInMsg - incoming message to process
   1262           *
   1263           * @return  none
   1264           */
   1265          static uint8 zclSampleLight_ProcessInDiscAttrsExtRspCmd( zclIncomingMsg_t *pInMsg )
   1266          {
   1267            zclDiscoverAttrsExtRsp_t *discoverRspCmd;
   1268            uint8 i;
   1269          
   1270            discoverRspCmd = (zclDiscoverAttrsExtRsp_t *)pInMsg->attrCmd;
   1271            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1272            {
   1273              // Device is notified of the result of its attribute discovery command.
   1274            }
   1275          
   1276            return ( TRUE );
   1277          }
   1278          #endif // ZCL_DISCOVER
   1279          
   1280          void zclSampleLight_UpdateLedState(void)
   1281          {
   1282            // set the LED1 based on light (on or off)
   1283            if ( zclSampleLight_OnOff == LIGHT_ON )
   1284            {
   1285              HalLedSet ( UI_LED_APP, HAL_LED_MODE_ON );
                                 ^
Error[Pe020]: identifier "UI_LED_APP" is undefined
   1286            }
   1287            else
   1288            {
   1289              HalLedSet ( UI_LED_APP, HAL_LED_MODE_OFF );
                                 ^
Error[Pe020]: identifier "UI_LED_APP" is undefined
   1290            }
   1291          }
   1292          
   1293          
   1294          
   1295          /****************************************************************************
   1296          ****************************************************************************/
   1297          
   1298          

Errors: 2
Warnings: none
