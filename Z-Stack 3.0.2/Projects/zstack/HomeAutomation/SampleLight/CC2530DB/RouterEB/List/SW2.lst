###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               22/Jul/2020  11:21:52
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\Source\SW2.c
#    Command line       =  
#        -f C:\Users\sunli\AppData\Local\Temp\EW2A76.tmp ("D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\Source\SW2.c" -D
#        BDB_REPORTING -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D xNV_RESTORE
#        -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D
#        xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_SCENES -D ZCL_GROUPS -D ZCL_LEVEL_CTRL -lC "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\List"
#        -lA "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\List"
#        --diag_suppress Pe001,Pa010 -o "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
#        "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\List\SW2.lst
#    Object file        =  
#        D:\AA\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\Obj\SW2.r51
#
###############################################################################

D:\AA\Z-Stack 3.0.2\Projects\zstack\HomeAutomation\SampleLight\Source\SW2.c
      1          /**************************************************************************************************
      2            Filename:       zcl_sampleLight.c
      3            Revised:        $Date: 2014-10-24 16:04:46 -0700 (Fri, 24 Oct 2014) $
      4            Revision:       $Revision: 40796 $
      5          
      6          
      7            Description:    Zigbee Cluster Library - sample light application.
      8          
      9          
     10            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42            This application implements a ZigBee Light, based on Z-Stack 3.0. It can be configured as an
     43            On/Off light or as a dimmable light, by undefining or defining ZCL_LEVEL_CTRL, respectively.
     44          
     45            This application is based on the common sample-application user interface. Please see the main
     46            comment in zcl_sampleapp_ui.c. The rest of this comment describes only the content specific for
     47            this sample applicetion.
     48            
     49            Application-specific UI peripherals being used:
     50          
     51            - LEDs:
     52              LED1 reflect the current light state (On / Off accordingly).
     53          
     54            Application-specific menu system:
     55          
     56              <TOGGLE LIGHT> Toggle the local light and display its status and level
     57                Press OK to toggle the local light on and off.
     58                This screen shows the following information
     59                  Line1: (only populated if ZCL_LEVEL_CTRL is defined)
     60                    LEVEL XXX - xxx is the current level of the light if the light state is ON, or the target level
     61                      of the light when the light state is off. The target level is the level that the light will be
     62                      set to when it is switched from off to on using the on or the toggle commands.
     63                  Line2:
     64                    LIGHT OFF / ON: shows the current state of the light.
     65                Note when ZCL_LEVEL_CTRL is enabled:
     66                  - If the light state is ON and the light level is X, and then the light receives the OFF or TOGGLE 
     67                    commands: The level will decrease gradually until it reaches 1, and only then the light state will
     68                    be changed to OFF. The level then will be restored to X, with the state staying OFF. At this stage
     69                    the light is not lighting, and the level represent the target level for the next ON or TOGGLE 
     70                    commands.
     71                  - If the light state is OFF and the light level is X, and then the light receives the ON or TOGGLE
     72                    commands; The level will be set to 1, the light state will be set to ON, and then the level will
     73                    increase gradually until it reaches level X.
     74                  - Any level-setting command will affect the level directly, and may also affect the on/off state,
     75                    depending on the command's arguments.       
     76          
     77          *********************************************************************/
     78          
     79          /*********************************************************************
     80           * INCLUDES
     81           */
     82          #include "ZComDef.h"
     83          #include "OSAL.h"
     84          #include "AF.h"
     85          #include "ZDApp.h"
     86          #include "ZDObject.h"
     87          #include "MT_SYS.h"
     88          
     89          #include "nwk_util.h"
     90          
     91          #include "zcl.h"
     92          #include "zcl_general.h"
     93          #include "zcl_ha.h"
     94          #include "zcl_diagnostic.h"
     95          
     96          #include "SW2.h"
     97             
     98          #include "bdb.h"
     99          #include "bdb_interface.h"
    100          #include "bdb_Reporting.h"
    101          
    102           //GP_UPDATE
    103          #include "gp_interface.h"
    104             
    105          #include "onboard.h"
    106          
    107          /* HAL */
    108          #include "hal_lcd.h"
    109          #include "hal_led.h"
    110          #include "hal_key.h"
    111          
    112          #include "NLMEDE.h"
    113          
    114          // Added to include TouchLink initiator functionality 
    115          #if defined ( BDB_TL_INITIATOR )
    116            #include "bdb_touchlink_initiator.h"
    117          #endif // BDB_TL_INITIATOR
    118          
    119          #if defined ( BDB_TL_TARGET )
    120            #include "bdb_touchlink_target.h"
    121          #endif // BDB_TL_TARGET
    122          
    123          #if defined ( BDB_TL_INITIATOR ) || defined ( BDB_TL_TARGET )
    124            #include "bdb_touchlink.h"
    125          #endif
    126          
    127          
    128          /*********************************************************************
    129           * MACROS
    130           */
    131          #define APP_TITLE "TI Sample Light"
    132          
    133          /*********************************************************************
    134           * TYPEDEFS
    135           */
    136          
    137          /*********************************************************************
    138           * GLOBAL VARIABLES
    139           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          byte SW2_TaskID;
   \                     SW2_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    141          uint8 SW2SeqNum;
   \                     SW2SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    142          
    143          /*********************************************************************
    144           * GLOBAL FUNCTIONS
    145           */
    146          
    147          /*********************************************************************
    148           * LOCAL VARIABLES
    149           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    150          afAddrType_t SW2_DstAddr;
   \                     SW2_DstAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    151          
    152          // Test Endpoint to allow SYS_APP_MSGs
    153          //static endPointDesc_t sampleLight_TestEp =
    154          //{
    155          //  SAMPLELIGHT_ENDPOINT,
    156          //  0,
    157          //  &SW2_TaskID,
    158          //  (SimpleDescriptionFormat_t *)NULL,  // No Simple description for this test endpoint
    159          //  (afNetworkLatencyReq_t)0            // No Network Latency req
    160          //};
    161          
    162          #ifdef ZCL_LEVEL_CTRL

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    163          uint8 SW2_WithOnOff;       // set to TRUE if state machine should set light on/off
   \                     SW2_WithOnOff:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    164          uint8 SW2_NewLevel;        // new level when done moving
   \                     SW2_NewLevel:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    165          uint8 SW2_LevelChangeCmd; // current level change was triggered by an on/off command
   \                     SW2_LevelChangeCmd:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    166          bool  SW2_NewLevelUp;      // is direction to new level up or down?
   \                     SW2_NewLevelUp:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    167          int32 SW2_CurrentLevel32;  // current level, fixed point (e.g. 192.456)
   \                     SW2_CurrentLevel32:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    168          int32 SW2_Rate32;          // rate in units, fixed point (e.g. 16.123)
   \                     SW2_Rate32:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    169          uint8 SW2_LevelLastLevel;  // to save the Current Level before the light was turned OFF
   \                     SW2_LevelLastLevel:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    170          #endif
    171          
    172          #ifdef BDB_REPORTING
    173          #if BDBREPORTING_MAX_ANALOG_ATTR_SIZE == 8
    174            uint8 reportableChangeSW2[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    175          #endif
    176          #if BDBREPORTING_MAX_ANALOG_ATTR_SIZE == 4

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    177            uint8 reportableChangeSW2[] = {0x00, 0x00, 0x00, 0x00};     
   \                     reportableChangeSW2:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    178          #endif 
    179          #if BDBREPORTING_MAX_ANALOG_ATTR_SIZE == 2
    180            uint8 reportableChangeSW2[] = {0x00, 0x00};
    181          #endif 
    182          #endif
    183          
    184          /*********************************************************************
    185           * LOCAL FUNCTIONS
    186           */
    187          static void SW2_HandleKeys( byte shift, byte keys );
    188          static void SW2_BasicResetCB( void );
    189          static void SW2_OnOffCB( uint8 cmd );
    190          //GP_UPDATE
    191          #if (ZG_BUILD_RTR_TYPE)
    192          static void gp_CommissioningMode(bool isEntering);
    193          static uint8 gp_ChangeChannelReq(void);
    194          #endif
    195          
    196          
    197          //static void SW2_ProcessCommissioningStatus(bdbCommissioningModeMsg_t *bdbCommissioningModeMsg);
    198          
    199          
    200          #ifdef ZCL_LEVEL_CTRL
    201          static void SW2_LevelControlMoveToLevelCB( zclLCMoveToLevel_t *pCmd );
    202          static void SW2_LevelControlMoveCB( zclLCMove_t *pCmd );
    203          static void SW2_LevelControlStepCB( zclLCStep_t *pCmd );
    204          static void SW2_LevelControlStopCB( void );
    205          static void SW2_DefaultMove( uint8 OnOff );
    206          static uint32 SW2_TimeRateHelper( uint8 newLevel );
    207          static uint16 SW2_GetTime ( uint8 level, uint16 time );
    208          static void SW2_MoveBasedOnRate( uint8 newLevel, uint32 rate );
    209          static void SW2_MoveBasedOnTime( uint8 newLevel, uint16 time );
    210          static void SW2_AdjustLightLevel( void );
    211          #endif
    212          
    213          // Functions to process ZCL Foundation incoming Command/Response messages
    214          static void SW2_ProcessIncomingMsg( zclIncomingMsg_t *msg );
    215          #ifdef ZCL_READ
    216          static uint8 SW2_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg );
    217          #endif
    218          #ifdef ZCL_WRITE
    219          static uint8 SW2_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg );
    220          #endif
    221          static uint8 SW2_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg );
    222          #ifdef ZCL_DISCOVER
    223          static uint8 SW2_ProcessInDiscCmdsRspCmd( zclIncomingMsg_t *pInMsg );
    224          static uint8 SW2_ProcessInDiscAttrsRspCmd( zclIncomingMsg_t *pInMsg );
    225          static uint8 SW2_ProcessInDiscAttrsExtRspCmd( zclIncomingMsg_t *pInMsg );
    226          #endif
    227          
    228          static void zclSampleApp_BatteryWarningCB( uint8 voltLevel);
    229          
    230          void SW2_UpdateLedState(void);
    231          
    232          /*********************************************************************
    233           * CONSTANTS
    234           */
    235          
    236          #define LEVEL_CHANGED_BY_LEVEL_CMD  0
    237          #define LEVEL_CHANGED_BY_ON_CMD     1
    238          #define LEVEL_CHANGED_BY_OFF_CMD    2
    239          
    240          /*********************************************************************
    241           * STATUS STRINGS
    242           */
    243          
    244          
    245          /*********************************************************************
    246           * REFERENCED EXTERNALS
    247           */
    248          extern int16 zdpExternalStateTaskID;
    249          
    250          /*********************************************************************
    251           * ZCL General Profile Callback table
    252           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    253          static zclGeneral_AppCallbacks_t SW2_CmdCallbacks =
   \                     SW2_CmdCallbacks:
   \   000000                DS 32
   \   000020                REQUIRE `?<Initializer for SW2_CmdCallbacks>`
   \   000020                REQUIRE __INIT_XDATA_I
    254          {
    255            SW2_BasicResetCB,            // Basic Cluster Reset command
    256            NULL,                                   // Identify Trigger Effect command
    257            SW2_OnOffCB,                 // On/Off cluster commands
    258            NULL,                                   // On/Off cluster enhanced command Off with Effect
    259            NULL,                                   // On/Off cluster enhanced command On with Recall Global Scene
    260            NULL,                                   // On/Off cluster enhanced command On with Timed Off
    261          #ifdef ZCL_LEVEL_CTRL
    262            SW2_LevelControlMoveToLevelCB, // Level Control Move to Level command
    263            SW2_LevelControlMoveCB,        // Level Control Move command
    264            SW2_LevelControlStepCB,        // Level Control Step command
    265            SW2_LevelControlStopCB,        // Level Control Stop command
    266          #endif
    267          #ifdef ZCL_GROUPS
    268            NULL,                                   // Group Response commands
    269          #endif
    270          #ifdef ZCL_SCENES
    271            NULL,                                  // Scene Store Request command
    272            NULL,                                  // Scene Recall Request command
    273            NULL,                                  // Scene Response command
    274          #endif
    275          #ifdef ZCL_ALARMS
    276            NULL,                                  // Alarm (Response) commands
    277          #endif
    278          #ifdef SE_UK_EXT
    279            NULL,                                  // Get Event Log command
    280            NULL,                                  // Publish Event Log command
    281          #endif
    282            NULL,                                  // RSSI Location command
    283            NULL                                   // RSSI Location Response command
    284          };
    285          
    286          /*********************************************************************
    287           * @fn          SW2_Init
    288           *
    289           * @brief       Initialization function for the zclGeneral layer.
    290           *
    291           * @param       none
    292           *
    293           * @return      none
    294           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    295          void SW2_Init( byte task_id )
   \                     SW2_Init:
    296          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
    297            SW2_TaskID = task_id;
   \   000006   90....       MOV       DPTR,#SW2_TaskID
   \   000009   F0           MOVX      @DPTR,A
    298          
    299            // Set destination address to indirect
    300            SW2_DstAddr.addrMode = (afAddrMode_t)AddrNotPresent;
   \   00000A   90....       MOV       DPTR,#SW2_DstAddr + 8
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
    301            SW2_DstAddr.endPoint = 0;
   \   00000F   A3           INC       DPTR
   \   000010   F0           MOVX      @DPTR,A
    302            SW2_DstAddr.addr.shortAddr = 0;
   \   000011   90....       MOV       DPTR,#SW2_DstAddr
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   F0           MOVX      @DPTR,A
    303          
    304            // Register the Simple Descriptor for this application
    305            bdb_RegisterSimpleDescriptor( &SW2_SimpleDesc );
   \   000017                ; Setup parameters for call to function bdb_RegisterSimpleDescriptor
   \   000017   7A..         MOV       R2,#SW2_SimpleDesc & 0xff
   \   000019   7B..         MOV       R3,#(SW2_SimpleDesc >> 8) & 0xff
   \   00001B   12....       LCALL     `??bdb_RegisterSimpleDescriptor::?relay`; Banked call to: bdb_RegisterSimpleDescriptor
    306          
    307            // Register the ZCL General Cluster Library callback functions
    308            zclGeneral_RegisterCmdCallbacks( SW2_ENDPOINT, &SW2_CmdCallbacks );
   \   00001E                ; Setup parameters for call to function zclGeneral_RegisterCmdCallbacks
   \   00001E   7A..         MOV       R2,#SW2_CmdCallbacks & 0xff
   \   000020   7B..         MOV       R3,#(SW2_CmdCallbacks >> 8) & 0xff
   \   000022   7909         MOV       R1,#0x9
   \   000024   12....       LCALL     `??zclGeneral_RegisterCmdCallbacks::?relay`; Banked call to: zclGeneral_RegisterCmdCallbacks
    309          
    310            // Register the application's attribute list
    311            SW2_ResetAttributesToDefaultValues();
   \   000027                ; Setup parameters for call to function SW2_ResetAttributesToDefaultValues
   \   000027   12....       LCALL     `??SW2_ResetAttributesToDefaultValues::?relay`; Banked call to: SW2_ResetAttributesToDefaultValues
    312            zcl_registerAttrList( SW2_ENDPOINT, SW2_NumAttributes, SW2_Attrs );
   \   00002A                ; Setup parameters for call to function zcl_registerAttrList
   \   00002A   7C..         MOV       R4,#SW2_Attrs & 0xff
   \   00002C   7D..         MOV       R5,#(SW2_Attrs >> 8) & 0xff
   \   00002E   90....       MOV       DPTR,#SW2_NumAttributes
   \   000031   E4           CLR       A
   \   000032   93           MOVC      A,@A+DPTR
   \   000033   FA           MOV       R2,A
   \   000034   7909         MOV       R1,#0x9
   \   000036   12....       LCALL     `??zcl_registerAttrList::?relay`; Banked call to: zcl_registerAttrList
    313          
    314          #ifdef ZCL_LEVEL_CTRL
    315            SW2_LevelLastLevel = SW2_LevelCurrentLevel;
   \   000039   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   90....       MOV       DPTR,#SW2_LevelLastLevel
   \   000040   F0           MOVX      @DPTR,A
    316          #endif
    317          
    318            // Register the Application to receive the unprocessed Foundation command/response messages
    319            zcl_registerForMsg( SW2_TaskID );
   \   000041                ; Setup parameters for call to function zcl_registerForMsg
   \   000041   90....       MOV       DPTR,#SW2_TaskID
   \   000044   E0           MOVX      A,@DPTR
   \   000045   F9           MOV       R1,A
   \   000046   12....       LCALL     `??zcl_registerForMsg::?relay`; Banked call to: zcl_registerForMsg
    320          
    321          #ifdef ZCL_DISCOVER
    322            // Register the application's command list
    323            zcl_registerCmdList( SW2_ENDPOINT, zclCmdsArraySize, SW2_Cmds );
   \   000049                ; Setup parameters for call to function zcl_registerCmdList
   \   000049   7C..         MOV       R4,#SW2_Cmds & 0xff
   \   00004B   7D..         MOV       R5,#(SW2_Cmds >> 8) & 0xff
   \   00004D   90....       MOV       DPTR,#zclCmdsArraySize
   \   000050   E4           CLR       A
   \   000051   93           MOVC      A,@A+DPTR
   \   000052   FA           MOV       R2,A
   \   000053   7909         MOV       R1,#0x9
   \   000055   12....       LCALL     `??zcl_registerCmdList::?relay`; Banked call to: zcl_registerCmdList
    324          #endif
    325          
    326            // Register low voltage NV memory protection application callback
    327            RegisterVoltageWarningCB( zclSampleApp_BatteryWarningCB );
   \   000058                ; Setup parameters for call to function RegisterVoltageWarningCB
   \   000058   7A..         MOV       R2,#`??zclSampleApp_BatteryWarningCB::?relay` & 0xff
   \   00005A   7B..         MOV       R3,#(`??zclSampleApp_BatteryWarningCB::?relay` >> 8) & 0xff
   \   00005C   12....       LCALL     `??RegisterVoltageWarningCB::?relay`; Banked call to: RegisterVoltageWarningCB
    328          
    329            // Register for all key events - This app will handle all key events
    330          //  RegisterForKeys( SW2_TaskID );
    331            
    332          //  bdb_RegisterCommissioningStatusCB( SW2_ProcessCommissioningStatus );
    333            
    334          
    335          #ifdef ZCL_DIAGNOSTIC
    336            // Register the application's callback function to read/write attribute data.
    337            // This is only required when the attribute data format is unknown to ZCL.
    338            zcl_registerReadWriteCB( SW2_ENDPOINT, zclDiagnostic_ReadWriteAttrCB, NULL );
    339          
    340            if ( zclDiagnostic_InitStats() == ZSuccess )
    341            {
    342              // Here the user could start the timer to save Diagnostics to NV
    343            }
    344          #endif
    345            
    346          //GP_UPDATE  
    347          #if (ZG_BUILD_RTR_TYPE)  
    348            gp_RegisterCommissioningModeCB(gp_CommissioningMode);
   \   00005F                ; Setup parameters for call to function gp_RegisterCommissioningModeCB
   \   00005F   7A..         MOV       R2,#`??gp_CommissioningMode::?relay` & 0xff
   \   000061   7B..         MOV       R3,#(`??gp_CommissioningMode::?relay` >> 8) & 0xff
   \   000063   12....       LCALL     `??gp_RegisterCommissioningModeCB::?relay`; Banked call to: gp_RegisterCommissioningModeCB
    349            gp_RegisterGPChangeChannelReqCB(gp_ChangeChannelReq);
   \   000066                ; Setup parameters for call to function gp_RegisterGPChangeChannelReqCB
   \   000066   7A..         MOV       R2,#`??gp_ChangeChannelReq::?relay` & 0xff
   \   000068   7B..         MOV       R3,#(`??gp_ChangeChannelReq::?relay` >> 8) & 0xff
   \   00006A   12....       LCALL     `??gp_RegisterGPChangeChannelReqCB::?relay`; Banked call to: gp_RegisterGPChangeChannelReqCB
    350          #endif
    351            
    352            zdpExternalStateTaskID = SW2_TaskID;
   \   00006D   90....       MOV       DPTR,#SW2_TaskID
   \   000070   E0           MOVX      A,@DPTR
   \   000071   90....       MOV       DPTR,#zdpExternalStateTaskID
   \   000074   F0           MOVX      @DPTR,A
   \   000075   A3           INC       DPTR
   \   000076   E4           CLR       A
   \   000077   F0           MOVX      @DPTR,A
    353            
    354            bdb_RepAddAttrCfgRecordDefaultToList(SW2_ENDPOINT, ZCL_CLUSTER_ID_GEN_ON_OFF, ATTRID_ON_OFF, 0, 0xFF, reportableChangeSW2);
   \   000078                ; Setup parameters for call to function bdb_RepAddAttrCfgRecordDefaultToList
   \   000078   75....       MOV       ?V0,#reportableChangeSW2 & 0xff
   \   00007B   75....       MOV       ?V1,#(reportableChangeSW2 >> 8) & 0xff
   \   00007E   78..         MOV       R0,#?V0
   \   000080   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000083   75..FF       MOV       ?V0,#-0x1
   \   000086   75..00       MOV       ?V1,#0x0
   \   000089   78..         MOV       R0,#?V0
   \   00008B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008E   E4           CLR       A
   \   00008F   F5..         MOV       ?V0,A
   \   000091   78..         MOV       R0,#?V0
   \   000093   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000096   7C00         MOV       R4,#0x0
   \   000098   7D00         MOV       R5,#0x0
   \   00009A   7A06         MOV       R2,#0x6
   \   00009C   7B00         MOV       R3,#0x0
   \   00009E   7909         MOV       R1,#0x9
   \   0000A0   12....       LCALL     `??bdb_RepAddAttrCfgRecordDefaultToList::?relay`; Banked call to: bdb_RepAddAttrCfgRecordDefaultToList
   \   0000A3   7406         MOV       A,#0x6
   \   0000A5   12....       LCALL     ?DEALLOC_XSTACK8
    355            
    356          //  bdb_RepAddAttrCfgRecordDefaultToList(SAMPLELIGHT_ENDPOINT, ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG, ATTRID_ON_OFF, 0, 10, reportableChangeTest);
    357          }
   \   0000A8   7F02         MOV       R7,#0x2
   \   0000AA   02....       LJMP      ?BANKED_LEAVE_XDATA
    358          
    359          /*********************************************************************
    360           * @fn          zclSample_event_loop
    361           *
    362           * @brief       Event Loop Processor for zclGeneral.
    363           *
    364           * @param       none
    365           *
    366           * @return      none
    367           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    368          uint16 SW2_event_loop( uint8 task_id, uint16 events )
   \                     SW2_event_loop:
    369          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    370            afIncomingMSGPacket_t *MSGpkt;
    371          
    372            (void)task_id;  // Intentionally unreferenced parameter
    373          
    374            if ( events & SYS_EVENT_MSG )
   \   000009   5480         ANL       A,#0x80
   \   00000B   7022         JNZ       ??SW2_event_loop_0
    375            {
    376              while ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( SW2_TaskID )) )
    377              {
    378                switch ( MSGpkt->hdr.event )
    379                {
    380                  case ZCL_INCOMING_MSG:
    381                    // Incoming ZCL Foundation command/response messages
    382                    SW2_ProcessIncomingMsg( (zclIncomingMsg_t *)MSGpkt );
    383                    break;
    384          
    385                  case KEY_CHANGE:
    386                    SW2_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    387                    break;
    388          
    389                  case ZDO_STATE_CHANGE:
    390                    break;
    391          
    392                  default:
    393                    break;
    394                }
    395          
    396                // Release the memory
    397                osal_msg_deallocate( (uint8 *)MSGpkt );
    398              }
    399          
    400              // return unprocessed events
    401              return (events ^ SYS_EVENT_MSG);
    402            }
    403          
    404          #ifdef ZCL_LEVEL_CTRL
    405            if ( events & SAMPLELIGHT_LEVEL_CTRL_EVT )
   \   00000D   EA           MOV       A,R2
   \   00000E   5402         ANL       A,#0x2
   \   000010   6035         JZ        ??SW2_event_loop_1
    406            {
    407              SW2_AdjustLightLevel();
   \   000012                ; Setup parameters for call to function SW2_AdjustLightLevel
   \   000012   12....       LCALL     `??SW2_AdjustLightLevel::?relay`; Banked call to: SW2_AdjustLightLevel
    408              return ( events ^ SAMPLELIGHT_LEVEL_CTRL_EVT );
   \   000015   EE           MOV       A,R6
   \   000016   6402         XRL       A,#0x2
   \   000018   FA           MOV       R2,A
   \   000019   EF           MOV       A,R7
   \   00001A   8028         SJMP      ??SW2_event_loop_2
    409            }
   \                     ??SW2_event_loop_3:
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   8B83         MOV       DPH,R3
   \   000020   E0           MOVX      A,@DPTR
   \   000021   6434         XRL       A,#0x34
   \   000023   7003         JNZ       ??SW2_event_loop_4
   \   000025                ; Setup parameters for call to function SW2_ProcessIncomingMsg
   \   000025   12....       LCALL     `??SW2_ProcessIncomingMsg::?relay`; Banked call to: SW2_ProcessIncomingMsg
   \                     ??SW2_event_loop_4:
   \   000028                ; Setup parameters for call to function osal_msg_deallocate
   \   000028   AA..         MOV       R2,?V0
   \   00002A   AB..         MOV       R3,?V1
   \   00002C   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \                     ??SW2_event_loop_0:
   \   00002F                ; Setup parameters for call to function osal_msg_receive
   \   00002F   90....       MOV       DPTR,#SW2_TaskID
   \   000032   E0           MOVX      A,@DPTR
   \   000033   F9           MOV       R1,A
   \   000034   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   000037   8A..         MOV       ?V0,R2
   \   000039   8B..         MOV       ?V1,R3
   \   00003B   EA           MOV       A,R2
   \   00003C   4B           ORL       A,R3
   \   00003D   70DD         JNZ       ??SW2_event_loop_3
   \   00003F   EE           MOV       A,R6
   \   000040   FA           MOV       R2,A
   \   000041   EF           MOV       A,R7
   \   000042   6480         XRL       A,#0x80
   \                     ??SW2_event_loop_2:
   \   000044   FB           MOV       R3,A
   \   000045   8019         SJMP      ??SW2_event_loop_5
    410          #endif
    411          
    412          #if ZG_BUILD_ENDDEVICE_TYPE    
    413            if ( events & SAMPLEAPP_END_DEVICE_REJOIN_EVT )
    414            {
    415              bdb_ZedAttemptRecoverNwk();
    416              return ( events ^ SAMPLEAPP_END_DEVICE_REJOIN_EVT );
    417            }
    418          #endif
    419          
    420            if ( events & SAMPLEAPP_LCD_AUTO_UPDATE_EVT )
   \                     ??SW2_event_loop_1:
   \   000047   EA           MOV       A,R2
   \   000048   5410         ANL       A,#0x10
   \   00004A   6005         JZ        ??SW2_event_loop_6
    421            {
    422              return ( events ^ SAMPLEAPP_LCD_AUTO_UPDATE_EVT );
   \   00004C   EA           MOV       A,R2
   \   00004D   6410         XRL       A,#0x10
   \   00004F   8008         SJMP      ??SW2_event_loop_7
    423            }
    424          
    425            if ( events & SAMPLEAPP_KEY_AUTO_REPEAT_EVT )
   \                     ??SW2_event_loop_6:
   \   000051   EA           MOV       A,R2
   \   000052   5420         ANL       A,#0x20
   \   000054   6006         JZ        ??SW2_event_loop_8
    426            {
    427              return ( events ^ SAMPLEAPP_KEY_AUTO_REPEAT_EVT );
   \   000056   EA           MOV       A,R2
   \   000057   6420         XRL       A,#0x20
   \                     ??SW2_event_loop_7:
   \   000059   FA           MOV       R2,A
   \   00005A   8004         SJMP      ??SW2_event_loop_5
    428            }
    429          
    430            // Discard unknown events
    431            return 0;
   \                     ??SW2_event_loop_8:
   \   00005C   7A00         MOV       R2,#0x0
   \   00005E   7B00         MOV       R3,#0x0
   \                     ??SW2_event_loop_5:
   \   000060   7F04         MOV       R7,#0x4
   \   000062   02....       LJMP      ?BANKED_LEAVE_XDATA
    432          }
    433          
    434          
    435          /*********************************************************************
    436           * @fn      SW2_HandleKeys
    437           *
    438           * @brief   Handles all key events for this device.
    439           *
    440           * @param   shift - true if in shift/alt.
    441           * @param   keys - bit field for key events. Valid entries:
    442           *                 HAL_KEY_SW_5
    443           *                 HAL_KEY_SW_4
    444           *                 HAL_KEY_SW_2
    445           *                 HAL_KEY_SW_1
    446           *
    447           * @return  none
    448           */
    449          static void SW2_HandleKeys( byte shift, byte keys )
    450          {
    451          //  if ( keys & HAL_KEY_SW_6 )  // Switch 6
    452          //  {     
    453          //    HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
    454          //    bdb_StartCommissioning(BDB_COMMISSIONING_MODE_NWK_STEERING | BDB_COMMISSIONING_MODE_FINDING_BINDING  );
    455          //  }
    456          //  if ( keys & HAL_KEY_SW_5 )  // Switch 5
    457          //  {     
    458          //    HalLedSet ( HAL_LED_2, HAL_LED_MODE_TOGGLE );
    459          //    if ( SW2_OnOff == LIGHT_OFF )
    460          //    {
    461          //      SW2_OnOff = LIGHT_ON;
    462          //    }
    463          //    else
    464          //    {
    465          //      SW2_OnOff = LIGHT_OFF;
    466          //    }
    467          //    //SW2_OnOff = SW2_OnOff + 5;
    468          //    bdb_RepChangedAttrValue(SW2_ENDPOINT, ZCL_CLUSTER_ID_GEN_ON_OFF, ATTRID_ON_OFF);
    469          //    SW2_UpdateLedState();
    470          //  }
    471          }
    472          
    473          //GP_UPDATE
    474          #if (ZG_BUILD_RTR_TYPE)
    475          /*********************************************************************
    476           * @fn      gp_CommissioningMode
    477           *
    478           * @brief   Callback that notifies the application that gp Proxy is entering 
    479           *          into commissioning mode
    480           *
    481           * @param   isEntering - 
    482           *
    483           * @return  
    484           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    485          static void gp_CommissioningMode(bool isEntering)
   \                     gp_CommissioningMode:
    486          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    487            if(isEntering)
    488            {
    489              //Led on indicating enter commissioning mode
    490            }
    491            else
    492            {
    493              //Led off indicating enter commissioning mode
    494            }
    495          }
   \   000000   02....       LJMP      ?BRET
    496          
    497          
    498          
    499          //GP_UPDATE
    500          /*********************************************************************
    501           * @fn      gp_ChangeChannelReq
    502           *
    503           * @brief   Callback function to notify the application about a GP commissioning 
    504           * request that will change the current channel for at most 
    505           * gpBirectionalCommissioningChangeChannelTimeout ms
    506           *
    507           * @param   channel - Channel in which the commissioning will take place
    508           *
    509           * @return  TRUE to allow change channel, FALSE to do not allow
    510           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    511          static uint8 gp_ChangeChannelReq(void)
   \                     gp_ChangeChannelReq:
    512          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    513            bool allowChangeChannel = TRUE;
    514            
    515            //Check application state to decide if allow change channel or not
    516            
    517            return allowChangeChannel;
   \   000000   7901         MOV       R1,#0x1
   \   000002   02....       LJMP      ?BRET
    518          }
    519          
    520          #endif
    521          
    522          
    523          /*********************************************************************
    524           * @fn      SW2_ProcessCommissioningStatus
    525           *
    526           * @brief   Callback in which the status of the commissioning process are reported
    527           *
    528           * @param   bdbCommissioningModeMsg - Context message of the status of a commissioning process
    529           *
    530           * @return  none
    531           */
    532          //static void SW2_ProcessCommissioningStatus(bdbCommissioningModeMsg_t *bdbCommissioningModeMsg)
    533          //{
    534          //  switch(bdbCommissioningModeMsg->bdbCommissioningMode)
    535          //  {
    536          //    case BDB_COMMISSIONING_FORMATION:
    537          //      if(bdbCommissioningModeMsg->bdbCommissioningStatus == BDB_COMMISSIONING_SUCCESS)
    538          //      {
    539          //        //After formation, perform nwk steering again plus the remaining commissioning modes that has not been process yet
    540          //        bdb_StartCommissioning(BDB_COMMISSIONING_MODE_NWK_STEERING | bdbCommissioningModeMsg->bdbRemainingCommissioningModes);
    541          //      }
    542          //      else
    543          //      {
    544          //        //Want to try other channels?
    545          //        //try with bdb_setChannelAttribute
    546          //      }
    547          //    break;
    548          //    case BDB_COMMISSIONING_NWK_STEERING:
    549          //      if(bdbCommissioningModeMsg->bdbCommissioningStatus == BDB_COMMISSIONING_SUCCESS)
    550          //      {
    551          //        //YOUR JOB:
    552          //        //We are on the nwk, what now?
    553          //      }
    554          //      else
    555          //      {
    556          //        //See the possible errors for nwk steering procedure
    557          //        //No suitable networks found
    558          //        //Want to try other channels?
    559          //        //try with bdb_setChannelAttribute
    560          //      }
    561          //    break;
    562          //    case BDB_COMMISSIONING_FINDING_BINDING:
    563          //      if(bdbCommissioningModeMsg->bdbCommissioningStatus == BDB_COMMISSIONING_SUCCESS)
    564          //      {
    565          //        //YOUR JOB:
    566          //      }
    567          //      else
    568          //      {
    569          //        //YOUR JOB:
    570          //        //retry?, wait for user interaction?
    571          //      }
    572          //    break;
    573          //    case BDB_COMMISSIONING_INITIALIZATION:
    574          //      //Initialization notification can only be successful. Failure on initialization 
    575          //      //only happens for ZED and is notified as BDB_COMMISSIONING_PARENT_LOST notification
    576          //      
    577          //      //YOUR JOB:
    578          //      //We are on a network, what now?
    579          //      
    580          //    break;
    581          //#if ZG_BUILD_ENDDEVICE_TYPE    
    582          //    case BDB_COMMISSIONING_PARENT_LOST:
    583          //      if(bdbCommissioningModeMsg->bdbCommissioningStatus == BDB_COMMISSIONING_NETWORK_RESTORED)
    584          //      {
    585          //        //We did recover from losing parent
    586          //      }
    587          //      else
    588          //      {
    589          //        //Parent not found, attempt to rejoin again after a fixed delay
    590          //        osal_start_timerEx(SW2_TaskID, SAMPLEAPP_END_DEVICE_REJOIN_EVT, SAMPLEAPP_END_DEVICE_REJOIN_DELAY);
    591          //      }
    592          //    break;
    593          //#endif 
    594          //  }
    595          //
    596          //}
    597          
    598          /*********************************************************************
    599           * @fn      SW2_BasicResetCB
    600           *
    601           * @brief   Callback from the ZCL General Cluster Library
    602           *          to set all the Basic Cluster attributes to default values.
    603           *
    604           * @param   none
    605           *
    606           * @return  none
    607           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    608          static void SW2_BasicResetCB( void )
   \                     SW2_BasicResetCB:
    609          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    610            //Reset every attribute in all supported cluster to their default value.
    611          
    612            SW2_ResetAttributesToDefaultValues();
   \   000004                ; Setup parameters for call to function SW2_ResetAttributesToDefaultValues
   \   000004   12....       LCALL     `??SW2_ResetAttributesToDefaultValues::?relay`; Banked call to: SW2_ResetAttributesToDefaultValues
    613          
    614            SW2_UpdateLedState();
   \   000007                ; Setup parameters for call to function SW2_UpdateLedState
   \   000007   12....       LCALL     `??SW2_UpdateLedState::?relay`; Banked call to: SW2_UpdateLedState
    615          }
   \   00000A   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    616          
    617          /*********************************************************************
    618           * @fn      SW2_OnOffCB
    619           *
    620           * @brief   Callback from the ZCL General Cluster Library when
    621           *          it received an On/Off Command for this application.
    622           *
    623           * @param   cmd - COMMAND_ON, COMMAND_OFF or COMMAND_TOGGLE
    624           *
    625           * @return  none
    626           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    627          static void SW2_OnOffCB( uint8 cmd )
   \                     SW2_OnOffCB:
    628          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FF           MOV       R7,A
    629            afIncomingMSGPacket_t *pPtr = zcl_getRawAFMsg();
   \   000007                ; Setup parameters for call to function zcl_getRawAFMsg
   \   000007   12....       LCALL     `??zcl_getRawAFMsg::?relay`; Banked call to: zcl_getRawAFMsg
   \   00000A   8A82         MOV       DPL,R2
   \   00000C   8B83         MOV       DPH,R3
    630          
    631            uint8 OnOff;
    632          
    633            SW2_DstAddr.addr.shortAddr = pPtr->srcAddr.addr.shortAddr;
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000017   90....       MOV       DPTR,#SW2_DstAddr
   \   00001A   E8           MOV       A,R0
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   A3           INC       DPTR
   \   00001D   E9           MOV       A,R1
   \   00001E   F0           MOVX      @DPTR,A
    634          
    635          
    636            // Turn on the light
    637            if ( cmd == COMMAND_ON )
   \   00001F   7401         MOV       A,#0x1
   \   000021   6F           XRL       A,R7
   \   000022   602D         JZ        ??SW2_OnOffCB_0
    638            {
    639              OnOff = LIGHT_ON;
    640            }
    641            // Turn off the light
    642            else if ( cmd == COMMAND_OFF )
   \   000024   EF           MOV       A,R7
   \   000025   6010         JZ        ??SW2_OnOffCB_1
    643            {
    644              OnOff = LIGHT_OFF;
    645            }
    646            // Toggle the light
    647            else if ( cmd == COMMAND_TOGGLE )
   \   000027   7402         MOV       A,#0x2
   \   000029   6F           XRL       A,R7
   \   00002A   7022         JNZ       ??SW2_OnOffCB_2
    648            {
    649          #ifdef ZCL_LEVEL_CTRL
    650              if (SW2_LevelRemainingTime > 0) 
   \   00002C   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00002F   6013         JZ        ??SW2_OnOffCB_3
    651              {
    652                if (SW2_NewLevelUp)
   \   000031   90....       MOV       DPTR,#SW2_NewLevelUp
   \   000034   E0           MOVX      A,@DPTR
   \   000035   601A         JZ        ??SW2_OnOffCB_0
   \                     ??SW2_OnOffCB_1:
   \   000037   90....       MOV       DPTR,#SW2_LevelChangeCmd
   \   00003A   7402         MOV       A,#0x2
   \   00003C   F0           MOVX      @DPTR,A
   \   00003D   7E01         MOV       R6,#0x1
   \   00003F   90....       MOV       DPTR,#SW2_LevelOffTransitionTime
   \   000042   802E         SJMP      ??SW2_OnOffCB_4
    653                {
    654                  OnOff = LIGHT_OFF;
    655                }
    656                else
    657                {
    658                  OnOff = LIGHT_ON;
    659                }
    660              }
    661              else
    662              {
    663                if (SW2_OnOff == LIGHT_ON)
   \                     ??SW2_OnOffCB_3:
   \   000044   90....       MOV       DPTR,#SW2_OnOff
   \   000047   E0           MOVX      A,@DPTR
   \   000048   6401         XRL       A,#0x1
   \   00004A   7005         JNZ       ??SW2_OnOffCB_0
   \   00004C   80E9         SJMP      ??SW2_OnOffCB_1
    664                {
    665                  OnOff = LIGHT_OFF;
    666                }
    667                else
    668                {
    669                  OnOff = LIGHT_ON;
    670                }
    671              }
    672          #else
    673              if (SW2_OnOff == LIGHT_ON)
    674              {
    675                OnOff = LIGHT_OFF;
    676              }
    677              else
    678              {
    679                OnOff = LIGHT_ON;
    680              }
    681          #endif
    682            }
    683          
    684          #ifdef ZCL_LEVEL_CTRL
    685            SW2_LevelChangeCmd = (OnOff == LIGHT_ON ? LEVEL_CHANGED_BY_ON_CMD : LEVEL_CHANGED_BY_OFF_CMD);
   \                     ??SW2_OnOffCB_2:
   \   00004E   EA           MOV       A,R2
   \   00004F   60E6         JZ        ??SW2_OnOffCB_1
   \                     ??SW2_OnOffCB_0:
   \   000051   90....       MOV       DPTR,#SW2_LevelChangeCmd
   \   000054   7401         MOV       A,#0x1
   \   000056   F0           MOVX      @DPTR,A
   \   000057   90....       MOV       DPTR,#SW2_OnOff
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   7006         JNZ       ??SW2_OnOffCB_5
   \   00005D   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   000060   7401         MOV       A,#0x1
   \   000062   F0           MOVX      @DPTR,A
   \                     ??SW2_OnOffCB_5:
   \   000063   90....       MOV       DPTR,#SW2_LevelOnLevel
   \   000066   E0           MOVX      A,@DPTR
   \   000067   F4           CPL       A
   \   000068   7003         JNZ       ??SW2_OnOffCB_6
   \   00006A   90....       MOV       DPTR,#SW2_LevelLastLevel
   \                     ??SW2_OnOffCB_6:
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   FE           MOV       R6,A
   \   00006F   90....       MOV       DPTR,#SW2_LevelOnTransitionTime
   \                     ??SW2_OnOffCB_4:
   \   000072   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000075   74FF         MOV       A,#-0x1
   \   000077   68           XRL       A,R0
   \   000078   7003         JNZ       ??SW2_OnOffCB_7
   \   00007A   74FF         MOV       A,#-0x1
   \   00007C   69           XRL       A,R1
   \                     ??SW2_OnOffCB_7:
   \   00007D   7006         JNZ       ??CrossCallReturnLabel_23
   \   00007F   90....       MOV       DPTR,#SW2_LevelOnOffTransitionTime
   \   000082   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000085   74FF         MOV       A,#-0x1
   \   000087   68           XRL       A,R0
   \   000088   7003         JNZ       ??SW2_OnOffCB_8
   \   00008A   74FF         MOV       A,#-0x1
   \   00008C   69           XRL       A,R1
   \                     ??SW2_OnOffCB_8:
   \   00008D   7004         JNZ       ??SW2_OnOffCB_9
   \   00008F   7801         MOV       R0,#0x1
   \   000091   7900         MOV       R1,#0x0
   \                     ??SW2_OnOffCB_9:
   \   000093   90....       MOV       DPTR,#SW2_WithOnOff
   \   000096   7401         MOV       A,#0x1
   \   000098   F0           MOVX      @DPTR,A
   \   000099                ; Setup parameters for call to function SW2_MoveBasedOnRate
   \   000099   75..18       MOV       ?V0,#0x18
   \   00009C   75..E4       MOV       ?V1,#-0x1c
   \   00009F   75..03       MOV       ?V2,#0x3
   \   0000A2   75..00       MOV       ?V3,#0x0
   \   0000A5   88..         MOV       ?V4,R0
   \   0000A7   89..         MOV       ?V5,R1
   \   0000A9   E4           CLR       A
   \   0000AA   F5..         MOV       ?V6,A
   \   0000AC   F5..         MOV       ?V7,A
   \   0000AE   78..         MOV       R0,#?V0
   \   0000B0   79..         MOV       R1,#?V4
   \   0000B2   12....       LCALL     ?L_DIV_MOD
   \   0000B5   AA..         MOV       R2,?V0
   \   0000B7   AB..         MOV       R3,?V1
   \   0000B9   AC..         MOV       R4,?V2
   \   0000BB   AD..         MOV       R5,?V3
   \   0000BD   EE           MOV       A,R6
   \   0000BE   F9           MOV       R1,A
   \   0000BF   12....       LCALL     `??SW2_MoveBasedOnRate::?relay`; Banked call to: SW2_MoveBasedOnRate
    686          
    687            SW2_DefaultMove(OnOff);
    688          #else
    689            SW2_OnOff = OnOff;
    690          #endif
    691            bdb_RepChangedAttrValue(SW2_ENDPOINT, ZCL_CLUSTER_ID_GEN_ON_OFF, ATTRID_ON_OFF);
   \   0000C2                ; Setup parameters for call to function bdb_RepChangedAttrValue
   \   0000C2   7C00         MOV       R4,#0x0
   \   0000C4   7D00         MOV       R5,#0x0
   \   0000C6   7A06         MOV       R2,#0x6
   \   0000C8   7B00         MOV       R3,#0x0
   \   0000CA   7909         MOV       R1,#0x9
   \   0000CC   12....       LCALL     `??bdb_RepChangedAttrValue::?relay`; Banked call to: bdb_RepChangedAttrValue
    692            SW2_UpdateLedState();
   \   0000CF                ; Setup parameters for call to function SW2_UpdateLedState
   \   0000CF   12....       LCALL     `??SW2_UpdateLedState::?relay`; Banked call to: SW2_UpdateLedState
    693          }
   \   0000D2   02....       LJMP      ??Subroutine11_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine11_0:
   \   000000   7F08         MOV       R7,#0x8
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   90....       MOV       DPTR,#SW2_LevelRemainingTime
   \   000003   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000006   E8           MOV       A,R0
   \   000007   49           ORL       A,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   22           RET
    694          
    695          #ifdef ZCL_LEVEL_CTRL
    696          /*********************************************************************
    697           * @fn      SW2_TimeRateHelper
    698           *
    699           * @brief   Calculate time based on rate, and startup level state machine
    700           *
    701           * @param   newLevel - new level for current level
    702           *
    703           * @return  diff (directly), SW2_CurrentLevel32 and SW2_NewLevel, SW2_NewLevelUp
    704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    705          static uint32 SW2_TimeRateHelper( uint8 newLevel )
   \                     SW2_TimeRateHelper:
    706          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    707            uint32 diff;
    708            uint32 newLevel32;
    709          
    710            // remember current and new level
    711            SW2_NewLevel = newLevel;
   \   000007   90....       MOV       DPTR,#SW2_NewLevel
   \   00000A   F0           MOVX      @DPTR,A
    712            SW2_CurrentLevel32 = (uint32)1000 * SW2_LevelCurrentLevel;
   \   00000B   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   00000E   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000011   90....       MOV       DPTR,#__Constant_3e8
   \   000014   78..         MOV       R0,#?V4
   \   000016   12....       LCALL     ?L_MOV_X
   \   000019   78..         MOV       R0,#?V0
   \   00001B   79..         MOV       R1,#?V4
   \   00001D   12....       LCALL     ?L_MUL
   \   000020   90....       MOV       DPTR,#SW2_CurrentLevel32
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?L_MOV_TO_X
    713          
    714            // calculate diff
    715            newLevel32 = (uint32)1000 * newLevel;
   \   000028   8E..         MOV       ?V4,R6
   \   00002A   E4           CLR       A
   \   00002B   F5..         MOV       ?V5,A
   \   00002D   F5..         MOV       ?V6,A
   \   00002F   F5..         MOV       ?V7,A
   \   000031   90....       MOV       DPTR,#__Constant_3e8
   \   000034   78..         MOV       R0,#?V0
   \   000036   12....       LCALL     ?L_MOV_X
   \   000039   78..         MOV       R0,#?V4
   \   00003B   79..         MOV       R1,#?V0
   \   00003D   12....       LCALL     ?L_MUL
    716            if ( SW2_LevelCurrentLevel > newLevel )
   \   000040   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   000043   E0           MOVX      A,@DPTR
   \   000044   F8           MOV       R0,A
   \   000045   EE           MOV       A,R6
   \   000046   C3           CLR       C
   \   000047   98           SUBB      A,R0
   \   000048   90....       MOV       DPTR,#SW2_CurrentLevel32
   \   00004B   501E         JNC       ??SW2_TimeRateHelper_0
    717            {
    718              diff = SW2_CurrentLevel32 - newLevel32;
   \   00004D   78..         MOV       R0,#?V0
   \   00004F   12....       LCALL     ?L_MOV_X
   \   000052   78..         MOV       R0,#?V0
   \   000054   79..         MOV       R1,#?V4
   \   000056   12....       LCALL     ?L_SUB
   \   000059   85....       MOV       ?V4,?V0
   \   00005C   85....       MOV       ?V5,?V1
   \   00005F   85....       MOV       ?V6,?V2
   \   000062   85....       MOV       ?V7,?V3
    719              SW2_NewLevelUp = FALSE;  // moving down
   \   000065   90....       MOV       DPTR,#SW2_NewLevelUp
   \   000068   E4           CLR       A
   \   000069   800A         SJMP      ??SW2_TimeRateHelper_1
    720            }
    721            else
    722            {
    723              diff = newLevel32 - SW2_CurrentLevel32;
   \                     ??SW2_TimeRateHelper_0:
   \   00006B   78..         MOV       R0,#?V4
   \   00006D   12....       LCALL     ?L_SUB_X
    724              SW2_NewLevelUp = TRUE;   // moving up
   \   000070   90....       MOV       DPTR,#SW2_NewLevelUp
   \   000073   7401         MOV       A,#0x1
   \                     ??SW2_TimeRateHelper_1:
   \   000075   F0           MOVX      @DPTR,A
    725            }
    726          
    727            return ( diff );
   \   000076   AA..         MOV       R2,?V4
   \   000078   AB..         MOV       R3,?V5
   \   00007A   AC..         MOV       R4,?V6
   \   00007C   AD..         MOV       R5,?V7
   \   00007E   80..         SJMP      ??Subroutine11_0
    728          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   E4           CLR       A
   \   000004   F5..         MOV       ?V1,A
   \   000006   F5..         MOV       ?V2,A
   \   000008   F5..         MOV       ?V3,A
   \   00000A   22           RET
    729          
    730          /*********************************************************************
    731           * @fn      SW2_MoveBasedOnRate
    732           *
    733           * @brief   Calculate time based on rate, and startup level state machine
    734           *
    735           * @param   newLevel - new level for current level
    736           * @param   rate16   - fixed point rate (e.g. 16.123)
    737           *
    738           * @return  none
    739           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   90....       MOV       DPTR,#__Constant_64
   \   000003   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000006   7A02         MOV       R2,#0x2
   \   000008   7B00         MOV       R3,#0x0
   \   00000A   90....       MOV       DPTR,#SW2_TaskID
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   F9           MOV       R1,A
   \   00000F   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000012   7404         MOV       A,#0x4
   \   000014   12....       LCALL     ?DEALLOC_XSTACK8
   \   000017                REQUIRE ??Subroutine11_0
   \   000017                ; // Fall through to label ??Subroutine11_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    740          static void SW2_MoveBasedOnRate( uint8 newLevel, uint32 rate )
   \                     SW2_MoveBasedOnRate:
    741          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V4,R2
   \   000007   8B..         MOV       ?V5,R3
   \   000009   8C..         MOV       ?V6,R4
   \   00000B   8D..         MOV       ?V7,R5
    742            uint32 diff;
    743          
    744            // determine how much time (in 10ths of seconds) based on the difference and rate
    745            SW2_Rate32 = rate;
   \   00000D   90....       MOV       DPTR,#SW2_Rate32
   \   000010   78..         MOV       R0,#?V4
   \   000012   12....       LCALL     ?L_MOV_TO_X
    746            diff = SW2_TimeRateHelper( newLevel );
    747            SW2_LevelRemainingTime = diff / rate;
   \   000015                ; Setup parameters for call to function SW2_TimeRateHelper
   \   000015   12....       LCALL     `??SW2_TimeRateHelper::?relay`; Banked call to: SW2_TimeRateHelper
   \   000018   8A..         MOV       ?V0,R2
   \   00001A   8B..         MOV       ?V1,R3
   \   00001C   8C..         MOV       ?V2,R4
   \   00001E   8D..         MOV       ?V3,R5
   \   000020   78..         MOV       R0,#?V0
   \   000022   79..         MOV       R1,#?V4
   \   000024   12....       LCALL     ?UL_DIV_MOD
   \   000027   90....       MOV       DPTR,#SW2_LevelRemainingTime
   \   00002A   E5..         MOV       A,?V0
   \   00002C   F0           MOVX      @DPTR,A
   \   00002D   A3           INC       DPTR
   \   00002E   E5..         MOV       A,?V1
   \   000030   F0           MOVX      @DPTR,A
    748            if ( !SW2_LevelRemainingTime )
   \   000031   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000034   7009         JNZ       ??SW2_MoveBasedOnRate_0
    749            {
    750              SW2_LevelRemainingTime = 1;
   \   000036   90....       MOV       DPTR,#SW2_LevelRemainingTime
   \   000039   7401         MOV       A,#0x1
   \   00003B   F0           MOVX      @DPTR,A
   \   00003C   A3           INC       DPTR
   \   00003D   E4           CLR       A
   \   00003E   F0           MOVX      @DPTR,A
    751            }
    752          
    753            osal_start_timerEx( SW2_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
   \                     ??SW2_MoveBasedOnRate_0:
   \   00003F                ; Setup parameters for call to function osal_start_timerEx
   \   00003F   80..         SJMP      ?Subroutine1
    754          }
    755          
    756          /*********************************************************************
    757           * @fn      SW2_MoveBasedOnTime
    758           *
    759           * @brief   Calculate rate based on time, and startup level state machine
    760           *
    761           * @param   newLevel  - new level for current level
    762           * @param   time      - in 10ths of seconds
    763           *
    764           * @return  none
    765           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    766          static void SW2_MoveBasedOnTime( uint8 newLevel, uint16 time )
   \                     SW2_MoveBasedOnTime:
    767          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
    768            uint16 diff;
    769          
    770            // determine rate (in units) based on difference and time
    771            diff = SW2_TimeRateHelper( newLevel );
   \   00000B                ; Setup parameters for call to function SW2_TimeRateHelper
   \   00000B   12....       LCALL     `??SW2_TimeRateHelper::?relay`; Banked call to: SW2_TimeRateHelper
   \   00000E   8A..         MOV       ?V4,R2
   \   000010   8B..         MOV       ?V5,R3
   \   000012   A8..         MOV       R0,?V4
   \   000014   A9..         MOV       R1,?V5
    772            SW2_LevelRemainingTime = SW2_GetTime( newLevel, time );
   \   000016   EE           MOV       A,R6
   \   000017   FA           MOV       R2,A
   \   000018   EF           MOV       A,R7
   \   000019   FB           MOV       R3,A
   \   00001A   74FF         MOV       A,#-0x1
   \   00001C   6A           XRL       A,R2
   \   00001D   7003         JNZ       ??SW2_MoveBasedOnTime_0
   \   00001F   74FF         MOV       A,#-0x1
   \   000021   6B           XRL       A,R3
   \                     ??SW2_MoveBasedOnTime_0:
   \   000022   7030         JNZ       ??SW2_MoveBasedOnTime_1
   \   000024   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   000027   E0           MOVX      A,@DPTR
   \   000028   FA           MOV       R2,A
   \   000029   E5..         MOV       A,?V0
   \   00002B   C3           CLR       C
   \   00002C   9A           SUBB      A,R2
   \   00002D   5005         JNC       ??SW2_MoveBasedOnTime_2
   \   00002F   90....       MOV       DPTR,#SW2_LevelOffTransitionTime
   \   000032   8003         SJMP      ??SW2_MoveBasedOnTime_3
   \                     ??SW2_MoveBasedOnTime_2:
   \   000034   90....       MOV       DPTR,#SW2_LevelOnTransitionTime
   \                     ??SW2_MoveBasedOnTime_3:
   \   000037   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   00003A   74FF         MOV       A,#-0x1
   \   00003C   6A           XRL       A,R2
   \   00003D   7003         JNZ       ??SW2_MoveBasedOnTime_4
   \   00003F   74FF         MOV       A,#-0x1
   \   000041   6B           XRL       A,R3
   \                     ??SW2_MoveBasedOnTime_4:
   \   000042   7006         JNZ       ??CrossCallReturnLabel_7
   \   000044   90....       MOV       DPTR,#SW2_LevelOnOffTransitionTime
   \   000047   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00004A   74FF         MOV       A,#-0x1
   \   00004C   6A           XRL       A,R2
   \   00004D   7003         JNZ       ??SW2_MoveBasedOnTime_5
   \   00004F   74FF         MOV       A,#-0x1
   \   000051   6B           XRL       A,R3
   \                     ??SW2_MoveBasedOnTime_5:
   \   000052   6004         JZ        ??SW2_MoveBasedOnTime_6
   \                     ??SW2_MoveBasedOnTime_1:
   \   000054   EA           MOV       A,R2
   \   000055   4B           ORL       A,R3
   \   000056   7004         JNZ       ??SW2_MoveBasedOnTime_7
   \                     ??SW2_MoveBasedOnTime_6:
   \   000058   7A01         MOV       R2,#0x1
   \   00005A   7B00         MOV       R3,#0x0
   \                     ??SW2_MoveBasedOnTime_7:
   \   00005C   90....       MOV       DPTR,#SW2_LevelRemainingTime
   \   00005F   EA           MOV       A,R2
   \   000060   F0           MOVX      @DPTR,A
   \   000061   A3           INC       DPTR
   \   000062   EB           MOV       A,R3
   \   000063   F0           MOVX      @DPTR,A
    773            SW2_Rate32 = diff / time;
   \   000064   EE           MOV       A,R6
   \   000065   FA           MOV       R2,A
   \   000066   EF           MOV       A,R7
   \   000067   FB           MOV       R3,A
   \   000068   12....       LCALL     ?US_DIV_MOD
   \   00006B   90....       MOV       DPTR,#SW2_Rate32
   \   00006E   E8           MOV       A,R0
   \   00006F   F0           MOVX      @DPTR,A
   \   000070   A3           INC       DPTR
   \   000071   E9           MOV       A,R1
   \   000072   F0           MOVX      @DPTR,A
   \   000073   A3           INC       DPTR
   \   000074   E4           CLR       A
   \   000075   F0           MOVX      @DPTR,A
   \   000076   A3           INC       DPTR
   \   000077   F0           MOVX      @DPTR,A
    774          
    775            osal_start_timerEx( SW2_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
   \   000078                ; Setup parameters for call to function osal_start_timerEx
   \   000078   02....       LJMP      ?Subroutine1 & 0xFFFF
    776          }
    777          
    778          /*********************************************************************
    779           * @fn      SW2_GetTime
    780           *
    781           * @brief   Determine amount of time that MoveXXX will take to complete.
    782           *
    783           * @param   level = new level to move to
    784           *          time  = 0xffff=default, or 0x0000-n amount of time in tenths of seconds.
    785           *
    786           * @return  none
    787           */
    788          static uint16 SW2_GetTime( uint8 newLevel, uint16 time )
    789          {
    790            // there is a hiearchy of the amount of time to use for transistioning
    791            // check each one in turn. If none of defaults are set, then use fastest
    792            // time possible.
    793            if ( time == 0xFFFF )
    794            {
    795              // use On or Off Transition Time if set (not 0xffff)
    796              if ( SW2_LevelCurrentLevel > newLevel )
    797              {
    798                time = SW2_LevelOffTransitionTime;
    799              }
    800              else
    801              {
    802                time = SW2_LevelOnTransitionTime;
    803              }
    804          
    805              // else use OnOffTransitionTime if set (not 0xffff)
    806              if ( time == 0xFFFF )
    807              {
    808                time = SW2_LevelOnOffTransitionTime;
    809              }
    810          
    811              // else as fast as possible
    812              if ( time == 0xFFFF )
    813              {
    814                time = 1;
    815              }
    816            }
    817          
    818            if ( time == 0 )
    819            {
    820              time = 1; // as fast as possible
    821            }
    822          
    823            return ( time );
    824          }
    825          
    826          /*********************************************************************
    827           * @fn      SW2_DefaultMove
    828           *
    829           * @brief   We were turned on/off. Use default time to move to on or off.
    830           *
    831           * @param   SW2_OnOff - must be set prior to calling this function.
    832           *
    833           * @return  none
    834           */
    835          static void SW2_DefaultMove( uint8 OnOff )
    836          {
    837            uint8  newLevel;
    838            uint32 rate;      // fixed point decimal (3 places, eg. 16.345)
    839            uint16 time;
    840          
    841            // if moving to on position, move to on level
    842            if ( OnOff )
    843            {
    844              if (SW2_OnOff == LIGHT_OFF)
    845              {
    846                SW2_LevelCurrentLevel = ATTR_LEVEL_MIN_LEVEL;
    847              }
    848              
    849              if ( SW2_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT )
    850              {
    851                // The last Level (before going OFF) should be used)
    852                newLevel = SW2_LevelLastLevel;
    853              }
    854              else
    855              {
    856                newLevel = SW2_LevelOnLevel;
    857              }
    858          
    859              time = SW2_LevelOnTransitionTime;
    860          
    861            }
    862            else
    863            {
    864              newLevel = ATTR_LEVEL_MIN_LEVEL;
    865          
    866              time = SW2_LevelOffTransitionTime;
    867            }
    868          
    869            // else use OnOffTransitionTime if set (not 0xffff)
    870            if ( time == 0xFFFF )
    871            {
    872              time = SW2_LevelOnOffTransitionTime;
    873            }
    874          
    875            // else as fast as possible
    876            if ( time == 0xFFFF )
    877            {
    878              time = 1;
    879            }
    880          
    881            // calculate rate based on time (int 10ths) for full transition (1-254)
    882            rate = 255000 / time;    // units per tick, fixed point, 3 decimal places (e.g. 8500 = 8.5 units per tick)
    883          
    884            // start up state machine.
    885            SW2_WithOnOff = TRUE;
    886            SW2_MoveBasedOnRate( newLevel, rate );
    887          }
    888          
    889          /*********************************************************************
    890           * @fn      SW2_AdjustLightLevel
    891           *
    892           * @brief   Called each 10th of a second while state machine running
    893           *
    894           * @param   none
    895           *
    896           * @return  none
    897           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    898          static void SW2_AdjustLightLevel( void )
   \                     SW2_AdjustLightLevel:
    899          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    900            // one tick (10th of a second) less
    901            if ( SW2_LevelRemainingTime )
   \   000005   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000008   6012         JZ        ??SW2_AdjustLightLevel_0
    902            {
    903              --SW2_LevelRemainingTime;
    904            }
    905          
    906            // no time left, done
    907            if ( SW2_LevelRemainingTime == 0)
   \   00000A   90....       MOV       DPTR,#SW2_LevelRemainingTime
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   24FF         ADD       A,#-0x1
   \   000010   F0           MOVX      @DPTR,A
   \   000011   18           DEC       R0
   \   000012   A3           INC       DPTR
   \   000013   E0           MOVX      A,@DPTR
   \   000014   34FF         ADDC      A,#-0x1
   \   000016   F0           MOVX      @DPTR,A
   \   000017   F9           MOV       R1,A
   \   000018   E8           MOV       A,R0
   \   000019   49           ORL       A,R1
   \   00001A   7006         JNZ       ??SW2_AdjustLightLevel_1
    908            {
    909              SW2_LevelCurrentLevel = SW2_NewLevel;
   \                     ??SW2_AdjustLightLevel_0:
   \   00001C   90....       MOV       DPTR,#SW2_NewLevel
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   803C         SJMP      ??SW2_AdjustLightLevel_2
    910            }
    911          
    912            // still time left, keep increment/decrementing
    913            else
    914            {
    915              if ( SW2_NewLevelUp )
   \                     ??SW2_AdjustLightLevel_1:
   \   000022   90....       MOV       DPTR,#SW2_NewLevelUp
   \   000025   E0           MOVX      A,@DPTR
   \   000026   90....       MOV       DPTR,#SW2_Rate32
   \   000029   78..         MOV       R0,#?V0
   \   00002B   600D         JZ        ??SW2_AdjustLightLevel_3
    916              {
    917                SW2_CurrentLevel32 += SW2_Rate32;
   \   00002D   12....       LCALL     ?L_MOV_X
   \   000030   90....       MOV       DPTR,#SW2_CurrentLevel32
   \   000033   78..         MOV       R0,#?V0
   \   000035   12....       LCALL     ?L_ADD_TO_X
   \   000038   800B         SJMP      ??SW2_AdjustLightLevel_4
    918              }
    919              else
    920              {
    921                SW2_CurrentLevel32 -= SW2_Rate32;
   \                     ??SW2_AdjustLightLevel_3:
   \   00003A   12....       LCALL     ?L_MOV_X
   \   00003D   90....       MOV       DPTR,#SW2_CurrentLevel32
   \   000040   78..         MOV       R0,#?V0
   \   000042   12....       LCALL     ?L_SUB_FROM_X
    922              }
    923              SW2_LevelCurrentLevel = (uint8)( SW2_CurrentLevel32 / 1000 );
   \                     ??SW2_AdjustLightLevel_4:
   \   000045   90....       MOV       DPTR,#SW2_CurrentLevel32
   \   000048   78..         MOV       R0,#?V0
   \   00004A   12....       LCALL     ?L_MOV_X
   \   00004D   90....       MOV       DPTR,#__Constant_3e8
   \   000050   78..         MOV       R0,#?V4
   \   000052   12....       LCALL     ?L_MOV_X
   \   000055   78..         MOV       R0,#?V0
   \   000057   79..         MOV       R1,#?V4
   \   000059   12....       LCALL     ?L_DIV_MOD
   \   00005C   E5..         MOV       A,?V0
   \                     ??SW2_AdjustLightLevel_2:
   \   00005E   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   000061   F0           MOVX      @DPTR,A
    924            }
    925          
    926            if (( SW2_LevelChangeCmd == LEVEL_CHANGED_BY_LEVEL_CMD ) && ( SW2_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT ))
   \   000062   90....       MOV       DPTR,#SW2_LevelChangeCmd
   \   000065   E0           MOVX      A,@DPTR
   \   000066   700F         JNZ       ??SW2_AdjustLightLevel_5
   \   000068   90....       MOV       DPTR,#SW2_LevelOnLevel
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   F4           CPL       A
   \   00006D   7008         JNZ       ??SW2_AdjustLightLevel_5
    927            {
    928              SW2_LevelLastLevel = SW2_LevelCurrentLevel;
   \   00006F   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   000072   E0           MOVX      A,@DPTR
   \   000073   90....       MOV       DPTR,#SW2_LevelLastLevel
   \   000076   F0           MOVX      @DPTR,A
    929            }
    930          
    931            // also affect on/off
    932            if ( SW2_WithOnOff )
   \                     ??SW2_AdjustLightLevel_5:
   \   000077   90....       MOV       DPTR,#SW2_WithOnOff
   \   00007A   E0           MOVX      A,@DPTR
   \   00007B   6037         JZ        ??SW2_AdjustLightLevel_6
    933            {
    934              if ( SW2_LevelCurrentLevel > ATTR_LEVEL_MIN_LEVEL )
   \   00007D   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   000080   E0           MOVX      A,@DPTR
   \   000081   C3           CLR       C
   \   000082   9402         SUBB      A,#0x2
   \   000084   4007         JC        ??SW2_AdjustLightLevel_7
    935              {
    936                SW2_OnOff = LIGHT_ON;
   \   000086   90....       MOV       DPTR,#SW2_OnOff
   \   000089   7401         MOV       A,#0x1
   \   00008B   8026         SJMP      ??SW2_AdjustLightLevel_8
    937              }
    938              else
    939              {
    940                if (SW2_LevelChangeCmd != LEVEL_CHANGED_BY_ON_CMD)
   \                     ??SW2_AdjustLightLevel_7:
   \   00008D   90....       MOV       DPTR,#SW2_LevelChangeCmd
   \   000090   E0           MOVX      A,@DPTR
   \   000091   6401         XRL       A,#0x1
   \   000093   90....       MOV       DPTR,#SW2_OnOff
   \   000096   600A         JZ        ??SW2_AdjustLightLevel_9
    941                {
    942                  SW2_OnOff = LIGHT_OFF;
   \   000098   E4           CLR       A
   \   000099   F0           MOVX      @DPTR,A
    943                }
    944                else
    945                {
    946                  SW2_OnOff = LIGHT_ON;
    947                }
    948                
    949                if (( SW2_LevelChangeCmd != LEVEL_CHANGED_BY_LEVEL_CMD ) && ( SW2_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT ))
   \   00009A   90....       MOV       DPTR,#SW2_LevelChangeCmd
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   7005         JNZ       ??SW2_AdjustLightLevel_10
   \   0000A0   8012         SJMP      ??SW2_AdjustLightLevel_6
   \                     ??SW2_AdjustLightLevel_9:
   \   0000A2   7401         MOV       A,#0x1
   \   0000A4   F0           MOVX      @DPTR,A
   \                     ??SW2_AdjustLightLevel_10:
   \   0000A5   90....       MOV       DPTR,#SW2_LevelOnLevel
   \   0000A8   E0           MOVX      A,@DPTR
   \   0000A9   F4           CPL       A
   \   0000AA   7008         JNZ       ??SW2_AdjustLightLevel_6
    950                {
    951                  SW2_LevelCurrentLevel = SW2_LevelLastLevel;
   \   0000AC   90....       MOV       DPTR,#SW2_LevelLastLevel
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \                     ??SW2_AdjustLightLevel_8:
   \   0000B3   F0           MOVX      @DPTR,A
    952                }
    953              }
    954            }
    955          
    956            SW2_UpdateLedState();
   \                     ??SW2_AdjustLightLevel_6:
   \   0000B4                ; Setup parameters for call to function SW2_UpdateLedState
   \   0000B4   12....       LCALL     `??SW2_UpdateLedState::?relay`; Banked call to: SW2_UpdateLedState
    957          
    958            // keep ticking away
    959            if ( SW2_LevelRemainingTime )
   \   0000B7   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000BA   6017         JZ        ??SW2_AdjustLightLevel_11
    960            {
    961              osal_start_timerEx( SW2_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
   \   0000BC                ; Setup parameters for call to function osal_start_timerEx
   \   0000BC   90....       MOV       DPTR,#__Constant_64
   \   0000BF   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0000C2   7A02         MOV       R2,#0x2
   \   0000C4   7B00         MOV       R3,#0x0
   \   0000C6   90....       MOV       DPTR,#SW2_TaskID
   \   0000C9   E0           MOVX      A,@DPTR
   \   0000CA   F9           MOV       R1,A
   \   0000CB   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   0000CE   7404         MOV       A,#0x4
   \   0000D0   12....       LCALL     ?DEALLOC_XSTACK8
    962            }
    963          }
   \                     ??SW2_AdjustLightLevel_11:
   \   0000D3   02....       LJMP      ??Subroutine11_0 & 0xFFFF
    964          
    965          /*********************************************************************
    966           * @fn      SW2_LevelControlMoveToLevelCB
    967           *
    968           * @brief   Callback from the ZCL General Cluster Library when
    969           *          it received a LevelControlMoveToLevel Command for this application.
    970           *
    971           * @param   pCmd - ZigBee command parameters
    972           *
    973           * @return  none
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          static void SW2_LevelControlMoveToLevelCB( zclLCMoveToLevel_t *pCmd )
   \                     SW2_LevelControlMoveToLevelCB:
    976          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   EA           MOV       A,R2
   \   000005   F8           MOV       R0,A
   \   000006   EB           MOV       A,R3
   \   000007   F9           MOV       R1,A
    977            SW2_LevelChangeCmd = LEVEL_CHANGED_BY_LEVEL_CMD;
   \   000008   12....       LCALL     ?Subroutine3 & 0xFFFF
    978          
    979            SW2_WithOnOff = pCmd->withOnOff;
   \                     ??CrossCallReturnLabel_0:
   \   00000B   12....       LCALL     ?Subroutine4 & 0xFFFF
    980            SW2_MoveBasedOnTime( pCmd->level, pCmd->transitionTime );
   \                     ??CrossCallReturnLabel_15:
   \   00000E   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000011   8882         MOV       DPL,R0
   \   000013   8983         MOV       DPH,R1
   \   000015   E0           MOVX      A,@DPTR
   \   000016   F9           MOV       R1,A
   \   000017   12....       LCALL     `??SW2_MoveBasedOnTime::?relay`; Banked call to: SW2_MoveBasedOnTime
    981          }
   \   00001A   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   90....       MOV       DPTR,#SW2_WithOnOff
   \   000004                REQUIRE ??Subroutine12_0
   \   000004                ; // Fall through to label ??Subroutine12_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine12_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function SW2_MoveBasedOnTime
   \   000001                ; Setup parameters for call to function SW2_MoveBasedOnTime
   \   000001                ; Setup parameters for call to function SW2_MoveBasedOnRate
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV       DPTR,#SW2_LevelChangeCmd
   \   000003   E4           CLR       A
   \   000004   F0           MOVX      @DPTR,A
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   22           RET
    982          
    983          /*********************************************************************
    984           * @fn      SW2_LevelControlMoveCB
    985           *
    986           * @brief   Callback from the ZCL General Cluster Library when
    987           *          it received a LevelControlMove Command for this application.
    988           *
    989           * @param   pCmd - ZigBee command parameters
    990           *
    991           * @return  none
    992           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    993          static void SW2_LevelControlMoveCB( zclLCMove_t *pCmd )
   \                     SW2_LevelControlMoveCB:
    994          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    995            uint8 newLevel;
    996            uint32 rate;
    997          
    998            // convert rate from units per second to units per tick (10ths of seconds)
    999            // and move at that right up or down
   1000            SW2_WithOnOff = pCmd->withOnOff;
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   90....       MOV       DPTR,#SW2_WithOnOff
   \   00000F   F0           MOVX      @DPTR,A
   1001          
   1002            if ( pCmd->moveMode == LEVEL_MOVE_UP )
   \   000010   8A82         MOV       DPL,R2
   \   000012   8B83         MOV       DPH,R3
   \   000014   E0           MOVX      A,@DPTR
   \   000015   7004         JNZ       ??SW2_LevelControlMoveCB_0
   1003            {
   1004              newLevel = ATTR_LEVEL_MAX_LEVEL;  // fully on
   \   000017   7EFE         MOV       R6,#-0x2
   \   000019   8002         SJMP      ??SW2_LevelControlMoveCB_1
   1005            }
   1006            else
   1007            {
   1008              newLevel = ATTR_LEVEL_MIN_LEVEL; // fully off
   \                     ??SW2_LevelControlMoveCB_0:
   \   00001B   7E01         MOV       R6,#0x1
   1009            }
   1010          
   1011            SW2_LevelChangeCmd = LEVEL_CHANGED_BY_LEVEL_CMD;
   \                     ??SW2_LevelControlMoveCB_1:
   \   00001D   90....       MOV       DPTR,#SW2_LevelChangeCmd
   \   000020   E4           CLR       A
   \   000021   12....       LCALL     ??Subroutine12_0 & 0xFFFF
   1012          
   1013            rate = (uint32)100 * pCmd->rate;
   1014            SW2_MoveBasedOnRate( newLevel, rate );
   \                     ??CrossCallReturnLabel_17:
   \   000024   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000027   90....       MOV       DPTR,#__Constant_64
   \   00002A   78..         MOV       R0,#?V4
   \   00002C   12....       LCALL     ?L_MOV_X
   \   00002F   78..         MOV       R0,#?V0
   \   000031   79..         MOV       R1,#?V4
   \   000033   12....       LCALL     ?L_MUL
   \   000036   AA..         MOV       R2,?V0
   \   000038   AB..         MOV       R3,?V1
   \   00003A   AC..         MOV       R4,?V2
   \   00003C   AD..         MOV       R5,?V3
   \   00003E   EE           MOV       A,R6
   \   00003F   F9           MOV       R1,A
   \   000040   12....       LCALL     `??SW2_MoveBasedOnRate::?relay`; Banked call to: SW2_MoveBasedOnRate
   1015          }
   \   000043   02....       LJMP      ??Subroutine11_0 & 0xFFFF
   1016          
   1017          /*********************************************************************
   1018           * @fn      SW2_LevelControlStepCB
   1019           *
   1020           * @brief   Callback from the ZCL General Cluster Library when
   1021           *          it received an On/Off Command for this application.
   1022           *
   1023           * @param   pCmd - ZigBee command parameters
   1024           *
   1025           * @return  none
   1026           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1027          static void SW2_LevelControlStepCB( zclLCStep_t *pCmd )
   \                     SW2_LevelControlStepCB:
   1028          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1029            uint8 newLevel;
   1030          
   1031            // determine new level, but don't exceed boundaries
   1032            if ( pCmd->stepMode == LEVEL_MOVE_UP )
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   FC           MOV       R4,A
   \   00000C   8A82         MOV       DPL,R2
   \   00000E   8B83         MOV       DPH,R3
   \   000010   E0           MOVX      A,@DPTR
   \   000011   90....       MOV       DPTR,#SW2_LevelCurrentLevel
   \   000014   7017         JNZ       ??SW2_LevelControlStepCB_0
   1033            {
   1034              if ( (uint16)SW2_LevelCurrentLevel + pCmd->amount > ATTR_LEVEL_MAX_LEVEL )
   \   000016   E0           MOVX      A,@DPTR
   \   000017   2C           ADD       A,R4
   \   000018   F8           MOV       R0,A
   \   000019   E4           CLR       A
   \   00001A   3400         ADDC      A,#0x0
   \   00001C   F9           MOV       R1,A
   \   00001D   E8           MOV       A,R0
   \   00001E   94FF         SUBB      A,#-0x1
   \   000020   E9           MOV       A,R1
   \   000021   9400         SUBB      A,#0x0
   \   000023   4004         JC        ??SW2_LevelControlStepCB_1
   1035              {
   1036                newLevel = ATTR_LEVEL_MAX_LEVEL;
   \   000025   79FE         MOV       R1,#-0x2
   \   000027   8013         SJMP      ??SW2_LevelControlStepCB_2
   1037              }
   1038              else
   1039              {
   1040                newLevel = SW2_LevelCurrentLevel + pCmd->amount;
   \                     ??SW2_LevelControlStepCB_1:
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   2C           ADD       A,R4
   \   00002B   800E         SJMP      ??SW2_LevelControlStepCB_3
   1041              }
   1042            }
   1043            else
   1044            {
   1045              if ( pCmd->amount >= SW2_LevelCurrentLevel )
   \                     ??SW2_LevelControlStepCB_0:
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   F8           MOV       R0,A
   \   00002F   EC           MOV       A,R4
   \   000030   C3           CLR       C
   \   000031   98           SUBB      A,R0
   \   000032   4004         JC        ??SW2_LevelControlStepCB_4
   1046              {
   1047                newLevel = ATTR_LEVEL_MIN_LEVEL;
   \   000034   7901         MOV       R1,#0x1
   \   000036   8004         SJMP      ??SW2_LevelControlStepCB_2
   1048              }
   1049              else
   1050              {
   1051                newLevel = SW2_LevelCurrentLevel - pCmd->amount;
   \                     ??SW2_LevelControlStepCB_4:
   \   000038   E0           MOVX      A,@DPTR
   \   000039   C3           CLR       C
   \   00003A   9C           SUBB      A,R4
   \                     ??SW2_LevelControlStepCB_3:
   \   00003B   F9           MOV       R1,A
   1052              }
   1053            }
   1054            
   1055            SW2_LevelChangeCmd = LEVEL_CHANGED_BY_LEVEL_CMD;
   \                     ??SW2_LevelControlStepCB_2:
   \   00003C   12....       LCALL     ?Subroutine3 & 0xFFFF
   1056          
   1057            // move to the new level
   1058            SW2_WithOnOff = pCmd->withOnOff;
   \                     ??CrossCallReturnLabel_1:
   \   00003F   A3           INC       DPTR
   \   000040   12....       LCALL     ?Subroutine4 & 0xFFFF
   1059            SW2_MoveBasedOnTime( newLevel, pCmd->transitionTime );
   \                     ??CrossCallReturnLabel_16:
   \   000043   A3           INC       DPTR
   \   000044   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000047   12....       LCALL     `??SW2_MoveBasedOnTime::?relay`; Banked call to: SW2_MoveBasedOnTime
   1060          }
   \   00004A                REQUIRE ?Subroutine2
   \   00004A                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   1061          
   1062          /*********************************************************************
   1063           * @fn      SW2_LevelControlStopCB
   1064           *
   1065           * @brief   Callback from the ZCL General Cluster Library when
   1066           *          it received an Level Control Stop Command for this application.
   1067           *
   1068           * @param   pCmd - ZigBee command parameters
   1069           *
   1070           * @return  none
   1071           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1072          static void SW2_LevelControlStopCB( void )
   \                     SW2_LevelControlStopCB:
   1073          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1074            // stop immediately
   1075            osal_stop_timerEx( SW2_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT );
   \   000004                ; Setup parameters for call to function osal_stop_timerEx
   \   000004   7A02         MOV       R2,#0x2
   \   000006   7B00         MOV       R3,#0x0
   \   000008   90....       MOV       DPTR,#SW2_TaskID
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   F9           MOV       R1,A
   \   00000D   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
   1076            SW2_LevelRemainingTime = 0;
   \   000010   90....       MOV       DPTR,#SW2_LevelRemainingTime
   \   000013   E4           CLR       A
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   F0           MOVX      @DPTR,A
   1077          }
   \   000017                REQUIRE ?Subroutine0
   \   000017                ; // Fall through to label ?Subroutine0
   1078          #endif
   1079          
   1080          /*********************************************************************
   1081           * @fn      zclSampleApp_BatteryWarningCB
   1082           *
   1083           * @brief   Called to handle battery-low situation.
   1084           *
   1085           * @param   voltLevel - level of severity
   1086           *
   1087           * @return  none
   1088           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1089          void zclSampleApp_BatteryWarningCB( uint8 voltLevel )
   \                     zclSampleApp_BatteryWarningCB:
   1090          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1091            if ( voltLevel == VOLT_LEVEL_CAUTIOUS )
   1092            {
   1093              // Send warning message to the gateway and blink LED
   1094            }
   1095            else if ( voltLevel == VOLT_LEVEL_BAD )
   1096            {
   1097              // Shut down the system
   1098            }
   1099          }
   \   000000   02....       LJMP      ?BRET
   1100          
   1101          /******************************************************************************
   1102           *
   1103           *  Functions for processing ZCL Foundation incoming Command/Response messages
   1104           *
   1105           *****************************************************************************/
   1106          
   1107          /*********************************************************************
   1108           * @fn      SW2_ProcessIncomingMsg
   1109           *
   1110           * @brief   Process ZCL Foundation incoming message
   1111           *
   1112           * @param   pInMsg - pointer to the received message
   1113           *
   1114           * @return  none
   1115           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1116          static void SW2_ProcessIncomingMsg( zclIncomingMsg_t *pInMsg )
   \                     SW2_ProcessIncomingMsg:
   1117          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1118            switch ( pInMsg->zclHdr.commandID )
   \   000005   EA           MOV       A,R2
   \   000006   2417         ADD       A,#0x17
   \   000008   F8           MOV       R0,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   F9           MOV       R1,A
   \   00000C   E8           MOV       A,R0
   \   00000D   FE           MOV       R6,A
   \   00000E   E9           MOV       A,R1
   \   00000F   FF           MOV       R7,A
   \   000010   8A82         MOV       DPL,R2
   \   000012   8B83         MOV       DPH,R3
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   14           DEC       A
   \   00001D   6016         JZ        ??SW2_ProcessIncomingMsg_0
   \   00001F   24FD         ADD       A,#-0x3
   \   000021   601F         JZ        ??SW2_ProcessIncomingMsg_1
   \   000023   24F7         ADD       A,#-0x9
   \   000025   602D         JZ        ??SW2_ProcessIncomingMsg_2
   \   000027   24FB         ADD       A,#-0x5
   \   000029   6024         JZ        ??SW2_ProcessIncomingMsg_3
   \   00002B   24FE         ADD       A,#-0x2
   \   00002D   6020         JZ        ??SW2_ProcessIncomingMsg_3
   \   00002F   24FE         ADD       A,#-0x2
   \   000031   6033         JZ        ??SW2_ProcessIncomingMsg_4
   \   000033   8043         SJMP      ??SW2_ProcessIncomingMsg_5
   1119            {
   1120          #ifdef ZCL_READ
   1121              case ZCL_CMD_READ_RSP:
   1122                SW2_ProcessInReadRspCmd( pInMsg );
   \                     ??SW2_ProcessIncomingMsg_0:
   \   000035   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F9           MOV       R1,A
   \   00003A   E8           MOV       A,R0
   \   00003B   C3           CLR       C
   \   00003C   99           SUBB      A,R1
   \   00003D   5039         JNC       ??SW2_ProcessIncomingMsg_5
   \   00003F   08           INC       R0
   \   000040   80F6         SJMP      ??CrossCallReturnLabel_11
   1123                break;
   1124          #endif
   1125          #ifdef ZCL_WRITE
   1126              case ZCL_CMD_WRITE_RSP:
   1127                SW2_ProcessInWriteRspCmd( pInMsg );
   \                     ??SW2_ProcessIncomingMsg_1:
   \   000042   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F9           MOV       R1,A
   \   000047   E8           MOV       A,R0
   \   000048   C3           CLR       C
   \   000049   99           SUBB      A,R1
   \   00004A   502C         JNC       ??SW2_ProcessIncomingMsg_5
   \   00004C   08           INC       R0
   \   00004D   80F6         SJMP      ??CrossCallReturnLabel_12
   1128                break;
   1129          #endif
   1130              case ZCL_CMD_CONFIG_REPORT:
   1131              case ZCL_CMD_CONFIG_REPORT_RSP:
   1132              case ZCL_CMD_READ_REPORT_CFG:
   1133              case ZCL_CMD_READ_REPORT_CFG_RSP:
   1134              case ZCL_CMD_REPORT:
   1135                //bdb_ProcessIncomingReportingMsg( pInMsg );
   1136                break;
   1137          
   1138              case ZCL_CMD_DEFAULT_RSP:
   1139                SW2_ProcessInDefaultRspCmd( pInMsg );
   1140                break;
   1141          #ifdef ZCL_DISCOVER
   1142              case ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP:
   1143                SW2_ProcessInDiscCmdsRspCmd( pInMsg );
   \                     ??SW2_ProcessIncomingMsg_3:
   \   00004F                ; Setup parameters for call to function SW2_ProcessInDiscCmdsRspCmd
   1144                break;
   1145          
   1146              case ZCL_CMD_DISCOVER_CMDS_GEN_RSP:
   1147                SW2_ProcessInDiscCmdsRspCmd( pInMsg );
   \   00004F                ; Setup parameters for call to function SW2_ProcessInDiscCmdsRspCmd
   \   00004F   12....       LCALL     `??SW2_ProcessInDiscCmdsRspCmd::?relay`; Banked call to: SW2_ProcessInDiscCmdsRspCmd
   1148                break;
   \   000052   8024         SJMP      ??SW2_ProcessIncomingMsg_5
   1149          
   1150              case ZCL_CMD_DISCOVER_ATTRS_RSP:
   1151                SW2_ProcessInDiscAttrsRspCmd( pInMsg );
   \                     ??SW2_ProcessIncomingMsg_2:
   \   000054   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000057   8882         MOV       DPL,R0
   \   000059   8983         MOV       DPH,R1
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   FB           MOV       R3,A
   \   00005E   EA           MOV       A,R2
   \   00005F   C3           CLR       C
   \   000060   9B           SUBB      A,R3
   \   000061   5015         JNC       ??SW2_ProcessIncomingMsg_5
   \   000063   0A           INC       R2
   \   000064   80F1         SJMP      ??CrossCallReturnLabel_19
   1152                break;
   1153          
   1154              case ZCL_CMD_DISCOVER_ATTRS_EXT_RSP:
   1155                SW2_ProcessInDiscAttrsExtRspCmd( pInMsg );
   \                     ??SW2_ProcessIncomingMsg_4:
   \   000066   12....       LCALL     ?Subroutine6 & 0xFFFF
   1156                break;
   1157          #endif
   1158              default:
   1159                break;
   1160            }
   \                     ??CrossCallReturnLabel_20:
   \   000069   8001         SJMP      ??SW2_ProcessIncomingMsg_6
   \                     ??SW2_ProcessIncomingMsg_7:
   \   00006B   0A           INC       R2
   \                     ??SW2_ProcessIncomingMsg_6:
   \   00006C   8882         MOV       DPL,R0
   \   00006E   8983         MOV       DPH,R1
   \   000070   A3           INC       DPTR
   \   000071   E0           MOVX      A,@DPTR
   \   000072   FB           MOV       R3,A
   \   000073   EA           MOV       A,R2
   \   000074   C3           CLR       C
   \   000075   9B           SUBB      A,R3
   \   000076   40F3         JC        ??SW2_ProcessIncomingMsg_7
   1161          
   1162            if ( pInMsg->attrCmd )
   \                     ??SW2_ProcessIncomingMsg_5:
   \   000078   8E82         MOV       DPL,R6
   \   00007A   8F83         MOV       DPH,R7
   \   00007C   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00007F   EA           MOV       A,R2
   \   000080   4B           ORL       A,R3
   \   000081   6003         JZ        ??SW2_ProcessIncomingMsg_8
   1163              osal_mem_free( pInMsg->attrCmd );
   \   000083                ; Setup parameters for call to function osal_mem_free
   \   000083   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   1164          }
   \                     ??SW2_ProcessIncomingMsg_8:
   \   000086   02....       LJMP      ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   8882         MOV       DPL,R0
   \   000002   8983         MOV       DPH,R1
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F8           MOV       R0,A
   \   000006   A3           INC       DPTR
   \   000007   E0           MOVX      A,@DPTR
   \   000008   8882         MOV       DPL,R0
   \   00000A   F583         MOV       DPH,A
   \   00000C   7800         MOV       R0,#0x0
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   8882         MOV       DPL,R0
   \   000002   8983         MOV       DPH,R1
   \   000004                REQUIRE ??Subroutine13_0
   \   000004                ; // Fall through to label ??Subroutine13_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine13_0:
   \   000000   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000003   7A00         MOV       R2,#0x0
   \   000005   22           RET
   1165          
   1166          #ifdef ZCL_READ
   1167          /*********************************************************************
   1168           * @fn      SW2_ProcessInReadRspCmd
   1169           *
   1170           * @brief   Process the "Profile" Read Response Command
   1171           *
   1172           * @param   pInMsg - incoming message to process
   1173           *
   1174           * @return  none
   1175           */
   1176          static uint8 SW2_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg )
   1177          {
   1178            zclReadRspCmd_t *readRspCmd;
   1179            uint8 i;
   1180          
   1181            readRspCmd = (zclReadRspCmd_t *)pInMsg->attrCmd;
   1182            for (i = 0; i < readRspCmd->numAttr; i++)
   1183            {
   1184              // Notify the originator of the results of the original read attributes
   1185              // attempt and, for each successfull request, the value of the requested
   1186              // attribute
   1187            }
   1188          
   1189            return ( TRUE );
   1190          }
   1191          #endif // ZCL_READ
   1192          
   1193          #ifdef ZCL_WRITE
   1194          /*********************************************************************
   1195           * @fn      SW2_ProcessInWriteRspCmd
   1196           *
   1197           * @brief   Process the "Profile" Write Response Command
   1198           *
   1199           * @param   pInMsg - incoming message to process
   1200           *
   1201           * @return  none
   1202           */
   1203          static uint8 SW2_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg )
   1204          {
   1205            zclWriteRspCmd_t *writeRspCmd;
   1206            uint8 i;
   1207          
   1208            writeRspCmd = (zclWriteRspCmd_t *)pInMsg->attrCmd;
   1209            for ( i = 0; i < writeRspCmd->numAttr; i++ )
   1210            {
   1211              // Notify the device of the results of the its original write attributes
   1212              // command.
   1213            }
   1214          
   1215            return ( TRUE );
   1216          }
   1217          #endif // ZCL_WRITE
   1218          
   1219          /*********************************************************************
   1220           * @fn      SW2_ProcessInDefaultRspCmd
   1221           *
   1222           * @brief   Process the "Profile" Default Response Command
   1223           *
   1224           * @param   pInMsg - incoming message to process
   1225           *
   1226           * @return  none
   1227           */
   1228          static uint8 SW2_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg )
   1229          {
   1230            // zclDefaultRspCmd_t *defaultRspCmd = (zclDefaultRspCmd_t *)pInMsg->attrCmd;
   1231          
   1232            // Device is notified of the Default Response command.
   1233            (void)pInMsg;
   1234          
   1235            return ( TRUE );
   1236          }
   1237          
   1238          #ifdef ZCL_DISCOVER
   1239          /*********************************************************************
   1240           * @fn      SW2_ProcessInDiscCmdsRspCmd
   1241           *
   1242           * @brief   Process the Discover Commands Response Command
   1243           *
   1244           * @param   pInMsg - incoming message to process
   1245           *
   1246           * @return  none
   1247           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1248          static uint8 SW2_ProcessInDiscCmdsRspCmd( zclIncomingMsg_t *pInMsg )
   \                     SW2_ProcessInDiscCmdsRspCmd:
   1249          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1250            zclDiscoverCmdsCmdRsp_t *discoverRspCmd;
   1251            uint8 i;
   1252          
   1253            discoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)pInMsg->attrCmd;
   \   000004   EA           MOV       A,R2
   \   000005   2417         ADD       A,#0x17
   \   000007   F582         MOV       DPL,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   F583         MOV       DPH,A
   \   00000D   12....       LCALL     ??Subroutine13_0 & 0xFFFF
   1254            for ( i = 0; i < discoverRspCmd->numCmd; i++ )
   \                     ??CrossCallReturnLabel_18:
   \   000010   8001         SJMP      ??SW2_ProcessInDiscCmdsRspCmd_0
   \                     ??SW2_ProcessInDiscCmdsRspCmd_1:
   \   000012   0A           INC       R2
   \                     ??SW2_ProcessInDiscCmdsRspCmd_0:
   \   000013   8882         MOV       DPL,R0
   \   000015   8983         MOV       DPH,R1
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   FB           MOV       R3,A
   \   00001B   EA           MOV       A,R2
   \   00001C   C3           CLR       C
   \   00001D   9B           SUBB      A,R3
   \   00001E   40F2         JC        ??SW2_ProcessInDiscCmdsRspCmd_1
   1255            {
   1256              // Device is notified of the result of its attribute discovery command.
   1257            }
   1258          
   1259            return ( TRUE );
   \   000020   7901         MOV       R1,#0x1
   \   000022   02....       LJMP      ?Subroutine0 & 0xFFFF
   1260          }
   1261          
   1262          /*********************************************************************
   1263           * @fn      SW2_ProcessInDiscAttrsRspCmd
   1264           *
   1265           * @brief   Process the "Profile" Discover Attributes Response Command
   1266           *
   1267           * @param   pInMsg - incoming message to process
   1268           *
   1269           * @return  none
   1270           */
   1271          static uint8 SW2_ProcessInDiscAttrsRspCmd( zclIncomingMsg_t *pInMsg )
   1272          {
   1273            zclDiscoverAttrsRspCmd_t *discoverRspCmd;
   1274            uint8 i;
   1275          
   1276            discoverRspCmd = (zclDiscoverAttrsRspCmd_t *)pInMsg->attrCmd;
   1277            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1278            {
   1279              // Device is notified of the result of its attribute discovery command.
   1280            }
   1281          
   1282            return ( TRUE );
   1283          }
   1284          
   1285          /*********************************************************************
   1286           * @fn      SW2_ProcessInDiscAttrsExtRspCmd
   1287           *
   1288           * @brief   Process the "Profile" Discover Attributes Extended Response Command
   1289           *
   1290           * @param   pInMsg - incoming message to process
   1291           *
   1292           * @return  none
   1293           */
   1294          static uint8 SW2_ProcessInDiscAttrsExtRspCmd( zclIncomingMsg_t *pInMsg )
   1295          {
   1296            zclDiscoverAttrsExtRsp_t *discoverRspCmd;
   1297            uint8 i;
   1298          
   1299            discoverRspCmd = (zclDiscoverAttrsExtRsp_t *)pInMsg->attrCmd;
   1300            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1301            {
   1302              // Device is notified of the result of its attribute discovery command.
   1303            }
   1304          
   1305            return ( TRUE );
   1306          }
   1307          #endif // ZCL_DISCOVER
   1308          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1309          void SW2_UpdateLedState(void)
   \                     SW2_UpdateLedState:
   1310          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1311            // set the LED1 based on light (on or off)
   1312            if ( SW2_OnOff == LIGHT_ON )
   \   000004   90....       MOV       DPTR,#SW2_OnOff
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   7004         JNZ       ??SW2_UpdateLedState_0
   1313            {
   1314              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   \   00000C                ; Setup parameters for call to function HalLedSet
   \   00000C   7A01         MOV       R2,#0x1
   \   00000E   8002         SJMP      ??SW2_UpdateLedState_1
   1315            }
   1316            else
   1317            {
   1318              HalLedSet ( HAL_LED_3, HAL_LED_MODE_OFF );
   \                     ??SW2_UpdateLedState_0:
   \   000010                ; Setup parameters for call to function HalLedSet
   \   000010   7A00         MOV       R2,#0x0
   \                     ??SW2_UpdateLedState_1:
   \   000012   7904         MOV       R1,#0x4
   \   000014   12....       LCALL     `??HalLedSet::?relay`; Banked call to: HalLedSet
   1319            }
   1320          }
   \   000017   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for SW2_CmdCallbacks>`:
   \   000000   ....         DW `??SW2_BasicResetCB::?relay`
   \   000002   0000         DW 0H
   \   000004   ....         DW `??SW2_OnOffCB::?relay`
   \   000006   0000         DW 0H
   \   000008   0000         DW 0H
   \   00000A   0000         DW 0H
   \   00000C   ....         DW `??SW2_LevelControlMoveToLevelCB::?relay`
   \   00000E   ....         DW `??SW2_LevelControlMoveCB::?relay`
   \   000010   ....         DW `??SW2_LevelControlStepCB::?relay`
   \   000012   ....         DW `??SW2_LevelControlStopCB::?relay`
   \   000014   0000         DW 0H
   \   000016   0000         DW 0H
   \   000018   0000         DW 0H
   \   00001A   0000         DW 0H
   \   00001C   0000         DW 0H
   \   00001E   0000         DW 0H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e8:
   \   000000   E8030000     DD 1000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_64:
   \   000000   64000000     DD 100
   1321          
   1322          
   1323          
   1324          /****************************************************************************
   1325          ****************************************************************************/
   1326          
   1327          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     32   SW2_AdjustLightLevel
        0     16   -> SW2_UpdateLedState
        0     20   -> osal_start_timerEx
      2      0   SW2_BasicResetCB
        2      0   -> SW2_ResetAttributesToDefaultValues
        2      0   -> SW2_UpdateLedState
      0     16   SW2_Init
        0     10   -> RegisterVoltageWarningCB
        0     10   -> SW2_ResetAttributesToDefaultValues
        0     10   -> bdb_RegisterSimpleDescriptor
        0     16   -> bdb_RepAddAttrCfgRecordDefaultToList
        0     10   -> gp_RegisterCommissioningModeCB
        0     10   -> gp_RegisterGPChangeChannelReqCB
        0     10   -> zclGeneral_RegisterCmdCallbacks
        0     10   -> zcl_registerAttrList
        0     10   -> zcl_registerCmdList
        0     10   -> zcl_registerForMsg
      0     16   SW2_LevelControlMoveCB
        0     16   -> SW2_MoveBasedOnRate
      2      0   SW2_LevelControlMoveToLevelCB
        2      0   -> SW2_MoveBasedOnTime
      0      9   SW2_LevelControlStepCB
        0      9   -> SW2_MoveBasedOnTime
      2      0   SW2_LevelControlStopCB
        2      0   -> osal_stop_timerEx
      0     36   SW2_MoveBasedOnRate
        0     16   -> SW2_TimeRateHelper
        0     20   -> osal_start_timerEx
      0     29   SW2_MoveBasedOnTime
        0     16   -> SW2_TimeRateHelper
        0     20   -> osal_start_timerEx
      0     16   SW2_OnOffCB
        0     16   -> SW2_MoveBasedOnRate
        0     16   -> SW2_UpdateLedState
        0     16   -> bdb_RepChangedAttrValue
        0     16   -> zcl_getRawAFMsg
      2      9   SW2_ProcessInDiscCmdsRspCmd
      0     21   SW2_ProcessIncomingMsg
        0      9   -> SW2_ProcessInDiscCmdsRspCmd
        0      9   -> osal_mem_free
      0     32   SW2_TimeRateHelper
      2     16   SW2_UpdateLedState
        2      0   -> HalLedSet
      0     12   SW2_event_loop
        0     12   -> SW2_AdjustLightLevel
        0     12   -> SW2_ProcessIncomingMsg
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
      0      0   gp_ChangeChannelReq
      0      0   gp_CommissioningMode
      0      0   zclSampleApp_BatteryWarningCB


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Initializer for SW2_CmdCallbacks>
       5  ??Subroutine11_0
       7  ??Subroutine12_0
       6  ??Subroutine13_0
       7  ?Subroutine0
      23  ?Subroutine1
       6  ?Subroutine10
       5  ?Subroutine2
      13  ?Subroutine3
       4  ?Subroutine4
       9  ?Subroutine5
       4  ?Subroutine6
       6  ?Subroutine7
      15  ?Subroutine8
      11  ?Subroutine9
       1  SW2SeqNum
     214  SW2_AdjustLightLevel
      13  SW2_BasicResetCB
      32  SW2_CmdCallbacks
       4  SW2_CurrentLevel32
      12  SW2_DstAddr
     173  SW2_Init
       1  SW2_LevelChangeCmd
      70  SW2_LevelControlMoveCB
      29  SW2_LevelControlMoveToLevelCB
      74  SW2_LevelControlStepCB
      23  SW2_LevelControlStopCB
       1  SW2_LevelLastLevel
      65  SW2_MoveBasedOnRate
     123  SW2_MoveBasedOnTime
       1  SW2_NewLevel
       1  SW2_NewLevelUp
     213  SW2_OnOffCB
      37  SW2_ProcessInDiscCmdsRspCmd
     137  SW2_ProcessIncomingMsg
       4  SW2_Rate32
       1  SW2_TaskID
     128  SW2_TimeRateHelper
      26  SW2_UpdateLedState
       1  SW2_WithOnOff
     101  SW2_event_loop
       4  __Constant_3e8
       4  __Constant_64
       5  gp_ChangeChannelReq
       3  gp_CommissioningMode
       4  reportableChangeSW2
       3  zclSampleApp_BatteryWarningCB
     108  -- Other

 
 1 558 bytes in segment BANKED_CODE
   108 bytes in segment BANK_RELAYS
    32 bytes in segment XDATA_I
    32 bytes in segment XDATA_ID
     8 bytes in segment XDATA_ROM_C
    31 bytes in segment XDATA_Z
 
   140 bytes of CODE     memory
     0 bytes of CONST    memory (+ 8 bytes shared)
 1 558 bytes of HUGECODE memory
    63 bytes of XDATA    memory

Errors: none
Warnings: none
